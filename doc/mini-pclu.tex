\documentstyle[12pt]{article}

% Use full page
\topmargin 0pt
\advance \topmargin by -\headheight
\advance \topmargin by -\headsep
\textheight 8.9in
\oddsidemargin 0pt
\evensidemargin \oddsidemargin
\marginparwidth 0.5in
\textwidth 6.5in

% Useful environments
\newenvironment{indenttext}{%
\begin{list}{}{%
\leftmargin=0.5in%
\rightmargin=0in%
\labelsep=0pt%
\labelwidth=0pt%
\listparindent=\parindent%
}%
\item%
}{%
\end{list}%
}

\newenvironment{syntax}{%
\subsection*{\hspace{0.25in}Syntax}%
\begin{indenttext}
}{%
\end{indenttext}%
}

\newenvironment{overview}{%
\subsection*{\hspace{0.25in}Overview}%
\begin{indenttext}
}{%
\end{indenttext}%
}

\newenvironment{options}{%
\subsection*{\hspace{0.25in}Options}%
\begin{indenttext}
\begin{tabular}{@{\hspace{\tabcolsep}\tt}lp{4.4in}}%
}{%
\end{tabular}%
\end{indenttext}%
}

\newenvironment{comments}{%
\subsection*{\hspace{0.25in}Comments}%
\begin{indenttext}
}{%
\end{indenttext}%
}

\title{Using Portable CLU}
\date{February 10, 1992; Updated November 29, 2016}
\author{Stephen Garland\\Dorothy Curtis}

\begin{document}

\maketitle

\noindent This document provides a short explanation of how to compile
and link CLU programs to produce executables.

\section{Overview}

A CLU program consists of one or more modules, also known as {\em
abstractions}.  The {\em interface specification} for an abstraction
completely describes how clients (i.e., other abstractions) see the
abstraction and how they can use it.  The interface specification for
a procedural or iteration abstraction is determined by the header for
that procedure or iterator; the interface specification for a data
abstraction (i.e., a cluster) is determined by the header for the
cluster together with the headers for the operations named in the
cluster header.  The implementation of each abstraction is
theoretically invisible to its clients.

Generally, the code for each module is kept in a separate file, the
name of which ends with \verb|.clu|.  Sometimes it is convenient for
several modules to employ common declarations for compile-time
constants, e.g., $maxLen = 100$ or $intSeq = seq[int]$.  Such
``equates'' are generally kept in a separate file, the name of which
ends with \verb|.equ|.

\section{Using the Compiler}

There are three steps in compiling a CLU program. First, we create an
interface library that contains the interface specifications of all of
the modules that will make up the program. Second, we compile the
modules against this library. (Portable CLU differs from earlier
native CLU compilers in that the interfaces of all modules must be
extracted into an interface library before any module is compiled.
Earlier compilers were more relaxed about this requirement.)  And
third, we link the resulting object files together into an executable
program.

The default of the pclu compiler is to produce optimized code.  Use the
\verb|-debug| flag consistently to each pclu invocation if debugging is
desired.

\subsection{Creating a type library}

\begin{syntax}
\verb|pclu -spec <source>.clu ... -dump <file>.lib|
\end{syntax}

\begin{overview}
  Checks the interface specifications of the specified source files
  and dumps the resulting interface information into the library file
  \verb|<file>.lib|
\end{overview}

\begin{options}
-ce <foo>.equ&Use equates from specified file\\
-use <foo>.lib&Read type info from library before compiling\\
\end{options}

\begin{comments}
Multiple \verb|.lib| files and equate files can be specified.
\end{comments}

\subsection{Compiling CLU files}

\begin{syntax}
\verb|pclu -compile <source>.clu ...|
\end{syntax}

\begin{overview}
Generates \verb|<source>.o| for each specified CLU file \verb|<source>.clu|.
\end{overview}

\begin{options}
-debug&Generate output for debugging\\
-opt&Generate optimized output (the default)\\
-ce <foo>.equ&Use equates from specified file\\
-merge <foo>.lib&Read type info from library before compiling\\
\end{options}

\begin{comments}
Multiple \verb|.lib| files and equate files can be specified.
\end{comments}

\subsection{Linking a program}

\begin{syntax}
\verb+plink -o <program> [<object>.o] [<object-library>.a] ...+
\end{syntax}

\begin{overview}
Links the specified \verb|.o| and \verb|.a| files together and creates
executable \verb|<program>|.  \verb|.o| files are generated by pclu
(and various other compilers).  \verb|.a| files contain a number of
different \verb|.o| files and can be generated via the \verb|ar|
program.
\end{overview}

\begin{options}
-debug&Generate a program for debugging\\
-opt&Generate an optimized program\\
\end{options}

\subsection{Spec-checking CLU files}

\begin{syntax}
\verb|pclu -spec <source>.clu ...|
\end{syntax}

\begin{overview}
Spec checks each source file \verb|<source>.clu|
\end{overview}

\begin{options}
-ce <foo>.equ&Use equates from specified file\\
-merge <foo>.lib&Read type info from library before compiling\\
\end{options}

\begin{comments}
Multiple \verb|.lib| files and equate files can be specified.
\end{comments}

\subsection{Examples}

The first example demonstrates how to compile a CLU program with all
code in a single file. We first need to create a type library for the
program.

\begin{indenttext}
\verb|pclu -spec factorial.clu -dump factorial.lib|
\end{indenttext}

\noindent Now we compile the file against the type library created
during the last step.

\begin{indenttext}
\verb|pclu -merge factorial.lib -compile factorial.clu|
\end{indenttext}

\noindent Now link the program together.

\begin{indenttext}
\verb|plink factorial factorial.o|
\end{indenttext}

\noindent Suppose we have a multiple file program with an equate file that we
wish to compile with optimization enabled. Here are the three pclu
invocations that achieve that goal.

\begin{indenttext}
  \verb|pclu -ce define.equ -spec main.clu support.clu -dump prog.lib|\\
  \verb|pclu -merge prog.lib -ce define.equ -compile main.clu support.clu|\\
  \verb|plink -o prog main.o support.o|
\end{indenttext}

\subsection{A More Complicated Example}

Suppose someone else implemented some abstractions and provided us
with an interface library and object files for those abstractions.
Suppose the supplied interface library is called \verb|ps9.lib|, the
supplied object files are \verb|graph.o| and \verb|tree.o|, and all of
these files are stored in some directory \verb|<dir>|.

We write code that uses these supplied abstractions and put our code in
two CLU files, \verb|main.clu| and \verb|spanning.clu|. In addition, we
create an equate file \verb|x.equ| containing some common
abbreviations.

Before we can compile our program, we need to create an interface
library for it. We do this by using the supplied interface library and
checking the two CLU files we wrote. (The backslash in the following
text is a shell convention that indicates that the next line is part
of the command started on this line.)

\begin{indenttext}
\begin{verbatim}
pclu -merge <dir>/ps9.lib -ce x.equ main.clu spanning.clu -dump my.lib
\end{verbatim}
\end{indenttext}

\noindent Now we can compile our CLU files against the interface
library we just generated. Note that we do not need to mention the
original interface library in this step because the contents of that
interface library were copied into our library by the first
step. However, the equate file is specified for all compiler
invocations (except the last linking phase). This will be true both of
equates files we write and of equate files supplied by somebody else.

\begin{indenttext}
  \verb|pclu -merge my.lib -ce x.equ -co main.clu spanning.clu|
\end{indenttext}

\noindent Finally, we link everything (including the supplied object
files) together.

\begin{indenttext}
  \verb|plink -o program main.o spanning.o <dir>/graph.o <dir>/tree.o|
\end{indenttext}

\section{Using Makefiles}

This section describes how to write makefiles for CLU programs that
are intended to be compiled by the portable CLU compiler. If you don't
know what a makefile is or what the program \verb|make| does, then
skip this section. You can come back to it when you know more about
\verb|make|.

Makefiles can be used to automate the process of compiling CLU
programs. This can be useful for two reasons. First, programs like the
one in the example given above are quite complicated. Automating the
compilation process can reduce the tedium and complexity of typing in
long compilation commands over and over again.

Second, using \verb|make| can also help avoid unnecessary
recompilation.  Because of the way the portable CLU compiler works, it
is somewhat complicated to use this feature of \verb|make| to its full
extent.  Therefore, these notes describe only a simple, but not the
most efficient, use of \verb|make| to avoid recompilation.

Let us construct a makefile to perform the task described in the
previous example, where some code is supplied by someone else.  We
describe this task in a top-down manner.  The main goal of the
makefile is to produce the executable \verb|program|. The following
rule describes how to generate \verb|program| from the \verb|.o| files
on which it depends.

\begin{indenttext}
\begin{verbatim}
program: main.o spanning.o <dir>/graph.o <dir>/tree.o
         plink program main.o spanning.o <dir>/graph.o <dir>/tree.o
\end{verbatim}
\end{indenttext}

\noindent If \verb|main.o| and \verb|spanning.o| exist, then
\verb|make| will produce \verb|program| by linking the specified
object files together. Otherwise, it will have to generate
\verb|main.o| and \verb|spanning.o|. (We assume the supplied object
files \verb|<dir>graph.o| and \verb|<dir>tree.o| already exist so that
the makefile does not have to create them).  The following rules
generating these \verb|.o| files.

\begin{indenttext}
\begin{verbatim}
main.o: main.clu my.lib
        pclu -merge my.lib -ce x.equ -co main.clu

spanning.o: spanning.clu my.lib
        pclu -merge my.lib -ce x.equ -co spanning.clu
\end{verbatim}
\end{indenttext}

\noindent Now we have to tell \verb|make| how and when to create
\verb|my.lib|.

\begin{indenttext}
\begin{verbatim}
my.lib: main.clu spanning.clu
        pclu -merge <dir>/ps9.lib -ce x.equ \
             -spec main.clu spanning.clu -dump my.lib
\end{verbatim}
\end{indenttext}

\noindent Finally, we combine all these rules and put them into a file
named \verb|Makefile|.

\begin{indenttext}
\begin{verbatim}
program: main.o spanning.o
        plink -o program main.o spanning.o \
                <dir>/graph.o <dir>/tree.o

main.o: main.clu my.lib
        pclu -merge my.lib -ce x.equ -co main.clu

spanning.o: spanning.clu my.lib
        pclu -merge my.lib -ce x.equ -co spanning.clu

my.lib: main.clu spanning.clu
        pclu -merge <dir>/ps9.lib -ce x.equ -co main.clu spanning.clu \
             -dump my.lib
\end{verbatim}
\end{indenttext}

\noindent The command \verb|make| issued to the shell will perform any
necessary recompilations and produce an executable file called
\verb|program|.

\end{document}
