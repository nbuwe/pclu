
/* This file was automatically generated by pclu. */

#include "pclu_err.h"
#include "pclu_sys.h"

/**** BEGIN CLUSTER stream ****/

extern errcode stringOPequal();
extern errcode boolOPnot();
extern errcode file_nameOPget_dir();
extern errcode stringOPempty();
extern errcode file_nameOPget_suffix();
extern errcode file_nameOPget_other();
extern errcode file_nameOPget_name();
extern errcode streamOPprimary_input();
extern errcode streamOPprimary_output();
extern errcode streamOPerror_output();
extern errcode sequenceOPnew();
extern errcode oneofOPmake_3();
extern errcode arrayOPaddh();
extern errcode streamOPopen_streams();
extern errcode _chanOPopen();
extern errcode _bytevecOPcreate();
extern errcode _chanOPis_tty();
extern errcode _chanOPclose();
extern errcode arrayOPnew();
extern errcode oneofOPmake_6();
extern errcode streamOPtermcap();
extern errcode oneofOPmake_5();
extern errcode oneofOPmake_7();
extern errcode _chanOPget_name();
extern errcode streamOPget_prims();
extern errcode _chanOPerror_output();
extern errcode _chanOPprimary_input();
extern errcode _chanOPprimary_output();
extern errcode _chanOPequal();
extern errcode _get_termcap();
extern errcode recordOPset_15();
extern errcode intOPparse();
extern errcode _termcap();
extern errcode recordOPset_17();
extern errcode intOPgt();
extern errcode stringOPindexs();
extern errcode _chanOPget_speeds();
extern errcode recordOPget_3();
extern errcode recordOPset_1();
extern errcode recordOPset_13();
extern errcode recordOPget_1();
extern errcode intOPequal();
extern errcode stringOPconcat();
extern errcode stringOPappend();
extern errcode recordOPset_4();
extern errcode recordOPget_17();
extern errcode recordOPget_13();
extern errcode recordOPget_4();
extern errcode recordOPset_7();
extern errcode streamOPall_scripts();
extern errcode recordOPequal();
extern errcode sequenceOPaddh();
extern errcode recordOPset_3();
extern errcode sequenceOPelements();
extern errcode sequenceOPindexes();
extern errcode streamOPequal();
extern errcode sequenceOPfetch();
extern errcode sequenceOPconcat();
extern errcode sequenceOPsubseq();
extern errcode intOPsub();
extern errcode intOPadd();
extern errcode sequenceOPsize();
extern errcode sequenceOPempty();
extern errcode recordOPget_5();
extern errcode recordOPset_5();
extern errcode _chanOPgetb();
extern errcode recordOPget_2();
extern errcode _bytevecOPfetch();
extern errcode charOPequal();
extern errcode streamOPflush();
extern errcode streamOPtty_get1();
extern errcode streamOPtty_put1();
extern errcode stringOPfetch();
extern errcode recordOPset_2();
extern errcode streamOPscript();
extern errcode stringOPc2s();
extern errcode recordOPget_8();
extern errcode recordOPget_9();
extern errcode arrayOPempty();
extern errcode recordOPget_19();
extern errcode _chanOPgetc();
extern errcode recordOPset_8();
extern errcode recordOPset_6();
extern errcode arrayOPbottom();
extern errcode _chanOPpending();
extern errcode streamOPempty();
extern errcode streamOPpeekc();
extern errcode stringOPsize();
extern errcode _chanOPput();
extern errcode _chanOPputc();
extern errcode streamOPtty_put();
extern errcode recordOPget_14();
extern errcode _chanOPreset();
extern errcode recordOPset_12();
extern errcode arrayOPset_low();
extern errcode arrayOPtrim();
extern errcode recordOPset_14();
extern errcode _chanOPputb();
extern errcode recordOPget_12();
extern errcode recordOPget_11();
extern errcode recordOPset_11();
extern errcode recordOPget_15();
extern errcode _chanOPget_date();
extern errcode oneofOPmake_1();
extern errcode arrayOPindexes();
extern errcode arrayOPfetch();
extern errcode arrayOPstore();
extern errcode arrayOPremh();
extern errcode _chanOPabort();
extern errcode oneofOPis_1();
extern errcode oneofOPis_6();
extern errcode streamOPgets();
extern errcode arrayOPreml();
extern errcode recordOPget_6();
extern errcode streamOPputs();
extern errcode streamOPputc();
extern errcode _chanOPget();
extern errcode stringOPindexc();
extern errcode streamOPlines();
extern errcode recordOPget_10();
extern errcode recordOPget_18();
extern errcode streamOPedit();
extern errcode streamOPtty_get();
extern errcode streamOPstr_get();
extern errcode streamOPecho();
extern errcode arrayOPaddl();
extern errcode stringOPac2s();
extern errcode stringOPsubstr();
extern errcode stringOPrest();
extern errcode stringOPchars();
extern errcode _chanOPputs();
extern errcode _bytevecOPstore();
extern errcode boolOPequal();
extern errcode recordOPget_16();
extern errcode intOPlt();
extern errcode charOPge();
extern errcode charOPle();
extern errcode streamOPputspace();
extern errcode file_nameOPparse();
extern errcode oneofOPmake_2();
extern errcode oneofOPmake_4();
extern errcode _bytevecOPindexc();
extern errcode _cvt();
extern errcode streamOPputs_image();
extern errcode _eventOPdefer();
extern errcode _bytevecOPmove_lr();
extern errcode streamOPrubout();
extern errcode streamOPerase();
extern errcode intOPfrom_to();
extern errcode _eventOPundefer();
extern errcode charOPc2i();
extern errcode _chanOPputi();
extern errcode intOPmod();
extern errcode intOPle();
extern errcode recordOPget_7();
extern errcode charOPlt();
extern errcode streamOPcalc_pos();
extern errcode intOPfrom_to_by();
extern errcode streamOPttydsp();
extern errcode recordOPset_18();
extern errcode stringOPs2ac();
extern errcode recordOPset_19();
extern errcode recordOPset_10();
extern errcode recordOPset_16();
extern errcode recordOPset_9();
extern errcode pstreamOPtext();
extern errcode streamOPcan_read();
extern errcode pstreamOPtextc();
extern errcode streamOPcan_write();
extern errcode streamOPis_closed();
extern errcode file_nameOPprint();
extern errcode streamOPget_name();
extern errcode arrayOPelements();
extern errcode streamOPclose();
extern errcode streamOPabort();
static CLUREF STR_read;
static CLUREF STR_write;
static CLUREF STR_append;
static CLUREF STR_bad_040access_040mode;
static CLUREF STR__057dev;
static CLUREF STR_p;
static CLUREF STR_e;
static CLUREF STR_cannot_040read_040from_040this_040stream;
static CLUREF STR_null;
static CLUREF STR_tty;
static CLUREF STR_modify;
static CLUREF STR__072co_043;
static CLUREF STR__072li_043;
static CLUREF STR__072hc_072;
static CLUREF STR__072bs_072;
static CLUREF STR__010;
static CLUREF STR__072bc_075;
static CLUREF STR__072kb_075;
static CLUREF STR__072ce_075;
static CLUREF STR__072os_072;
static CLUREF STR__072eo_072;
static CLUREF STR__072cl_075;
static CLUREF STR__012;
static CLUREF STR_cannot_040write_040to_040this_040stream;
static CLUREF STR_no_040line_040numbers;
static CLUREF STR_cannot_040get_040date;
static CLUREF STR_cannot_040set_040date;
static CLUREF STR_no_040name_040for_040string_040stream;
static CLUREF STR_not_040a_040string_040output_040stream;
static CLUREF STR__136_077;
static CLUREF STR_not_040a_040terminal_040stream;
static CLUREF STR_cannot_040rescan_040on_040this_040stream;
static CLUREF STR_input_040is_040always_040buffered;
static CLUREF STR_output_040is_040always_040buffered;
static CLUREF STR_cannot_040disable_040eof_040on_040this_040stream;
static CLUREF STR_cannot_040enable_040eof_040on_040this_040stream;
static CLUREF STR_stream_133;
static CLUREF STR__050internal_051;
static CLUREF STR_does_040not_040contain_040a_040_137chan;
static int stream_own_init = 0;
const OWN_req stream_ownreqs = { 0, 0 };
CLUREF streamOPfree;
CLUREF streamOPfreebuf;

errcode
stream_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (stream_own_init == 0) {
        stringOPcons("read", CLU_1, CLUREF_make_num(4), &STR_read);
        stringOPcons("write", CLU_1, CLUREF_make_num(5), &STR_write);
        stringOPcons("append", CLU_1, CLUREF_make_num(6), &STR_append);
        stringOPcons("bad access mode", CLU_1, CLUREF_make_num(15), &STR_bad_040access_040mode);
        stringOPcons("/dev", CLU_1, CLUREF_make_num(4), &STR__057dev);
        stringOPcons("p", CLU_1, CLUREF_make_num(1), &STR_p);
        stringOPcons("e", CLU_1, CLUREF_make_num(1), &STR_e);
        stringOPcons("cannot read from this stream", CLU_1, CLUREF_make_num(28), &STR_cannot_040read_040from_040this_040stream);
        stringOPcons("null", CLU_1, CLUREF_make_num(4), &STR_null);
        stringOPcons("tty", CLU_1, CLUREF_make_num(3), &STR_tty);
        stringOPcons("modify", CLU_1, CLUREF_make_num(6), &STR_modify);
        stringOPcons(":co#", CLU_1, CLUREF_make_num(4), &STR__072co_043);
        stringOPcons(":li#", CLU_1, CLUREF_make_num(4), &STR__072li_043);
        stringOPcons(":hc:", CLU_1, CLUREF_make_num(4), &STR__072hc_072);
        stringOPcons(":bs:", CLU_1, CLUREF_make_num(4), &STR__072bs_072);
        stringOPcons("\b", CLU_1, CLUREF_make_num(1), &STR__010);
        stringOPcons(":bc=", CLU_1, CLUREF_make_num(4), &STR__072bc_075);
        stringOPcons(":kb=", CLU_1, CLUREF_make_num(4), &STR__072kb_075);
        stringOPcons(":ce=", CLU_1, CLUREF_make_num(4), &STR__072ce_075);
        stringOPcons(":os:", CLU_1, CLUREF_make_num(4), &STR__072os_072);
        stringOPcons(":eo:", CLU_1, CLUREF_make_num(4), &STR__072eo_072);
        stringOPcons(":cl=", CLU_1, CLUREF_make_num(4), &STR__072cl_075);
        stringOPcons("\n", CLU_1, CLUREF_make_num(1), &STR__012);
        stringOPcons("cannot write to this stream", CLU_1, CLUREF_make_num(27), &STR_cannot_040write_040to_040this_040stream);
        stringOPcons("no line numbers", CLU_1, CLUREF_make_num(15), &STR_no_040line_040numbers);
        stringOPcons("cannot get date", CLU_1, CLUREF_make_num(15), &STR_cannot_040get_040date);
        stringOPcons("cannot set date", CLU_1, CLUREF_make_num(15), &STR_cannot_040set_040date);
        stringOPcons("no name for string stream", CLU_1, CLUREF_make_num(25), &STR_no_040name_040for_040string_040stream);
        stringOPcons("not a string output stream", CLU_1, CLUREF_make_num(26), &STR_not_040a_040string_040output_040stream);
        stringOPcons("^?", CLU_1, CLUREF_make_num(2), &STR__136_077);
        stringOPcons("not a terminal stream", CLU_1, CLUREF_make_num(21), &STR_not_040a_040terminal_040stream);
        stringOPcons("cannot rescan on this stream", CLU_1, CLUREF_make_num(28), &STR_cannot_040rescan_040on_040this_040stream);
        stringOPcons("input is always buffered", CLU_1, CLUREF_make_num(24), &STR_input_040is_040always_040buffered);
        stringOPcons("output is always buffered", CLU_1, CLUREF_make_num(25), &STR_output_040is_040always_040buffered);
        stringOPcons("cannot disable eof on this stream", CLU_1, CLUREF_make_num(33), &STR_cannot_040disable_040eof_040on_040this_040stream);
        stringOPcons("cannot enable eof on this stream", CLU_1, CLUREF_make_num(32), &STR_cannot_040enable_040eof_040on_040this_040stream);
        stringOPcons("stream[", CLU_1, CLUREF_make_num(7), &STR_stream_133);
        stringOPcons("(internal)", CLU_1, CLUREF_make_num(10), &STR__050internal_051);
        stringOPcons("does not contain a _chan", CLU_1, CLUREF_make_num(24), &STR_does_040not_040contain_040a_040_137chan);
        stream_own_init = 1;
        {
        streamOPfree.tf = false;
        }
        signal(ERR_ok);
      ex_0:
        __CLU_EX_HANDLER;
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE open ****/

static int streamOPopen_own_init = 0;

errcode
streamOPopen(CLUREF fn, CLUREF mode, CLUREF *ret_1)
{
    errcode err;
    CLUREF _can_read;
    CLUREF _can_write;
    CLUREF st;
    CLUREF ch;
    CLUREF bvec;
    CLUREF b;
    CLUREF istty;
    CLUREF nch;
    CLUREF tb;
    if (streamOPopen_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPopen_own_init = 1;
    }
    enter_proc(84);

  LINE(86);
    {
    CLUREF T_1_1;
    T_1_1.num = ((mode.str->size != STR_read.str->size)? false :
        !(memcmp(mode.str->data, STR_read.str->data, mode.str->size)));
    _can_read.num = T_1_1.num;
    }

  LINE(87);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = ((mode.str->size != STR_write.str->size)? false :
        !(memcmp(mode.str->data, STR_write.str->data, mode.str->size)));
    T_1_1.num = T_1_2.num;
    if (!T_1_2.num) {
        T_1_3.num = ((mode.str->size != STR_append.str->size)? false :
            !(memcmp(mode.str->data, STR_append.str->data, mode.str->size)));
        T_1_1.num = T_1_3.num;
    }
    _can_write.num = T_1_1.num;
    }

  LINE(88);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = _can_read.num;
    if (!_can_read.num) {
        T_1_1.num = _can_write.num;
    }
    T_1_2.num = !T_1_1.num;
    if (T_1_2.num == true) { /* if */

  LINE(89);
        { /* signal */
            elist[0] = STR_bad_040access_040mode;
            signal(ERR_not_possible);
        }
    }
    } /* end if */

  LINE(90);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    CLUREF T_1_8;
    err = file_nameOPget_dir(fn, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_4.num = ((T_1_3.str->size != STR__057dev.str->size)? false :
        !(memcmp(T_1_3.str->data, STR__057dev.str->data, T_1_3.str->size)));
    T_1_2.num = T_1_4.num;
    if (T_1_4.num) {
        err = file_nameOPget_suffix(fn, &T_1_5);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPempty(T_1_5, &T_1_6);
        if (err != ERR_ok)
            goto ex_0;
        T_1_2.num = T_1_6.num;
    }
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        err = file_nameOPget_other(fn, &T_1_7);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPempty(T_1_7, &T_1_8);
        if (err != ERR_ok)
            goto ex_0;
        T_1_1.num = T_1_8.num;
    }
    if (T_1_1.num == true) { /* if */

  LINE(92);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = file_nameOPget_name(fn, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        T_2_2.num = ((T_2_1.str->size != STR_p.str->size)? false :
            !(memcmp(T_2_1.str->data, STR_p.str->data, T_2_1.str->size)));
        if (T_2_2.num == true) { /* if */

  LINE(93);
            { /* if */
            if (_can_read.num == true) { /* if */

  LINE(94);
                { /* return */
                {
                CLUREF T_4_1;
                err = streamOPprimary_input(&T_4_1);
                if (err != ERR_ok)
                    goto ex_0;
                ret_1->num = T_4_1.num;
                }
                signal (ERR_ok);
                }
            }
            else { /* else */

  LINE(95);
                { /* return */
                {
                CLUREF T_4_1;
                err = streamOPprimary_output(&T_4_1);
                if (err != ERR_ok)
                    goto ex_0;
                ret_1->num = T_4_1.num;
                }
                signal (ERR_ok);
                }
            }} /* end if */
        }
        else {

  LINE(97);
        CLUREF T_2_3;
        CLUREF T_2_4;
        err = file_nameOPget_name(fn, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_4.num = ((T_2_3.str->size != STR_e.str->size)? false :
            !(memcmp(T_2_3.str->data, STR_e.str->data, T_2_3.str->size)));
        if (T_2_4.num == true) { /* elseif */

  LINE(98);
            { /* if */
            if (_can_write.num == true) { /* if */

  LINE(99);
                { /* return */
                {
                CLUREF T_4_1;
                err = streamOPerror_output(&T_4_1);
                if (err != ERR_ok)
                    goto ex_0;
                ret_1->num = T_4_1.num;
                }
                signal (ERR_ok);
                }
            }
            } /* end if */

  LINE(100);
            { /* signal */
                elist[0] = STR_cannot_040read_040from_040this_040stream;
                signal(ERR_not_possible);
            }
        }
        else {

  LINE(101);
        CLUREF T_2_5;
        CLUREF T_2_6;
        err = file_nameOPget_name(fn, &T_2_5);
        if (err != ERR_ok)
            goto ex_0;
        T_2_6.num = ((T_2_5.str->size != STR_null.str->size)? false :
            !(memcmp(T_2_5.str->data, STR_null.str->data, T_2_5.str->size)));
        if (T_2_6.num == true) { /* elseif */

  LINE(102);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            RecordAlloc(4, T_3_1);
            T_3_1.vec->data[1] = fn.num;
            err = sequenceOPnew(&T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            T_3_1.vec->data[3] = T_3_2.num;
            T_3_1.vec->data[2] = false;
            CellAlloc(3, nil, T_3_3);
            T_3_1.vec->data[0] = T_3_3.num;
            st.num = T_3_1.num;
            }

  LINE(106);
            {
            CLUREF T_3_1;
            err = streamOPopen_streams(&T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            {
            if ((T_3_1.array->int_low + T_3_1.array->ext_size + 1) < T_3_1.array->int_size) {
                T_3_1.array->store->data[T_3_1.array->int_low + T_3_1.array->ext_size] = st.num;
                T_3_1.array->ext_size++;
                T_3_1.array->ext_high++;
            }
            else {
                err = arrayOPaddh(T_3_1, st);
                if (err != ERR_ok)
                    goto ex_0;
            }
            }
            }

  LINE(107);
            { /* return */
            {
            ret_1->num = st.num;
            }
            signal (ERR_ok);
            }
        }
        else {

  LINE(108);
        CLUREF T_2_7;
        CLUREF T_2_8;
        err = file_nameOPget_name(fn, &T_2_7);
        if (err != ERR_ok)
            goto ex_0;
        T_2_8.num = ((T_2_7.str->size != STR_tty.str->size)? false :
            !(memcmp(T_2_7.str->data, STR_tty.str->data, T_2_7.str->size)));
        if (T_2_8.num == true) { /* elseif */

  LINE(109);
            {
            mode = STR_modify;
            }
        }
        }}}} /* end if */
    }
    } /* end if */

  LINE(111);
    {
    CLUREF T_2_1;
    err = _chanOPopen(fn, mode, CLU_0, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    ch.num = T_2_1.num;
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(114);
    { /* if */
    if (streamOPfree.num == true) { /* if */

  LINE(115);
        {
        bvec.num = streamOPfreebuf.num;
        }

  LINE(116);
        {
        streamOPfree.tf = false;
        }
    }
    else { /* else */

  LINE(117);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 4096;
        err = _bytevecOPcreate(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        bvec.num = T_2_2.num;
        }
    }} /* end if */

  LINE(120);
    {
    CLUREF T_1_1;
    err = _chanOPis_tty(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    istty.num = T_1_1.num;
    }

  LINE(121);
    { /* if */
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    T_2_1.num = istty.num;
    if (istty.num) {
        T_2_2.num = ((mode.str->size != STR_modify.str->size)? false :
            !(memcmp(mode.str->data, STR_modify.str->data, mode.str->size)));
        T_2_3.num = !T_2_2.num;
        T_2_1.num = T_2_3.num;
    }
    if (T_2_1.num == true) { /* if */

  LINE(122);
        {
        CLUREF T_3_1;
        err = _chanOPopen(fn, STR_modify, CLU_0, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        nch.num = T_3_1.num;
        }

  LINE(123);
        {
        err = _chanOPclose(ch);
        if (err != ERR_ok)
            goto ex_2;
        }

  LINE(124);
        {
        ch.num = nch.num;
        }
    }
    } /* end if */
    goto end_2;
  ex_2: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible) {

  LINE(125);
        {
        istty.tf = false;
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_2:;

  LINE(126);
    { /* if */
    if (istty.num == true) { /* if */

  LINE(127);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(19, T_2_1);
        T_2_1.vec->data[1] = bvec.num;
        T_2_1.vec->data[4] = 1;
        T_2_1.vec->data[11] = 0;
        T_2_1.vec->data[9] = true;
        T_2_1.vec->data[15] = true;
        T_2_1.vec->data[10] = false;
        T_2_1.vec->data[2] = ch.num;
        err = arrayOPnew(&T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[18] = T_2_2.num;
        T_2_1.vec->data[5] = false;
        T_2_1.vec->data[7] = false;
        T_2_1.vec->data[8] = true;
        T_2_1.vec->data[13] = 1;
        T_2_1.vec->data[17] = CLU_empty_string.num;
        T_2_1.vec->data[6] = false;
        T_2_1.vec->data[14] = 0;
        T_2_1.vec->data[16] = 0;
        T_2_1.vec->data[0] = CLU_empty_string.num;
        T_2_1.vec->data[12] = CLU_empty_string.num;
        T_2_1.vec->data[3] = CLU_empty_string.num;
        tb.num = T_2_1.num;
        }

  LINE(146);
        {
        CLUREF T_2_1;
        CellAlloc(6, tb.num, T_2_1);
        b.num = T_2_1.num;
        }

  LINE(147);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = ((mode.str->size != STR_modify.str->size)? false :
            !(memcmp(mode.str->data, STR_modify.str->data, mode.str->size)));
        if (T_2_1.num == true) { /* if */

  LINE(148);
            {
            err = streamOPtermcap(tb, CLU_empty_string);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        } /* end if */
    }
    else {

  LINE(149);
    if (_can_read.num == true) { /* elseif */

  LINE(150);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(5, T_2_1);
        T_2_1.vec->data[0] = bvec.num;
        T_2_1.vec->data[2] = 1;
        T_2_1.vec->data[4] = 0;
        T_2_1.vec->data[3] = 1;
        T_2_1.vec->data[1] = ch.num;
        CellAlloc(5, T_2_1.num, T_2_2);
        b.num = T_2_2.num;
        }
    }
    else { /* else */

  LINE(155);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(4, T_2_1);
        T_2_1.vec->data[0] = bvec.num;
        T_2_1.vec->data[2] = 0;
        T_2_1.vec->data[3] = true;
        T_2_1.vec->data[1] = ch.num;
        CellAlloc(7, T_2_1.num, T_2_2);
        b.num = T_2_2.num;
        }
    }}} /* end if */

  LINE(160);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(4, T_1_1);
    err = _chanOPget_name(ch, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    err = sequenceOPnew(&T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[3] = T_1_3.num;
    T_1_1.vec->data[2] = false;
    T_1_1.vec->data[0] = b.num;
    st.num = T_1_1.num;
    }

  LINE(164);
    {
    CLUREF T_1_1;
    err = streamOPopen_streams(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    {
    if ((T_1_1.array->int_low + T_1_1.array->ext_size + 1) < T_1_1.array->int_size) {
        T_1_1.array->store->data[T_1_1.array->int_low + T_1_1.array->ext_size] = st.num;
        T_1_1.array->ext_size++;
        T_1_1.array->ext_high++;
    }
    else {
        err = arrayOPaddh(T_1_1, st);
        if (err != ERR_ok)
            goto ex_0;
    }
    }
    }

  LINE(165);
    { /* return */
    {
    ret_1->num = st.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE open ****/


/**** BEGIN PROCEDURE open_streams ****/

static int streamOPopen_streams_own_init = 0;
CLUREF streamOPopen_streamsOPlist;

errcode
streamOPopen_streams(CLUREF *ret_1)
{
    errcode err;
    if (streamOPopen_streams_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPopen_streams_own_init = 1;
        {
        CLUREF T_0_1;
        err = arrayOPnew(&T_0_1);
        if (err != ERR_ok)
            goto ex_0;
        streamOPopen_streamsOPlist.num = T_0_1.num;
        }
    }
    enter_proc(168);

  LINE(170);
    { /* return */
    {
    ret_1->num = streamOPopen_streamsOPlist.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE open_streams ****/


/**** BEGIN PROCEDURE primary_input ****/

static int streamOPprimary_input_own_init = 0;
CLUREF streamOPprimary_inputOPpri;
CLUREF streamOPprimary_inputOPpro;

errcode
streamOPprimary_input(CLUREF *ret_1)
{
    errcode err;
    if (streamOPprimary_input_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPprimary_input_own_init = 1;
        {
        CLUREF T_0_1;
        CLUREF T_0_2;
        err = streamOPget_prims(&T_0_1, &T_0_2);
        if (err != ERR_ok)
            goto ex_0;
        streamOPprimary_inputOPpri.num = T_0_1.num;
        streamOPprimary_inputOPpro.num = T_0_2.num;
        }
    }
    enter_proc(173);

  LINE(175);
    { /* return */
    {
    ret_1->num = streamOPprimary_inputOPpri.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE primary_input ****/


/**** BEGIN PROCEDURE primary_output ****/

static int streamOPprimary_output_own_init = 0;
CLUREF streamOPprimary_outputOPpri;
CLUREF streamOPprimary_outputOPpro;

errcode
streamOPprimary_output(CLUREF *ret_1)
{
    errcode err;
    if (streamOPprimary_output_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPprimary_output_own_init = 1;
        {
        CLUREF T_0_1;
        CLUREF T_0_2;
        err = streamOPget_prims(&T_0_1, &T_0_2);
        if (err != ERR_ok)
            goto ex_0;
        streamOPprimary_outputOPpri.num = T_0_1.num;
        streamOPprimary_outputOPpro.num = T_0_2.num;
        }
    }
    enter_proc(178);

  LINE(180);
    { /* return */
    {
    ret_1->num = streamOPprimary_outputOPpro.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE primary_output ****/


/**** BEGIN PROCEDURE error_output ****/

static int streamOPerror_output_own_init = 0;
CLUREF streamOPerror_outputOPinit;
CLUREF streamOPerror_outputOPero;

errcode
streamOPerror_output(CLUREF *ret_1)
{
    errcode err;
    CLUREF ch;
    CLUREF b;
    if (streamOPerror_output_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPerror_output_own_init = 1;
        {
        streamOPerror_outputOPinit.tf = false;
        }
    }
    enter_proc(183);

  LINE(186);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = !streamOPerror_outputOPinit.num;
    if (T_1_1.num == true) { /* if */

  LINE(187);
        {
        CLUREF T_2_1;
        err = _chanOPerror_output(&T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ch.num = T_2_1.num;
        }

  LINE(188);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        RecordAlloc(4, T_2_1);
        T_2_2.num = 2048;
        err = _bytevecOPcreate(T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[0] = T_2_3.num;
        T_2_1.vec->data[2] = 0;
        T_2_1.vec->data[3] = false;
        T_2_1.vec->data[1] = ch.num;
        CellAlloc(7, T_2_1.num, T_2_4);
        b.num = T_2_4.num;
        }

  LINE(193);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        RecordAlloc(4, T_2_1);
        err = _chanOPget_name(ch, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        err = sequenceOPnew(&T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[3] = T_2_3.num;
        T_2_1.vec->data[2] = false;
        T_2_1.vec->data[0] = b.num;
        streamOPerror_outputOPero.num = T_2_1.num;
        }

  LINE(197);
        {
        CLUREF T_2_1;
        err = streamOPopen_streams(&T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        {
        if ((T_2_1.array->int_low + T_2_1.array->ext_size + 1) < T_2_1.array->int_size) {
            T_2_1.array->store->data[T_2_1.array->int_low + T_2_1.array->ext_size] = streamOPerror_outputOPero.num;
            T_2_1.array->ext_size++;
            T_2_1.array->ext_high++;
        }
        else {
            err = arrayOPaddh(T_2_1, streamOPerror_outputOPero);
            if (err != ERR_ok)
                goto ex_0;
        }
        }
        }

  LINE(198);
        {
        streamOPerror_outputOPinit.tf = true;
        }
    }
    } /* end if */

  LINE(200);
    { /* return */
    {
    ret_1->num = streamOPerror_outputOPero.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE error_output ****/


/**** BEGIN PROCEDURE get_prims ****/

static int streamOPget_prims_own_init = 0;
CLUREF streamOPget_primsOPinit;
CLUREF streamOPget_primsOPpri;
CLUREF streamOPget_primsOPpro;

errcode
streamOPget_prims(CLUREF *ret_1, CLUREF *ret_2)
{
    errcode err;
    CLUREF chi;
    CLUREF cho;
    CLUREF opens;
    CLUREF tb;
    CLUREF b;
    if (streamOPget_prims_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPget_prims_own_init = 1;
        {
        streamOPget_primsOPinit.tf = false;
        }
    }
    enter_proc(203);

  LINE(206);
    { /* if */
    if (streamOPget_primsOPinit.num == true) { /* if */

  LINE(207);
        { /* return */
        {
        ret_1->num = streamOPget_primsOPpri.num;
        }
        {
        ret_2->num = streamOPget_primsOPpro.num;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(208);
    {
    CLUREF T_1_1;
    err = _chanOPprimary_input(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    chi.num = T_1_1.num;
    }

  LINE(209);
    {
    CLUREF T_1_1;
    err = _chanOPprimary_output(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    cho.num = T_1_1.num;
    }

  LINE(210);
    {
    CLUREF T_1_1;
    err = streamOPopen_streams(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    opens.num = T_1_1.num;
    }

  LINE(211);
    { /* if */
    CLUREF T_1_1;
    err = _chanOPequal(chi, cho, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_1.num == true) { /* if */

  LINE(212);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        RecordAlloc(19, T_2_1);
        T_2_2.num = 1024;
        err = _bytevecOPcreate(T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[1] = T_2_3.num;
        T_2_1.vec->data[4] = 1;
        T_2_1.vec->data[11] = 0;
        T_2_1.vec->data[9] = true;
        T_2_1.vec->data[15] = true;
        T_2_1.vec->data[10] = false;
        T_2_1.vec->data[2] = chi.num;
        err = arrayOPnew(&T_2_4);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[18] = T_2_4.num;
        T_2_1.vec->data[5] = false;
        T_2_1.vec->data[7] = false;
        T_2_1.vec->data[8] = true;
        T_2_1.vec->data[13] = 1;
        T_2_1.vec->data[17] = CLU_empty_string.num;
        T_2_1.vec->data[6] = false;
        T_2_1.vec->data[14] = 0;
        T_2_1.vec->data[16] = 0;
        T_2_1.vec->data[0] = CLU_empty_string.num;
        T_2_1.vec->data[12] = CLU_empty_string.num;
        T_2_1.vec->data[3] = CLU_empty_string.num;
        tb.num = T_2_1.num;
        }

  LINE(231);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        RecordAlloc(4, T_2_1);
        err = _chanOPget_name(chi, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        err = sequenceOPnew(&T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[3] = T_2_3.num;
        T_2_1.vec->data[2] = false;
        CellAlloc(6, tb.num, T_2_4);
        T_2_1.vec->data[0] = T_2_4.num;
        streamOPget_primsOPpro.num = T_2_1.num;
        }

  LINE(235);
        {
        streamOPget_primsOPpri.num = streamOPget_primsOPpro.num;
        }

  LINE(236);
        {
        {
        if ((opens.array->int_low + opens.array->ext_size + 1) < opens.array->int_size) {
            opens.array->store->data[opens.array->int_low + opens.array->ext_size] = streamOPget_primsOPpro.num;
            opens.array->ext_size++;
            opens.array->ext_high++;
        }
        else {
            err = arrayOPaddh(opens, streamOPget_primsOPpro);
            if (err != ERR_ok)
                goto ex_0;
        }
        }
        }

  LINE(237);
        {
        streamOPget_primsOPinit.tf = true;
        }

  LINE(238);
        {
        err = streamOPtermcap(tb, CLU_empty_string);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(239);
        { /* return */
        {
        ret_1->num = streamOPget_primsOPpri.num;
        }
        {
        ret_2->num = streamOPget_primsOPpro.num;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(241);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    RecordAlloc(5, T_1_1);
    T_1_2.num = 2048;
    err = _bytevecOPcreate(T_1_2, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[0] = T_1_3.num;
    T_1_1.vec->data[2] = 1;
    T_1_1.vec->data[4] = 0;
    T_1_1.vec->data[3] = 1;
    T_1_1.vec->data[1] = chi.num;
    CellAlloc(5, T_1_1.num, T_1_4);
    b.num = T_1_4.num;
    }

  LINE(246);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(4, T_1_1);
    err = _chanOPget_name(chi, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    err = sequenceOPnew(&T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[3] = T_1_3.num;
    T_1_1.vec->data[2] = false;
    T_1_1.vec->data[0] = b.num;
    streamOPget_primsOPpri.num = T_1_1.num;
    }

  LINE(250);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    RecordAlloc(4, T_1_1);
    T_1_2.num = 2048;
    err = _bytevecOPcreate(T_1_2, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[0] = T_1_3.num;
    T_1_1.vec->data[2] = 0;
    T_1_1.vec->data[3] = true;
    T_1_1.vec->data[1] = cho.num;
    CellAlloc(7, T_1_1.num, T_1_4);
    b.num = T_1_4.num;
    }

  LINE(254);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(4, T_1_1);
    err = _chanOPget_name(cho, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    err = sequenceOPnew(&T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[3] = T_1_3.num;
    T_1_1.vec->data[2] = false;
    T_1_1.vec->data[0] = b.num;
    streamOPget_primsOPpro.num = T_1_1.num;
    }

  LINE(258);
    {
    {
    if ((opens.array->int_low + opens.array->ext_size + 1) < opens.array->int_size) {
        opens.array->store->data[opens.array->int_low + opens.array->ext_size] = streamOPget_primsOPpri.num;
        opens.array->ext_size++;
        opens.array->ext_high++;
    }
    else {
        err = arrayOPaddh(opens, streamOPget_primsOPpri);
        if (err != ERR_ok)
            goto ex_0;
    }
    }
    }

  LINE(259);
    {
    {
    if ((opens.array->int_low + opens.array->ext_size + 1) < opens.array->int_size) {
        opens.array->store->data[opens.array->int_low + opens.array->ext_size] = streamOPget_primsOPpro.num;
        opens.array->ext_size++;
        opens.array->ext_high++;
    }
    else {
        err = arrayOPaddh(opens, streamOPget_primsOPpro);
        if (err != ERR_ok)
            goto ex_0;
    }
    }
    }

  LINE(260);
    {
    streamOPget_primsOPinit.tf = true;
    }

  LINE(261);
    { /* return */
    {
    ret_1->num = streamOPget_primsOPpri.num;
    }
    {
    ret_2->num = streamOPget_primsOPpro.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_prims ****/


/**** BEGIN PROCEDURE termcap ****/

static int streamOPtermcap_own_init = 0;

errcode
streamOPtermcap(CLUREF b, CLUREF term)
{
    errcode err;
    CLUREF ibaud;
    CLUREF obaud;
    if (streamOPtermcap_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPtermcap_own_init = 1;
    }
    enter_proc(264);

  LINE(265);
    { /* if */
    CLUREF T_1_1;
    err = stringOPempty(term, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_1.num == true) { /* if */

  LINE(266);
        {
        CLUREF T_3_1;
        err = _get_termcap(&T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        term.num = T_3_1.num;
        }
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_not_found) {

  LINE(267);
            { /* return */
            signal (ERR_ok);
            }
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;
    }
    } /* end if */

  LINE(269);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    err = _termcap(term, STR__072co_043, CLU_0, CLU_0, &T_2_1);
    if (err != ERR_ok)
        goto ex_2;
    err = intOPparse(T_2_1, &T_2_2);
    if (err != ERR_ok)
        goto ex_2;
    b.vec->data[14] = T_2_2.num;
    }
    goto end_2;
  ex_2: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_found
        || err == ERR_bad_format
        || err == ERR_overflow)
    {

  LINE(270);
        {
        b.vec->data[14] = 0;
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_2:;

  LINE(271);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    err = _termcap(term, STR__072li_043, CLU_0, CLU_0, &T_2_1);
    if (err != ERR_ok)
        goto ex_3;
    err = intOPparse(T_2_1, &T_2_2);
    if (err != ERR_ok)
        goto ex_3;
    b.vec->data[16] = T_2_2.num;
    }
    goto end_3;
  ex_3: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_found
        || err == ERR_bad_format
        || err == ERR_overflow)
    {

  LINE(272);
        {
        b.vec->data[14] = 0;
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_3:;

  LINE(273);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = stringOPindexs(STR__072hc_072, term, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_2.num = (T_1_1.num > 0);
    if (T_1_2.num == true) { /* if */

  LINE(274);
        { /* return */
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(275);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    T_2_1.num = b.vec->data[2];
    err = _chanOPget_speeds(T_2_1, &T_2_2, &T_2_3);
    if (err != ERR_ok)
        goto ex_4;
    ibaud.num = T_2_2.num;
    obaud.num = T_2_3.num;
    }
    goto end_4;
  ex_4: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible) {

  LINE(276);
        {
        obaud.num = 9600;
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_4:;

  LINE(277);
    { /* if */
    CLUREF T_3_1;
    CLUREF T_3_2;
    err = stringOPindexs(STR__072bs_072, term, &T_3_1);
    if (err != ERR_ok)
        goto ex_6;
    T_3_2.num = (T_3_1.num > 0);
    if (T_3_2.num == true) { /* if */

  LINE(278);
        {
        b.vec->data[0] = STR__010.num;
        }
    }
    else { /* else */

  LINE(279);
        {
        CLUREF T_4_1;
        err = _termcap(term, STR__072bc_075, CLU_0, CLU_0, &T_4_1);
        if (err != ERR_ok)
            goto ex_6;
        b.vec->data[0] = T_4_1.num;
        }
    }} /* end if */
    goto end_6;
  ex_6: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_found) {

  LINE(281);
        {
        CLUREF T_3_1;
        err = _termcap(term, STR__072kb_075, CLU_0, CLU_0, &T_3_1);
        if (err != ERR_ok)
            goto ex_5;
        b.vec->data[0] = T_3_1.num;
        }
    }
    else { /* not handled */
        goto ex_5;
    }
  end_6:;
    goto end_5;
  ex_5: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_found) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_5:;

  LINE(283);
    {
    CLUREF T_2_1;
    err = _termcap(term, STR__072ce_075, CLU_1, obaud, &T_2_1);
    if (err != ERR_ok)
        goto ex_7;
    b.vec->data[12] = T_2_1.num;
    }
    goto end_7;
  ex_7: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_found) {

  LINE(285);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        CLUREF T_2_7;
        CLUREF T_2_8;
        CLUREF T_2_9;
        T_2_2.num = b.vec->data[0];
        err = stringOPempty(T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_4.num = !T_2_3.num;
        T_2_1.num = T_2_4.num;
        if (T_2_4.num) {
            err = stringOPindexs(STR__072os_072, term, &T_2_6);
            if (err != ERR_ok)
                goto ex_0;
            T_2_7.num = (T_2_6.num == 0);
            T_2_5.num = T_2_7.num;
            if (!T_2_7.num) {
                err = stringOPindexs(STR__072eo_072, term, &T_2_8);
                if (err != ERR_ok)
                    goto ex_0;
                T_2_9.num = (T_2_8.num > 0);
                T_2_5.num = T_2_9.num;
            }
            T_2_1.num = T_2_5.num;
        }
        if (T_2_1.num == true) { /* if */

  LINE(288);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            T_3_1.num = b.vec->data[0];
            T_3_2.ch = ' ';
            err = stringOPappend(T_3_1, T_3_2, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            T_3_4.num = b.vec->data[0];
            err = stringOPconcat(T_3_3, T_3_4, &T_3_5);
            if (err != ERR_ok)
                goto ex_0;
            b.vec->data[0] = T_3_5.num;
            }
        }
        } /* end if */
    }
    else { /* not handled */
        goto ex_0;
    }
  end_7:;

  LINE(291);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = b.vec->data[16];
    err = _termcap(term, STR__072cl_075, T_2_1, obaud, &T_2_2);
    if (err != ERR_ok)
        goto ex_8;
    b.vec->data[3] = T_2_2.num;
    }
    goto end_8;
  ex_8: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_found) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_8:;

  LINE(293);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    CLUREF T_1_8;
    T_1_3.num = b.vec->data[0];
    err = stringOPempty(T_1_3, &T_1_4);
    if (err != ERR_ok)
        goto ex_0;
    T_1_2.num = T_1_4.num;
    if (T_1_4.num) {
        T_1_5.num = b.vec->data[12];
        err = stringOPempty(T_1_5, &T_1_6);
        if (err != ERR_ok)
            goto ex_0;
        T_1_2.num = T_1_6.num;
    }
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        T_1_7.num = b.vec->data[3];
        err = stringOPempty(T_1_7, &T_1_8);
        if (err != ERR_ok)
            goto ex_0;
        T_1_1.num = T_1_8.num;
    }
    if (T_1_1.num == true) { /* if */

  LINE(296);
        {
        b.vec->data[12] = STR__012.num;
        }

  LINE(297);
        {
        b.vec->data[3] = STR__012.num;
        }
    }
    else { /* else */

  LINE(298);
        {
        b.vec->data[6] = true;
        }
    }} /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE termcap ****/


/**** BEGIN PROCEDURE add_script ****/

static errcode streamOPadd_script_IB_1();
static errcode streamOPadd_script_IB_2();
typedef struct {
    errcode ecode2;
    errcode err;
    CLUREF scr;
    CLUREF st1;
    CLUREF st2;
} streamOPadd_script_LOCALS_t;

errcode
streamOPadd_script(CLUREF st1, CLUREF st2)
{
    streamOPadd_script_LOCALS_t locals;
    locals.st1 = st1;
    locals.st2 = st2;
    if (stream_own_init == 0) {
        locals.err = stream_own_init_proc();
        if (locals.err != ERR_ok)
            goto ex_0;
    }
    enter_proc(302);

  LINE(303);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = locals.st2.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(305);
        { /* signal */
            signal(ERR_script_failed);
        }
        break;
    }
    default: {

  LINE(307);
        { /* for */
            locals.err = streamOPall_scripts(locals.st2, streamOPadd_script_IB_1, &locals, &locals.ecode2);

            if (locals.err == ERR_iterbodyreturn) {
                signal(ERR_ok);
            }
            if (locals.err == ERR_iterbodysignal)
                signal(locals.ecode2);
            if (locals.err == ERR_break)
                locals.err = ERR_ok;
            if (locals.err == ERR_iterbodyexit)
                locals.err = locals.ecode2;
            if (locals.err != ERR_ok)
                goto ex_0;
        }

  LINE(311);
        { /* for */
            locals.err = streamOPall_scripts(locals.st1, streamOPadd_script_IB_2, &locals, &locals.ecode2);

            if (locals.err == ERR_iterbodyreturn) {
                signal(ERR_ok);
            }
            if (locals.err == ERR_iterbodysignal)
                signal(locals.ecode2);
            if (locals.err == ERR_break)
                locals.err = ERR_ok;
            if (locals.err == ERR_iterbodyexit)
                locals.err = locals.ecode2;
            if (locals.err != ERR_ok)
                goto ex_0;
        }

  LINE(315);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = locals.st1.vec->data[3];
        locals.err = sequenceOPaddh(T_2_1, locals.st2, &T_2_2);
        if (locals.err != ERR_ok)
            goto ex_0;
        locals.st1.vec->data[3] = T_2_2.num;
        }

  LINE(316);
        {
        locals.st1.vec->data[2] = true;
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (locals.err != ERR_failure)
        elist[0] = _pclu_erstr(locals.err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE add_script ****/


/**** BEGIN ITERATOR BODIES for add_script ****/

static errcode
streamOPadd_script_IB_1(CLUREF iv_1, streamOPadd_script_LOCALS_t *locals, errcode *iecode)
{
    locals->scr.num = iv_1.num;
    enter_iter_body_proc(308);

  FB_LINE(308);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (locals->st1.num == locals->scr.num);
    if (T_1_1.num == true) { /* if */

  FB_LINE(309);
        { /* signal */
            *iecode = ERR_script_failed;
            signal(ERR_iterbodysignal);
        }
    }
    } /* end if */

    signal(ERR_ok);
  ex_0:
    __CLU_EX_HANDLER;
    *iecode = locals->err;
    signal(ERR_iterbodyexit);
  end_0:
    __CLU_END_LABEL;
    signal(ERR_ok);
}

static errcode
streamOPadd_script_IB_2(CLUREF iv_1, streamOPadd_script_LOCALS_t *locals, errcode *iecode)
{
    locals->scr.num = iv_1.num;
    enter_iter_body_proc(312);

  FB_LINE(312);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (locals->st2.num == locals->scr.num);
    if (T_1_1.num == true) { /* if */

  FB_LINE(313);
        { /* signal */
            *iecode = ERR_script_failed;
            signal(ERR_iterbodysignal);
        }
    }
    } /* end if */

    signal(ERR_ok);
  ex_0:
    __CLU_EX_HANDLER;
    *iecode = locals->err;
    signal(ERR_iterbodyexit);
  end_0:
    __CLU_END_LABEL;
    signal(ERR_ok);
}

/**** END ITERATOR BODIES for add_script ****/


/**** BEGIN ITERATOR all_scripts ****/

static errcode streamOPall_scripts_IB_1();
typedef struct {
    void *user_locals;
    errcode (*proc)();
    errcode ecode2;
    errcode err;
    bool body_ctrl_req;
    CLUREF scr1;
    CLUREF scr2;
    CLUREF st;
} streamOPall_scripts_LOCALS_t;

errcode
streamOPall_scripts(CLUREF st, errcode (*proc)(), void *user_locals, errcode *iecode)
{
    errcode ecode __CLU_UNUSED;
    streamOPall_scripts_LOCALS_t locals;
    locals.st = st;
    locals.proc = proc;
    locals.user_locals = user_locals;
    if (stream_own_init == 0) {
        locals.err = stream_own_init_proc();
        if (locals.err != ERR_ok)
            goto ex_0;
    }
    enter_proc(320);

  LINE(321);
    { /* yield */
    locals.err = (*locals.proc)(locals.st, locals.user_locals, iecode);
    if (locals.err != ERR_ok) {
        signal(locals.err);
    }
    }

  LINE(322);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = locals.st.vec->data[3];
    T_1_3.num = T_1_1.vec->size;
    T_1_4 = T_1_1;
    for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
        locals.scr1.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(323);
        { /* for */
            locals.body_ctrl_req = false;
            locals.err = streamOPall_scripts(locals.scr1, streamOPall_scripts_IB_1, &locals, &locals.ecode2);

            if (locals.err == ERR_iterbodyreturn)
                signal(ERR_iterbodyreturn);
            if (locals.err == ERR_iterbodysignal) {
                *iecode = locals.ecode2;
                signal(ERR_iterbodysignal);
            }
            if (locals.err == ERR_iterbodyexit) {
                *iecode = locals.ecode2;
                signal(ERR_iterbodyexit);
            }
            if (locals.body_ctrl_req) {
                locals.body_ctrl_req = false;
                if (locals.err == ERR_iteriterbodyreturn)
                    signal(ERR_ok);
                if (locals.err == ERR_iteriterbodysignal)
                    signal(locals.ecode2);
                if (locals.err == ERR_break)
                    locals.err = ERR_ok;
                if (locals.err == ERR_iteriterbodyexit)
                    locals.err = locals.ecode2;
            }
            else {
                if (locals.err == ERR_iteriterbodyreturn)
                    signal(ERR_iteriterbodyreturn);
                if (locals.err == ERR_break)
                    signal(ERR_break);
                if (locals.err == ERR_iteriterbodysignal) {
                    *iecode = locals.ecode2;
                    signal(ERR_iteriterbodysignal);
                }
                if (locals.err == ERR_iteriterbodyexit) {
                    *iecode = locals.ecode2;
                    signal(ERR_iteriterbodyexit);
                }
            }
            if (locals.err != ERR_ok)
                goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (locals.err != ERR_failure)
        elist[0] = _pclu_erstr(locals.err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END ITERATOR all_scripts ****/


/**** BEGIN ITERATOR BODIES for all_scripts ****/

static errcode
streamOPall_scripts_IB_1(CLUREF iv_1, streamOPall_scripts_LOCALS_t *locals, errcode *iecode)
{
    locals->scr2.num = iv_1.num;
    enter_iter_body_proc(324);

  FB_LINE(324);
    { /* yield */
    locals->err = (*locals->proc)(locals->scr2, locals->user_locals, iecode);
    if (locals->body_ctrl_req && locals->err == ERR_iteriterbodyexit) {
        locals->err = *iecode;
        goto ex_0;
    }
    if (locals->err != ERR_ok) {
        signal(locals->err);
    }
    }

    signal(ERR_ok);
  ex_0:
    __CLU_EX_HANDLER;
    *iecode = locals->err;
    locals->body_ctrl_req = true;
    signal(ERR_iteriterbodyexit);
  end_0:
    __CLU_END_LABEL;
    signal(ERR_ok);
}

/**** END ITERATOR BODIES for all_scripts ****/


/**** BEGIN ITERATOR scripts ****/


errcode
streamOPscripts(CLUREF st, errcode (*proc)(), void *user_locals, errcode *iecode)
{
    errcode ecode __CLU_UNUSED;
    errcode err;
    CLUREF scr;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(329);

  LINE(330);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = st.vec->data[3];
    T_1_3.num = T_1_1.vec->size;
    T_1_4 = T_1_1;
    for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
        scr.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(331);
        { /* yield */
        err = (*proc)(scr, user_locals, iecode);
        if (err != ERR_ok) {
            signal(err);
        }
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END ITERATOR scripts ****/


/**** BEGIN PROCEDURE rem_script ****/


errcode
streamOPrem_script(CLUREF st1, CLUREF st2)
{
    errcode err;
    CLUREF scrs;
    CLUREF i;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(335);

  LINE(336);
    {
    CLUREF T_1_1;
    T_1_1.num = st1.vec->data[3];
    scrs.num = T_1_1.num;
    }

  LINE(337);
    { /* for sequence$indexes */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = scrs.vec->size;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        i.num = T_1_1.num;

  LINE(338);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (i.num < 1 || i.num > scrs.vec->size) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.num = scrs.vec->data[i.num - 1];
        err = streamOPequal(T_2_1, st2, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        if (T_2_2.num == true) { /* if */

  LINE(339);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            CLUREF T_3_6;
            T_3_1.num = i.num - 1;
            if ((T_3_1.num >= 0 && i.num < 0 && (-1) < 0) ||
                (T_3_1.num <= 0 && i.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            err = sequenceOPsubseq(scrs, CLU_1, T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            T_3_3.num = i.num + 1;
            if ((T_3_3.num > 0 && i.num < 0 && 1 < 0) ||
                (T_3_3.num < 0 && i.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            T_3_4.num = scrs.vec->size;
            err = sequenceOPsubseq(scrs, T_3_3, T_3_4, &T_3_5);
            if (err != ERR_ok)
                goto ex_0;
            err = sequenceOPconcat(T_3_2, T_3_5, &T_3_6);
            if (err != ERR_ok)
                goto ex_0;
            st1.vec->data[3] = T_3_6.num;
            }

  LINE(341);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = st1.vec->data[3];
            err = sequenceOPempty(T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            T_3_3.num = !T_3_2.num;
            st1.vec->data[2] = T_3_3.num;
            }

  LINE(342);
            { /* return */
            signal (ERR_ok);
            }
        }
        } /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE rem_script ****/


/**** BEGIN PROCEDURE unscript ****/


errcode
streamOPunscript(CLUREF st)
{
    errcode err;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(347);

  LINE(348);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    st.vec->data[3] = T_1_1.num;
    }

  LINE(349);
    {
    st.vec->data[2] = false;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE unscript ****/


/**** BEGIN PROCEDURE can_read ****/


errcode
streamOPcan_read(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(352);

  LINE(353);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 7: /* write */ /* FALLTHROUGH */
    case 4: /* ostr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(355);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(357);
        { /* return */
        {
        ret_1->tf = true;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE can_read ****/


/**** BEGIN PROCEDURE can_write ****/


errcode
streamOPcan_write(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(361);

  LINE(362);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(364);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(366);
        { /* return */
        {
        ret_1->tf = true;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE can_write ****/


/**** BEGIN PROCEDURE getc ****/

static int streamOPgetc_own_init = 0;

errcode
streamOPgetc(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF c;
    CLUREF rb;
    CLUREF index;
    CLUREF tb;
    CLUREF sb;
    if (streamOPgetc_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPgetc_own_init = 1;
    }
    enter_proc(370);

  LINE(373);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(375);
        {
        CLUREF T_3_1;
        T_3_1.num = rb.vec->data[2];
        index.num = T_3_1.num;
        }

  LINE(376);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = rb.vec->data[4];
        T_3_2.num = (index.num > T_3_1.num);
        if (T_3_2.num == true) { /* if */

  LINE(377);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = rb.vec->data[1];
            T_4_2.num = rb.vec->data[0];
            err = _chanOPgetb(T_4_1, T_4_2, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            rb.vec->data[4] = T_4_3.num;
            }

  LINE(378);
            {
            index.num = 1;
            }
        }
        } /* end if */

  LINE(380);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = rb.vec->data[0];
        if (index.num < 1 || index.num > T_3_1.str->size) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_2.ch = T_3_1.str->data[index.num - 1];
        c.num = T_3_2.num;
        }

  LINE(381);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.ch = '\n';
        T_3_2.num = (c.ch == T_3_1.ch);
        if (T_3_2.num == true) { /* if */

  LINE(382);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = rb.vec->data[3];
            T_4_2.num = T_4_1.num + 1;
            if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) ||
                (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            rb.vec->data[3] = T_4_2.num;
            }
        }
        } /* end if */

  LINE(383);
        {
        CLUREF T_3_1;
        T_3_1.num = index.num + 1;
        if ((T_3_1.num > 0 && index.num < 0 && 1 < 0) ||
            (T_3_1.num < 0 && index.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        rb.vec->data[2] = T_3_1.num;
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(385);
        {
        err = streamOPflush(st);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(386);
        {
        CLUREF T_3_1;
        err = streamOPtty_get1(tb, CLU_false, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        c.num = T_3_1.num;
        }

  LINE(387);
        {
        err = streamOPtty_put1(tb, c);
        if (err != ERR_ok)
            goto ex_1;
        }
        break;
    }
    case 2: /* istr */ {
        CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        sb.num = T_2_4.num;

  LINE(389);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_1.num = sb.vec->data[0];
        T_4_2.num = sb.vec->data[1];
        err = stringOPfetch(T_4_1, T_4_2, &T_4_3);
        if (err != ERR_ok)
            goto ex_2;
        c.num = T_4_3.num;
        }
        goto end_2;
      ex_2: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_bounds) {

  LINE(391);
            {
            CLUREF T_4_1;
            T_4_1.num = sb.vec->data[3];
            c.num = T_4_1.num;
            }

  LINE(392);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.ch = ' ';
            T_4_2.num = (c.ch == T_4_1.ch);
            if (T_4_2.num == true) { /* if */

  LINE(393);
                { /* signal */
                    signal(ERR_end_of_file);
                }
            }
            } /* end if */

  LINE(394);
            {
            CLUREF T_4_1;
            T_4_1.ch = ' ';
            sb.vec->data[3] = T_4_1.num;
            }
        }
        else { /* not handled */
            goto ex_1;
        }
      end_2:;

  LINE(396);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = sb.vec->data[1];
        T_3_2.num = T_3_1.num + 1;
        if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) ||
            (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        sb.vec->data[1] = T_3_2.num;
        }

  LINE(397);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.ch = '\n';
        T_3_2.num = (c.ch == T_3_1.ch);
        if (T_3_2.num == true) { /* if */

  LINE(398);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = sb.vec->data[2];
            T_4_2.num = T_4_1.num + 1;
            if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) ||
                (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            sb.vec->data[2] = T_4_2.num;
            }
        }
        } /* end if */
        break;
    }
    case 3: /* nul */ {

  LINE(400);
        { /* signal */
            signal(ERR_end_of_file);
        }
        break;
    }
    case 7: /* write */ /* FALLTHROUGH */
    case 4: /* ostr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(402);
        { /* signal */
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file)
        signal(err);
    else if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(404);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) { /* if */

  LINE(405);
        {
        CLUREF T_2_1;
        err = stringOPc2s(c, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = streamOPscript(st, T_2_1, CLU_false);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(406);
    { /* return */
    {
    ret_1->num = c.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE getc ****/


/**** BEGIN PROCEDURE getc_image ****/

static int streamOPgetc_image_own_init = 0;

errcode
streamOPgetc_image(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF c;
    CLUREF rb;
    CLUREF index;
    CLUREF tb;
    CLUREF sb;
    if (streamOPgetc_image_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPgetc_image_own_init = 1;
    }
    enter_proc(409);

  LINE(412);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(414);
        {
        CLUREF T_3_1;
        T_3_1.num = rb.vec->data[2];
        index.num = T_3_1.num;
        }

  LINE(415);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = rb.vec->data[4];
        T_3_2.num = (index.num > T_3_1.num);
        if (T_3_2.num == true) { /* if */

  LINE(416);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = rb.vec->data[1];
            T_4_2.num = rb.vec->data[0];
            err = _chanOPgetb(T_4_1, T_4_2, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            rb.vec->data[4] = T_4_3.num;
            }

  LINE(417);
            {
            index.num = 1;
            }
        }
        } /* end if */

  LINE(419);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = rb.vec->data[0];
        if (index.num < 1 || index.num > T_3_1.str->size) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_2.ch = T_3_1.str->data[index.num - 1];
        c.num = T_3_2.num;
        }

  LINE(420);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.ch = '\n';
        T_3_2.num = (c.ch == T_3_1.ch);
        if (T_3_2.num == true) { /* if */

  LINE(421);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = rb.vec->data[3];
            T_4_2.num = T_4_1.num + 1;
            if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) ||
                (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            rb.vec->data[3] = T_4_2.num;
            }
        }
        } /* end if */

  LINE(422);
        {
        CLUREF T_3_1;
        T_3_1.num = index.num + 1;
        if ((T_3_1.num > 0 && index.num < 0 && 1 < 0) ||
            (T_3_1.num < 0 && index.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        rb.vec->data[2] = T_3_1.num;
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(424);
        {
        err = streamOPflush(st);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(425);
        {
        CLUREF T_3_1;
        err = streamOPtty_get1(tb, CLU_true, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        c.num = T_3_1.num;
        }
        break;
    }
    case 2: /* istr */ {
        CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        sb.num = T_2_4.num;

  LINE(427);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_1.num = sb.vec->data[0];
        T_4_2.num = sb.vec->data[1];
        err = stringOPfetch(T_4_1, T_4_2, &T_4_3);
        if (err != ERR_ok)
            goto ex_2;
        c.num = T_4_3.num;
        }
        goto end_2;
      ex_2: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_bounds) {

  LINE(429);
            {
            CLUREF T_4_1;
            T_4_1.num = sb.vec->data[3];
            c.num = T_4_1.num;
            }

  LINE(430);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.ch = ' ';
            T_4_2.num = (c.ch == T_4_1.ch);
            if (T_4_2.num == true) { /* if */

  LINE(431);
                { /* signal */
                    signal(ERR_end_of_file);
                }
            }
            } /* end if */

  LINE(432);
            {
            CLUREF T_4_1;
            T_4_1.ch = ' ';
            sb.vec->data[3] = T_4_1.num;
            }
        }
        else { /* not handled */
            goto ex_1;
        }
      end_2:;

  LINE(434);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = sb.vec->data[1];
        T_3_2.num = T_3_1.num + 1;
        if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) ||
            (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        sb.vec->data[1] = T_3_2.num;
        }

  LINE(435);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.ch = '\n';
        T_3_2.num = (c.ch == T_3_1.ch);
        if (T_3_2.num == true) { /* if */

  LINE(436);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = sb.vec->data[2];
            T_4_2.num = T_4_1.num + 1;
            if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) ||
                (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            sb.vec->data[2] = T_4_2.num;
            }
        }
        } /* end if */
        break;
    }
    case 3: /* nul */ {

  LINE(438);
        { /* signal */
            signal(ERR_end_of_file);
        }
        break;
    }
    case 7: /* write */ /* FALLTHROUGH */
    case 4: /* ostr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(440);
        { /* signal */
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file)
        signal(err);
    else if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(442);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) { /* if */

  LINE(443);
        {
        CLUREF T_2_1;
        err = stringOPc2s(c, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = streamOPscript(st, T_2_1, CLU_true);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(444);
    { /* return */
    {
    ret_1->num = c.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE getc_image ****/


/**** BEGIN PROCEDURE peekc ****/

static int streamOPpeekc_own_init = 0;

errcode
streamOPpeekc(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF rb;
    CLUREF index;
    CLUREF tb;
    CLUREF c;
    CLUREF sb;
    if (streamOPpeekc_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPpeekc_own_init = 1;
    }
    enter_proc(447);

  LINE(449);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(451);
        {
        CLUREF T_3_1;
        T_3_1.num = rb.vec->data[2];
        index.num = T_3_1.num;
        }

  LINE(452);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = rb.vec->data[4];
        T_3_2.num = (index.num > T_3_1.num);
        if (T_3_2.num == true) { /* if */

  LINE(453);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = rb.vec->data[1];
            T_4_2.num = rb.vec->data[0];
            err = _chanOPgetb(T_4_1, T_4_2, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            rb.vec->data[4] = T_4_3.num;
            }

  LINE(454);
            {
            rb.vec->data[2] = 1;
            }

  LINE(455);
            {
            index.num = 1;
            }
        }
        } /* end if */

  LINE(457);
        { /* return */
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = rb.vec->data[0];
        if (index.num < 1 || index.num > T_3_1.str->size) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_2.ch = T_3_1.str->data[index.num - 1];
        ret_1->num = T_3_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(459);
        {
        err = streamOPflush(st);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(460);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        T_3_2.num = tb.vec->data[7];
        T_3_1.num = T_3_2.num;
        if (T_3_2.num) {
            T_3_3.num = tb.vec->data[8];
            T_3_1.num = T_3_3.num;
        }
        if (T_3_1.num == true) { /* if */

  LINE(461);
            { /* signal */
                signal(ERR_end_of_file);
            }
        }
        } /* end if */

  LINE(462);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = tb.vec->data[18];
        T_3_2.num = (T_3_1.array->ext_size == 0);
        if (T_3_2.num == true) { /* if */

  LINE(463);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = tb.vec->data[2];
            err = _chanOPgetc(T_4_1, CLU_true, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            c.num = T_4_2.num;
            }

  LINE(464);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            T_4_2.ch = '\004';
            T_4_3.num = (c.ch == T_4_2.ch);
            T_4_1.num = T_4_3.num;
            if (T_4_3.num) {
                T_4_4.num = tb.vec->data[8];
                T_4_1.num = T_4_4.num;
            }
            if (T_4_1.num == true) { /* if */

  LINE(465);
                {
                tb.vec->data[7] = true;
                }

  LINE(466);
                { /* signal */
                    signal(ERR_end_of_file);
                }
            }
            } /* end if */

  LINE(468);
            {
            CLUREF T_4_1;
            T_4_1.num = tb.vec->data[18];
            {
            if ((T_4_1.array->int_low + T_4_1.array->ext_size + 1) < T_4_1.array->int_size) {
                T_4_1.array->store->data[T_4_1.array->int_low + T_4_1.array->ext_size] = c.num;
                T_4_1.array->ext_size++;
                T_4_1.array->ext_high++;
            }
            else {
                err = arrayOPaddh(T_4_1, c);
                if (err != ERR_ok)
                    goto ex_1;
            }
            }
            }

  LINE(469);
            {
            tb.vec->data[5] = true;
            }
        }
        } /* end if */

  LINE(471);
        { /* return */
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = tb.vec->data[18];
        err = arrayOPbottom(T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        ret_1->num = T_3_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 2: /* istr */ {
        CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        sb.num = T_2_4.num;

  LINE(473);
        { /* return */
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_1.num = sb.vec->data[0];
        T_4_2.num = sb.vec->data[1];
        err = stringOPfetch(T_4_1, T_4_2, &T_4_3);
        if (err != ERR_ok)
            goto ex_2;
        ret_1->num = T_4_3.num;
        }
        signal (ERR_ok);
        }
        goto end_2;
      ex_2: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_bounds) {

  LINE(475);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = sb.vec->data[3];
            T_4_2.ch = ' ';
            T_4_3.num = (T_4_1.ch == T_4_2.ch);
            if (T_4_3.num == true) { /* if */

  LINE(476);
                { /* signal */
                    signal(ERR_end_of_file);
                }
            }
            } /* end if */

  LINE(477);
            { /* return */
            {
            CLUREF T_4_1;
            T_4_1.ch = '\n';
            ret_1->num = T_4_1.num;
            }
            signal (ERR_ok);
            }
        }
        else { /* not handled */
            goto ex_1;
        }
      end_2:;
        break;
    }
    case 3: /* nul */ {

  LINE(480);
        { /* signal */
            signal(ERR_end_of_file);
        }
        break;
    }
    case 7: /* write */ /* FALLTHROUGH */
    case 4: /* ostr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(482);
        { /* signal */
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file)
        signal(err);
    else if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE peekc ****/


/**** BEGIN PROCEDURE pending ****/


errcode
streamOPpending(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF tb;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(486);

  LINE(487);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 6: /* tty */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        tb.num = T_2_2.num;

  LINE(489);
        { /* return */
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        CLUREF T_3_7;
        CLUREF T_3_8;
        CLUREF T_3_9;
        CLUREF T_3_10;
        CLUREF T_3_11;
        T_3_3.num = tb.vec->data[7];
        T_3_2.num = T_3_3.num;
        if (T_3_3.num) {
            T_3_4.num = tb.vec->data[8];
            T_3_2.num = T_3_4.num;
        }
        T_3_5.num = !T_3_2.num;
        T_3_1.num = T_3_5.num;
        if (T_3_5.num) {
            T_3_7.num = tb.vec->data[18];
            T_3_8.num = (T_3_7.array->ext_size == 0);
            T_3_9.num = !T_3_8.num;
            T_3_6.num = T_3_9.num;
            if (!T_3_9.num) {
                T_3_10.num = tb.vec->data[2];
                err = _chanOPpending(T_3_10, CLU_false, &T_3_11);
                if (err != ERR_ok)
                    goto ex_1;
                T_3_6.num = T_3_11.num;
            }
            T_3_1.num = T_3_6.num;
        }
        ret_1->num = T_3_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(493);
        { /* return */
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = streamOPempty(st, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        T_3_2.num = !T_3_1.num;
        ret_1->num = T_3_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE pending ****/


/**** BEGIN PROCEDURE empty ****/

static int streamOPempty_own_init = 0;

errcode
streamOPempty(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF rb;
    CLUREF tb;
    CLUREF sb;
    if (streamOPempty_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPempty_own_init = 1;
    }
    enter_proc(497);

  LINE(498);
    { /* qtagcase */
    CLUREF T_3_1;
    T_3_1.num = st.vec->data[0];
    switch (T_3_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_3_2;
        T_3_2.num = T_3_1.cell->value;
        rb.num = T_3_2.num;

  LINE(500);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_1.num = rb.vec->data[2];
        T_4_2.num = rb.vec->data[4];
        T_4_3.num = (T_4_1.num > T_4_2.num);
        if (T_4_3.num == true) { /* if */

  LINE(501);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            CLUREF T_5_3;
            T_5_1.num = rb.vec->data[1];
            T_5_2.num = rb.vec->data[0];
            err = _chanOPgetb(T_5_1, T_5_2, &T_5_3);
            if (err != ERR_ok)
                goto ex_2;
            rb.vec->data[4] = T_5_3.num;
            }

  LINE(502);
            {
            rb.vec->data[2] = 1;
            }
        }
        } /* end if */

  LINE(504);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_3_3;
        T_3_3.num = T_3_1.cell->value;
        tb.num = T_3_3.num;

  LINE(506);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        T_4_1.num = tb.vec->data[8];
        T_4_2.num = !T_4_1.num;
        if (T_4_2.num == true) { /* if */

  LINE(507);
            { /* return */
            {
            ret_1->tf = false;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(508);
        {
        CLUREF T_4_1;
        err = streamOPpeekc(st, &T_4_1);
        if (err != ERR_ok)
            goto ex_2;
        }

  LINE(509);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 2: /* istr */ {
        CLUREF T_3_4;
        T_3_4.num = T_3_1.cell->value;
        sb.num = T_3_4.num;

  LINE(511);
        { /* return */
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        CLUREF T_4_4;
        CLUREF T_4_5;
        CLUREF T_4_6;
        CLUREF T_4_7;
        CLUREF T_4_8;
        T_4_2.num = sb.vec->data[1];
        T_4_3.num = sb.vec->data[0];
        err = stringOPsize(T_4_3, &T_4_4);
        if (err != ERR_ok)
            goto ex_2;
        T_4_5.num = (T_4_2.num > T_4_4.num);
        T_4_1.num = T_4_5.num;
        if (T_4_5.num) {
            T_4_6.num = sb.vec->data[3];
            T_4_7.ch = ' ';
            T_4_8.num = (T_4_6.ch == T_4_7.ch);
            T_4_1.num = T_4_8.num;
        }
        ret_1->num = T_4_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 3: /* nul */ {

  LINE(513);
        { /* return */
        {
        ret_1->tf = true;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 7: /* write */ /* FALLTHROUGH */
    case 4: /* ostr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(515);
        { /* signal */
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_2;
  ex_2: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_1;
  end_2:;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file) {

  LINE(517);
        { /* return */
        {
        ret_1->tf = true;
        }
        signal (ERR_ok);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE empty ****/


/**** BEGIN PROCEDURE putc ****/

static int streamOPputc_own_init = 0;

errcode
streamOPputc(CLUREF st, CLUREF c)
{
    errcode err;
    CLUREF wb;
    CLUREF low;
    CLUREF index;
    CLUREF tb;
    CLUREF chars;
    if (streamOPputc_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPputc_own_init = 1;
    }
    enter_proc(520);

  LINE(521);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 7: /* write */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(523);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = wb.vec->data[3];
        if (T_3_1.num == true) { /* if */

  LINE(524);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            CLUREF T_4_6;
            T_4_1.num = wb.vec->data[1];
            T_4_2.num = wb.vec->data[0];
            T_4_3.num = wb.vec->data[2];
            err = stringOPc2s(c, &T_4_4);
            if (err != ERR_ok)
                goto ex_1;
            err = _chanOPput(T_4_1, T_4_2, CLU_1, T_4_3, T_4_4, CLU_false, &T_4_5, &T_4_6);
            if (err != ERR_ok)
                goto ex_1;
            low.num = T_4_5.num;
            index.num = T_4_6.num;
            }

  LINE(527);
            {
            wb.vec->data[2] = index.num;
            }
        }
        else { /* else */

  LINE(528);
            {
            CLUREF T_4_1;
            T_4_1.num = wb.vec->data[1];
            err = _chanOPputc(T_4_1, c, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }
        }} /* end if */
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(531);
        {
        CLUREF T_3_1;
        err = stringOPc2s(c, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        err = streamOPtty_put(tb, T_3_1, CLU_false);
        if (err != ERR_ok)
            goto ex_1;
        }
        break;
    }
    case 4: /* ostr */ {
        CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        chars.num = T_2_4.num;

  LINE(533);
        {
        {
        if ((chars.array->int_low + chars.array->ext_size + 1) < chars.array->int_size) {
            chars.array->store->data[chars.array->int_low + chars.array->ext_size] = c.num;
            chars.array->ext_size++;
            chars.array->ext_high++;
        }
        else {
            err = arrayOPaddh(chars, c);
            if (err != ERR_ok)
                goto ex_1;
        }
        }
        }
        break;
    }
    case 3: /* nul */ {
        break;
    }
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(536);
        { /* signal */
            elist[0] = STR_cannot_040write_040to_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(538);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) { /* if */

  LINE(539);
        {
        CLUREF T_2_1;
        err = stringOPc2s(c, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = streamOPscript(st, T_2_1, CLU_false);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE putc ****/


/**** BEGIN PROCEDURE putc_image ****/

static int streamOPputc_image_own_init = 0;

errcode
streamOPputc_image(CLUREF st, CLUREF c)
{
    errcode err;
    CLUREF wb;
    CLUREF low;
    CLUREF index;
    CLUREF tb;
    CLUREF chars;
    if (streamOPputc_image_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPputc_image_own_init = 1;
    }
    enter_proc(542);

  LINE(543);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 7: /* write */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(545);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = wb.vec->data[3];
        if (T_3_1.num == true) { /* if */

  LINE(546);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            CLUREF T_4_6;
            T_4_1.num = wb.vec->data[1];
            T_4_2.num = wb.vec->data[0];
            T_4_3.num = wb.vec->data[2];
            err = stringOPc2s(c, &T_4_4);
            if (err != ERR_ok)
                goto ex_1;
            err = _chanOPput(T_4_1, T_4_2, CLU_1, T_4_3, T_4_4, CLU_true, &T_4_5, &T_4_6);
            if (err != ERR_ok)
                goto ex_1;
            low.num = T_4_5.num;
            index.num = T_4_6.num;
            }

  LINE(549);
            {
            wb.vec->data[2] = index.num;
            }
        }
        else { /* else */

  LINE(550);
            {
            CLUREF T_4_1;
            T_4_1.num = wb.vec->data[1];
            err = _chanOPputc(T_4_1, c, CLU_true);
            if (err != ERR_ok)
                goto ex_1;
            }
        }} /* end if */
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(553);
        {
        CLUREF T_3_1;
        err = stringOPc2s(c, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        err = streamOPtty_put(tb, T_3_1, CLU_true);
        if (err != ERR_ok)
            goto ex_1;
        }
        break;
    }
    case 4: /* ostr */ {
        CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        chars.num = T_2_4.num;

  LINE(555);
        {
        {
        if ((chars.array->int_low + chars.array->ext_size + 1) < chars.array->int_size) {
            chars.array->store->data[chars.array->int_low + chars.array->ext_size] = c.num;
            chars.array->ext_size++;
            chars.array->ext_high++;
        }
        else {
            err = arrayOPaddh(chars, c);
            if (err != ERR_ok)
                goto ex_1;
        }
        }
        }
        break;
    }
    case 3: /* nul */ {
        break;
    }
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(558);
        { /* signal */
            elist[0] = STR_cannot_040write_040to_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(560);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) { /* if */

  LINE(561);
        {
        CLUREF T_2_1;
        err = stringOPc2s(c, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = streamOPscript(st, T_2_1, CLU_true);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE putc_image ****/


/**** BEGIN PROCEDURE get_lineno ****/

static int streamOPget_lineno_own_init = 0;

errcode
streamOPget_lineno(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF rb;
    CLUREF tb;
    CLUREF sb;
    if (streamOPget_lineno_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPget_lineno_own_init = 1;
    }
    enter_proc(564);

  LINE(565);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        rb.num = T_1_2.num;

  LINE(567);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = rb.vec->data[3];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        tb.num = T_1_3.num;

  LINE(569);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[13];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 2: /* istr */ {
        CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        sb.num = T_1_4.num;

  LINE(571);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = sb.vec->data[2];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(573);
        { /* signal */
            elist[0] = STR_no_040line_040numbers;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_lineno ****/


/**** BEGIN PROCEDURE set_lineno ****/


errcode
streamOPset_lineno(CLUREF st, CLUREF ln)
{
    errcode err;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(577);

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_lineno ****/


/**** BEGIN PROCEDURE reset ****/


errcode
streamOPreset(CLUREF st)
{
    errcode err;
    CLUREF rb;
    CLUREF wb;
    CLUREF tb;
    CLUREF sb;
    CLUREF chars;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(580);

  LINE(581);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(583);
        {
        CLUREF T_3_1;
        T_3_1.num = rb.vec->data[1];
        err = _chanOPreset(T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(584);
        {
        rb.vec->data[3] = 1;
        }

  LINE(585);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = rb.vec->data[4];
        T_3_2.num = T_3_1.num + 1;
        if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) ||
            (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        rb.vec->data[2] = T_3_2.num;
        }
        break;
    }
    case 7: /* write */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(587);
        {
        CLUREF T_3_1;
        T_3_1.num = wb.vec->data[1];
        err = _chanOPreset(T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(588);
        {
        wb.vec->data[2] = 0;
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        tb.num = T_2_4.num;

  LINE(590);
        {
        CLUREF T_3_1;
        T_3_1.num = tb.vec->data[2];
        err = _chanOPreset(T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(591);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        T_3_2.num = tb.vec->data[4];
        T_3_3.num = (T_3_2.num > 1);
        T_3_1.num = T_3_3.num;
        if (!T_3_3.num) {
            T_3_4.num = tb.vec->data[7];
            T_3_1.num = T_3_4.num;
        }
        if (T_3_1.num == true) { /* if */

  LINE(592);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            T_5_1.num = tb.vec->data[2];
            T_5_2.ch = '\n';
            err = _chanOPputc(T_5_1, T_5_2, CLU_false);
            if (err != ERR_ok)
                goto ex_2;
            }
            goto end_2;
          ex_2: /* except */
            __CLU_EX_HANDLER;
            if (err == ERR_not_possible) {
            }
            else { /* not handled */
                goto ex_1;
            }
          end_2:;
        }
        } /* end if */

  LINE(595);
        {
        tb.vec->data[4] = 1;
        }

  LINE(596);
        {
        tb.vec->data[11] = 0;
        }

  LINE(597);
        {
        CLUREF T_3_1;
        T_3_1.num = tb.vec->data[18];
        err = arrayOPset_low(T_3_1, CLU_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(598);
        {
        CLUREF T_3_1;
        T_3_1.num = tb.vec->data[18];
        err = arrayOPtrim(T_3_1, CLU_1, CLU_0);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(599);
        {
        tb.vec->data[5] = false;
        }

  LINE(600);
        {
        tb.vec->data[7] = false;
        }

  LINE(601);
        {
        tb.vec->data[13] = 1;
        }
        break;
    }
    case 2: /* istr */ {
        CLUREF T_2_5;
        T_2_5.num = T_2_1.cell->value;
        sb.num = T_2_5.num;

  LINE(603);
        {
        sb.vec->data[1] = 1;
        }

  LINE(604);
        {
        sb.vec->data[2] = 1;
        }

  LINE(605);
        {
        CLUREF T_3_1;
        T_3_1.ch = ' ';
        sb.vec->data[3] = T_3_1.num;
        }

  LINE(606);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        CLUREF T_4_4;
        CLUREF T_4_5;
        CLUREF T_4_6;
        CLUREF T_4_7;
        T_4_1.num = sb.vec->data[0];
        T_4_2.num = sb.vec->data[0];
        err = stringOPsize(T_4_2, &T_4_3);
        if (err != ERR_ok)
            goto ex_3;
        err = stringOPfetch(T_4_1, T_4_3, &T_4_4);
        if (err != ERR_ok)
            goto ex_3;
        T_4_5.ch = '\n';
        T_4_6.num = (T_4_4.ch == T_4_5.ch);
        T_4_7.num = !T_4_6.num;
        if (T_4_7.num == true) { /* if */

  LINE(607);
            {
            CLUREF T_5_1;
            T_5_1.ch = '\n';
            sb.vec->data[3] = T_5_1.num;
            }
        }
        } /* end if */
        goto end_3;
      ex_3: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_bounds) {
        }
        else { /* not handled */
            goto ex_1;
        }
      end_3:;
        break;
    }
    case 4: /* ostr */ {
        CLUREF T_2_6;
        T_2_6.num = T_2_1.cell->value;
        chars.num = T_2_6.num;

  LINE(610);
        {
        err = arrayOPtrim(chars, CLU_1, CLU_0);
        if (err != ERR_ok)
            goto ex_1;
        }
        break;
    }
    case 3: /* nul */ /* FALLTHROUGH */
    case 1: /* closed */ {
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE reset ****/


/**** BEGIN PROCEDURE flush ****/


errcode
streamOPflush(CLUREF st)
{
    errcode err;
    CLUREF wb;
    CLUREF tb;
    CLUREF scr;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(615);

  LINE(616);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 7: /* write */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(618);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        T_3_1.num = wb.vec->data[1];
        T_3_2.num = wb.vec->data[0];
        T_3_3.num = wb.vec->data[2];
        err = _chanOPputb(T_3_1, T_3_2, CLU_1, T_3_3, CLU_false);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(619);
        {
        wb.vec->data[2] = 0;
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(621);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        T_3_1.num = tb.vec->data[2];
        T_3_2.num = tb.vec->data[1];
        T_3_3.num = tb.vec->data[4];
        T_3_4.num = tb.vec->data[11];
        T_3_5.num = tb.vec->data[10];
        err = _chanOPputb(T_3_1, T_3_2, T_3_3, T_3_4, T_3_5);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(622);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = tb.vec->data[11];
        T_3_2.num = T_3_1.num + 1;
        if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) ||
            (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        tb.vec->data[4] = T_3_2.num;
        }

  LINE(623);
        {
        tb.vec->data[10] = false;
        }
        break;
    }
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 4: /* ostr */ /* FALLTHROUGH */
    case 3: /* nul */ {
        break;
    }
    case 1: /* closed */ {

  LINE(626);
        { /* return */
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(628);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) { /* if */

  LINE(629);
        { /* for sequence$elements */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        T_3_1.num = st.vec->data[3];
        T_3_3.num = T_3_1.vec->size;
        T_3_4 = T_3_1;
        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
            scr.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(630);
            {
            err = streamOPflush(scr);
            if (err != ERR_ok)
                goto ex_2;
            }
        }
        }
        end_inline_for_1:
        __CLU_END_LABEL;
        goto end_2;
      ex_2: /* resignal */
        __CLU_EX_HANDLER;
        if (err == ERR_not_possible)
            signal(err);
        else
            goto ex_0;
      end_2:;
    }
    } /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE flush ****/


/**** BEGIN PROCEDURE get_line_length ****/


errcode
streamOPget_line_length(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF tb;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(635);

  LINE(636);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: /* tty */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(638);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[14];
        T_2_2.num = (T_2_1.num > 0);
        if (T_2_2.num == true) { /* if */

  LINE(639);
            { /* return */
            {
            CLUREF T_3_1;
            T_3_1.num = tb.vec->data[14];
            ret_1->num = T_3_1.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */
        break;
    }
    }
    } /* end qtagcase */

  LINE(642);
    { /* signal */
        signal(ERR_no_limit);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_line_length ****/


/**** BEGIN PROCEDURE get_page_length ****/


errcode
streamOPget_page_length(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF tb;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(645);

  LINE(646);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: /* tty */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(648);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[16];
        T_2_2.num = (T_2_1.num > 0);
        if (T_2_2.num == true) { /* if */

  LINE(649);
            { /* return */
            {
            CLUREF T_3_1;
            T_3_1.num = tb.vec->data[16];
            ret_1->num = T_3_1.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */
        break;
    }
    }
    } /* end qtagcase */

  LINE(652);
    { /* signal */
        signal(ERR_no_limit);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_page_length ****/


/**** BEGIN PROCEDURE get_date ****/

static int streamOPget_date_own_init = 0;

errcode
streamOPget_date(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF rb;
    CLUREF wb;
    if (streamOPget_date_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPget_date_own_init = 1;
    }
    enter_proc(655);

  LINE(656);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(658);
        { /* return */
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = rb.vec->data[1];
        err = _chanOPget_date(T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        ret_1->num = T_3_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 7: /* write */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(660);
        { /* return */
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = wb.vec->data[1];
        err = _chanOPget_date(T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        ret_1->num = T_3_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(662);
        { /* signal */
            elist[0] = STR_cannot_040get_040date;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_date ****/


/**** BEGIN PROCEDURE set_date ****/

static int streamOPset_date_own_init = 0;

errcode
streamOPset_date(CLUREF st, CLUREF ndate)
{
    errcode err;
    if (streamOPset_date_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPset_date_own_init = 1;
    }
    enter_proc(666);

  LINE(667);
    { /* signal */
        elist[0] = STR_cannot_040set_040date;
        signal(ERR_not_possible);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_date ****/


/**** BEGIN PROCEDURE get_name ****/

static int streamOPget_name_own_init = 0;

errcode
streamOPget_name(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    if (streamOPget_name_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPget_name_own_init = 1;
    }
    enter_proc(670);

  LINE(671);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 2: /* istr */ /* FALLTHROUGH */
    case 4: /* ostr */ {

  LINE(673);
        { /* signal */
            elist[0] = STR_no_040name_040for_040string_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    default: {

  LINE(675);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = st.vec->data[1];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_name ****/


/**** BEGIN PROCEDURE close ****/


errcode
streamOPclose(CLUREF st)
{
    errcode err;
    CLUREF rb;
    CLUREF wb;
    CLUREF tb;
    CLUREF opens;
    CLUREF i;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(679);

  LINE(680);
    {
    err = streamOPflush(st);
    if (err != ERR_ok)
        goto ex_1;
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(682);
    { /* qtagcase */
    CLUREF T_3_1;
    T_3_1.num = st.vec->data[0];
    switch (T_3_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_3_2;
        T_3_2.num = T_3_1.cell->value;
        rb.num = T_3_2.num;

  LINE(684);
        {
        CLUREF T_4_1;
        T_4_1.num = rb.vec->data[1];
        err = _chanOPclose(T_4_1);
        if (err != ERR_ok)
            goto ex_3;
        }

  LINE(685);
        {
        CLUREF T_4_1;
        T_4_1.num = rb.vec->data[0];
        streamOPfreebuf.num = T_4_1.num;
        }

  LINE(686);
        {
        streamOPfree.tf = true;
        }
        break;
    }
    case 7: /* write */ {
        CLUREF T_3_3;
        T_3_3.num = T_3_1.cell->value;
        wb.num = T_3_3.num;

  LINE(688);
        {
        CLUREF T_4_1;
        T_4_1.num = wb.vec->data[1];
        err = _chanOPclose(T_4_1);
        if (err != ERR_ok)
            goto ex_3;
        }

  LINE(689);
        {
        CLUREF T_4_1;
        T_4_1.num = wb.vec->data[0];
        streamOPfreebuf.num = T_4_1.num;
        }

  LINE(690);
        {
        streamOPfree.tf = true;
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_3_4;
        T_3_4.num = T_3_1.cell->value;
        tb.num = T_3_4.num;

  LINE(692);
        {
        CLUREF T_4_1;
        T_4_1.num = tb.vec->data[2];
        err = _chanOPclose(T_4_1);
        if (err != ERR_ok)
            goto ex_3;
        }

  LINE(693);
        {
        CLUREF T_4_1;
        T_4_1.num = tb.vec->data[1];
        streamOPfreebuf.num = T_4_1.num;
        }

  LINE(694);
        {
        streamOPfree.tf = true;
        }
        break;
    }
    case 3: /* nul */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 4: /* ostr */ {
        break;
    }
    case 1: /* closed */ {

  LINE(697);
        { /* return */
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_3;
  ex_3: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_2;
  end_3:;
    goto end_2;
  ex_2: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_permanent) {

  LINE(699);
        { /* return */
        signal (ERR_ok);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_2:;

  LINE(700);
    {
    CLUREF T_1_1;
    CellAlloc(1, nil, T_1_1);
    st.vec->data[0] = T_1_1.num;
    }

  LINE(701);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    st.vec->data[3] = T_1_1.num;
    }

  LINE(702);
    {
    st.vec->data[2] = false;
    }

  LINE(703);
    {
    CLUREF T_1_1;
    err = streamOPopen_streams(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    opens.num = T_1_1.num;
    }

  LINE(704);
    { /* for array$indexes */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = opens.array->ext_high;
    for (T_1_1.num = opens.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        i.num = T_1_1.num;

  LINE(705);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (i.num < opens.array->ext_low || i.num > opens.array->ext_high) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.num = opens.array->store->data[i.num - opens.array->ext_low + opens.array->int_low];
        T_2_2.num = (st.num == T_2_1.num);
        if (T_2_2.num == true) { /* if */

  LINE(706);
            {
            CLUREF T_4_1;
            err = arrayOPremh(opens, &T_4_1);
            if (err != ERR_ok)
                goto ex_4;
            {
            if (i.num < opens.array->ext_low || i.num > opens.array->ext_high) {
                err = ERR_bounds;
                goto ex_4;
            }
            opens.array->store->data[i.num + opens.array->int_low - opens.array->ext_low] = T_4_1.num;
            }
            }
            goto end_4;
          ex_4: /* except */
            __CLU_EX_HANDLER;
            if (err == ERR_bounds) {
            }
            else { /* not handled */
                goto ex_0;
            }
          end_4:;

  LINE(708);
            { /* return */
            signal (ERR_ok);
            }
        }
        } /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE close ****/


/**** BEGIN PROCEDURE abort ****/


errcode
streamOPabort(CLUREF st)
{
    errcode err;
    CLUREF rb;
    CLUREF wb;
    CLUREF tb;
    CLUREF opens;
    CLUREF i;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(713);

  LINE(714);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(716);
        {
        CLUREF T_3_1;
        T_3_1.num = rb.vec->data[1];
        err = _chanOPabort(T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(717);
        {
        CLUREF T_3_1;
        T_3_1.num = rb.vec->data[0];
        streamOPfreebuf.num = T_3_1.num;
        }

  LINE(718);
        {
        streamOPfree.tf = true;
        }
        break;
    }
    case 7: /* write */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(720);
        {
        CLUREF T_3_1;
        T_3_1.num = wb.vec->data[1];
        err = _chanOPabort(T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(721);
        {
        CLUREF T_3_1;
        T_3_1.num = wb.vec->data[0];
        streamOPfreebuf.num = T_3_1.num;
        }

  LINE(722);
        {
        streamOPfree.tf = true;
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        tb.num = T_2_4.num;

  LINE(724);
        {
        CLUREF T_3_1;
        T_3_1.num = tb.vec->data[2];
        err = _chanOPabort(T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(725);
        {
        CLUREF T_3_1;
        T_3_1.num = tb.vec->data[1];
        streamOPfreebuf.num = T_3_1.num;
        }

  LINE(726);
        {
        streamOPfree.tf = true;
        }
        break;
    }
    case 3: /* nul */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 4: /* ostr */ {
        break;
    }
    case 1: /* closed */ {

  LINE(729);
        { /* return */
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_permanent
        || err == ERR_not_possible)
    {

  LINE(730);
        { /* return */
        signal (ERR_ok);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(731);
    {
    CLUREF T_1_1;
    CellAlloc(1, nil, T_1_1);
    st.vec->data[0] = T_1_1.num;
    }

  LINE(732);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    st.vec->data[3] = T_1_1.num;
    }

  LINE(733);
    {
    st.vec->data[2] = false;
    }

  LINE(734);
    {
    CLUREF T_1_1;
    err = streamOPopen_streams(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    opens.num = T_1_1.num;
    }

  LINE(735);
    { /* for array$indexes */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = opens.array->ext_high;
    for (T_1_1.num = opens.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        i.num = T_1_1.num;

  LINE(736);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (i.num < opens.array->ext_low || i.num > opens.array->ext_high) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.num = opens.array->store->data[i.num - opens.array->ext_low + opens.array->int_low];
        T_2_2.num = (st.num == T_2_1.num);
        if (T_2_2.num == true) { /* if */

  LINE(737);
            {
            CLUREF T_4_1;
            err = arrayOPremh(opens, &T_4_1);
            if (err != ERR_ok)
                goto ex_2;
            {
            if (i.num < opens.array->ext_low || i.num > opens.array->ext_high) {
                err = ERR_bounds;
                goto ex_2;
            }
            opens.array->store->data[i.num + opens.array->int_low - opens.array->ext_low] = T_4_1.num;
            }
            }
            goto end_2;
          ex_2: /* except */
            __CLU_EX_HANDLER;
            if (err == ERR_bounds) {
            }
            else { /* not handled */
                goto ex_0;
            }
          end_2:;

  LINE(739);
            { /* return */
            signal (ERR_ok);
            }
        }
        } /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE abort ****/


/**** BEGIN PROCEDURE is_closed ****/


errcode
streamOPis_closed(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(744);

  LINE(745);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = st.vec->data[0];
    if (T_1_1.cell->tag == 1) T_1_2.num = true; else T_1_2.num = false;
    ret_1->num = T_1_2.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE is_closed ****/


/**** BEGIN PROCEDURE is_terminal ****/


errcode
streamOPis_terminal(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(748);

  LINE(749);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = st.vec->data[0];
    if (T_1_1.cell->tag == 6) T_1_2.num = true; else T_1_2.num = false;
    ret_1->num = T_1_2.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE is_terminal ****/


/**** BEGIN PROCEDURE getl ****/

static int streamOPgetl_own_init = 0;

errcode
streamOPgetl(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF line;
    CLUREF rb;
    CLUREF index;
    CLUREF tb;
    CLUREF sb;
    if (streamOPgetl_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPgetl_own_init = 1;
    }
    enter_proc(752);

  LINE(754);
    {
    CLUREF T_2_1;
    err = streamOPgets(st, STR__012, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    line.num = T_2_1.num;
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file)
        signal(err);
    else if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(756);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        rb.num = T_1_2.num;

  LINE(758);
        {
        CLUREF T_2_1;
        T_2_1.num = rb.vec->data[2];
        index.num = T_2_1.num;
        }

  LINE(759);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = rb.vec->data[4];
        T_2_2.num = (index.num > T_2_1.num);
        if (T_2_2.num == true) { /* if */

  LINE(760);
            { /* return */
            {
            ret_1->num = line.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(761);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = rb.vec->data[3];
        T_2_2.num = T_2_1.num + 1;
        if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) ||
            (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        rb.vec->data[3] = T_2_2.num;
        }

  LINE(762);
        {
        CLUREF T_2_1;
        T_2_1.num = index.num + 1;
        if ((T_2_1.num > 0 && index.num < 0 && 1 < 0) ||
            (T_2_1.num < 0 && index.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        rb.vec->data[2] = T_2_1.num;
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        tb.num = T_1_3.num;

  LINE(764);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = tb.vec->data[18];
        err = arrayOPreml(T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_2;
        }
        goto end_2;
      ex_2: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_bounds) {

  LINE(765);
            { /* return */
            {
            ret_1->num = line.num;
            }
            signal (ERR_ok);
            }
        }
        else { /* not handled */
            goto ex_0;
        }
      end_2:;

  LINE(766);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = tb.vec->data[5];
        if (T_3_1.num == true) { /* if */

  LINE(767);
            {
            tb.vec->data[5] = false;
            }

  LINE(768);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = tb.vec->data[2];
            T_4_2.ch = '\n';
            err = _chanOPputc(T_4_1, T_4_2, CLU_false);
            if (err != ERR_ok)
                goto ex_3;
            }
        }
        } /* end if */
        goto end_3;
      ex_3: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_not_possible) {
        }
        else { /* not handled */
            goto ex_0;
        }
      end_3:;

  LINE(770);
        {
        tb.vec->data[11] = 0;
        }

  LINE(771);
        {
        tb.vec->data[4] = 1;
        }
        break;
    }
    case 2: /* istr */ {
        CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        sb.num = T_1_4.num;

  LINE(773);
        {
        CLUREF T_2_1;
        T_2_1.num = sb.vec->data[1];
        index.num = T_2_1.num;
        }

  LINE(774);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = sb.vec->data[0];
        err = stringOPsize(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_3.num = (index.num > T_2_2.num);
        if (T_2_3.num == true) { /* if */

  LINE(775);
            {
            CLUREF T_3_1;
            T_3_1.ch = ' ';
            sb.vec->data[3] = T_3_1.num;
            }

  LINE(776);
            { /* return */
            {
            ret_1->num = line.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(778);
        {
        CLUREF T_2_1;
        T_2_1.num = index.num + 1;
        if ((T_2_1.num > 0 && index.num < 0 && 1 < 0) ||
            (T_2_1.num < 0 && index.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        sb.vec->data[1] = T_2_1.num;
        }

  LINE(779);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = sb.vec->data[2];
        T_2_2.num = T_2_1.num + 1;
        if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) ||
            (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        sb.vec->data[2] = T_2_2.num;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(782);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) { /* if */

  LINE(783);
        {
        err = streamOPscript(st, STR__012, CLU_false);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(784);
    { /* return */
    {
    ret_1->num = line.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE getl ****/


/**** BEGIN PROCEDURE putl ****/


errcode
streamOPputl(CLUREF st, CLUREF line)
{
    errcode err;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(787);

  LINE(788);
    { /* begin */

  LINE(789);
        {
        err = streamOPputs(st, line);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(790);
        {
        CLUREF T_3_1;
        T_3_1.ch = '\n';
        err = streamOPputc(st, T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE putl ****/


/**** BEGIN PROCEDURE gets ****/

static int streamOPgets_own_init = 0;

errcode
streamOPgets(CLUREF st, CLUREF term, CLUREF *ret_1)
{
    errcode err;
    CLUREF s;
    CLUREF rb;
    CLUREF index;
    CLUREF max;
    CLUREF i;
    CLUREF tb;
    CLUREF sb;
    if (streamOPgets_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPgets_own_init = 1;
    }
    enter_proc(794);

  LINE(797);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(800);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        CLUREF T_3_7;
        T_3_1.num = rb.vec->data[1];
        T_3_2.num = rb.vec->data[0];
        T_3_3.num = rb.vec->data[2];
        T_3_4.num = rb.vec->data[4];
        err = _chanOPget(T_3_1, T_3_2, T_3_3, T_3_4, term, CLU_false, &T_3_5, &T_3_6, &T_3_7);
        if (err != ERR_ok)
            goto ex_1;
        s.num = T_3_5.num;
        index.num = T_3_6.num;
        max.num = T_3_7.num;
        }

  LINE(802);
        {
        rb.vec->data[2] = index.num;
        }

  LINE(803);
        {
        rb.vec->data[4] = max.num;
        }

  LINE(804);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        T_3_1.ch = '\n';
        err = stringOPindexc(T_3_1, term, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        T_3_3.num = (T_3_2.num == 0);
        if (T_3_3.num == true) { /* if */

  LINE(805);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.ch = '\n';
            err = stringOPindexc(T_4_1, s, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            i.num = T_4_2.num;
            }

  LINE(806);
            { /* if */
            CLUREF T_4_1;
            T_4_1.num = (i.num > 0);
            if (T_4_1.num == true) { /* if */

  LINE(807);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                T_5_1.num = rb.vec->data[3];
                err = streamOPlines(s, i, &T_5_2);
                if (err != ERR_ok)
                    goto ex_1;
                T_5_3.num = T_5_1.num + T_5_2.num;
                if ((T_5_3.num > 0 && T_5_1.num < 0 && T_5_2.num < 0) ||
                    (T_5_3.num < 0 && T_5_1.num > 0 && T_5_2.num > 0)) {
                    err = ERR_overflow;
                    goto ex_1;
                }
                rb.vec->data[3] = T_5_3.num;
                }
            }
            } /* end if */
        }
        } /* end if */
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(810);
        {
        err = streamOPflush(st);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(811);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = tb.vec->data[9];
        if (T_3_1.num == true) { /* if */

  LINE(812);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            CLUREF T_4_6;
            T_4_2.num = st.vec->data[2];
            T_4_1.num = T_4_2.num;
            if (T_4_2.num) {
                T_4_4.num = tb.vec->data[11];
                T_4_5.num = (T_4_4.num == 0);
                T_4_3.num = T_4_5.num;
                if (!T_4_5.num) {
                    T_4_6.num = tb.vec->data[10];
                    T_4_3.num = T_4_6.num;
                }
                T_4_1.num = T_4_3.num;
            }
            if (T_4_1.num == true) { /* if */

  LINE(813);
                {
                CLUREF T_5_1;
                T_5_1.num = tb.vec->data[17];
                err = streamOPscript(st, T_5_1, CLU_false);
                if (err != ERR_ok)
                    goto ex_1;
                }
            }
            } /* end if */

  LINE(814);
            {
            CLUREF T_4_1;
            err = streamOPedit(tb, term, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            s.num = T_4_1.num;
            }
        }
        else { /* else */

  LINE(815);
            {
            CLUREF T_4_1;
            err = streamOPtty_get(tb, term, CLU_false, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            s.num = T_4_1.num;
            }
        }} /* end if */
        break;
    }
    case 2: /* istr */ {
        CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        sb.num = T_2_4.num;

  LINE(818);
        {
        CLUREF T_3_1;
        err = streamOPstr_get(sb, term, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        s.num = T_3_1.num;
        }
        break;
    }
    case 3: /* nul */ {

  LINE(820);
        { /* signal */
            signal(ERR_end_of_file);
        }
        break;
    }
    case 7: /* write */ /* FALLTHROUGH */
    case 4: /* ostr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(822);
        { /* signal */
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file)
        signal(err);
    else if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(824);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) { /* if */

  LINE(825);
        {
        err = streamOPscript(st, s, CLU_false);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(826);
    { /* return */
    {
    ret_1->num = s.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE gets ****/


/**** BEGIN PROCEDURE gets_image ****/

static int streamOPgets_image_own_init = 0;

errcode
streamOPgets_image(CLUREF st, CLUREF term, CLUREF *ret_1)
{
    errcode err;
    CLUREF s;
    CLUREF rb;
    CLUREF index;
    CLUREF max;
    CLUREF i;
    CLUREF tb;
    CLUREF sb;
    if (streamOPgets_image_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPgets_image_own_init = 1;
    }
    enter_proc(829);

  LINE(832);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(835);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        CLUREF T_3_7;
        T_3_1.num = rb.vec->data[1];
        T_3_2.num = rb.vec->data[0];
        T_3_3.num = rb.vec->data[2];
        T_3_4.num = rb.vec->data[4];
        err = _chanOPget(T_3_1, T_3_2, T_3_3, T_3_4, term, CLU_true, &T_3_5, &T_3_6, &T_3_7);
        if (err != ERR_ok)
            goto ex_1;
        s.num = T_3_5.num;
        index.num = T_3_6.num;
        max.num = T_3_7.num;
        }

  LINE(837);
        {
        rb.vec->data[2] = index.num;
        }

  LINE(838);
        {
        rb.vec->data[4] = max.num;
        }

  LINE(839);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        T_3_1.ch = '\n';
        err = stringOPindexc(T_3_1, term, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        T_3_3.num = (T_3_2.num == 0);
        if (T_3_3.num == true) { /* if */

  LINE(840);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.ch = '\n';
            err = stringOPindexc(T_4_1, s, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            i.num = T_4_2.num;
            }

  LINE(841);
            { /* if */
            CLUREF T_4_1;
            T_4_1.num = (i.num > 0);
            if (T_4_1.num == true) { /* if */

  LINE(842);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                T_5_1.num = rb.vec->data[3];
                err = streamOPlines(s, i, &T_5_2);
                if (err != ERR_ok)
                    goto ex_1;
                T_5_3.num = T_5_1.num + T_5_2.num;
                if ((T_5_3.num > 0 && T_5_1.num < 0 && T_5_2.num < 0) ||
                    (T_5_3.num < 0 && T_5_1.num > 0 && T_5_2.num > 0)) {
                    err = ERR_overflow;
                    goto ex_1;
                }
                rb.vec->data[3] = T_5_3.num;
                }
            }
            } /* end if */
        }
        } /* end if */
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(845);
        {
        err = streamOPflush(st);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(846);
        {
        CLUREF T_3_1;
        err = streamOPtty_get(tb, term, CLU_true, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        s.num = T_3_1.num;
        }
        break;
    }
    case 2: /* istr */ {
        CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        sb.num = T_2_4.num;

  LINE(848);
        {
        CLUREF T_3_1;
        err = streamOPstr_get(sb, term, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        s.num = T_3_1.num;
        }
        break;
    }
    case 3: /* nul */ {

  LINE(850);
        { /* signal */
            signal(ERR_end_of_file);
        }
        break;
    }
    case 7: /* write */ /* FALLTHROUGH */
    case 4: /* ostr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(852);
        { /* signal */
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file)
        signal(err);
    else if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(854);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) { /* if */

  LINE(855);
        {
        err = streamOPscript(st, s, CLU_true);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(856);
    { /* return */
    {
    ret_1->num = s.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE gets_image ****/


/**** BEGIN PROCEDURE tty_get1 ****/


errcode
streamOPtty_get1(CLUREF tb, CLUREF image, CLUREF *ret_1)
{
    errcode err;
    CLUREF c;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(859);

  LINE(861);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = tb.vec->data[7];
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        T_1_3.num = tb.vec->data[8];
        T_1_1.num = T_1_3.num;
    }
    if (T_1_1.num == true) { /* if */

  LINE(862);
        { /* signal */
            signal(ERR_end_of_file);
        }
    }
    } /* end if */

  LINE(864);
    { /* if */
    CLUREF T_3_1;
    CLUREF T_3_2;
    CLUREF T_3_3;
    T_3_1.num = tb.vec->data[18];
    T_3_2.num = (T_3_1.array->ext_size == 0);
    T_3_3.num = !T_3_2.num;
    if (T_3_3.num == true) { /* if */

  LINE(865);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        T_4_1.num = tb.vec->data[18];
        err = arrayOPreml(T_4_1, &T_4_2);
        if (err != ERR_ok)
            goto ex_2;
        c.num = T_4_2.num;
        }

  LINE(866);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_2.num = tb.vec->data[5];
        T_4_1.num = T_4_2.num;
        if (T_4_2.num) {
            T_4_3.num = !image.num;
            T_4_1.num = T_4_3.num;
        }
        if (T_4_1.num == true) { /* if */

  LINE(867);
            {
            CLUREF T_5_1;
            T_5_1.num = tb.vec->data[2];
            err = streamOPecho(T_5_1, c);
            if (err != ERR_ok)
                goto ex_2;
            }
        }
        } /* end if */

  LINE(868);
        {
        tb.vec->data[5] = false;
        }
    }
    else { /* else */

  LINE(869);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        T_4_1.num = tb.vec->data[2];
        err = _chanOPgetc(T_4_1, image, &T_4_2);
        if (err != ERR_ok)
            goto ex_2;
        c.num = T_4_2.num;
        }
    }} /* end if */
    goto end_2;
  ex_2: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_1;
  end_2:;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file) {

  LINE(873);
        {
        tb.vec->data[7] = true;
        }

  LINE(874);
        { /* signal */
            signal(ERR_end_of_file);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(876);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = '\n';
    T_1_2.num = (c.ch == T_1_1.ch);
    if (T_1_2.num == true) { /* if */

  LINE(877);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[13];
        T_2_2.num = T_2_1.num + 1;
        if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) ||
            (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        tb.vec->data[13] = T_2_2.num;
        }

  LINE(878);
        { /* return */
        {
        ret_1->num = c.num;
        }
        signal (ERR_ok);
        }
    }
    else {

  LINE(879);
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    T_1_4.ch = '\004';
    T_1_5.num = (c.ch == T_1_4.ch);
    T_1_3.num = T_1_5.num;
    if (T_1_5.num) {
        T_1_6.num = tb.vec->data[8];
        T_1_3.num = T_1_6.num;
    }
    T_1_7.num = !T_1_3.num;
    if (T_1_7.num == true) { /* elseif */

  LINE(880);
        { /* return */
        {
        ret_1->num = c.num;
        }
        signal (ERR_ok);
        }
    }
    }} /* end if */

  LINE(881);
    {
    tb.vec->data[7] = true;
    }

  LINE(882);
    { /* signal */
        signal(ERR_end_of_file);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE tty_get1 ****/


/**** BEGIN PROCEDURE tty_get ****/

static int streamOPtty_get_own_init = 0;
CLUREF streamOPtty_getOPtmp;
CLUREF streamOPtty_getOPinuse;

errcode
streamOPtty_get(CLUREF tb, CLUREF term, CLUREF image, CLUREF *ret_1)
{
    errcode err;
    CLUREF temp;
    CLUREF used;
    CLUREF c;
    CLUREF s;
    if (streamOPtty_get_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPtty_get_own_init = 1;
        {
        CLUREF T_0_1;
        err = arrayOPnew(&T_0_1);
        if (err != ERR_ok)
            goto ex_0;
        streamOPtty_getOPtmp.num = T_0_1.num;
        }
        {
        streamOPtty_getOPinuse.tf = false;
        }
    }
    enter_proc(885);

  LINE(889);
    {
    temp.num = streamOPtty_getOPtmp.num;
    }

  LINE(890);
    {
    used.num = streamOPtty_getOPinuse.num;
    }

  LINE(891);
    {
    streamOPtty_getOPinuse.tf = true;
    }

  LINE(892);
    { /* if */
    if (used.num == true) { /* if */

  LINE(893);
        {
        CLUREF T_2_1;
        err = arrayOPnew(&T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        temp.num = T_2_1.num;
        }
    }
    else { /* else */

  LINE(894);
        {
        err = arrayOPtrim(temp, CLU_1, CLU_0);
        if (err != ERR_ok)
            goto ex_0;
        }
    }} /* end if */

  LINE(896);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(897);
        {
        CLUREF T_4_1;
        err = streamOPtty_get1(tb, image, &T_4_1);
        if (err != ERR_ok)
            goto ex_2;
        c.num = T_4_1.num;
        }

  LINE(898);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        err = stringOPindexc(c, term, &T_4_1);
        if (err != ERR_ok)
            goto ex_2;
        T_4_2.num = (T_4_1.num > 0);
        if (T_4_2.num == true) { /* if */

  LINE(899);
            {
            CLUREF T_5_1;
            T_5_1.num = tb.vec->data[18];
            err = arrayOPaddl(T_5_1, c);
            if (err != ERR_ok)
                goto ex_2;
            }

  LINE(900);
            goto end_while_1;
        }
        } /* end if */

  LINE(902);
        { /* if */
        CLUREF T_4_1;
        T_4_1.num = !image.num;
        if (T_4_1.num == true) { /* if */

  LINE(903);
            {
            err = streamOPtty_put1(tb, c);
            if (err != ERR_ok)
                goto ex_2;
            }
        }
        } /* end if */

  LINE(904);
        {
        {
        if ((temp.array->int_low + temp.array->ext_size + 1) < temp.array->int_size) {
            temp.array->store->data[temp.array->int_low + temp.array->ext_size] = c.num;
            temp.array->ext_size++;
            temp.array->ext_high++;
        }
        else {
            err = arrayOPaddh(temp, c);
            if (err != ERR_ok)
                goto ex_2;
        }
        }
        }
    }
    end_while_1:
    __CLU_END_LABEL;
    goto end_2;
  ex_2: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_1;
  end_2:;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file) {

  LINE(907);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = (temp.array->ext_size == 0);
        if (T_2_1.num == true) { /* if */

  LINE(908);
            {
            streamOPtty_getOPinuse.num = used.num;
            }

  LINE(909);
            { /* signal */
                signal(ERR_end_of_file);
            }
        }
        } /* end if */
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(912);
    {
    CLUREF T_1_1;
    err = stringOPac2s(temp, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    s.num = T_1_1.num;
    }

  LINE(913);
    {
    err = arrayOPtrim(temp, CLU_1, CLU_0);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(914);
    {
    streamOPtty_getOPinuse.num = used.num;
    }

  LINE(915);
    { /* return */
    {
    ret_1->num = s.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE tty_get ****/


/**** BEGIN PROCEDURE str_get ****/

static int streamOPstr_get_own_init = 0;

errcode
streamOPstr_get(CLUREF sb, CLUREF term, CLUREF *ret_1)
{
    errcode err;
    CLUREF first;
    CLUREF chars;
    CLUREF last;
    CLUREF s;
    if (streamOPstr_get_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPstr_get_own_init = 1;
    }
    enter_proc(918);

  LINE(919);
    {
    CLUREF T_1_1;
    T_1_1.num = sb.vec->data[1];
    first.num = T_1_1.num;
    }

  LINE(920);
    {
    CLUREF T_1_1;
    T_1_1.num = sb.vec->data[0];
    chars.num = T_1_1.num;
    }

  LINE(921);
    {
    last.num = first.num;
    }

  LINE(922);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(923);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        err = stringOPfetch(chars, last, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        err = stringOPindexc(T_3_1, term, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        T_3_3.num = (T_3_2.num > 0);
        if (T_3_3.num == true) { /* if */

  LINE(924);
            {
            sb.vec->data[1] = last.num;
            }

  LINE(925);
            { /* return */
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = last.num - first.num;
            if ((T_4_1.num >= 0 && last.num < 0 && (-first.num) < 0) ||
                (T_4_1.num <= 0 && last.num > 0 && (-first.num) > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            err = stringOPsubstr(chars, first, T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_2.num;
            }
            signal (ERR_ok);
            }
        }
        else {

  LINE(926);
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        err = stringOPfetch(chars, last, &T_3_4);
        if (err != ERR_ok)
            goto ex_1;
        T_3_5.ch = '\n';
        T_3_6.num = (T_3_4.ch == T_3_5.ch);
        if (T_3_6.num == true) { /* elseif */

  LINE(927);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = sb.vec->data[2];
            T_4_2.num = T_4_1.num + 1;
            if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) ||
                (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            sb.vec->data[2] = T_4_2.num;
            }
        }
        }} /* end if */

  LINE(928);
        {
        CLUREF T_3_1;
        T_3_1.num = last.num + 1;
        if ((T_3_1.num > 0 && last.num < 0 && 1 < 0) ||
            (T_3_1.num < 0 && last.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        last.num = T_3_1.num;
        }
    }
    end_while_1:
    __CLU_END_LABEL;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_bounds) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(931);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (first.num == last.num);
    if (T_1_1.num == true) { /* if */

  LINE(932);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = sb.vec->data[3];
        T_2_2.ch = ' ';
        T_2_3.num = (T_2_1.ch == T_2_2.ch);
        if (T_2_3.num == true) { /* if */

  LINE(933);
            { /* signal */
                signal(ERR_end_of_file);
            }
        }
        } /* end if */

  LINE(934);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.ch = '\n';
        err = stringOPindexc(T_2_1, term, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_3.num = (T_2_2.num > 0);
        if (T_2_3.num == true) { /* if */

  LINE(935);
            { /* return */
            {
            ret_1->str = CLU_empty_string.str;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(936);
        {
        CLUREF T_2_1;
        T_2_1.ch = ' ';
        sb.vec->data[3] = T_2_1.num;
        }

  LINE(937);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = sb.vec->data[2];
        T_2_2.num = T_2_1.num + 1;
        if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) ||
            (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        sb.vec->data[2] = T_2_2.num;
        }

  LINE(938);
        { /* return */
        {
        ret_1->str = STR__012.str;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(940);
    {
    sb.vec->data[1] = last.num;
    }

  LINE(941);
    {
    CLUREF T_1_1;
    err = stringOPrest(chars, first, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    s.num = T_1_1.num;
    }

  LINE(942);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.ch = '\n';
    err = stringOPindexc(T_1_1, term, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_3.num = (T_1_2.num == 0);
    if (T_1_3.num == true) { /* if */

  LINE(943);
        {
        CLUREF T_2_1;
        T_2_1.ch = ' ';
        sb.vec->data[3] = T_2_1.num;
        }

  LINE(944);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = sb.vec->data[2];
        T_2_2.num = T_2_1.num + 1;
        if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) ||
            (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        sb.vec->data[2] = T_2_2.num;
        }

  LINE(945);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.ch = '\n';
        err = stringOPappend(s, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        s.num = T_2_2.num;
        }
    }
    } /* end if */

  LINE(947);
    { /* return */
    {
    ret_1->num = s.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE str_get ****/


/**** BEGIN PROCEDURE puts ****/

static errcode streamOPputs_IB_1();
static int streamOPputs_own_init = 0;
typedef struct {
    errcode ecode2;
    errcode err;
    CLUREF wb;
    CLUREF low;
    CLUREF index;
    CLUREF tb;
    CLUREF chars;
    CLUREF c;
    CLUREF st;
    CLUREF s;
} streamOPputs_LOCALS_t;

errcode
streamOPputs(CLUREF st, CLUREF s)
{
    streamOPputs_LOCALS_t locals;
    locals.st = st;
    locals.s = s;
    if (streamOPputs_own_init == 0) {
        if (stream_own_init == 0) {
            locals.err = stream_own_init_proc();
            if (locals.err != ERR_ok)
                goto ex_0;
        }
        streamOPputs_own_init = 1;
    }
    enter_proc(950);

  LINE(951);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = locals.st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 7: /* write */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        locals.wb.num = T_2_2.num;

  LINE(953);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        T_3_1.num = locals.wb.vec->data[1];
        T_3_2.num = locals.wb.vec->data[0];
        T_3_3.num = locals.wb.vec->data[2];
        locals.err = _chanOPput(T_3_1, T_3_2, CLU_1, T_3_3, locals.s, CLU_false, &T_3_4, &T_3_5);
        if (locals.err != ERR_ok)
            goto ex_1;
        locals.low.num = T_3_4.num;
        locals.index.num = T_3_5.num;
        }

  LINE(955);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = locals.wb.vec->data[3];
        T_3_2.num = !T_3_1.num;
        if (T_3_2.num == true) { /* if */

  LINE(956);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = locals.wb.vec->data[1];
            T_4_2.num = locals.wb.vec->data[0];
            locals.err = _chanOPputb(T_4_1, T_4_2, CLU_1, locals.index, CLU_false);
            if (locals.err != ERR_ok)
                goto ex_1;
            }

  LINE(957);
            {
            locals.index.num = 0;
            }
        }
        } /* end if */

  LINE(959);
        {
        locals.wb.vec->data[2] = locals.index.num;
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        locals.tb.num = T_2_3.num;

  LINE(961);
        {
        locals.err = streamOPtty_put(locals.tb, locals.s, CLU_false);
        if (locals.err != ERR_ok)
            goto ex_1;
        }
        break;
    }
    case 4: /* ostr */ {
        CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        locals.chars.num = T_2_4.num;

  LINE(963);
        { /* for */
            locals.err = stringOPchars(locals.s, streamOPputs_IB_1, &locals, &locals.ecode2);

            if (locals.err == ERR_iterbodyreturn) {
                signal(ERR_ok);
            }
            if (locals.err == ERR_iterbodysignal)
                signal(locals.ecode2);
            if (locals.err == ERR_break)
                locals.err = ERR_ok;
            if (locals.err == ERR_iterbodyexit)
                locals.err = locals.ecode2;
            if (locals.err != ERR_ok)
                goto ex_1;
        }
        break;
    }
    case 3: /* nul */ {
        break;
    }
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(968);
        { /* signal */
            elist[0] = STR_cannot_040write_040to_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (locals.err == ERR_not_possible)
        signal(locals.err);
    else
        goto ex_0;
  end_1:;

  LINE(970);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = locals.st.vec->data[2];
    if (T_1_1.num == true) { /* if */

  LINE(971);
        {
        locals.err = streamOPscript(locals.st, locals.s, CLU_false);
        if (locals.err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (locals.err != ERR_failure)
        elist[0] = _pclu_erstr(locals.err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE puts ****/


/**** BEGIN ITERATOR BODIES for puts ****/

static errcode
streamOPputs_IB_1(CLUREF iv_1, streamOPputs_LOCALS_t *locals, errcode *iecode)
{
    locals->c.num = iv_1.num;
    enter_iter_body_proc(964);

  FB_LINE(964);
    {
    {
    if ((locals->chars.array->int_low + locals->chars.array->ext_size + 1) < locals->chars.array->int_size) {
        locals->chars.array->store->data[locals->chars.array->int_low + locals->chars.array->ext_size] = locals->c.num;
        locals->chars.array->ext_size++;
        locals->chars.array->ext_high++;
    }
    else {
        locals->err = arrayOPaddh(locals->chars, locals->c);
        if (locals->err != ERR_ok)
            goto ex_0;
    }
    }
    }

    signal(ERR_ok);
  ex_0:
    __CLU_EX_HANDLER;
    *iecode = locals->err;
    signal(ERR_iterbodyexit);
  end_0:
    __CLU_END_LABEL;
    signal(ERR_ok);
}

/**** END ITERATOR BODIES for puts ****/


/**** BEGIN PROCEDURE puts_image ****/

static errcode streamOPputs_image_IB_1();
static int streamOPputs_image_own_init = 0;
typedef struct {
    errcode ecode2;
    errcode err;
    CLUREF wb;
    CLUREF low;
    CLUREF index;
    CLUREF tb;
    CLUREF chars;
    CLUREF c;
    CLUREF st;
    CLUREF s;
} streamOPputs_image_LOCALS_t;

errcode
streamOPputs_image(CLUREF st, CLUREF s)
{
    streamOPputs_image_LOCALS_t locals;
    locals.st = st;
    locals.s = s;
    if (streamOPputs_image_own_init == 0) {
        if (stream_own_init == 0) {
            locals.err = stream_own_init_proc();
            if (locals.err != ERR_ok)
                goto ex_0;
        }
        streamOPputs_image_own_init = 1;
    }
    enter_proc(974);

  LINE(975);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = locals.st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 7: /* write */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        locals.wb.num = T_2_2.num;

  LINE(977);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = locals.wb.vec->data[3];
        if (T_3_1.num == true) { /* if */

  LINE(978);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            T_4_1.num = locals.wb.vec->data[1];
            T_4_2.num = locals.wb.vec->data[0];
            T_4_3.num = locals.wb.vec->data[2];
            locals.err = _chanOPput(T_4_1, T_4_2, CLU_1, T_4_3, locals.s, CLU_true, &T_4_4, &T_4_5);
            if (locals.err != ERR_ok)
                goto ex_1;
            locals.low.num = T_4_4.num;
            locals.index.num = T_4_5.num;
            }

  LINE(980);
            {
            locals.wb.vec->data[2] = locals.index.num;
            }
        }
        else { /* else */

  LINE(981);
            {
            CLUREF T_4_1;
            T_4_1.num = locals.wb.vec->data[1];
            locals.err = _chanOPputs(T_4_1, locals.s, CLU_true);
            if (locals.err != ERR_ok)
                goto ex_1;
            }
        }} /* end if */
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        locals.tb.num = T_2_3.num;

  LINE(984);
        {
        locals.err = streamOPtty_put(locals.tb, locals.s, CLU_true);
        if (locals.err != ERR_ok)
            goto ex_1;
        }
        break;
    }
    case 4: /* ostr */ {
        CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        locals.chars.num = T_2_4.num;

  LINE(986);
        { /* for */
            locals.err = stringOPchars(locals.s, streamOPputs_image_IB_1, &locals, &locals.ecode2);

            if (locals.err == ERR_iterbodyreturn) {
                signal(ERR_ok);
            }
            if (locals.err == ERR_iterbodysignal)
                signal(locals.ecode2);
            if (locals.err == ERR_break)
                locals.err = ERR_ok;
            if (locals.err == ERR_iterbodyexit)
                locals.err = locals.ecode2;
            if (locals.err != ERR_ok)
                goto ex_1;
        }
        break;
    }
    case 3: /* nul */ {
        break;
    }
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(991);
        { /* signal */
            elist[0] = STR_cannot_040write_040to_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (locals.err == ERR_not_possible)
        signal(locals.err);
    else
        goto ex_0;
  end_1:;

  LINE(993);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = locals.st.vec->data[2];
    if (T_1_1.num == true) { /* if */

  LINE(994);
        {
        locals.err = streamOPscript(locals.st, locals.s, CLU_true);
        if (locals.err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (locals.err != ERR_failure)
        elist[0] = _pclu_erstr(locals.err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE puts_image ****/


/**** BEGIN ITERATOR BODIES for puts_image ****/

static errcode
streamOPputs_image_IB_1(CLUREF iv_1, streamOPputs_image_LOCALS_t *locals, errcode *iecode)
{
    locals->c.num = iv_1.num;
    enter_iter_body_proc(987);

  FB_LINE(987);
    {
    {
    if ((locals->chars.array->int_low + locals->chars.array->ext_size + 1) < locals->chars.array->int_size) {
        locals->chars.array->store->data[locals->chars.array->int_low + locals->chars.array->ext_size] = locals->c.num;
        locals->chars.array->ext_size++;
        locals->chars.array->ext_high++;
    }
    else {
        locals->err = arrayOPaddh(locals->chars, locals->c);
        if (locals->err != ERR_ok)
            goto ex_0;
    }
    }
    }

    signal(ERR_ok);
  ex_0:
    __CLU_EX_HANDLER;
    *iecode = locals->err;
    signal(ERR_iterbodyexit);
  end_0:
    __CLU_END_LABEL;
    signal(ERR_ok);
}

/**** END ITERATOR BODIES for puts_image ****/


/**** BEGIN PROCEDURE tty_put1 ****/


errcode
streamOPtty_put1(CLUREF tb, CLUREF c)
{
    errcode err;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(997);

  LINE(998);
    { /* if */
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.ch = '\n';
    T_2_2.num = (c.ch == T_2_1.ch);
    if (T_2_2.num == true) { /* if */

  LINE(999);
        {
        tb.vec->data[11] = 0;
        }

  LINE(1000);
        {
        tb.vec->data[4] = 1;
        }
    }
    else { /* else */

  LINE(1001);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = tb.vec->data[11];
        T_3_2.num = T_3_1.num + 1;
        if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) ||
            (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        tb.vec->data[11] = T_3_2.num;
        }

  LINE(1002);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = tb.vec->data[1];
        T_3_2.num = tb.vec->data[11];
        err = _bytevecOPstore(T_3_1, T_3_2, c);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(1003);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = tb.vec->data[11];
        T_3_2.num = T_3_1.num + 1;
        if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) ||
            (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        tb.vec->data[4] = T_3_2.num;
        }
    }} /* end if */
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_bounds) {

  LINE(1004);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[11];
        T_2_2.num = T_2_1.num - 1;
        if ((T_2_2.num >= 0 && T_2_1.num < 0 && (-1) < 0) ||
            (T_2_2.num <= 0 && T_2_1.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        tb.vec->data[11] = T_2_2.num;
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE tty_put1 ****/


/**** BEGIN PROCEDURE tty_put ****/


errcode
streamOPtty_put(CLUREF tb, CLUREF s, CLUREF image)
{
    errcode err;
    CLUREF disp;
    CLUREF index;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1007);

  LINE(1009);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = tb.vec->data[10];
    T_1_2.num = (image.tf == T_1_1.tf);
    T_1_3.num = !T_1_2.num;
    if (T_1_3.num == true) { /* if */

  LINE(1010);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_1.num = tb.vec->data[2];
        T_2_2.num = tb.vec->data[1];
        T_2_3.num = tb.vec->data[4];
        T_2_4.num = tb.vec->data[11];
        T_2_5.num = tb.vec->data[10];
        err = _chanOPputb(T_2_1, T_2_2, T_2_3, T_2_4, T_2_5);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(1011);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[11];
        T_2_2.num = T_2_1.num + 1;
        if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) ||
            (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        tb.vec->data[4] = T_2_2.num;
        }

  LINE(1012);
        {
        tb.vec->data[10] = image.num;
        }
    }
    } /* end if */

  LINE(1014);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    CLUREF T_2_4;
    CLUREF T_2_5;
    CLUREF T_2_6;
    T_2_1.num = tb.vec->data[2];
    T_2_2.num = tb.vec->data[1];
    T_2_3.num = tb.vec->data[4];
    T_2_4.num = tb.vec->data[11];
    err = _chanOPput(T_2_1, T_2_2, T_2_3, T_2_4, s, image, &T_2_5, &T_2_6);
    if (err != ERR_ok)
        goto ex_1;
    disp.num = T_2_5.num;
    index.num = T_2_6.num;
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(1017);
    {
    tb.vec->data[11] = index.num;
    }

  LINE(1018);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[15];
    T_1_2.num = !T_1_1.num;
    if (T_1_2.num == true) { /* if */

  LINE(1019);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[2];
        T_2_2.num = tb.vec->data[1];
        err = _chanOPputb(T_2_1, T_2_2, disp, index, image);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(1020);
        {
        CLUREF T_2_1;
        T_2_1.num = index.num + 1;
        if ((T_2_1.num > 0 && index.num < 0 && 1 < 0) ||
            (T_2_1.num < 0 && index.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        disp.num = T_2_1.num;
        }
    }
    } /* end if */

  LINE(1022);
    {
    tb.vec->data[4] = disp.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE tty_put ****/


/**** BEGIN PROCEDURE putzero ****/

static errcode streamOPputzero_IB_1();
typedef struct {
    errcode ecode2;
    errcode err;
    CLUREF not_inserted;
    CLUREF diff;
    CLUREF c;
    CLUREF st;
    CLUREF s;
    CLUREF size;
} streamOPputzero_LOCALS_t;

errcode
streamOPputzero(CLUREF st, CLUREF s, CLUREF size)
{
    streamOPputzero_LOCALS_t locals;
    locals.st = st;
    locals.s = s;
    locals.size = size;
    if (stream_own_init == 0) {
        locals.err = stream_own_init_proc();
        if (locals.err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1025);

  LINE(1027);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (locals.size.num < 0);
    if (T_1_1.num == true) { /* if */

  LINE(1028);
        { /* signal */
            signal(ERR_negative_field_width);
        }
    }
    } /* end if */

  LINE(1029);
    {
    locals.not_inserted.tf = true;
    }

  LINE(1030);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    locals.err = stringOPsize(locals.s, &T_1_1);
    if (locals.err != ERR_ok)
        goto ex_0;
    T_1_2.num = locals.size.num - T_1_1.num;
    if ((T_1_2.num >= 0 && locals.size.num < 0 && (-T_1_1.num) < 0) ||
        (T_1_2.num <= 0 && locals.size.num > 0 && (-T_1_1.num) > 0)) {
        locals.err = ERR_overflow;
        goto ex_0;
    }
    locals.diff.num = T_1_2.num;
    }

  LINE(1031);
    { /* for */
        locals.err = stringOPchars(locals.s, streamOPputzero_IB_1, &locals, &locals.ecode2);

        if (locals.err == ERR_iterbodyreturn) {
            signal(ERR_ok);
        }
        if (locals.err == ERR_iterbodysignal)
            signal(locals.ecode2);
        if (locals.err == ERR_break)
            locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit)
            locals.err = locals.ecode2;
        if (locals.err != ERR_ok)
            goto ex_1;
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (locals.err == ERR_not_possible)
        signal(locals.err);
    else
        goto ex_0;
  end_1:;

  LINE(1043);
    { /* if */
    if (locals.not_inserted.num == true) { /* if */

  LINE(1044);
        for (;;) { /* while */
            CLUREF T_3_1;
            T_3_1.num = (locals.diff.num > 0);
            if (T_3_1.num != true)
                break;

  LINE(1045);
            {
            CLUREF T_4_1;
            T_4_1.ch = '0';
            locals.err = streamOPputc(locals.st, T_4_1);
            if (locals.err != ERR_ok)
                goto ex_2;
            }

  LINE(1046);
            {
            CLUREF T_4_1;
            T_4_1.num = locals.diff.num - 1;
            if ((T_4_1.num >= 0 && locals.diff.num < 0 && (-1) < 0) ||
                (T_4_1.num <= 0 && locals.diff.num > 0 && (-1) > 0)) {
                locals.err = ERR_overflow;
                goto ex_2;
            }
            locals.diff.num = T_4_1.num;
            }
        }
        end_while_1:
        __CLU_END_LABEL;
        goto end_2;
      ex_2: /* resignal */
        __CLU_EX_HANDLER;
        if (locals.err == ERR_not_possible)
            signal(locals.err);
        else
            goto ex_0;
      end_2:;
    }
    } /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (locals.err != ERR_failure)
        elist[0] = _pclu_erstr(locals.err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE putzero ****/


/**** BEGIN ITERATOR BODIES for putzero ****/

static errcode
streamOPputzero_IB_1(CLUREF iv_1, streamOPputzero_LOCALS_t *locals, errcode *iecode)
{
    locals->c.num = iv_1.num;
    enter_iter_body_proc(1032);

  FB_LINE(1032);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    CLUREF T_1_8;
    CLUREF T_1_9;
    T_1_1.num = locals->not_inserted.num;
    if (locals->not_inserted.num) {
        T_1_3.ch = '.';
        T_1_4.num = (locals->c.ch == T_1_3.ch);
        T_1_2.num = T_1_4.num;
        if (!T_1_4.num) {
            T_1_6.ch = '0';
            locals->err = charOPge(locals->c, T_1_6, &T_1_7);
            if (locals->err != ERR_ok)
                goto ex_0;
            T_1_5.num = T_1_7.num;
            if (T_1_7.num) {
                T_1_8.ch = '9';
                locals->err = charOPle(locals->c, T_1_8, &T_1_9);
                if (locals->err != ERR_ok)
                    goto ex_0;
                T_1_5.num = T_1_9.num;
            }
            T_1_2.num = T_1_5.num;
        }
        T_1_1.num = T_1_2.num;
    }
    if (T_1_1.num == true) { /* if */

  FB_LINE(1034);
        {
        locals->not_inserted.tf = false;
        }

  FB_LINE(1035);
        for (;;) { /* while */
            CLUREF T_2_1;
            T_2_1.num = (locals->diff.num > 0);
            if (T_2_1.num != true)
                break;

  FB_LINE(1036);
            {
            CLUREF T_3_1;
            T_3_1.ch = '0';
            locals->err = streamOPputc(locals->st, T_3_1);
            if (locals->err != ERR_ok)
                goto ex_0;
            }

  FB_LINE(1037);
            {
            CLUREF T_3_1;
            T_3_1.num = locals->diff.num - 1;
            if ((T_3_1.num >= 0 && locals->diff.num < 0 && (-1) < 0) ||
                (T_3_1.num <= 0 && locals->diff.num > 0 && (-1) > 0)) {
                locals->err = ERR_overflow;
                goto ex_0;
            }
            locals->diff.num = T_3_1.num;
            }
        }
        end_while_2:
        __CLU_END_LABEL;
    }
    } /* end if */

  FB_LINE(1040);
    {
    locals->err = streamOPputc(locals->st, locals->c);
    if (locals->err != ERR_ok)
        goto ex_0;
    }

    signal(ERR_ok);
  ex_0:
    __CLU_EX_HANDLER;
    *iecode = locals->err;
    signal(ERR_iterbodyexit);
  end_0:
    __CLU_END_LABEL;
    signal(ERR_ok);
}

/**** END ITERATOR BODIES for putzero ****/


/**** BEGIN PROCEDURE putleft ****/


errcode
streamOPputleft(CLUREF st, CLUREF s, CLUREF size)
{
    errcode err;
    CLUREF diff;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1052);

  LINE(1054);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (size.num < 0);
    if (T_1_1.num == true) { /* if */

  LINE(1055);
        { /* signal */
            signal(ERR_negative_field_width);
        }
    }
    } /* end if */

  LINE(1056);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = stringOPsize(s, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_2.num = size.num - T_1_1.num;
    if ((T_1_2.num >= 0 && size.num < 0 && (-T_1_1.num) < 0) ||
        (T_1_2.num <= 0 && size.num > 0 && (-T_1_1.num) > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    diff.num = T_1_2.num;
    }

  LINE(1057);
    { /* begin */

  LINE(1058);
        {
        err = streamOPputs(st, s);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(1059);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = (diff.num > 0);
        if (T_3_1.num == true) { /* if */

  LINE(1060);
            {
            err = streamOPputspace(st, diff);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        } /* end if */
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE putleft ****/


/**** BEGIN PROCEDURE putright ****/


errcode
streamOPputright(CLUREF st, CLUREF s, CLUREF size)
{
    errcode err;
    CLUREF diff;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1064);

  LINE(1066);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (size.num < 0);
    if (T_1_1.num == true) { /* if */

  LINE(1067);
        { /* signal */
            signal(ERR_negative_field_width);
        }
    }
    } /* end if */

  LINE(1068);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = stringOPsize(s, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_2.num = size.num - T_1_1.num;
    if ((T_1_2.num >= 0 && size.num < 0 && (-T_1_1.num) < 0) ||
        (T_1_2.num <= 0 && size.num > 0 && (-T_1_1.num) > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    diff.num = T_1_2.num;
    }

  LINE(1069);
    { /* begin */

  LINE(1070);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = (diff.num > 0);
        if (T_3_1.num == true) { /* if */

  LINE(1071);
            {
            err = streamOPputspace(st, diff);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        } /* end if */

  LINE(1072);
        {
        err = streamOPputs(st, s);
        if (err != ERR_ok)
            goto ex_1;
        }
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE putright ****/


/**** BEGIN PROCEDURE putspace ****/


errcode
streamOPputspace(CLUREF st, CLUREF len)
{
    errcode err;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1076);

  LINE(1078);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (len.num < 0);
    if (T_1_1.num == true) { /* if */

  LINE(1079);
        { /* signal */
            signal(ERR_negative_field_width);
        }
    }
    } /* end if */

  LINE(1080);
    for (;;) { /* while */
        CLUREF T_2_1;
        T_2_1.num = (len.num > 0);
        if (T_2_1.num != true)
            break;

  LINE(1081);
        {
        CLUREF T_3_1;
        T_3_1.ch = ' ';
        err = streamOPputc(st, T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(1082);
        {
        CLUREF T_3_1;
        T_3_1.num = len.num - 1;
        if ((T_3_1.num >= 0 && len.num < 0 && (-1) < 0) ||
            (T_3_1.num <= 0 && len.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        len.num = T_3_1.num;
        }
    }
    end_while_1:
    __CLU_END_LABEL;
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE putspace ****/


/**** BEGIN PROCEDURE create_input ****/

static int streamOPcreate_input_own_init = 0;

errcode
streamOPcreate_input(CLUREF s, CLUREF *ret_1)
{
    errcode err;
    CLUREF newln;
    if (streamOPcreate_input_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPcreate_input_own_init = 1;
    }
    enter_proc(1087);

  LINE(1088);
    {
    CLUREF T_1_1;
    T_1_1.ch = ' ';
    newln.num = T_1_1.num;
    }

  LINE(1089);
    { /* if */
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    CLUREF T_2_4;
    CLUREF T_2_5;
    err = stringOPsize(s, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    err = stringOPfetch(s, T_2_1, &T_2_2);
    if (err != ERR_ok)
        goto ex_1;
    T_2_3.ch = '\n';
    T_2_4.num = (T_2_2.ch == T_2_3.ch);
    T_2_5.num = !T_2_4.num;
    if (T_2_5.num == true) { /* if */

  LINE(1090);
        {
        CLUREF T_3_1;
        T_3_1.ch = '\n';
        newln.num = T_3_1.num;
        }
    }
    } /* end if */
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_bounds) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(1092);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    RecordAlloc(4, T_1_1);
    err = file_nameOPparse(CLU_empty_string, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    err = sequenceOPnew(&T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[3] = T_1_3.num;
    T_1_1.vec->data[2] = false;
    RecordAlloc(4, T_1_4);
    T_1_4.vec->data[0] = s.num;
    T_1_4.vec->data[1] = 1;
    T_1_4.vec->data[2] = 1;
    T_1_4.vec->data[3] = newln.num;
    CellAlloc(2, T_1_4.num, T_1_5);
    T_1_1.vec->data[0] = T_1_5.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE create_input ****/


/**** BEGIN PROCEDURE create_output ****/

static int streamOPcreate_output_own_init = 0;

errcode
streamOPcreate_output(CLUREF *ret_1)
{
    errcode err;
    if (streamOPcreate_output_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPcreate_output_own_init = 1;
    }
    enter_proc(1101);

  LINE(1102);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    RecordAlloc(4, T_1_1);
    err = file_nameOPparse(CLU_empty_string, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    err = sequenceOPnew(&T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[3] = T_1_3.num;
    T_1_1.vec->data[2] = false;
    err = arrayOPnew(&T_1_4);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(4, T_1_4.num, T_1_5);
    T_1_1.vec->data[0] = T_1_5.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE create_output ****/


/**** BEGIN PROCEDURE get_contents ****/

static int streamOPget_contents_own_init = 0;

errcode
streamOPget_contents(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF chars;
    if (streamOPget_contents_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPget_contents_own_init = 1;
    }
    enter_proc(1108);

  LINE(1109);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 4: /* ostr */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        chars.num = T_1_2.num;

  LINE(1111);
        { /* return */
        {
        CLUREF T_2_1;
        err = stringOPac2s(chars, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(1113);
        { /* signal */
            elist[0] = STR_not_040a_040string_040output_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_contents ****/


/**** BEGIN PROCEDURE getbuf ****/

static int streamOPgetbuf_own_init = 0;

errcode
streamOPgetbuf(CLUREF st, CLUREF term, CLUREF *ret_1)
{
    errcode err;
    CLUREF s;
    CLUREF rb;
    CLUREF index;
    CLUREF max;
    CLUREF i;
    CLUREF tb;
    CLUREF sb;
    if (streamOPgetbuf_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPgetbuf_own_init = 1;
    }
    enter_proc(1117);

  LINE(1120);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(1123);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        CLUREF T_3_7;
        T_3_1.num = rb.vec->data[1];
        T_3_2.num = rb.vec->data[0];
        T_3_3.num = rb.vec->data[2];
        T_3_4.num = rb.vec->data[4];
        err = _chanOPget(T_3_1, T_3_2, T_3_3, T_3_4, term, CLU_false, &T_3_5, &T_3_6, &T_3_7);
        if (err != ERR_ok)
            goto ex_1;
        s.num = T_3_5.num;
        index.num = T_3_6.num;
        max.num = T_3_7.num;
        }

  LINE(1125);
        {
        rb.vec->data[2] = index.num;
        }

  LINE(1126);
        {
        rb.vec->data[4] = max.num;
        }

  LINE(1127);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        T_3_1.ch = '\n';
        err = stringOPindexc(T_3_1, term, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        T_3_3.num = (T_3_2.num == 0);
        if (T_3_3.num == true) { /* if */

  LINE(1128);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.ch = '\n';
            err = stringOPindexc(T_4_1, s, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            i.num = T_4_2.num;
            }

  LINE(1129);
            { /* if */
            CLUREF T_4_1;
            T_4_1.num = (i.num > 0);
            if (T_4_1.num == true) { /* if */

  LINE(1130);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                T_5_1.num = rb.vec->data[3];
                err = streamOPlines(s, i, &T_5_2);
                if (err != ERR_ok)
                    goto ex_1;
                T_5_3.num = T_5_1.num + T_5_2.num;
                if ((T_5_3.num > 0 && T_5_1.num < 0 && T_5_2.num < 0) ||
                    (T_5_3.num < 0 && T_5_1.num > 0 && T_5_2.num > 0)) {
                    err = ERR_overflow;
                    goto ex_1;
                }
                rb.vec->data[3] = T_5_3.num;
                }
            }
            } /* end if */
        }
        } /* end if */
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(1133);
        {
        err = streamOPflush(st);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(1134);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        T_3_2.num = st.vec->data[2];
        T_3_1.num = T_3_2.num;
        if (T_3_2.num) {
            T_3_4.num = tb.vec->data[11];
            T_3_5.num = (T_3_4.num == 0);
            T_3_3.num = T_3_5.num;
            if (!T_3_5.num) {
                T_3_6.num = tb.vec->data[10];
                T_3_3.num = T_3_6.num;
            }
            T_3_1.num = T_3_3.num;
        }
        if (T_3_1.num == true) { /* if */

  LINE(1135);
            {
            CLUREF T_4_1;
            T_4_1.num = tb.vec->data[17];
            err = streamOPscript(st, T_4_1, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        } /* end if */

  LINE(1136);
        {
        CLUREF T_3_1;
        err = streamOPedit(tb, term, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        s.num = T_3_1.num;
        }
        break;
    }
    case 2: /* istr */ {
        CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        sb.num = T_2_4.num;

  LINE(1138);
        {
        CLUREF T_3_1;
        err = streamOPstr_get(sb, term, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        s.num = T_3_1.num;
        }
        break;
    }
    case 3: /* nul */ {

  LINE(1140);
        { /* signal */
            signal(ERR_end_of_file);
        }
        break;
    }
    case 7: /* write */ /* FALLTHROUGH */
    case 4: /* ostr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(1142);
        { /* signal */
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file)
        signal(err);
    else if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(1144);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) { /* if */

  LINE(1145);
        {
        err = streamOPscript(st, s, CLU_false);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(1146);
    { /* return */
    {
    ret_1->num = s.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE getbuf ****/


/**** BEGIN PROCEDURE lines ****/


errcode
streamOPlines(CLUREF s, CLUREF i, CLUREF *ret_1)
{
    errcode err;
    CLUREF cnt;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1149);

  LINE(1150);
    {
    cnt.num = 0;
    }

  LINE(1151);
    for (;;) { /* while */
        CLUREF T_1_1;
        T_1_1.num = (i.num > 0);
        if (T_1_1.num != true)
            break;

  LINE(1152);
        {
        CLUREF T_2_1;
        T_2_1.num = cnt.num + 1;
        if ((T_2_1.num > 0 && cnt.num < 0 && 1 < 0) ||
            (T_2_1.num < 0 && cnt.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        cnt.num = T_2_1.num;
        }

  LINE(1153);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.ch = '\n';
        T_2_2.num = (long)s.num;
        T_2_3.num = i.num + 1;
        if ((T_2_3.num > 0 && i.num < 0 && 1 < 0) ||
            (T_2_3.num < 0 && i.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        err = _bytevecOPindexc(T_2_1, T_2_2, T_2_3, &T_2_4);
        if (err != ERR_ok)
            goto ex_0;
        i.num = T_2_4.num;
        }
    }
    end_while_1:
    __CLU_END_LABEL;

  LINE(1155);
    { /* return */
    {
    ret_1->num = cnt.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE lines ****/


/**** BEGIN PROCEDURE script ****/


errcode
streamOPscript(CLUREF st, CLUREF s, CLUREF image)
{
    errcode err;
    CLUREF scr;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1158);

  LINE(1159);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = st.vec->data[3];
    T_1_3.num = T_1_1.vec->size;
    T_1_4 = T_1_1;
    for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
        scr.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(1160);
        { /* if */
        if (image.num == true) { /* if */

  LINE(1161);
            {
            err = streamOPputs_image(scr, s);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        else { /* else */

  LINE(1162);
            {
            err = streamOPputs(scr, s);
            if (err != ERR_ok)
                goto ex_1;
            }
        }} /* end if */
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_not_possible) {
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE script ****/


/**** BEGIN PROCEDURE edit ****/

static int streamOPedit_own_init = 0;

errcode
streamOPedit(CLUREF tb, CLUREF term, CLUREF *ret_1)
{
    errcode err;
    CLUREF ch;
    CLUREF bvec;
    CLUREF redisp;
    CLUREF c;
    CLUREF doecho;
    CLUREF s;
    CLUREF nl;
    CLUREF lag;
    CLUREF max;
    CLUREF i;
    if (streamOPedit_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPedit_own_init = 1;
    }
    enter_proc(1167);

  LINE(1169);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = tb.vec->data[7];
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        T_1_3.num = tb.vec->data[8];
        T_1_1.num = T_1_3.num;
    }
    if (T_1_1.num == true) { /* if */

  LINE(1170);
        { /* signal */
            signal(ERR_end_of_file);
        }
    }
    } /* end if */

  LINE(1171);
    {
    err = _eventOPdefer();
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(1172);
    {
    CLUREF T_1_1;
    T_1_1.num = tb.vec->data[2];
    ch.num = T_1_1.num;
    }

  LINE(1173);
    {
    CLUREF T_1_1;
    T_1_1.num = tb.vec->data[1];
    bvec.num = T_1_1.num;
    }

  LINE(1175);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_2.num = tb.vec->data[11];
    T_1_3.num = (T_1_2.num == 0);
    T_1_1.num = T_1_3.num;
    if (!T_1_3.num) {
        T_1_4.num = tb.vec->data[10];
        T_1_1.num = T_1_4.num;
    }
    if (T_1_1.num == true) { /* if */

  LINE(1176);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[17];
        err = stringOPsize(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        tb.vec->data[11] = T_2_2.num;
        }

  LINE(1177);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = tb.vec->data[17];
        T_2_2.num = (long)T_2_1.str;
        T_2_3.num = tb.vec->data[11];
        err = _bytevecOPmove_lr(T_2_2, CLU_1, bvec, CLU_1, T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(1179);
        {
        redisp.num = 1;
        }
    }
    else { /* else */

  LINE(1180);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[4];
        T_2_2.num = tb.vec->data[11];
        err = _chanOPputb(ch, bvec, T_2_1, T_2_2, CLU_false);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(1181);
        {
        redisp.num = 0;
        }
    }} /* end if */

  LINE(1183);
    {
    CLUREF T_1_1;
    T_1_1.num = tb.vec->data[11];
    tb.vec->data[4] = T_1_1.num;
    }

  LINE(1185);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(1186);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        T_4_1.num = (redisp.num == 0);
        T_4_2.num = !T_4_1.num;
        if (T_4_2.num == true) { /* if */

  LINE(1187);
            { /* if */
            CLUREF T_5_1;
            T_5_1.num = (redisp.num < 0);
            if (T_5_1.num == true) { /* if */

  LINE(1188);
                {
                CLUREF T_6_1;
                T_6_1.num = tb.vec->data[4];
                redisp.num = T_6_1.num;
                }

  LINE(1189);
                for (;;) { /* while */
                    if (true != true)
                        break;

  LINE(1190);
                    {
                    CLUREF T_8_1;
                    if (redisp.num < 1 || redisp.num > bvec.str->size) {
                        err = ERR_bounds;
                        goto ex_3;
                    }
                    T_8_1.ch = bvec.str->data[redisp.num - 1];
                    c.num = T_8_1.num;
                    }

  LINE(1191);
                    { /* if */
                    CLUREF T_8_1;
                    CLUREF T_8_2;
                    CLUREF T_8_3;
                    CLUREF T_8_4;
                    CLUREF T_8_5;
                    T_8_2.ch = '\034';
                    T_8_3.num = (c.ch == T_8_2.ch);
                    T_8_1.num = T_8_3.num;
                    if (!T_8_3.num) {
                        T_8_4.ch = '\n';
                        T_8_5.num = (c.ch == T_8_4.ch);
                        T_8_1.num = T_8_5.num;
                    }
                    if (T_8_1.num == true) { /* if */

  LINE(1192);
                        goto end_while_2;
                    }
                    } /* end if */

  LINE(1193);
                    {
                    CLUREF T_8_1;
                    T_8_1.num = redisp.num - 1;
                    if ((T_8_1.num >= 0 && redisp.num < 0 && (-1) < 0) ||
                        (T_8_1.num <= 0 && redisp.num > 0 && (-1) > 0)) {
                        err = ERR_overflow;
                        goto ex_3;
                    }
                    redisp.num = T_8_1.num;
                    }
                }
                end_while_2:
                __CLU_END_LABEL;
                goto end_3;
              ex_3: /* except */
                __CLU_EX_HANDLER;
                if (err == ERR_bounds) {
                }
                else { /* not handled */
                    goto ex_2;
                }
              end_3:;
            }
            else { /* else */

  LINE(1195);
                {
                redisp.num = 0;
                }
            }} /* end if */

  LINE(1197);
            for (;;) { /* while */
                CLUREF T_5_1;
                CLUREF T_5_2;
                T_5_1.num = tb.vec->data[4];
                T_5_2.num = (redisp.num < T_5_1.num);
                if (T_5_2.num != true)
                    break;

  LINE(1198);
                {
                CLUREF T_6_1;
                T_6_1.num = redisp.num + 1;
                if ((T_6_1.num > 0 && redisp.num < 0 && 1 < 0) ||
                    (T_6_1.num < 0 && redisp.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_2;
                }
                redisp.num = T_6_1.num;
                }

  LINE(1199);
                {
                CLUREF T_6_1;
                if (redisp.num < 1 || redisp.num > bvec.str->size) {
                    err = ERR_bounds;
                    goto ex_2;
                }
                T_6_1.ch = bvec.str->data[redisp.num - 1];
                c.num = T_6_1.num;
                }

  LINE(1200);
                {
                err = streamOPecho(ch, c);
                if (err != ERR_ok)
                    goto ex_2;
                }

  LINE(1201);
                { /* if */
                CLUREF T_6_1;
                CLUREF T_6_2;
                T_6_1.ch = '\034';
                T_6_2.num = (c.ch == T_6_1.ch);
                if (T_6_2.num == true) { /* if */

  LINE(1202);
                    {
                    CLUREF T_7_1;
                    T_7_1.ch = '\n';
                    err = _chanOPputc(ch, T_7_1, CLU_false);
                    if (err != ERR_ok)
                        goto ex_2;
                    }
                }
                } /* end if */
            }
            end_while_3:
            __CLU_END_LABEL;

  LINE(1204);
            {
            redisp.num = 0;
            }
        }
        } /* end if */

  LINE(1207);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_1.num = tb.vec->data[18];
        T_4_2.num = (T_4_1.array->ext_size == 0);
        T_4_3.num = !T_4_2.num;
        if (T_4_3.num == true) { /* if */

  LINE(1208);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            T_5_1.num = tb.vec->data[18];
            err = arrayOPreml(T_5_1, &T_5_2);
            if (err != ERR_ok)
                goto ex_2;
            c.num = T_5_2.num;
            }

  LINE(1209);
            {
            CLUREF T_5_1;
            T_5_1.num = tb.vec->data[5];
            doecho.num = T_5_1.num;
            }

  LINE(1210);
            {
            tb.vec->data[5] = false;
            }
        }
        else { /* else */

  LINE(1211);
            {
            CLUREF T_5_1;
            err = _chanOPgetc(ch, CLU_true, &T_5_1);
            if (err != ERR_ok)
                goto ex_2;
            c.num = T_5_1.num;
            }

  LINE(1212);
            {
            doecho.tf = true;
            }
        }} /* end if */

  LINE(1214);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        T_4_1.ch = '\n';
        T_4_2.num = (c.ch == T_4_1.ch);
        if (T_4_2.num == true) { /* if */

  LINE(1215);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            T_5_1.num = tb.vec->data[13];
            T_5_2.num = T_5_1.num + 1;
            if ((T_5_2.num > 0 && T_5_1.num < 0 && 1 < 0) ||
                (T_5_2.num < 0 && T_5_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_2;
            }
            tb.vec->data[13] = T_5_2.num;
            }
        }
        } /* end if */

  LINE(1216);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        err = stringOPindexc(c, term, &T_4_1);
        if (err != ERR_ok)
            goto ex_2;
        T_4_2.num = (T_4_1.num > 0);
        if (T_4_2.num == true) { /* if */

  LINE(1217);
            {
            tb.vec->data[5] = doecho.num;
            }

  LINE(1218);
            {
            CLUREF T_5_1;
            T_5_1.num = tb.vec->data[18];
            err = arrayOPaddl(T_5_1, c);
            if (err != ERR_ok)
                goto ex_2;
            }

  LINE(1219);
            goto end_while_1;
        }
        else {

  LINE(1220);
        CLUREF T_4_3;
        CLUREF T_4_4;
        T_4_3.ch = '\177';
        T_4_4.num = (c.ch == T_4_3.ch);
        if (T_4_4.num == true) { /* elseif */

  LINE(1222);
            {
            CLUREF T_5_1;
            err = streamOPrubout(tb, &T_5_1);
            if (err != ERR_ok)
                goto ex_2;
            redisp.num = T_5_1.num;
            }
        }
        else {

  LINE(1223);
        CLUREF T_4_5;
        CLUREF T_4_6;
        CLUREF T_4_7;
        CLUREF T_4_8;
        T_4_6.ch = '\004';
        T_4_7.num = (c.ch == T_4_6.ch);
        T_4_5.num = T_4_7.num;
        if (T_4_7.num) {
            T_4_8.num = tb.vec->data[8];
            T_4_5.num = T_4_8.num;
        }
        if (T_4_5.num == true) { /* elseif */

  LINE(1224);
            { /* if */
            if (doecho.num == true) { /* if */

  LINE(1225);
                {
                err = streamOPecho(ch, c);
                if (err != ERR_ok)
                    goto ex_2;
                }
            }
            } /* end if */

  LINE(1226);
            { /* exit */
                err = ERR_end_of_file;
                goto ex_2;
            }
        }
        else {

  LINE(1227);
        CLUREF T_4_9;
        CLUREF T_4_10;
        T_4_9.ch = '\030';
        T_4_10.num = (c.ch == T_4_9.ch);
        if (T_4_10.num == true) { /* elseif */

  LINE(1229);
            {
            CLUREF T_5_1;
            T_5_1.num = tb.vec->data[11];
            tb.vec->data[4] = T_5_1.num;
            }

  LINE(1230);
            {
            CLUREF T_5_1;
            T_5_1.ch = '\n';
            err = _chanOPputc(ch, T_5_1, CLU_false);
            if (err != ERR_ok)
                goto ex_2;
            }

  LINE(1231);
            {
            redisp.num = 1;
            }
        }
        else {

  LINE(1232);
        CLUREF T_4_11;
        CLUREF T_4_12;
        T_4_11.ch = '\f';
        T_4_12.num = (c.ch == T_4_11.ch);
        if (T_4_12.num == true) { /* elseif */

  LINE(1234);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            T_5_1.num = tb.vec->data[2];
            T_5_2.num = tb.vec->data[3];
            err = _chanOPputs(T_5_1, T_5_2, CLU_false);
            if (err != ERR_ok)
                goto ex_2;
            }

  LINE(1235);
            {
            redisp.num = 1;
            }
        }
        else {

  LINE(1236);
        CLUREF T_4_13;
        CLUREF T_4_14;
        T_4_13.ch = '\022';
        T_4_14.num = (c.ch == T_4_13.ch);
        if (T_4_14.num == true) { /* elseif */

  LINE(1238);
            {
            CLUREF T_5_1;
            T_5_1.ch = '\n';
            err = _chanOPputc(ch, T_5_1, CLU_false);
            if (err != ERR_ok)
                goto ex_2;
            }

  LINE(1239);
            {
            redisp.num = 1;
            }
        }
        else {

  LINE(1240);
        CLUREF T_4_15;
        CLUREF T_4_16;
        T_4_15.ch = '\025';
        T_4_16.num = (c.ch == T_4_15.ch);
        if (T_4_16.num == true) { /* elseif */

  LINE(1242);
            {
            CLUREF T_5_1;
            err = streamOPerase(tb, CLU_true, &T_5_1);
            if (err != ERR_ok)
                goto ex_2;
            redisp.num = T_5_1.num;
            }
        }
        else {

  LINE(1243);
        CLUREF T_4_17;
        CLUREF T_4_18;
        T_4_17.ch = '\027';
        T_4_18.num = (c.ch == T_4_17.ch);
        if (T_4_18.num == true) { /* elseif */

  LINE(1245);
            {
            CLUREF T_5_1;
            err = streamOPerase(tb, CLU_false, &T_5_1);
            if (err != ERR_ok)
                goto ex_2;
            redisp.num = T_5_1.num;
            }
        }
        else { /* else */

  LINE(1246);
            { /* if */
            if (doecho.num == true) { /* if */

  LINE(1247);
                {
                err = streamOPecho(ch, c);
                if (err != ERR_ok)
                    goto ex_2;
                }
            }
            } /* end if */

  LINE(1248);
            { /* if */
            CLUREF T_5_1;
            CLUREF T_5_2;
            T_5_1.ch = '\034';
            T_5_2.num = (c.ch == T_5_1.ch);
            if (T_5_2.num == true) { /* if */

  LINE(1249);
                {
                CLUREF T_6_1;
                T_6_1.ch = '\n';
                err = _chanOPputc(ch, T_6_1, CLU_false);
                if (err != ERR_ok)
                    goto ex_2;
                }
            }
            } /* end if */

  LINE(1250);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            T_5_1.num = tb.vec->data[4];
            T_5_2.num = T_5_1.num + 1;
            if ((T_5_2.num > 0 && T_5_1.num < 0 && 1 < 0) ||
                (T_5_2.num < 0 && T_5_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_2;
            }
            tb.vec->data[4] = T_5_2.num;
            }

  LINE(1251);
            {
            CLUREF T_5_1;
            T_5_1.num = tb.vec->data[4];
            err = _bytevecOPstore(bvec, T_5_1, c);
            if (err != ERR_ok)
                goto ex_2;
            }
        }}}}}}}}} /* end if */
    }
    end_while_1:
    __CLU_END_LABEL;
    goto end_2;
  ex_2: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_1;
  end_2:;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file) {

  LINE(1256);
        {
        tb.vec->data[7] = true;
        }

  LINE(1257);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = tb.vec->data[4];
        T_2_2.num = tb.vec->data[11];
        T_2_3.num = (T_2_1.num == T_2_2.num);
        if (T_2_3.num == true) { /* if */

  LINE(1258);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = tb.vec->data[11];
            T_3_2.num = T_3_1.num + 1;
            if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) ||
                (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            tb.vec->data[4] = T_3_2.num;
            }

  LINE(1259);
            { /* signal */
                signal(ERR_end_of_file);
            }
        }
        } /* end if */
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(1262);
    {
    s = CLU_empty_string;
    }

  LINE(1263);
    {
    nl.num = 0;
    }

  LINE(1264);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[11];
    T_1_2.num = T_1_1.num + 1;
    if ((T_1_2.num > 0 && T_1_1.num < 0 && 1 < 0) ||
        (T_1_2.num < 0 && T_1_1.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    lag.num = T_1_2.num;
    }

  LINE(1265);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[4];
    T_1_2.num = T_1_1.num + 1;
    if ((T_1_2.num > 0 && T_1_1.num < 0 && 1 < 0) ||
        (T_1_2.num < 0 && T_1_1.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    max.num = T_1_2.num;
    }

  LINE(1266);
    {
    CLUREF T_1_1;
    T_1_1.ch = '\034';
    err = _bytevecOPstore(bvec, max, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(1267);
    { /* for int$from_to */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = max.num;
    for (T_1_1.num = lag.num; T_1_1.num <= T_1_2.num; T_1_1.num++
    ) {
        i.num = T_1_1.num;

  LINE(1268);
        {
        CLUREF T_2_1;
        if (i.num < 1 || i.num > bvec.str->size) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.ch = bvec.str->data[i.num - 1];
        c.num = T_2_1.num;
        }

  LINE(1269);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.ch = '\034';
        T_2_2.num = (c.ch == T_2_1.ch);
        if (T_2_2.num == true) { /* if */

  LINE(1270);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_1.num = (long)bvec.num;
            T_3_2.num = i.num - lag.num;
            if ((T_3_2.num >= 0 && i.num < 0 && (-lag.num) < 0) ||
                (T_3_2.num <= 0 && i.num > 0 && (-lag.num) > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            err = stringOPsubstr(T_3_1, lag, T_3_2, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(s, T_3_3, &T_3_4);
            if (err != ERR_ok)
                goto ex_0;
            s.num = T_3_4.num;
            }

  LINE(1272);
            {
            CLUREF T_3_1;
            T_3_1.num = i.num + 1;
            if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) ||
                (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            lag.num = T_3_1.num;
            }

  LINE(1273);
            { /* if */
            CLUREF T_3_1;
            T_3_1.num = (lag.num < max.num);
            if (T_3_1.num == true) { /* if */

  LINE(1274);
                {
                nl.num = lag.num;
                }
            }
            } /* end if */
        }
        else {

  LINE(1275);
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_3.ch = '\n';
        T_2_4.num = (c.ch == T_2_3.ch);
        if (T_2_4.num == true) { /* elseif */

  LINE(1276);
            {
            CLUREF T_3_1;
            T_3_1.num = i.num + 1;
            if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) ||
                (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            nl.num = T_3_1.num;
            }
        }
        }} /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(1278);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (nl.num > 0);
    if (T_1_1.num == true) { /* if */

  LINE(1279);
        {
        CLUREF T_2_1;
        T_2_1.num = max.num - nl.num;
        if ((T_2_1.num >= 0 && max.num < 0 && (-nl.num) < 0) ||
            (T_2_1.num <= 0 && max.num > 0 && (-nl.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        tb.vec->data[11] = T_2_1.num;
        }

  LINE(1280);
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[11];
        err = _bytevecOPmove_lr(bvec, nl, bvec, CLU_1, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(1281);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[11];
        T_2_2.num = T_2_1.num + 1;
        if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) ||
            (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        tb.vec->data[4] = T_2_2.num;
        }
    }
    else { /* else */

  LINE(1282);
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[4];
        tb.vec->data[11] = T_2_1.num;
        }

  LINE(1283);
        {
        tb.vec->data[4] = max.num;
        }
    }} /* end if */

  LINE(1285);
    {
    err = _eventOPundefer();
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(1286);
    { /* return */
    {
    ret_1->num = s.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE edit ****/


/**** BEGIN PROCEDURE echo ****/

static int streamOPecho_own_init = 0;

errcode
streamOPecho(CLUREF ch, CLUREF c)
{
    errcode err;
    if (streamOPecho_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPecho_own_init = 1;
    }
    enter_proc(1289);

  LINE(1290);
    { /* if */
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.ch = '\177';
    err = charOPge(c, T_2_1, &T_2_2);
    if (err != ERR_ok)
        goto ex_1;
    if (T_2_2.num == true) { /* if */

  LINE(1291);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.ch = '\177';
        T_3_2.num = (c.ch == T_3_1.ch);
        if (T_3_2.num == true) { /* if */

  LINE(1292);
            {
            err = _chanOPputs(ch, STR__136_077, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        else {

  LINE(1293);
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        CLUREF T_3_7;
        CLUREF T_3_8;
        CLUREF T_3_9;
        T_3_4.num = (long)(c.ch & 0xff);
        T_3_5.num = 160;
        T_3_6.num = (T_3_4.num < T_3_5.num);
        T_3_3.num = T_3_6.num;
        if (!T_3_6.num) {
            T_3_7.num = (long)(c.ch & 0xff);
            T_3_8.num = 255;
            T_3_9.num = (T_3_7.num == T_3_8.num);
            T_3_3.num = T_3_9.num;
        }
        if (T_3_3.num == true) { /* elseif */

  LINE(1295);
            {
            CLUREF T_4_1;
            T_4_1.ch = '!';
            err = _chanOPputc(ch, T_4_1, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }

  LINE(1296);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            T_4_1.num = (long)(c.ch & 0xff);
            T_4_2.num = 64;
            T_4_3.num = T_4_1.num - T_4_2.num;
            if ((T_4_3.num >= 0 && T_4_1.num < 0 && (-T_4_2.num) < 0) ||
                (T_4_3.num <= 0 && T_4_1.num > 0 && (-T_4_2.num) > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            T_4_4.num = 128;
            err = intOPmod(T_4_3, T_4_4, &T_4_5);
            if (err != ERR_ok)
                goto ex_1;
            err = _chanOPputi(ch, T_4_5, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        else { /* else */

  LINE(1297);
            {
            CLUREF T_4_1;
            T_4_1.ch = '&';
            err = _chanOPputc(ch, T_4_1, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }

  LINE(1298);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = (long)(c.ch & 0xff);
            T_4_2.num = 128;
            T_4_3.num = T_4_1.num - T_4_2.num;
            if ((T_4_3.num >= 0 && T_4_1.num < 0 && (-T_4_2.num) < 0) ||
                (T_4_3.num <= 0 && T_4_1.num > 0 && (-T_4_2.num) > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            err = _chanOPputi(ch, T_4_3, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }
        }}} /* end if */
    }
    else {

  LINE(1300);
    CLUREF T_2_3;
    CLUREF T_2_4;
    CLUREF T_2_5;
    CLUREF T_2_6;
    CLUREF T_2_7;
    CLUREF T_2_8;
    CLUREF T_2_9;
    CLUREF T_2_10;
    T_2_5.ch = ' ';
    err = charOPge(c, T_2_5, &T_2_6);
    if (err != ERR_ok)
        goto ex_1;
    T_2_4.num = T_2_6.num;
    if (!T_2_6.num) {
        T_2_7.ch = '\n';
        T_2_8.num = (c.ch == T_2_7.ch);
        T_2_4.num = T_2_8.num;
    }
    T_2_3.num = T_2_4.num;
    if (!T_2_4.num) {
        T_2_9.ch = '\t';
        T_2_10.num = (c.ch == T_2_9.ch);
        T_2_3.num = T_2_10.num;
    }
    if (T_2_3.num == true) { /* elseif */

  LINE(1301);
        {
        err = _chanOPputc(ch, c, CLU_false);
        if (err != ERR_ok)
            goto ex_1;
        }
    }
    else { /* else */

  LINE(1302);
        {
        CLUREF T_3_1;
        T_3_1.ch = '^';
        err = _chanOPputc(ch, T_3_1, CLU_false);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(1303);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        T_3_1.num = (long)(c.ch & 0xff);
        T_3_2.num = 64;
        T_3_3.num = T_3_1.num + T_3_2.num;
        if ((T_3_3.num > 0 && T_3_1.num < 0 && T_3_2.num < 0) ||
            (T_3_3.num < 0 && T_3_1.num > 0 && T_3_2.num > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        err = _chanOPputi(ch, T_3_3, CLU_false);
        if (err != ERR_ok)
            goto ex_1;
        }
    }}} /* end if */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE echo ****/


/**** BEGIN PROCEDURE rubout ****/


errcode
streamOPrubout(CLUREF tb, CLUREF *ret_1)
{
    errcode err;
    CLUREF c;
    CLUREF cnt;
    CLUREF i;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1307);

  LINE(1308);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = tb.vec->data[4];
    T_1_2.num = tb.vec->data[11];
    T_1_3.num = (T_1_1.num <= T_1_2.num);
    if (T_1_3.num == true) { /* if */

  LINE(1309);
        { /* return */
        {
        ret_1->num = 0;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(1310);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = tb.vec->data[1];
    T_1_2.num = tb.vec->data[4];
    if (T_1_2.num < 1 || T_1_2.num > T_1_1.str->size) {
        err = ERR_bounds;
        goto ex_0;
    }
    T_1_3.ch = T_1_1.str->data[T_1_2.num - 1];
    c.num = T_1_3.num;
    }

  LINE(1311);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[4];
    T_1_2.num = T_1_1.num - 1;
    if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-1) < 0) ||
        (T_1_2.num <= 0 && T_1_1.num > 0 && (-1) > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    tb.vec->data[4] = T_1_2.num;
    }

  LINE(1312);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[6];
    T_1_2.num = !T_1_1.num;
    if (T_1_2.num == true) { /* if */

  LINE(1313);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_2.ch = '\034';
        T_2_3.num = (c.ch == T_2_2.ch);
        T_2_1.num = T_2_3.num;
        if (!T_2_3.num) {
            T_2_4.ch = '\n';
            T_2_5.num = (c.ch == T_2_4.ch);
            T_2_1.num = T_2_5.num;
        }
        if (T_2_1.num == true) { /* if */

  LINE(1314);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = tb.vec->data[2];
            T_3_2.ch = '\n';
            err = _chanOPputc(T_3_1, T_3_2, CLU_false);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(1315);
            { /* return */
            {
            ret_1->num = -1;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(1317);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[2];
        T_2_2.ch = '\\';
        err = _chanOPputc(T_2_1, T_2_2, CLU_false);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(1318);
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[2];
        err = _chanOPputc(T_2_1, c, CLU_false);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(1319);
        { /* return */
        {
        ret_1->num = 0;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(1322);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    T_1_2.ch = ' ';
    err = charOPge(c, T_1_2, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.num = T_1_3.num;
    if (T_1_3.num) {
        T_1_4.ch = '\177';
        err = charOPlt(c, T_1_4, &T_1_5);
        if (err != ERR_ok)
            goto ex_0;
        T_1_1.num = T_1_5.num;
    }
    if (T_1_1.num == true) { /* if */

  LINE(1323);
        {
        cnt.num = 1;
        }
    }
    else {

  LINE(1324);
    CLUREF T_1_6;
    CLUREF T_1_7;
    T_1_6.ch = '\t';
    T_1_7.num = (c.ch == T_1_6.ch);
    if (T_1_7.num == true) { /* elseif */

  LINE(1325);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = streamOPcalc_pos(tb, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = intOPmod(T_2_1, CLU_8, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_3.num = 8 - T_2_2.num;
        if ((T_2_3.num >= 0 && 8 < 0 && (-T_2_2.num) < 0) ||
            (T_2_3.num <= 0 && 8 > 0 && (-T_2_2.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        cnt.num = T_2_3.num;
        }
    }
    else {

  LINE(1326);
    CLUREF T_1_8;
    CLUREF T_1_9;
    CLUREF T_1_10;
    CLUREF T_1_11;
    CLUREF T_1_12;
    T_1_9.ch = '\034';
    T_1_10.num = (c.ch == T_1_9.ch);
    T_1_8.num = T_1_10.num;
    if (!T_1_10.num) {
        T_1_11.ch = '\n';
        T_1_12.num = (c.ch == T_1_11.ch);
        T_1_8.num = T_1_12.num;
    }
    if (T_1_8.num == true) { /* elseif */

  LINE(1327);
        { /* return */
        {
        ret_1->num = -1;
        }
        signal (ERR_ok);
        }
    }
    else { /* else */

  LINE(1328);
        {
        cnt.num = 2;
        }
    }}}} /* end if */

  LINE(1329);
    { /* for int$from_to_by */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = 1;
    T_1_3.num = -1;
    for (T_1_1.num = cnt.num; ((T_1_3.num == 0) || ((T_1_3.num > 0)? (T_1_1.num <= T_1_2.num) : (T_1_1.num >= T_1_2.num))); T_1_1.num += T_1_3.num) {
        i.num = T_1_1.num;

  LINE(1330);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[2];
        T_2_2.num = tb.vec->data[0];
        err = _chanOPputs(T_2_1, T_2_2, CLU_false);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(1332);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[2];
    T_1_2.num = tb.vec->data[12];
    err = _chanOPputs(T_1_1, T_1_2, CLU_false);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(1333);
    { /* return */
    {
    ret_1->num = 0;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE rubout ****/


/**** BEGIN PROCEDURE erase ****/


errcode
streamOPerase(CLUREF tb, CLUREF all, CLUREF *ret_1)
{
    errcode err;
    CLUREF redisp;
    CLUREF pre;
    CLUREF post;
    CLUREF c;
    CLUREF wchar;
    CLUREF i;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1336);

  LINE(1337);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = tb.vec->data[4];
    T_1_2.num = tb.vec->data[11];
    T_1_3.num = (T_1_1.num <= T_1_2.num);
    if (T_1_3.num == true) { /* if */

  LINE(1338);
        { /* return */
        {
        ret_1->num = 0;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(1339);
    {
    redisp.num = 0;
    }

  LINE(1340);
    {
    CLUREF T_1_1;
    err = streamOPcalc_pos(tb, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    pre.num = T_1_1.num;
    }

  LINE(1342);
    { /* if */
    if (all.num == true) { /* if */

  LINE(1343);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_1.ch = '\034';
        T_2_2.num = tb.vec->data[1];
        T_2_3.num = tb.vec->data[11];
        T_2_4.num = T_2_3.num + 1;
        if ((T_2_4.num > 0 && T_2_3.num < 0 && 1 < 0) ||
            (T_2_4.num < 0 && T_2_3.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        err = _bytevecOPindexc(T_2_1, T_2_2, T_2_4, &T_2_5);
        if (err != ERR_ok)
            goto ex_0;
        post.num = T_2_5.num;
        }

  LINE(1344);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = (post.num == 0);
        if (T_2_1.num == true) { /* if */

  LINE(1345);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            T_3_1.ch = '\n';
            T_3_2.num = tb.vec->data[1];
            T_3_3.num = tb.vec->data[11];
            T_3_4.num = T_3_3.num + 1;
            if ((T_3_4.num > 0 && T_3_3.num < 0 && 1 < 0) ||
                (T_3_4.num < 0 && T_3_3.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            err = _bytevecOPindexc(T_3_1, T_3_2, T_3_4, &T_3_5);
            if (err != ERR_ok)
                goto ex_0;
            post.num = T_3_5.num;
            }
        }
        } /* end if */

  LINE(1347);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_2.num = (post.num > 0);
        T_2_1.num = T_2_2.num;
        if (T_2_2.num) {
            T_2_3.num = tb.vec->data[4];
            T_2_4.num = (post.num <= T_2_3.num);
            T_2_1.num = T_2_4.num;
        }
        if (T_2_1.num == true) { /* if */

  LINE(1348);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = tb.vec->data[2];
            T_3_2.ch = '\n';
            err = _chanOPputc(T_3_1, T_3_2, CLU_false);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(1349);
            {
            CLUREF T_3_1;
            T_3_1.num = tb.vec->data[11];
            tb.vec->data[4] = T_3_1.num;
            }

  LINE(1350);
            { /* return */
            {
            ret_1->num = -1;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(1352);
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[11];
        tb.vec->data[4] = T_2_1.num;
        }

  LINE(1353);
        {
        CLUREF T_2_1;
        err = streamOPcalc_pos(tb, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        post.num = T_2_1.num;
        }
    }
    else { /* else */

  LINE(1354);
        for (;;) { /* while */
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            T_2_1.num = tb.vec->data[4];
            T_2_2.num = tb.vec->data[11];
            T_2_3.num = (T_2_1.num > T_2_2.num);
            if (T_2_3.num != true)
                break;

  LINE(1355);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = tb.vec->data[1];
            T_3_2.num = tb.vec->data[4];
            if (T_3_2.num < 1 || T_3_2.num > T_3_1.str->size) {
                err = ERR_bounds;
                goto ex_0;
            }
            T_3_3.ch = T_3_1.str->data[T_3_2.num - 1];
            c.num = T_3_3.num;
            }

  LINE(1356);
            { /* if */
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.ch = '\034';
            T_3_2.num = (c.ch == T_3_1.ch);
            if (T_3_2.num == true) { /* if */

  LINE(1357);
                {
                redisp.num = -1;
                }

  LINE(1358);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = tb.vec->data[4];
                T_4_2.num = T_4_1.num - 1;
                if ((T_4_2.num >= 0 && T_4_1.num < 0 && (-1) < 0) ||
                    (T_4_2.num <= 0 && T_4_1.num > 0 && (-1) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;
                }
                tb.vec->data[4] = T_4_2.num;
                }

  LINE(1359);
                continue;
            }
            else {

  LINE(1360);
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_3.ch = '\n';
            T_3_4.num = (c.ch == T_3_3.ch);
            if (T_3_4.num == true) { /* elseif */

  LINE(1361);
                {
                redisp.num = -1;
                }
            }
            }} /* end if */

  LINE(1362);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            CLUREF T_3_6;
            CLUREF T_3_7;
            CLUREF T_3_8;
            CLUREF T_3_9;
            CLUREF T_3_10;
            CLUREF T_3_11;
            CLUREF T_3_12;
            CLUREF T_3_13;
            CLUREF T_3_14;
            CLUREF T_3_15;
            CLUREF T_3_16;
            CLUREF T_3_17;
            CLUREF T_3_18;
            CLUREF T_3_19;
            CLUREF T_3_20;
            T_3_5.ch = 'a';
            err = charOPge(c, T_3_5, &T_3_6);
            if (err != ERR_ok)
                goto ex_0;
            T_3_4.num = T_3_6.num;
            if (T_3_6.num) {
                T_3_7.ch = 'z';
                err = charOPle(c, T_3_7, &T_3_8);
                if (err != ERR_ok)
                    goto ex_0;
                T_3_4.num = T_3_8.num;
            }
            T_3_3.num = T_3_4.num;
            if (!T_3_4.num) {
                T_3_10.ch = '0';
                err = charOPge(c, T_3_10, &T_3_11);
                if (err != ERR_ok)
                    goto ex_0;
                T_3_9.num = T_3_11.num;
                if (T_3_11.num) {
                    T_3_12.ch = '9';
                    err = charOPle(c, T_3_12, &T_3_13);
                    if (err != ERR_ok)
                        goto ex_0;
                    T_3_9.num = T_3_13.num;
                }
                T_3_3.num = T_3_9.num;
            }
            T_3_2.num = T_3_3.num;
            if (!T_3_3.num) {
                T_3_15.ch = 'A';
                err = charOPge(c, T_3_15, &T_3_16);
                if (err != ERR_ok)
                    goto ex_0;
                T_3_14.num = T_3_16.num;
                if (T_3_16.num) {
                    T_3_17.ch = 'Z';
                    err = charOPle(c, T_3_17, &T_3_18);
                    if (err != ERR_ok)
                        goto ex_0;
                    T_3_14.num = T_3_18.num;
                }
                T_3_2.num = T_3_14.num;
            }
            T_3_1.num = T_3_2.num;
            if (!T_3_2.num) {
                T_3_19.ch = '_';
                T_3_20.num = (c.ch == T_3_19.ch);
                T_3_1.num = T_3_20.num;
            }
            wchar.num = T_3_1.num;
            }

  LINE(1366);
            { /* if */
            CLUREF T_3_1;
            T_3_1.num = !all.num;
            if (T_3_1.num == true) { /* if */

  LINE(1367);
                {
                all.num = wchar.num;
                }
            }
            else {

  LINE(1368);
            CLUREF T_3_2;
            T_3_2.num = !wchar.num;
            if (T_3_2.num == true) { /* elseif */

  LINE(1369);
                goto end_while_1;
            }
            }} /* end if */

  LINE(1370);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = tb.vec->data[4];
            T_3_2.num = T_3_1.num - 1;
            if ((T_3_2.num >= 0 && T_3_1.num < 0 && (-1) < 0) ||
                (T_3_2.num <= 0 && T_3_1.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            tb.vec->data[4] = T_3_2.num;
            }
        }
        end_while_1:
        __CLU_END_LABEL;

  LINE(1372);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = (redisp.num < 0);
        if (T_2_1.num == true) { /* if */

  LINE(1373);
            {
            post.num = 0;
            }
        }
        else { /* else */

  LINE(1374);
            {
            CLUREF T_3_1;
            err = streamOPcalc_pos(tb, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            post.num = T_3_1.num;
            }
        }} /* end if */
    }} /* end if */

  LINE(1377);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[6];
    T_1_2.num = !T_1_1.num;
    if (T_1_2.num == true) { /* if */

  LINE(1378);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[2];
        T_2_2.ch = '\n';
        err = _chanOPputc(T_2_1, T_2_2, CLU_false);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(1379);
        { /* return */
        {
        ret_1->num = -1;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(1381);
    { /* for int$from_to_by */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = pre.num - post.num;
    if ((T_1_1.num >= 0 && pre.num < 0 && (-post.num) < 0) ||
        (T_1_1.num <= 0 && pre.num > 0 && (-post.num) > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    T_1_3.num = 1;
    T_1_4.num = -1;
    for (T_1_2.num = T_1_1.num; ((T_1_4.num == 0) || ((T_1_4.num > 0)? (T_1_2.num <= T_1_3.num) : (T_1_2.num >= T_1_3.num))); T_1_2.num += T_1_4.num) {
        i.num = T_1_2.num;

  LINE(1382);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[2];
        T_2_2.num = tb.vec->data[0];
        err = _chanOPputs(T_2_1, T_2_2, CLU_false);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(1384);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[2];
    T_1_2.num = tb.vec->data[12];
    err = _chanOPputs(T_1_1, T_1_2, CLU_false);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(1385);
    { /* return */
    {
    ret_1->num = redisp.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE erase ****/


/**** BEGIN PROCEDURE calc_pos ****/


errcode
streamOPcalc_pos(CLUREF tb, CLUREF *ret_1)
{
    errcode err;
    CLUREF pos;
    CLUREF i;
    CLUREF c;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1388);

  LINE(1389);
    {
    pos.num = 0;
    }

  LINE(1390);
    { /* for int$from_to */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = tb.vec->data[4];
    T_1_3.num = T_1_1.num;
    for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++
    ) {
        i.num = T_1_2.num;

  LINE(1391);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[1];
        if (i.num < 1 || i.num > T_2_1.str->size) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_2.ch = T_2_1.str->data[i.num - 1];
        c.num = T_2_2.num;
        }

  LINE(1392);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_2.ch = ' ';
        err = charOPge(c, T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.num = T_2_3.num;
        if (T_2_3.num) {
            T_2_4.ch = '\177';
            err = charOPlt(c, T_2_4, &T_2_5);
            if (err != ERR_ok)
                goto ex_0;
            T_2_1.num = T_2_5.num;
        }
        if (T_2_1.num == true) { /* if */

  LINE(1393);
            {
            CLUREF T_3_1;
            T_3_1.num = pos.num + 1;
            if ((T_3_1.num > 0 && pos.num < 0 && 1 < 0) ||
                (T_3_1.num < 0 && pos.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            pos.num = T_3_1.num;
            }
        }
        else {

  LINE(1394);
        CLUREF T_2_6;
        CLUREF T_2_7;
        T_2_6.ch = '\t';
        T_2_7.num = (c.ch == T_2_6.ch);
        if (T_2_7.num == true) { /* elseif */

  LINE(1395);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = pos.num + 8;
            if ((T_3_1.num > 0 && pos.num < 0 && 8 < 0) ||
                (T_3_1.num < 0 && pos.num > 0 && 8 > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            err = intOPmod(pos, CLU_8, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            T_3_3.num = T_3_1.num - T_3_2.num;
            if ((T_3_3.num >= 0 && T_3_1.num < 0 && (-T_3_2.num) < 0) ||
                (T_3_3.num <= 0 && T_3_1.num > 0 && (-T_3_2.num) > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            pos.num = T_3_3.num;
            }
        }
        else {

  LINE(1396);
        CLUREF T_2_8;
        CLUREF T_2_9;
        CLUREF T_2_10;
        CLUREF T_2_11;
        CLUREF T_2_12;
        T_2_9.ch = '\034';
        T_2_10.num = (c.ch == T_2_9.ch);
        T_2_8.num = T_2_10.num;
        if (!T_2_10.num) {
            T_2_11.ch = '\n';
            T_2_12.num = (c.ch == T_2_11.ch);
            T_2_8.num = T_2_12.num;
        }
        if (T_2_8.num == true) { /* elseif */

  LINE(1397);
            {
            pos.num = 0;
            }
        }
        else { /* else */

  LINE(1398);
            {
            CLUREF T_3_1;
            T_3_1.num = pos.num + 2;
            if ((T_3_1.num > 0 && pos.num < 0 && 2 < 0) ||
                (T_3_1.num < 0 && pos.num > 0 && 2 > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            pos.num = T_3_1.num;
            }
        }}}} /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(1400);
    { /* return */
    {
    ret_1->num = pos.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE calc_pos ****/


/**** BEGIN PROCEDURE display ****/

static int streamOPdisplay_own_init = 0;

errcode
streamOPdisplay(CLUREF st, CLUREF s, CLUREF *ret_1)
{
    errcode err;
    CLUREF tb;
    if (streamOPdisplay_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPdisplay_own_init = 1;
    }
    enter_proc(1403);

  LINE(1405);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 6: /* tty */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        tb.num = T_2_2.num;

  LINE(1407);
        {
        err = streamOPflush(st);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(1408);
        { /* return */
        {
        CLUREF T_3_1;
        err = streamOPttydsp(tb, s, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        ret_1->num = T_3_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 7: /* write */ /* FALLTHROUGH */
    case 3: /* nul */ /* FALLTHROUGH */
    case 4: /* ostr */ {

  LINE(1410);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(1412);
        { /* signal */
            elist[0] = STR_cannot_040write_040to_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE display ****/


/**** BEGIN PROCEDURE modify_display ****/

static int streamOPmodify_display_own_init = 0;

errcode
streamOPmodify_display(CLUREF st, CLUREF term)
{
    errcode err;
    CLUREF tb;
    if (streamOPmodify_display_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPmodify_display_own_init = 1;
    }
    enter_proc(1416);

  LINE(1417);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: /* tty */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1419);
        {
        tb.vec->data[6] = false;
        }

  LINE(1420);
        {
        tb.vec->data[0] = CLU_empty_string.num;
        }

  LINE(1421);
        {
        tb.vec->data[12] = CLU_empty_string.num;
        }

  LINE(1422);
        {
        tb.vec->data[3] = CLU_empty_string.num;
        }

  LINE(1423);
        {
        err = streamOPtermcap(tb, term);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    default: {

  LINE(1425);
        { /* signal */
            elist[0] = STR_not_040a_040terminal_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE modify_display ****/


/**** BEGIN PROCEDURE ttydsp ****/


errcode
streamOPttydsp(CLUREF tb, CLUREF s, CLUREF *ret_1)
{
    errcode err;
    CLUREF ch;
    CLUREF i;
    CLUREF max;
    CLUREF c;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1429);

  LINE(1430);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[6];
    T_1_2.num = !T_1_1.num;
    if (T_1_2.num == true) { /* if */

  LINE(1431);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(1432);
    {
    CLUREF T_1_1;
    T_1_1.num = tb.vec->data[2];
    ch.num = T_1_1.num;
    }

  LINE(1433);
    {
    i.num = 1;
    }

  LINE(1434);
    {
    CLUREF T_1_1;
    err = stringOPsize(s, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    max.num = T_1_1.num;
    }

  LINE(1435);
    for (;;) { /* while */
        CLUREF T_2_1;
        T_2_1.num = (i.num <= max.num);
        if (T_2_1.num != true)
            break;

  LINE(1436);
        {
        CLUREF T_3_1;
        err = stringOPfetch(s, i, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        c.num = T_3_1.num;
        }

  LINE(1437);
        {
        CLUREF T_3_1;
        T_3_1.num = i.num + 1;
        if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) ||
            (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        i.num = T_3_1.num;
        }

  LINE(1438);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        T_3_2.ch = '\020';
        T_3_3.num = (c.ch == T_3_2.ch);
        T_3_1.num = T_3_3.num;
        if (T_3_3.num) {
            T_3_4.num = (i.num <= max.num);
            T_3_1.num = T_3_4.num;
        }
        T_3_5.num = !T_3_1.num;
        if (T_3_5.num == true) { /* if */

  LINE(1439);
            {
            err = _chanOPputc(ch, c, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }

  LINE(1440);
            continue;
        }
        } /* end if */

  LINE(1442);
        {
        CLUREF T_3_1;
        err = stringOPfetch(s, i, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        c.num = T_3_1.num;
        }

  LINE(1443);
        {
        CLUREF T_3_1;
        T_3_1.num = i.num + 1;
        if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) ||
            (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        i.num = T_3_1.num;
        }

  LINE(1444);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.ch = 'C';
        T_3_2.num = (c.ch == T_3_1.ch);
        if (T_3_2.num == true) { /* if */

  LINE(1445);
            {
            CLUREF T_4_1;
            T_4_1.num = tb.vec->data[3];
            err = _chanOPputs(ch, T_4_1, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        else {

  LINE(1446);
        CLUREF T_3_3;
        CLUREF T_3_4;
        T_3_3.ch = 'B';
        T_3_4.num = (c.ch == T_3_3.ch);
        if (T_3_4.num == true) { /* elseif */

  LINE(1447);
            {
            CLUREF T_4_1;
            T_4_1.num = tb.vec->data[0];
            err = _chanOPputs(ch, T_4_1, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        else {

  LINE(1448);
        CLUREF T_3_5;
        CLUREF T_3_6;
        T_3_5.ch = 'L';
        T_3_6.num = (c.ch == T_3_5.ch);
        if (T_3_6.num == true) { /* elseif */

  LINE(1449);
            {
            CLUREF T_4_1;
            T_4_1.num = tb.vec->data[12];
            err = _chanOPputs(ch, T_4_1, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        else { /* else */

  LINE(1450);
            {
            CLUREF T_4_1;
            T_4_1.ch = '\020';
            err = _chanOPputc(ch, T_4_1, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }

  LINE(1451);
            {
            err = _chanOPputc(ch, c, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }
        }}}} /* end if */
    }
    end_while_1:
    __CLU_END_LABEL;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible) {

  LINE(1453);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(1454);
    { /* return */
    {
    ret_1->tf = true;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE ttydsp ****/


/**** BEGIN PROCEDURE get_prompt ****/

static int streamOPget_prompt_own_init = 0;

errcode
streamOPget_prompt(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF tb;
    if (streamOPget_prompt_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPget_prompt_own_init = 1;
    }
    enter_proc(1457);

  LINE(1458);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: /* tty */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1460);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[17];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(1462);
        { /* return */
        {
        ret_1->str = CLU_empty_string.str;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_prompt ****/


/**** BEGIN PROCEDURE set_prompt ****/


errcode
streamOPset_prompt(CLUREF st, CLUREF prompt)
{
    errcode err;
    CLUREF tb;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1466);

  LINE(1467);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: /* tty */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1469);
        {
        tb.vec->data[17] = prompt.num;
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_prompt ****/


/**** BEGIN PROCEDURE get_rescan ****/

static int streamOPget_rescan_own_init = 0;

errcode
streamOPget_rescan(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF tb;
    CLUREF s;
    if (streamOPget_rescan_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPget_rescan_own_init = 1;
    }
    enter_proc(1474);

  LINE(1475);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: /* tty */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1477);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[18];
        err = stringOPac2s(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        s.num = T_2_2.num;
        }

  LINE(1478);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[5];
        if (T_2_1.num == true) { /* if */

  LINE(1479);
            {
            CLUREF T_3_1;
            err = stringOPrest(s, CLU_2, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            s.num = T_3_1.num;
            }
        }
        } /* end if */

  LINE(1480);
        { /* return */
        {
        ret_1->num = s.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(1482);
        { /* return */
        {
        ret_1->str = CLU_empty_string.str;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_rescan ****/


/**** BEGIN PROCEDURE set_rescan ****/

static int streamOPset_rescan_own_init = 0;

errcode
streamOPset_rescan(CLUREF st, CLUREF s)
{
    errcode err;
    CLUREF tb;
    CLUREF scan;
    if (streamOPset_rescan_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPset_rescan_own_init = 1;
    }
    enter_proc(1486);

  LINE(1487);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: /* tty */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1489);
        {
        CLUREF T_2_1;
        err = stringOPs2ac(s, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        scan.num = T_2_1.num;
        }

  LINE(1490);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[5];
        if (T_2_1.num == true) { /* if */

  LINE(1491);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = tb.vec->data[18];
            err = arrayOPbottom(T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            err = arrayOPaddl(scan, T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        } /* end if */

  LINE(1492);
        {
        tb.vec->data[18] = scan.num;
        }
        break;
    }
    default: {

  LINE(1494);
        { /* signal */
            elist[0] = STR_cannot_040rescan_040on_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_rescan ****/


/**** BEGIN PROCEDURE get_input_buffered ****/


errcode
streamOPget_input_buffered(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF tb;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1498);

  LINE(1499);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 3: /* nul */ {

  LINE(1501);
        { /* return */
        {
        ret_1->tf = true;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1503);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[9];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 7: /* write */ /* FALLTHROUGH */
    case 4: /* ostr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(1505);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_input_buffered ****/


/**** BEGIN PROCEDURE set_input_buffered ****/

static int streamOPset_input_buffered_own_init = 0;

errcode
streamOPset_input_buffered(CLUREF st, CLUREF flag)
{
    errcode err;
    CLUREF tb;
    if (streamOPset_input_buffered_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPset_input_buffered_own_init = 1;
    }
    enter_proc(1509);

  LINE(1510);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 3: /* nul */ {

  LINE(1512);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = !flag.num;
        if (T_2_1.num == true) { /* if */

  LINE(1513);
            { /* signal */
                elist[0] = STR_input_040is_040always_040buffered;
                signal(ERR_not_possible);
            }
        }
        } /* end if */
        break;
    }
    case 6: /* tty */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1515);
        {
        tb.vec->data[9] = flag.num;
        }
        break;
    }
    case 7: /* write */ /* FALLTHROUGH */
    case 4: /* ostr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(1517);
        { /* signal */
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_input_buffered ****/


/**** BEGIN PROCEDURE get_output_buffered ****/


errcode
streamOPget_output_buffered(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF wb;
    CLUREF tb;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1521);

  LINE(1522);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 7: /* write */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        wb.num = T_1_2.num;

  LINE(1524);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = wb.vec->data[3];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        tb.num = T_1_3.num;

  LINE(1526);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[15];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 4: /* ostr */ /* FALLTHROUGH */
    case 3: /* nul */ {

  LINE(1528);
        { /* return */
        {
        ret_1->tf = true;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(1530);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_output_buffered ****/


/**** BEGIN PROCEDURE set_output_buffered ****/

static int streamOPset_output_buffered_own_init = 0;

errcode
streamOPset_output_buffered(CLUREF st, CLUREF flag)
{
    errcode err;
    CLUREF wb;
    CLUREF tb;
    if (streamOPset_output_buffered_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPset_output_buffered_own_init = 1;
    }
    enter_proc(1534);

  LINE(1535);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 7: /* write */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(1537);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        T_3_2.num = !flag.num;
        T_3_1.num = T_3_2.num;
        if (T_3_2.num) {
            T_3_3.num = wb.vec->data[3];
            T_3_1.num = T_3_3.num;
        }
        if (T_3_1.num == true) { /* if */

  LINE(1538);
            {
            err = streamOPflush(st);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        } /* end if */

  LINE(1539);
        {
        wb.vec->data[3] = flag.num;
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(1541);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        T_3_2.num = !flag.num;
        T_3_1.num = T_3_2.num;
        if (T_3_2.num) {
            T_3_3.num = tb.vec->data[15];
            T_3_1.num = T_3_3.num;
        }
        if (T_3_1.num == true) { /* if */

  LINE(1542);
            {
            err = streamOPflush(st);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        } /* end if */

  LINE(1543);
        {
        tb.vec->data[15] = flag.num;
        }
        break;
    }
    case 4: /* ostr */ /* FALLTHROUGH */
    case 3: /* nul */ {

  LINE(1545);
        { /* signal */
            elist[0] = STR_output_040is_040always_040buffered;
            signal(ERR_not_possible);
        }
        break;
    }
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(1547);
        { /* signal */
            elist[0] = STR_cannot_040write_040to_040this_040stream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_output_buffered ****/


/**** BEGIN PROCEDURE get_eof_flag ****/


errcode
streamOPget_eof_flag(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF tb;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1551);

  LINE(1552);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: /* tty */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1554);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[8];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(1556);
        { /* return */
        {
        ret_1->tf = true;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(1558);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_eof_flag ****/


/**** BEGIN PROCEDURE set_eof_flag ****/

static int streamOPset_eof_flag_own_init = 0;

errcode
streamOPset_eof_flag(CLUREF st, CLUREF eofok)
{
    errcode err;
    CLUREF tb;
    if (streamOPset_eof_flag_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPset_eof_flag_own_init = 1;
    }
    enter_proc(1562);

  LINE(1563);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: /* tty */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1565);
        {
        tb.vec->data[8] = eofok.num;
        }
        break;
    }
    case 5: /* read */ /* FALLTHROUGH */
    case 2: /* istr */ /* FALLTHROUGH */
    case 1: /* closed */ {

  LINE(1567);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = !eofok.num;
        if (T_2_1.num == true) { /* if */

  LINE(1568);
            { /* signal */
                elist[0] = STR_cannot_040disable_040eof_040on_040this_040stream;
                signal(ERR_not_possible);
            }
        }
        } /* end if */
        break;
    }
    default: {

  LINE(1571);
        { /* if */
        if (eofok.num == true) { /* if */

  LINE(1572);
            { /* signal */
                elist[0] = STR_cannot_040enable_040eof_040on_040this_040stream;
                signal(ERR_not_possible);
            }
        }
        } /* end if */
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_eof_flag ****/


/**** BEGIN PROCEDURE equal ****/


errcode
streamOPequal(CLUREF x, CLUREF y, CLUREF *ret_1)
{
    errcode err;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1577);

  LINE(1578);
    { /* return */
    {
    CLUREF T_1_1;
    T_1_1.num = (x.num == y.num);
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE equal ****/


/**** BEGIN PROCEDURE similar ****/


errcode
streamOPsimilar(CLUREF x, CLUREF y, CLUREF *ret_1)
{
    errcode err;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1581);

  LINE(1582);
    { /* return */
    {
    CLUREF T_1_1;
    T_1_1.num = (x.num == y.num);
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE similar ****/


/**** BEGIN PROCEDURE copy ****/


errcode
streamOPcopy(CLUREF x, CLUREF *ret_1)
{
    errcode err;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1585);

  LINE(1586);
    { /* return */
    {
    ret_1->num = x.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE copy ****/


/**** BEGIN PROCEDURE print ****/

static int streamOPprint_own_init = 0;

errcode
streamOPprint(CLUREF x, CLUREF ps)
{
    errcode err;
    if (streamOPprint_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPprint_own_init = 1;
    }
    enter_proc(1589);

  LINE(1590);
    {
    CLUREF T_1_1;
    err = pstreamOPtext(ps, STR_stream_133, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(1591);
    { /* if */
    CLUREF T_1_1;
    err = streamOPcan_read(x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_1.num == true) { /* if */

  LINE(1592);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.ch = 'R';
        err = pstreamOPtextc(ps, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(1593);
    { /* if */
    CLUREF T_1_1;
    err = streamOPcan_write(x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_1.num == true) { /* if */

  LINE(1594);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.ch = 'W';
        err = pstreamOPtextc(ps, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(1595);
    { /* if */
    CLUREF T_1_1;
    err = streamOPis_closed(x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_1.num == true) { /* if */

  LINE(1596);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.ch = 'C';
        err = pstreamOPtextc(ps, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(1597);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = ' ';
    err = pstreamOPtextc(ps, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(1598);
    {
    CLUREF T_2_1;
    err = streamOPget_name(x, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    err = file_nameOPprint(T_2_1, ps);
    if (err != ERR_ok)
        goto ex_1;
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible) {

  LINE(1599);
        {
        CLUREF T_2_1;
        err = pstreamOPtext(ps, STR__050internal_051, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(1600);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = ']';
    err = pstreamOPtextc(ps, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE print ****/


/**** BEGIN PROCEDURE get_chan ****/

static int streamOPget_chan_own_init = 0;

errcode
streamOPget_chan(CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF rb;
    CLUREF wb;
    CLUREF tb;
    if (streamOPget_chan_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        streamOPget_chan_own_init = 1;
    }
    enter_proc(1603);

  LINE(1604);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: /* read */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        rb.num = T_1_2.num;

  LINE(1606);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = rb.vec->data[1];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 7: /* write */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        wb.num = T_1_3.num;

  LINE(1608);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = wb.vec->data[1];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 6: /* tty */ {
        CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        tb.num = T_1_4.num;

  LINE(1610);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[2];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(1612);
        { /* signal */
            elist[0] = STR_does_040not_040contain_040a_040_137chan;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_chan ****/


/**** BEGIN ITERATOR _open_streams ****/


errcode
streamOP_open_streams(errcode (*proc)(), void *user_locals, errcode *iecode)
{
    errcode ecode __CLU_UNUSED;
    errcode err;
    CLUREF s;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1616);

  LINE(1617);
    { /* for array$elements */
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    CLUREF T_2_4;
    err = streamOPopen_streams(&T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    T_2_3.num = T_2_1.array->ext_high;
    T_2_4 = T_2_1;
    for (T_2_2.num = T_2_1.array->ext_low; T_2_2.num <= T_2_3.num; T_2_2.num++) {
        if (T_2_2.num > T_2_4.array->ext_high || T_2_2.num < T_2_4.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_1;
        }
        s.num = T_2_4.array->store->data[T_2_2.num - T_2_4.array->ext_low + T_2_4.array->int_low];

  LINE(1618);
        { /* yield */
        err = (*proc)(s, user_locals, iecode);
        if (err != ERR_ok) {
            signal(err);
        }
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_bounds) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END ITERATOR _open_streams ****/


/**** BEGIN PROCEDURE _close_all ****/


errcode
streamOP_close_all(void)
{
    errcode err;
    CLUREF opens;
    CLUREF st;
    CLUREF i;
    if (stream_own_init == 0) {
        err = stream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(1622);

  LINE(1623);
    {
    CLUREF T_1_1;
    err = streamOPopen_streams(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    opens.num = T_1_1.num;
    }

  LINE(1624);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = opens.array->ext_high;
    T_1_3 = opens;
    for (T_1_1.num = opens.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        st.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(1625);
        {
        err = streamOPflush(st);
        if (err != ERR_ok)
            goto ex_1;
        }
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_not_possible) {
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(1628);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = opens.array->ext_high;
    T_1_3 = opens;
    for (T_1_1.num = opens.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        st.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(1629);
        {
        CLUREF T_2_1;
        err = sequenceOPnew(&T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        st.vec->data[3] = T_2_1.num;
        }

  LINE(1630);
        {
        st.vec->data[2] = false;
        }
    }
    }
    end_inline_for_2:
    __CLU_END_LABEL;

  LINE(1632);
    {
    i.num = 1;
    }

  LINE(1633);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(1634);
        {
        CLUREF T_3_1;
        if (i.num < opens.array->ext_low || i.num > opens.array->ext_high) {
            err = ERR_bounds;
            goto ex_2;
        }
        T_3_1.num = opens.array->store->data[i.num - opens.array->ext_low + opens.array->int_low];
        st.num = T_3_1.num;
        }

  LINE(1635);
        {
        err = streamOPclose(st);
        if (err != ERR_ok)
            goto ex_3;
        }
        goto end_3;
      ex_3: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_not_possible) {

  LINE(1636);
            {
            err = streamOPabort(st);
            if (err != ERR_ok)
                goto ex_2;
            }
        }
        else { /* not handled */
            goto ex_2;
        }
      end_3:;

  LINE(1637);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        if (i.num < opens.array->ext_low || i.num > opens.array->ext_high) {
            err = ERR_bounds;
            goto ex_2;
        }
        T_3_1.num = opens.array->store->data[i.num - opens.array->ext_low + opens.array->int_low];
        err = streamOPequal(st, T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_2;
        if (T_3_2.num == true) { /* if */

  LINE(1638);
            {
            CLUREF T_4_1;
            T_4_1.num = i.num + 1;
            if ((T_4_1.num > 0 && i.num < 0 && 1 < 0) ||
                (T_4_1.num < 0 && i.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_2;
            }
            i.num = T_4_1.num;
            }
        }
        } /* end if */
    }
    end_while_1:
    __CLU_END_LABEL;
    goto end_2;
  ex_2: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_bounds) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_2:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE _close_all ****/

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[62];
} stream_OPS;

static CLU_proc stream_oe__close_all = { .proc = streamOP_close_all };
static CLU_proc stream_oe__open_streams = { .proc = streamOP_open_streams };
static CLU_proc stream_oe_abort = { .proc = streamOPabort };
static CLU_proc stream_oe_add_script = { .proc = streamOPadd_script };
static CLU_proc stream_oe_can_read = { .proc = streamOPcan_read };
static CLU_proc stream_oe_can_write = { .proc = streamOPcan_write };
static CLU_proc stream_oe_close = { .proc = streamOPclose };
static CLU_proc stream_oe_copy = { .proc = streamOPcopy };
static CLU_proc stream_oe_create_input = { .proc = streamOPcreate_input };
static CLU_proc stream_oe_create_output = { .proc = streamOPcreate_output };
static CLU_proc stream_oe_display = { .proc = streamOPdisplay };
static CLU_proc stream_oe_empty = { .proc = streamOPempty };
static CLU_proc stream_oe_equal = { .proc = streamOPequal };
static CLU_proc stream_oe_error_output = { .proc = streamOPerror_output };
static CLU_proc stream_oe_flush = { .proc = streamOPflush };
static CLU_proc stream_oe_get_contents = { .proc = streamOPget_contents };
static CLU_proc stream_oe_get_date = { .proc = streamOPget_date };
static CLU_proc stream_oe_get_eof_flag = { .proc = streamOPget_eof_flag };
static CLU_proc stream_oe_get_input_buffered = { .proc = streamOPget_input_buffered };
static CLU_proc stream_oe_get_line_length = { .proc = streamOPget_line_length };
static CLU_proc stream_oe_get_lineno = { .proc = streamOPget_lineno };
static CLU_proc stream_oe_get_name = { .proc = streamOPget_name };
static CLU_proc stream_oe_get_output_buffered = { .proc = streamOPget_output_buffered };
static CLU_proc stream_oe_get_page_length = { .proc = streamOPget_page_length };
static CLU_proc stream_oe_get_prompt = { .proc = streamOPget_prompt };
static CLU_proc stream_oe_get_rescan = { .proc = streamOPget_rescan };
static CLU_proc stream_oe_getbuf = { .proc = streamOPgetbuf };
static CLU_proc stream_oe_getc = { .proc = streamOPgetc };
static CLU_proc stream_oe_getc_image = { .proc = streamOPgetc_image };
static CLU_proc stream_oe_getl = { .proc = streamOPgetl };
static CLU_proc stream_oe_gets = { .proc = streamOPgets };
static CLU_proc stream_oe_gets_image = { .proc = streamOPgets_image };
static CLU_proc stream_oe_is_closed = { .proc = streamOPis_closed };
static CLU_proc stream_oe_is_terminal = { .proc = streamOPis_terminal };
static CLU_proc stream_oe_modify_display = { .proc = streamOPmodify_display };
static CLU_proc stream_oe_open = { .proc = streamOPopen };
static CLU_proc stream_oe_peekc = { .proc = streamOPpeekc };
static CLU_proc stream_oe_pending = { .proc = streamOPpending };
static CLU_proc stream_oe_primary_input = { .proc = streamOPprimary_input };
static CLU_proc stream_oe_primary_output = { .proc = streamOPprimary_output };
static CLU_proc stream_oe_print = { .proc = streamOPprint };
static CLU_proc stream_oe_putc = { .proc = streamOPputc };
static CLU_proc stream_oe_putc_image = { .proc = streamOPputc_image };
static CLU_proc stream_oe_putl = { .proc = streamOPputl };
static CLU_proc stream_oe_putleft = { .proc = streamOPputleft };
static CLU_proc stream_oe_putright = { .proc = streamOPputright };
static CLU_proc stream_oe_puts = { .proc = streamOPputs };
static CLU_proc stream_oe_puts_image = { .proc = streamOPputs_image };
static CLU_proc stream_oe_putspace = { .proc = streamOPputspace };
static CLU_proc stream_oe_putzero = { .proc = streamOPputzero };
static CLU_proc stream_oe_rem_script = { .proc = streamOPrem_script };
static CLU_proc stream_oe_reset = { .proc = streamOPreset };
static CLU_proc stream_oe_scripts = { .proc = streamOPscripts };
static CLU_proc stream_oe_set_date = { .proc = streamOPset_date };
static CLU_proc stream_oe_set_eof_flag = { .proc = streamOPset_eof_flag };
static CLU_proc stream_oe_set_input_buffered = { .proc = streamOPset_input_buffered };
static CLU_proc stream_oe_set_lineno = { .proc = streamOPset_lineno };
static CLU_proc stream_oe_set_output_buffered = { .proc = streamOPset_output_buffered };
static CLU_proc stream_oe_set_prompt = { .proc = streamOPset_prompt };
static CLU_proc stream_oe_set_rescan = { .proc = streamOPset_rescan };
static CLU_proc stream_oe_similar = { .proc = streamOPsimilar };
static CLU_proc stream_oe_unscript = { .proc = streamOPunscript };

static stream_OPS stream_ops_actual = {62, (OWNPTR)&stream_own_init, (OWNPTR)&stream_own_init, {
    {&stream_oe__close_all, "_close_all"},
    {&stream_oe__open_streams, "_open_streams"},
    {&stream_oe_abort, "abort"},
    {&stream_oe_add_script, "add_script"},
    {&stream_oe_can_read, "can_read"},
    {&stream_oe_can_write, "can_write"},
    {&stream_oe_close, "close"},
    {&stream_oe_copy, "copy"},
    {&stream_oe_create_input, "create_input"},
    {&stream_oe_create_output, "create_output"},
    {&stream_oe_display, "display"},
    {&stream_oe_empty, "empty"},
    {&stream_oe_equal, "equal"},
    {&stream_oe_error_output, "error_output"},
    {&stream_oe_flush, "flush"},
    {&stream_oe_get_contents, "get_contents"},
    {&stream_oe_get_date, "get_date"},
    {&stream_oe_get_eof_flag, "get_eof_flag"},
    {&stream_oe_get_input_buffered, "get_input_buffered"},
    {&stream_oe_get_line_length, "get_line_length"},
    {&stream_oe_get_lineno, "get_lineno"},
    {&stream_oe_get_name, "get_name"},
    {&stream_oe_get_output_buffered, "get_output_buffered"},
    {&stream_oe_get_page_length, "get_page_length"},
    {&stream_oe_get_prompt, "get_prompt"},
    {&stream_oe_get_rescan, "get_rescan"},
    {&stream_oe_getbuf, "getbuf"},
    {&stream_oe_getc, "getc"},
    {&stream_oe_getc_image, "getc_image"},
    {&stream_oe_getl, "getl"},
    {&stream_oe_gets, "gets"},
    {&stream_oe_gets_image, "gets_image"},
    {&stream_oe_is_closed, "is_closed"},
    {&stream_oe_is_terminal, "is_terminal"},
    {&stream_oe_modify_display, "modify_display"},
    {&stream_oe_open, "open"},
    {&stream_oe_peekc, "peekc"},
    {&stream_oe_pending, "pending"},
    {&stream_oe_primary_input, "primary_input"},
    {&stream_oe_primary_output, "primary_output"},
    {&stream_oe_print, "print"},
    {&stream_oe_putc, "putc"},
    {&stream_oe_putc_image, "putc_image"},
    {&stream_oe_putl, "putl"},
    {&stream_oe_putleft, "putleft"},
    {&stream_oe_putright, "putright"},
    {&stream_oe_puts, "puts"},
    {&stream_oe_puts_image, "puts_image"},
    {&stream_oe_putspace, "putspace"},
    {&stream_oe_putzero, "putzero"},
    {&stream_oe_rem_script, "rem_script"},
    {&stream_oe_reset, "reset"},
    {&stream_oe_scripts, "scripts"},
    {&stream_oe_set_date, "set_date"},
    {&stream_oe_set_eof_flag, "set_eof_flag"},
    {&stream_oe_set_input_buffered, "set_input_buffered"},
    {&stream_oe_set_lineno, "set_lineno"},
    {&stream_oe_set_output_buffered, "set_output_buffered"},
    {&stream_oe_set_prompt, "set_prompt"},
    {&stream_oe_set_rescan, "set_rescan"},
    {&stream_oe_similar, "similar"},
    {&stream_oe_unscript, "unscript"}}};

struct OPS *stream_ops = (struct OPS *)&stream_ops_actual;

/**** END CLUSTER stream ****/
