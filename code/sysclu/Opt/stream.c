
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"

/**** BEGIN CLUSTER stream ****/

extern errcode stringOPequal();
extern errcode boolOPnot();
extern errcode file_nameOPget_dir();
extern errcode stringOPempty();
extern errcode file_nameOPget_suffix();
extern errcode file_nameOPget_other();
extern errcode file_nameOPget_name();
extern errcode streamOPprimary_input();
extern errcode streamOPprimary_output();
extern errcode streamOPerror_output();
extern errcode sequenceOPnew();
extern errcode oneofOPmake_3();
extern errcode arrayOPaddh();
extern errcode streamOPopen_streams();
extern errcode _chanOPopen();
extern errcode _bytevecOPcreate();
extern errcode _chanOPis_tty();
extern errcode _chanOPclose();
extern errcode arrayOPnew();
extern errcode oneofOPmake_6();
extern errcode streamOPtermcap();
extern errcode oneofOPmake_5();
extern errcode oneofOPmake_7();
extern errcode _chanOPget_name();
extern errcode streamOPget_prims();
extern errcode _chanOPerror_output();
extern errcode _chanOPprimary_input();
extern errcode _chanOPprimary_output();
extern errcode _chanOPequal();
extern errcode _get_termcap();
extern errcode recordOPset_15();
extern errcode intOPparse();
extern errcode _termcap();
extern errcode recordOPset_17();
extern errcode intOPgt();
extern errcode stringOPindexs();
extern errcode _chanOPget_speeds();
extern errcode recordOPget_3();
extern errcode recordOPset_1();
extern errcode recordOPset_13();
extern errcode recordOPget_1();
extern errcode intOPequal();
extern errcode stringOPconcat();
extern errcode stringOPappend();
extern errcode recordOPset_4();
extern errcode recordOPget_17();
extern errcode recordOPget_13();
extern errcode recordOPget_4();
extern errcode recordOPset_7();
extern errcode streamOPall_scripts();
extern errcode recordOPequal();
extern errcode sequenceOPaddh();
extern errcode recordOPset_3();
extern errcode sequenceOPelements();
extern errcode sequenceOPindexes();
extern errcode streamOPequal();
extern errcode sequenceOPfetch();
extern errcode sequenceOPconcat();
extern errcode sequenceOPsubseq();
extern errcode intOPsub();
extern errcode intOPadd();
extern errcode sequenceOPsize();
extern errcode sequenceOPempty();
extern errcode recordOPget_5();
extern errcode recordOPset_5();
extern errcode _chanOPgetb();
extern errcode recordOPget_2();
extern errcode _bytevecOPfetch();
extern errcode charOPequal();
extern errcode streamOPflush();
extern errcode streamOPtty_get1();
extern errcode streamOPtty_put1();
extern errcode stringOPfetch();
extern errcode recordOPset_2();
extern errcode streamOPscript();
extern errcode stringOPc2s();
extern errcode recordOPget_8();
extern errcode recordOPget_9();
extern errcode arrayOPempty();
extern errcode recordOPget_19();
extern errcode _chanOPgetc();
extern errcode recordOPset_8();
extern errcode recordOPset_6();
extern errcode arrayOPbottom();
extern errcode _chanOPpending();
extern errcode streamOPempty();
extern errcode streamOPpeekc();
extern errcode stringOPsize();
extern errcode _chanOPput();
extern errcode _chanOPputc();
extern errcode streamOPtty_put();
extern errcode recordOPget_14();
extern errcode _chanOPreset();
extern errcode recordOPset_12();
extern errcode arrayOPset_low();
extern errcode arrayOPtrim();
extern errcode recordOPset_14();
extern errcode _chanOPputb();
extern errcode recordOPget_12();
extern errcode recordOPget_11();
extern errcode recordOPset_11();
extern errcode recordOPget_15();
extern errcode _chanOPget_date();
extern errcode oneofOPmake_1();
extern errcode arrayOPindexes();
extern errcode arrayOPfetch();
extern errcode arrayOPstore();
extern errcode arrayOPremh();
extern errcode _chanOPabort();
extern errcode oneofOPis_1();
extern errcode oneofOPis_6();
extern errcode streamOPgets();
extern errcode arrayOPreml();
extern errcode recordOPget_6();
extern errcode streamOPputs();
extern errcode streamOPputc();
extern errcode _chanOPget();
extern errcode stringOPindexc();
extern errcode streamOPlines();
extern errcode recordOPget_10();
extern errcode recordOPget_18();
extern errcode streamOPedit();
extern errcode streamOPtty_get();
extern errcode streamOPstr_get();
extern errcode streamOPecho();
extern errcode arrayOPaddl();
extern errcode stringOPac2s();
extern errcode stringOPsubstr();
extern errcode stringOPrest();
extern errcode stringOPchars();
extern errcode _chanOPputs();
extern errcode _bytevecOPstore();
extern errcode boolOPequal();
extern errcode recordOPget_16();
extern errcode intOPlt();
extern errcode charOPge();
extern errcode charOPle();
extern errcode streamOPputspace();
extern errcode file_nameOPparse();
extern errcode oneofOPmake_2();
extern errcode oneofOPmake_4();
extern errcode _bytevecOPindexc();
extern errcode _cvt();
extern errcode streamOPputs_image();
extern errcode _eventOPdefer();
extern errcode _bytevecOPmove_lr();
extern errcode streamOPrubout();
extern errcode streamOPerase();
extern errcode intOPfrom_to();
extern errcode _eventOPundefer();
extern errcode charOPc2i();
extern errcode _chanOPputi();
extern errcode intOPmod();
extern errcode intOPle();
extern errcode recordOPget_7();
extern errcode charOPlt();
extern errcode streamOPcalc_pos();
extern errcode intOPfrom_to_by();
extern errcode streamOPttydsp();
extern errcode recordOPset_18();
extern errcode stringOPs2ac();
extern errcode recordOPset_19();
extern errcode recordOPset_10();
extern errcode recordOPset_16();
extern errcode recordOPset_9();
extern errcode pstreamOPtext();
extern errcode streamOPcan_read();
extern errcode pstreamOPtextc();
extern errcode streamOPcan_write();
extern errcode streamOPis_closed();
extern errcode file_nameOPprint();
extern errcode streamOPget_name();
extern errcode arrayOPelements();
extern errcode streamOPclose();
extern errcode streamOPabort();
extern errcode stream_IB_1();
extern errcode stream_IB_2();
extern errcode stream_IB_3();
extern errcode stream_IB_4();
extern errcode stream_IB_5();
extern errcode stream_IB_6();
CLUREF STR_read;
CLUREF STR_write;
CLUREF STR_append;
CLUREF STR_bad_040access_040mode;
CLUREF STR__057dev;
CLUREF STR_p;
CLUREF STR_e;
CLUREF STR_cannot_040read_040from_040this_040stream;
CLUREF STR_null;
CLUREF STR_tty;
CLUREF STR_modify;
CLUREF STR_;
CLUREF STR__072co_043;
CLUREF STR__072li_043;
CLUREF STR__072hc_072;
CLUREF STR__072bs_072;
CLUREF STR__010;
CLUREF STR__072bc_075;
CLUREF STR__072kb_075;
CLUREF STR__072ce_075;
CLUREF STR__072os_072;
CLUREF STR__072eo_072;
CLUREF STR__072cl_075;
CLUREF STR__012;
CLUREF STR_cannot_040write_040to_040this_040stream;
CLUREF STR_no_040line_040numbers;
CLUREF STR_cannot_040get_040date;
CLUREF STR_cannot_040set_040date;
CLUREF STR_no_040name_040for_040string_040stream;
CLUREF STR_not_040a_040string_040output_040stream;
CLUREF STR__136_077;
CLUREF STR_not_040a_040terminal_040stream;
CLUREF STR_cannot_040rescan_040on_040this_040stream;
CLUREF STR_input_040is_040always_040buffered;
CLUREF STR_output_040is_040always_040buffered;
CLUREF STR_cannot_040disable_040eof_040on_040this_040stream;
CLUREF STR_cannot_040enable_040eof_040on_040this_040stream;
CLUREF STR_stream_133;
CLUREF STR__050internal_051;
CLUREF STR_does_040not_040contain_040a_040_137chan;
static int stream_own_init = 0;
OWN_req stream_ownreqs = {0,0};
CLUREF streamOPfree;
CLUREF streamOPfreebuf;
errcode stream_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (stream_own_init == 0) {
        stringOPcons("read", CLU_1, CLU_4, &STR_read);
        stringOPcons("write", CLU_1, CLU_5, &STR_write);
        stringOPcons("append", CLU_1, CLU_6, &STR_append);
        stringOPcons("bad access mode", CLU_1, CLU_15, &STR_bad_040access_040mode);
        stringOPcons("/dev", CLU_1, CLU_4, &STR__057dev);
        stringOPcons("p", CLU_1, CLU_1, &STR_p);
        stringOPcons("e", CLU_1, CLU_1, &STR_e);
        stringOPcons("cannot read from this stream", CLU_1, CLU_28, &STR_cannot_040read_040from_040this_040stream);
        stringOPcons("null", CLU_1, CLU_4, &STR_null);
        stringOPcons("tty", CLU_1, CLU_3, &STR_tty);
        stringOPcons("modify", CLU_1, CLU_6, &STR_modify);
        stringOPcons("", CLU_1, CLU_0, &STR_);
        stringOPcons(":co#", CLU_1, CLU_4, &STR__072co_043);
        stringOPcons(":li#", CLU_1, CLU_4, &STR__072li_043);
        stringOPcons(":hc:", CLU_1, CLU_4, &STR__072hc_072);
        stringOPcons(":bs:", CLU_1, CLU_4, &STR__072bs_072);
        stringOPcons("\b", CLU_1, CLU_1, &STR__010);
        stringOPcons(":bc=", CLU_1, CLU_4, &STR__072bc_075);
        stringOPcons(":kb=", CLU_1, CLU_4, &STR__072kb_075);
        stringOPcons(":ce=", CLU_1, CLU_4, &STR__072ce_075);
        stringOPcons(":os:", CLU_1, CLU_4, &STR__072os_072);
        stringOPcons(":eo:", CLU_1, CLU_4, &STR__072eo_072);
        stringOPcons(":cl=", CLU_1, CLU_4, &STR__072cl_075);
        stringOPcons("\n", CLU_1, CLU_1, &STR__012);
        stringOPcons("cannot write to this stream", CLU_1, CLU_27, &STR_cannot_040write_040to_040this_040stream);
        stringOPcons("no line numbers", CLU_1, CLU_15, &STR_no_040line_040numbers);
        stringOPcons("cannot get date", CLU_1, CLU_15, &STR_cannot_040get_040date);
        stringOPcons("cannot set date", CLU_1, CLU_15, &STR_cannot_040set_040date);
        stringOPcons("no name for string stream", CLU_1, CLU_25, &STR_no_040name_040for_040string_040stream);
        stringOPcons("not a string output stream", CLU_1, CLU_26, &STR_not_040a_040string_040output_040stream);
        stringOPcons("^?", CLU_1, CLU_2, &STR__136_077);
        stringOPcons("not a terminal stream", CLU_1, CLU_21, &STR_not_040a_040terminal_040stream);
        stringOPcons("cannot rescan on this stream", CLU_1, CLU_28, &STR_cannot_040rescan_040on_040this_040stream);
        stringOPcons("input is always buffered", CLU_1, CLU_24, &STR_input_040is_040always_040buffered);
        stringOPcons("output is always buffered", CLU_1, CLU_25, &STR_output_040is_040always_040buffered);
        stringOPcons("cannot disable eof on this stream", CLU_1, CLU_33, &STR_cannot_040disable_040eof_040on_040this_040stream);
        stringOPcons("cannot enable eof on this stream", CLU_1, CLU_32, &STR_cannot_040enable_040eof_040on_040this_040stream);
        stringOPcons("stream[", CLU_1, CLU_7, &STR_stream_133);
        stringOPcons("(internal)", CLU_1, CLU_10, &STR__050internal_051);
        stringOPcons("does not contain a _chan", CLU_1, CLU_24, &STR_does_040not_040contain_040a_040_137chan);
        stream_own_init = 1;
        {
            {streamOPfree.tf = false;
            }
            }
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }

static int streamOPopen_own_init = 0;

/**** BEGIN PROCEDURE open ****/

errcode streamOPopen(fn, mode, ret_1)
CLUREF fn;
CLUREF mode;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF _can_read;
    CLUREF _can_write;
    CLUREF st;
    CLUREF ch;
    CLUREF bvec;
    CLUREF b;
    CLUREF istty;
    CLUREF nch;
    CLUREF tb;
        if (streamOPopen_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPopen_own_init = 1;
    }
    enter_proc(84);

  LINE(86);
    {
        {CLUREF T_1_1;
        T_1_1.num = ((mode.str->size != STR_read.str->size)? false :
            !(bcmp(mode.str->data, STR_read.str->data, mode.str->size)));
        _can_read.num = T_1_1.num;
        }
        }

  LINE(87);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_2.num = ((mode.str->size != STR_write.str->size)? false :
            !(bcmp(mode.str->data, STR_write.str->data, mode.str->size)));
        T_1_1.num = T_1_2.num;
        if (!T_1_2.num) {
            T_1_3.num = ((mode.str->size != STR_append.str->size)? false :
                !(bcmp(mode.str->data, STR_append.str->data, mode.str->size)));
            T_1_1.num = T_1_3.num;
        }
        _can_write.num = T_1_1.num;
        }
        }

  LINE(88);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = _can_read.num;
    if (!_can_read.num) {
        T_1_1.num = _can_write.num;
    }
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(89);
        {
        elist[0] = STR_bad_040access_040mode;
        {signal (ERR_not_possible);}}
        }
        }/* end if */

  LINE(90);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    CLUREF T_1_8;
    err = file_nameOPget_dir(fn, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_4.num = ((T_1_3.str->size != STR__057dev.str->size)? false :
        !(bcmp(T_1_3.str->data, STR__057dev.str->data, T_1_3.str->size)));
    T_1_2.num = T_1_4.num;
    if (T_1_4.num) {
        err = file_nameOPget_suffix(fn, &T_1_5);
        if (err != ERR_ok) goto ex_0;
        err = stringOPempty(T_1_5, &T_1_6);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = T_1_6.num;
    }
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        err = file_nameOPget_other(fn, &T_1_7);
        if (err != ERR_ok) goto ex_0;
        err = stringOPempty(T_1_7, &T_1_8);
        if (err != ERR_ok) goto ex_0;
        T_1_1.num = T_1_8.num;
    }
    if (T_1_1.num == true) {

  LINE(92);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = file_nameOPget_name(fn, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        T_2_2.num = ((T_2_1.str->size != STR_p.str->size)? false :
            !(bcmp(T_2_1.str->data, STR_p.str->data, T_2_1.str->size)));
        if (T_2_2.num == true) {

  LINE(93);
            {
            if (_can_read.num == true) {

  LINE(94);
                {
                {
                CLUREF T_4_1;
                err = streamOPprimary_input(&T_4_1);
                if (err != ERR_ok) goto ex_0;
                ret_1->num = T_4_1.num;
                }
                {signal (ERR_ok);}}
                }
            else {

  LINE(95);
                {
                {
                CLUREF T_4_1;
                err = streamOPprimary_output(&T_4_1);
                if (err != ERR_ok) goto ex_0;
                ret_1->num = T_4_1.num;
                }
                {signal (ERR_ok);}}
                }}/* end if */
            }
        else {
        CLUREF T_2_3;
        CLUREF T_2_4;
        err = file_nameOPget_name(fn, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        T_2_4.num = ((T_2_3.str->size != STR_e.str->size)? false :
            !(bcmp(T_2_3.str->data, STR_e.str->data, T_2_3.str->size)));
        if (T_2_4.num == true) {

  LINE(98);
            {
            if (_can_write.num == true) {

  LINE(99);
                {
                {
                CLUREF T_4_1;
                err = streamOPerror_output(&T_4_1);
                if (err != ERR_ok) goto ex_0;
                ret_1->num = T_4_1.num;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */

  LINE(100);
            {
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            {signal (ERR_not_possible);}}
            }
        else {
        CLUREF T_2_5;
        CLUREF T_2_6;
        err = file_nameOPget_name(fn, &T_2_5);
        if (err != ERR_ok) goto ex_0;
        T_2_6.num = ((T_2_5.str->size != STR_null.str->size)? false :
            !(bcmp(T_2_5.str->data, STR_null.str->data, T_2_5.str->size)));
        if (T_2_6.num == true) {

  LINE(102);
            {
                {CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                RecordAlloc(4, T_3_1);
                T_3_1.vec->data[1]  = fn.num;
                err = sequenceOPnew(&T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_1.vec->data[3]  = T_3_2.num;
                T_3_1.vec->data[2]  = false;
                CellAlloc(3, nil, T_3_3);
                T_3_1.vec->data[0]  = T_3_3.num;
                st.num = T_3_1.num;
                }
                }

  LINE(106);
            {
            CLUREF T_3_1;
            err = streamOPopen_streams(&T_3_1);
            if (err != ERR_ok) goto ex_0;
            {
            if ((T_3_1.array->int_low + T_3_1.array->ext_size + 1) < T_3_1.array->int_size) {
                T_3_1.array->store->data[T_3_1.array->int_low + T_3_1.array->ext_size] = st.num;
                T_3_1.array->ext_size++; T_3_1.array->ext_high++;}
            else {
                err = arrayOPaddh(T_3_1, st);
                if (err != ERR_ok) goto ex_0;}
            }
            }

  LINE(107);
            {
            {
            ret_1->num = st.num;
            }
            {signal (ERR_ok);}}
            }
        else {
        CLUREF T_2_7;
        CLUREF T_2_8;
        err = file_nameOPget_name(fn, &T_2_7);
        if (err != ERR_ok) goto ex_0;
        T_2_8.num = ((T_2_7.str->size != STR_tty.str->size)? false :
            !(bcmp(T_2_7.str->data, STR_tty.str->data, T_2_7.str->size)));
        if (T_2_8.num == true) {

  LINE(109);
            {
            mode = STR_modify;
            }
            }
            }}}}/* end if */
        }
        }/* end if */

  LINE(111);
    {
        {CLUREF T_2_1;
        err = _chanOPopen(fn, mode, CLU_0, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        ch.num = T_2_1.num;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(114);
    {
    if (streamOPfree.num == true) {

  LINE(115);
        {
        bvec.num = streamOPfreebuf.num;
        }

  LINE(116);
        {
        streamOPfree.tf = false;
        }
        }
    else {

  LINE(117);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 4096;
        err = _bytevecOPcreate(T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        bvec.num = T_2_2.num;
        }
        }}/* end if */

  LINE(120);
    {
        {CLUREF T_1_1;
        err = _chanOPis_tty(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        istty.num = T_1_1.num;
        }
        }

  LINE(121);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    T_2_1.num = istty.num;
    if (istty.num) {
        T_2_2.num = ((mode.str->size != STR_modify.str->size)? false :
            !(bcmp(mode.str->data, STR_modify.str->data, mode.str->size)));
        T_2_3.num = T_2_2.num ^ 1;
        T_2_1.num = T_2_3.num;
    }
    if (T_2_1.num == true) {

  LINE(122);
        {
            {CLUREF T_3_1;
            err = _chanOPopen(fn, STR_modify, CLU_0, &T_3_1);
            if (err != ERR_ok) goto ex_2;
            nch.num = T_3_1.num;
            }
            }

  LINE(123);
        {
        err = _chanOPclose(ch);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(124);
        {
        ch.num = nch.num;
        }
        }
        }/* end if */
        goto end_2;
        ex_2:
            if ((err == ERR_not_possible)) {

  LINE(125);
                {
                istty.tf = false;
                }
            }
            else {
                goto ex_0;
            }
        end_2:;

  LINE(126);
    {
    if (istty.num == true) {

  LINE(127);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            RecordAlloc(19, T_2_1);
            T_2_1.vec->data[1]  = bvec.num;
            T_2_1.vec->data[4]  = 1;
            T_2_1.vec->data[11]  = 0;
            T_2_1.vec->data[9]  = true;
            T_2_1.vec->data[15]  = true;
            T_2_1.vec->data[10]  = false;
            T_2_1.vec->data[2]  = ch.num;
            err = arrayOPnew(&T_2_2);
            if (err != ERR_ok) goto ex_0;
            T_2_1.vec->data[18]  = T_2_2.num;
            T_2_1.vec->data[5]  = false;
            T_2_1.vec->data[7]  = false;
            T_2_1.vec->data[8]  = true;
            T_2_1.vec->data[13]  = 1;
            T_2_1.vec->data[17]  = STR_.num;
            T_2_1.vec->data[6]  = false;
            T_2_1.vec->data[14]  = 0;
            T_2_1.vec->data[16]  = 0;
            T_2_1.vec->data[0]  = STR_.num;
            T_2_1.vec->data[12]  = STR_.num;
            T_2_1.vec->data[3]  = STR_.num;
            tb.num = T_2_1.num;
            }
            }

  LINE(146);
        {
        CLUREF T_2_1;
        CellAlloc(6, tb.num, T_2_1);
        b.num = T_2_1.num;
        }

  LINE(147);
        {
        CLUREF T_2_1;
        T_2_1.num = ((mode.str->size != STR_modify.str->size)? false :
            !(bcmp(mode.str->data, STR_modify.str->data, mode.str->size)));
        if (T_2_1.num == true) {

  LINE(148);
            {
            err = streamOPtermcap(tb, STR_);
            if (err != ERR_ok) goto ex_0;
            }
            }
            }/* end if */
        }
    else {
    if (_can_read.num == true) {

  LINE(150);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(5, T_2_1);
        T_2_1.vec->data[0]  = bvec.num;
        T_2_1.vec->data[2]  = 1;
        T_2_1.vec->data[4]  = 0;
        T_2_1.vec->data[3]  = 1;
        T_2_1.vec->data[1]  = ch.num;
        CellAlloc(5, T_2_1.num, T_2_2);
        b.num = T_2_2.num;
        }
        }
    else {

  LINE(155);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(4, T_2_1);
        T_2_1.vec->data[0]  = bvec.num;
        T_2_1.vec->data[2]  = 0;
        T_2_1.vec->data[3]  = true;
        T_2_1.vec->data[1]  = ch.num;
        CellAlloc(7, T_2_1.num, T_2_2);
        b.num = T_2_2.num;
        }
        }}}/* end if */

  LINE(160);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        RecordAlloc(4, T_1_1);
        err = _chanOPget_name(ch, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1]  = T_1_2.num;
        err = sequenceOPnew(&T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[3]  = T_1_3.num;
        T_1_1.vec->data[2]  = false;
        T_1_1.vec->data[0]  = b.num;
        st.num = T_1_1.num;
        }
        }

  LINE(164);
    {
    CLUREF T_1_1;
    err = streamOPopen_streams(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    {
    if ((T_1_1.array->int_low + T_1_1.array->ext_size + 1) < T_1_1.array->int_size) {
        T_1_1.array->store->data[T_1_1.array->int_low + T_1_1.array->ext_size] = st.num;
        T_1_1.array->ext_size++; T_1_1.array->ext_high++;}
    else {
        err = arrayOPaddh(T_1_1, st);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(165);
    {
    {
    ret_1->num = st.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE open ****/

static int streamOPopen_streams_own_init = 0;
CLUREF streamOPopen_streamsOPlist;

/**** BEGIN PROCEDURE open_streams ****/

errcode streamOPopen_streams(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (streamOPopen_streams_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPopen_streams_own_init = 1;
        {
            {CLUREF T_0_1;
            err = arrayOPnew(&T_0_1);
            if (err != ERR_ok) goto ex_0;
            streamOPopen_streamsOPlist.num = T_0_1.num;
            }
            }
    }
    enter_proc(168);

  LINE(170);
    {
    {
    ret_1->num = streamOPopen_streamsOPlist.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE open_streams ****/

static int streamOPprimary_input_own_init = 0;
CLUREF streamOPprimary_inputOPpri;
CLUREF streamOPprimary_inputOPpro;

/**** BEGIN PROCEDURE primary_input ****/

errcode streamOPprimary_input(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (streamOPprimary_input_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPprimary_input_own_init = 1;
        {
            {CLUREF T_0_1;
            CLUREF T_0_2;
            err = streamOPget_prims(&T_0_1, &T_0_2);
            if (err != ERR_ok) goto ex_0;
            streamOPprimary_inputOPpri.num = T_0_1.num;
            streamOPprimary_inputOPpro.num = T_0_2.num;
            }
            }
    }
    enter_proc(173);

  LINE(175);
    {
    {
    ret_1->num = streamOPprimary_inputOPpri.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE primary_input ****/

static int streamOPprimary_output_own_init = 0;
CLUREF streamOPprimary_outputOPpri;
CLUREF streamOPprimary_outputOPpro;

/**** BEGIN PROCEDURE primary_output ****/

errcode streamOPprimary_output(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (streamOPprimary_output_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPprimary_output_own_init = 1;
        {
            {CLUREF T_0_1;
            CLUREF T_0_2;
            err = streamOPget_prims(&T_0_1, &T_0_2);
            if (err != ERR_ok) goto ex_0;
            streamOPprimary_outputOPpri.num = T_0_1.num;
            streamOPprimary_outputOPpro.num = T_0_2.num;
            }
            }
    }
    enter_proc(178);

  LINE(180);
    {
    {
    ret_1->num = streamOPprimary_outputOPpro.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE primary_output ****/

static int streamOPerror_output_own_init = 0;
CLUREF streamOPerror_outputOPinit;
CLUREF streamOPerror_outputOPero;

/**** BEGIN PROCEDURE error_output ****/

errcode streamOPerror_output(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ch;
    CLUREF b;
        if (streamOPerror_output_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPerror_output_own_init = 1;
        {
            {streamOPerror_outputOPinit.tf = false;
            }
            }
    }
    enter_proc(183);

  LINE(186);
    {
    CLUREF T_1_1;
    T_1_1.num = streamOPerror_outputOPinit.num ^ 1;
    if (T_1_1.num == true) {

  LINE(187);
        {
            {CLUREF T_2_1;
            err = _chanOPerror_output(&T_2_1);
            if (err != ERR_ok) goto ex_0;
            ch.num = T_2_1.num;
            }
            }

  LINE(188);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            RecordAlloc(4, T_2_1);
            T_2_2.num = 2048;
            err = _bytevecOPcreate(T_2_2, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            T_2_1.vec->data[0]  = T_2_3.num;
            T_2_1.vec->data[2]  = 0;
            T_2_1.vec->data[3]  = false;
            T_2_1.vec->data[1]  = ch.num;
            CellAlloc(7, T_2_1.num, T_2_4);
            b.num = T_2_4.num;
            }
            }

  LINE(193);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        RecordAlloc(4, T_2_1);
        err = _chanOPget_name(ch, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[1]  = T_2_2.num;
        err = sequenceOPnew(&T_2_3);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[3]  = T_2_3.num;
        T_2_1.vec->data[2]  = false;
        T_2_1.vec->data[0]  = b.num;
        streamOPerror_outputOPero.num = T_2_1.num;
        }

  LINE(197);
        {
        CLUREF T_2_1;
        err = streamOPopen_streams(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        {
        if ((T_2_1.array->int_low + T_2_1.array->ext_size + 1) < T_2_1.array->int_size) {
            T_2_1.array->store->data[T_2_1.array->int_low + T_2_1.array->ext_size] = streamOPerror_outputOPero.num;
            T_2_1.array->ext_size++; T_2_1.array->ext_high++;}
        else {
            err = arrayOPaddh(T_2_1, streamOPerror_outputOPero);
            if (err != ERR_ok) goto ex_0;}
        }
        }

  LINE(198);
        {
        streamOPerror_outputOPinit.tf = true;
        }
        }
        }/* end if */

  LINE(200);
    {
    {
    ret_1->num = streamOPerror_outputOPero.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE error_output ****/

static int streamOPget_prims_own_init = 0;
CLUREF streamOPget_primsOPinit;
CLUREF streamOPget_primsOPpri;
CLUREF streamOPget_primsOPpro;

/**** BEGIN PROCEDURE get_prims ****/

errcode streamOPget_prims(ret_1, ret_2)
CLUREF *ret_1;
CLUREF *ret_2;
    {
    errcode err;
    errcode ecode2;
    CLUREF chi;
    CLUREF cho;
    CLUREF opens;
    CLUREF tb;
    CLUREF b;
        if (streamOPget_prims_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPget_prims_own_init = 1;
        {
            {streamOPget_primsOPinit.tf = false;
            }
            }
    }
    enter_proc(203);

  LINE(206);
    {
    if (streamOPget_primsOPinit.num == true) {

  LINE(207);
        {
        {
        ret_1->num = streamOPget_primsOPpri.num;
        }
        {
        ret_2->num = streamOPget_primsOPpro.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(208);
    {
        {CLUREF T_1_1;
        err = _chanOPprimary_input(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        chi.num = T_1_1.num;
        }
        }

  LINE(209);
    {
        {CLUREF T_1_1;
        err = _chanOPprimary_output(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        cho.num = T_1_1.num;
        }
        }

  LINE(210);
    {
        {CLUREF T_1_1;
        err = streamOPopen_streams(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        opens.num = T_1_1.num;
        }
        }

  LINE(211);
    {
    CLUREF T_1_1;
    err = _chanOPequal(chi, cho, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(212);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            RecordAlloc(19, T_2_1);
            T_2_2.num = 1024;
            err = _bytevecOPcreate(T_2_2, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            T_2_1.vec->data[1]  = T_2_3.num;
            T_2_1.vec->data[4]  = 1;
            T_2_1.vec->data[11]  = 0;
            T_2_1.vec->data[9]  = true;
            T_2_1.vec->data[15]  = true;
            T_2_1.vec->data[10]  = false;
            T_2_1.vec->data[2]  = chi.num;
            err = arrayOPnew(&T_2_4);
            if (err != ERR_ok) goto ex_0;
            T_2_1.vec->data[18]  = T_2_4.num;
            T_2_1.vec->data[5]  = false;
            T_2_1.vec->data[7]  = false;
            T_2_1.vec->data[8]  = true;
            T_2_1.vec->data[13]  = 1;
            T_2_1.vec->data[17]  = STR_.num;
            T_2_1.vec->data[6]  = false;
            T_2_1.vec->data[14]  = 0;
            T_2_1.vec->data[16]  = 0;
            T_2_1.vec->data[0]  = STR_.num;
            T_2_1.vec->data[12]  = STR_.num;
            T_2_1.vec->data[3]  = STR_.num;
            tb.num = T_2_1.num;
            }
            }

  LINE(231);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        RecordAlloc(4, T_2_1);
        err = _chanOPget_name(chi, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[1]  = T_2_2.num;
        err = sequenceOPnew(&T_2_3);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[3]  = T_2_3.num;
        T_2_1.vec->data[2]  = false;
        CellAlloc(6, tb.num, T_2_4);
        T_2_1.vec->data[0]  = T_2_4.num;
        streamOPget_primsOPpro.num = T_2_1.num;
        }

  LINE(235);
        {
        streamOPget_primsOPpri.num = streamOPget_primsOPpro.num;
        }

  LINE(236);
        {
        {
        if ((opens.array->int_low + opens.array->ext_size + 1) < opens.array->int_size) {
            opens.array->store->data[opens.array->int_low + opens.array->ext_size] = streamOPget_primsOPpro.num;
            opens.array->ext_size++; opens.array->ext_high++;}
        else {
            err = arrayOPaddh(opens, streamOPget_primsOPpro);
            if (err != ERR_ok) goto ex_0;}
        }
        }

  LINE(237);
        {
        streamOPget_primsOPinit.tf = true;
        }

  LINE(238);
        {
        err = streamOPtermcap(tb, STR_);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(239);
        {
        {
        ret_1->num = streamOPget_primsOPpri.num;
        }
        {
        ret_2->num = streamOPget_primsOPpro.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(241);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        RecordAlloc(5, T_1_1);
        T_1_2.num = 2048;
        err = _bytevecOPcreate(T_1_2, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_3.num;
        T_1_1.vec->data[2]  = 1;
        T_1_1.vec->data[4]  = 0;
        T_1_1.vec->data[3]  = 1;
        T_1_1.vec->data[1]  = chi.num;
        CellAlloc(5, T_1_1.num, T_1_4);
        b.num = T_1_4.num;
        }
        }

  LINE(246);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(4, T_1_1);
    err = _chanOPget_name(chi, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[1]  = T_1_2.num;
    err = sequenceOPnew(&T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[3]  = T_1_3.num;
    T_1_1.vec->data[2]  = false;
    T_1_1.vec->data[0]  = b.num;
    streamOPget_primsOPpri.num = T_1_1.num;
    }

  LINE(250);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    RecordAlloc(4, T_1_1);
    T_1_2.num = 2048;
    err = _bytevecOPcreate(T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[0]  = T_1_3.num;
    T_1_1.vec->data[2]  = 0;
    T_1_1.vec->data[3]  = true;
    T_1_1.vec->data[1]  = cho.num;
    CellAlloc(7, T_1_1.num, T_1_4);
    b.num = T_1_4.num;
    }

  LINE(254);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(4, T_1_1);
    err = _chanOPget_name(cho, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[1]  = T_1_2.num;
    err = sequenceOPnew(&T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[3]  = T_1_3.num;
    T_1_1.vec->data[2]  = false;
    T_1_1.vec->data[0]  = b.num;
    streamOPget_primsOPpro.num = T_1_1.num;
    }

  LINE(258);
    {
    {
    if ((opens.array->int_low + opens.array->ext_size + 1) < opens.array->int_size) {
        opens.array->store->data[opens.array->int_low + opens.array->ext_size] = streamOPget_primsOPpri.num;
        opens.array->ext_size++; opens.array->ext_high++;}
    else {
        err = arrayOPaddh(opens, streamOPget_primsOPpri);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(259);
    {
    {
    if ((opens.array->int_low + opens.array->ext_size + 1) < opens.array->int_size) {
        opens.array->store->data[opens.array->int_low + opens.array->ext_size] = streamOPget_primsOPpro.num;
        opens.array->ext_size++; opens.array->ext_high++;}
    else {
        err = arrayOPaddh(opens, streamOPget_primsOPpro);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(260);
    {
    streamOPget_primsOPinit.tf = true;
    }

  LINE(261);
    {
    {
    ret_1->num = streamOPget_primsOPpri.num;
    }
    {
    ret_2->num = streamOPget_primsOPpro.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_prims ****/

static int streamOPtermcap_own_init = 0;

/**** BEGIN PROCEDURE termcap ****/

errcode streamOPtermcap(b, term)
CLUREF b;
CLUREF term;
    {
    errcode err;
    errcode ecode2;
    CLUREF ibaud;
    CLUREF obaud;
        if (streamOPtermcap_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPtermcap_own_init = 1;
    }
    enter_proc(264);

  LINE(265);
    {
    CLUREF T_1_1;
    err = stringOPempty(term, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(266);
        {
        CLUREF T_3_1;
        err = _get_termcap(&T_3_1);
        if (err != ERR_ok) goto ex_1;
        term.num = T_3_1.num;
        }
            goto end_1;
            ex_1:
                if ((err == ERR_not_found)) {

  LINE(267);
                    {
                    {signal (ERR_ok);}}
                }
                else {
                    goto ex_0;
                }
            end_1:;
        }
        }/* end if */

  LINE(269);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    err = _termcap(term, STR__072co_043, CLU_0, CLU_0, &T_2_1);
    if (err != ERR_ok) goto ex_2;
    err = intOPparse(T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_2;
    b.vec->data[14]  = T_2_2.num;
    }
        goto end_2;
        ex_2:
            if ((err == ERR_not_found)
             || (err == ERR_bad_format)
             || (err == ERR_overflow)) {

  LINE(270);
                {
                b.vec->data[14]  = 0;
                }
            }
            else {
                goto ex_0;
            }
        end_2:;

  LINE(271);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    err = _termcap(term, STR__072li_043, CLU_0, CLU_0, &T_2_1);
    if (err != ERR_ok) goto ex_3;
    err = intOPparse(T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_3;
    b.vec->data[16]  = T_2_2.num;
    }
        goto end_3;
        ex_3:
            if ((err == ERR_not_found)
             || (err == ERR_bad_format)
             || (err == ERR_overflow)) {

  LINE(272);
                {
                b.vec->data[14]  = 0;
                }
            }
            else {
                goto ex_0;
            }
        end_3:;

  LINE(273);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = stringOPindexs(STR__072hc_072, term, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = (T_1_1.num > 0)? true : false;
    if (T_1_2.num == true) {

  LINE(274);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(275);
    {
        {CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = b.vec->data[2];
        err = _chanOPget_speeds(T_2_1, &T_2_2, &T_2_3);
        if (err != ERR_ok) goto ex_4;
        ibaud.num = T_2_2.num;
        obaud.num = T_2_3.num;
        }
        }
        goto end_4;
        ex_4:
            if ((err == ERR_not_possible)) {

  LINE(276);
                {
                obaud.num = 9600;
                }
            }
            else {
                goto ex_0;
            }
        end_4:;

  LINE(277);
    {
    CLUREF T_3_1;
    CLUREF T_3_2;
    err = stringOPindexs(STR__072bs_072, term, &T_3_1);
    if (err != ERR_ok) goto ex_6;
    T_3_2.num = (T_3_1.num > 0)? true : false;
    if (T_3_2.num == true) {

  LINE(278);
        {
        b.vec->data[0]  = STR__010.num;
        }
        }
    else {

  LINE(279);
        {
        CLUREF T_4_1;
        err = _termcap(term, STR__072bc_075, CLU_0, CLU_0, &T_4_1);
        if (err != ERR_ok) goto ex_6;
        b.vec->data[0]  = T_4_1.num;
        }
        }}/* end if */
        goto end_6;
        ex_6:
            if ((err == ERR_not_found)) {

  LINE(281);
                {
                CLUREF T_3_1;
                err = _termcap(term, STR__072kb_075, CLU_0, CLU_0, &T_3_1);
                if (err != ERR_ok) goto ex_5;
                b.vec->data[0]  = T_3_1.num;
                }
            }
            else {
                goto ex_5;
            }
        end_6:;
        goto end_5;
        ex_5:
            if ((err == ERR_not_found)) {
            }
            else {
                goto ex_0;
            }
        end_5:;

  LINE(283);
    {
    CLUREF T_2_1;
    err = _termcap(term, STR__072ce_075, CLU_1, obaud, &T_2_1);
    if (err != ERR_ok) goto ex_7;
    b.vec->data[12]  = T_2_1.num;
    }
        goto end_7;
        ex_7:
            if ((err == ERR_not_found)) {

  LINE(285);
                {
                CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                CLUREF T_2_4;
                CLUREF T_2_5;
                CLUREF T_2_6;
                CLUREF T_2_7;
                CLUREF T_2_8;
                CLUREF T_2_9;
                T_2_2.num = b.vec->data[0];
                err = stringOPempty(T_2_2, &T_2_3);
                if (err != ERR_ok) goto ex_0;
                T_2_4.num = T_2_3.num ^ 1;
                T_2_1.num = T_2_4.num;
                if (T_2_4.num) {
                    err = stringOPindexs(STR__072os_072, term, &T_2_6);
                    if (err != ERR_ok) goto ex_0;
                    T_2_7.num = (T_2_6.num == 0)? true : false;
                    T_2_5.num = T_2_7.num;
                    if (!T_2_7.num) {
                        err = stringOPindexs(STR__072eo_072, term, &T_2_8);
                        if (err != ERR_ok) goto ex_0;
                        T_2_9.num = (T_2_8.num > 0)? true : false;
                        T_2_5.num = T_2_9.num;
                    }
                    T_2_1.num = T_2_5.num;
                }
                if (T_2_1.num == true) {

  LINE(288);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                    CLUREF T_3_5;
                    T_3_1.num = b.vec->data[0];
                    T_3_2.ch = ' ';
                    err = stringOPappend(T_3_1, T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    T_3_4.num = b.vec->data[0];
                    err = stringOPconcat(T_3_3, T_3_4, &T_3_5);
                    if (err != ERR_ok) goto ex_0;
                    b.vec->data[0]  = T_3_5.num;
                    }
                    }
                    }/* end if */
            }
            else {
                goto ex_0;
            }
        end_7:;

  LINE(291);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = b.vec->data[16];
    err = _termcap(term, STR__072cl_075, T_2_1, obaud, &T_2_2);
    if (err != ERR_ok) goto ex_8;
    b.vec->data[3]  = T_2_2.num;
    }
        goto end_8;
        ex_8:
            if ((err == ERR_not_found)) {
            }
            else {
                goto ex_0;
            }
        end_8:;

  LINE(293);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    CLUREF T_1_8;
    T_1_3.num = b.vec->data[0];
    err = stringOPempty(T_1_3, &T_1_4);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = T_1_4.num;
    if (T_1_4.num) {
        T_1_5.num = b.vec->data[12];
        err = stringOPempty(T_1_5, &T_1_6);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = T_1_6.num;
    }
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        T_1_7.num = b.vec->data[3];
        err = stringOPempty(T_1_7, &T_1_8);
        if (err != ERR_ok) goto ex_0;
        T_1_1.num = T_1_8.num;
    }
    if (T_1_1.num == true) {

  LINE(296);
        {
        b.vec->data[12]  = STR__012.num;
        }

  LINE(297);
        {
        b.vec->data[3]  = STR__012.num;
        }
        }
    else {

  LINE(298);
        {
        b.vec->data[6]  = true;
        }
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE termcap ****/

extern errcode streamOPadd_script_IB_1();
extern errcode streamOPadd_script_IB_2();

/**** BEGIN PROCEDURE add_script ****/

errcode streamOPadd_script(st1, st2)
CLUREF st1;
CLUREF st2;
    {
    struct {
        errcode err;
        errcode ecode2;
        CLUREF scr;
        CLUREF st1;
        CLUREF st2;
        } locals;
    locals.st1 = st1;
    locals.st2 = st2;
        if (stream_own_init == 0) {
            locals.err = stream_own_init_proc();
            if (locals.err != ERR_ok) goto ex_0;
            }
    enter_proc(302);

  LINE(303);
    {
    CLUREF T_1_1;
    T_1_1.num = locals.st2.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: 
    case 2: 
    case 1: 
         {

  LINE(305);
            {
            {signal (ERR_script_failed);}}
            break;
            }
    default: {

  LINE(307);
        {
            locals.err = streamOPall_scripts(locals.st2, streamOPadd_script_IB_1, &locals, &locals.ecode2);
            if (locals.err == ERR_iterbodyreturn) {
            signal(ERR_ok);}
            if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
            if (locals.err == ERR_break) locals.err = ERR_ok;
            if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
            if (locals.err != ERR_ok) goto ex_0;
            }

  LINE(311);
        {
            locals.err = streamOPall_scripts(locals.st1, streamOPadd_script_IB_2, &locals, &locals.ecode2);
            if (locals.err == ERR_iterbodyreturn) {
            signal(ERR_ok);}
            if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
            if (locals.err == ERR_break) locals.err = ERR_ok;
            if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
            if (locals.err != ERR_ok) goto ex_0;
            }

  LINE(315);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = locals.st1.vec->data[3];
        locals.err = sequenceOPaddh(T_2_1, locals.st2, &T_2_2);
        if (locals.err != ERR_ok) goto ex_0;
        locals.st1.vec->data[3]  = T_2_2.num;
        }

  LINE(316);
        {
        locals.st1.vec->data[2]  = true;
        }
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE add_script ****/


/**** BEGIN ITERATOR BODIES for add_script ****/

errcode streamOPadd_script_IB_1(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    errcode err;
    errcode ecode2;
    CLUREF scr;
    CLUREF st1;
    CLUREF st2;
    } *locals;
{
    locals->scr.num = iv_1.num;
    enter_iter_body_proc(308);

  FB_LINE(308);
    {
    CLUREF T_1_1;
    T_1_1.num = (locals->st1.num == locals->scr.num)? true : false;
    if (T_1_1.num == true) {

  FB_LINE(309);
        {
        *iecode = ERR_script_failed;
        {signal(ERR_iterbodysignal);}
        }
        }
        }/* end if */
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end streamOPadd_script_IB_1 */
errcode streamOPadd_script_IB_2(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    errcode err;
    errcode ecode2;
    CLUREF scr;
    CLUREF st1;
    CLUREF st2;
    } *locals;
{
    locals->scr.num = iv_1.num;
    enter_iter_body_proc(312);

  FB_LINE(312);
    {
    CLUREF T_1_1;
    T_1_1.num = (locals->st2.num == locals->scr.num)? true : false;
    if (T_1_1.num == true) {

  FB_LINE(313);
        {
        *iecode = ERR_script_failed;
        {signal(ERR_iterbodysignal);}
        }
        }
        }/* end if */
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end streamOPadd_script_IB_2 */

/**** END ITERATOR BODIES for add_script ****/

extern errcode streamOPall_scripts_IB_1();

/**** BEGIN ITERATOR all_scripts ****/

errcode streamOPall_scripts(st, proc, user_locals, iecode)
CLUREF st;
errcode (*proc)();
char **user_locals;
errcode *iecode;
    {
    errcode ecode;
    struct {
        char **user_locals;
        errcode (*proc)();
        errcode err;
        errcode ecode2;
        bool body_ctrl_req;
        CLUREF scr1;
        CLUREF scr2;
        CLUREF st;
        } locals;
    locals.st = st;
    locals.proc = proc;
    locals.user_locals = user_locals;
    locals.user_locals = user_locals;
    locals.proc = proc;
        if (stream_own_init == 0) {
            locals.err = stream_own_init_proc();
            if (locals.err != ERR_ok) goto ex_0;
            }
    enter_proc(320);

  LINE(321);
    {
    locals.err = locals.proc(locals.st, locals.user_locals, iecode);
    if (locals.err != ERR_ok) {
    if (locals.err == ERR_break) {signal(ERR_break);}
    if (locals.err == ERR_iterbodyreturn) {signal(ERR_iterbodyreturn);}
    if (locals.err == ERR_iterbodyexit) {signal(ERR_iterbodyexit);}
    if (locals.err == ERR_iterbodysignal) {signal(ERR_iterbodysignal);}
    {signal(locals.err);
        }}
    }

  LINE(322);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = locals.st.vec->data[3];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            locals.scr1.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(323);
            {
                locals.body_ctrl_req = false;
                locals.err = streamOPall_scripts(locals.scr1, streamOPall_scripts_IB_1, &locals, &locals.ecode2);
                if (locals.err == ERR_iterbodyreturn) {signal(ERR_iterbodyreturn);}
                if (locals.err == ERR_iterbodysignal) {
                    *iecode = locals.ecode2; signal(ERR_iterbodysignal);}
                if (locals.err == ERR_iterbodyexit) {
                    *iecode = locals.ecode2; signal(ERR_iterbodyexit);}
                if (locals.body_ctrl_req == true) {
                    locals.body_ctrl_req = false;
                    if (locals.err == ERR_iteriterbodyreturn) {signal(ERR_ok);}
                    if (locals.err == ERR_iteriterbodysignal) {signal(locals.ecode2);}
                    if (locals.err == ERR_break) locals.err = ERR_ok;
                    if (locals.err == ERR_iteriterbodyexit) locals.err = locals.ecode2;
                    }
                else {
                    if (locals.err == ERR_iteriterbodyreturn) {signal(ERR_iteriterbodyreturn);}
                    if (locals.err == ERR_break) {signal(ERR_break);}
                    if (locals.err == ERR_iteriterbodysignal) {
                          *iecode = locals.ecode2; signal(ERR_iteriterbodysignal);}
                    if (locals.err == ERR_iteriterbodyexit) {
                          *iecode = locals.ecode2; signal(ERR_iteriterbodyexit);}}
                if (locals.err != ERR_ok) goto ex_0;
                }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END ITERATOR all_scripts ****/


/**** BEGIN ITERATOR BODIES for all_scripts ****/

errcode streamOPall_scripts_IB_1(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    char **user_locals;
    errcode (*proc)();
    errcode err;
    errcode ecode2;
    bool body_ctrl_req;
    CLUREF scr1;
    CLUREF scr2;
    CLUREF st;
    } *locals;
{
    locals->scr2.num = iv_1.num;
    enter_iter_body_proc(324);

  FB_LINE(324);
    {
    locals->err = locals->proc(locals->scr2, locals->user_locals, iecode);
    if ((locals->body_ctrl_req == true) && (locals->err == ERR_iteriterbodyexit)) {
        locals->err = *iecode;
        goto ex_0;}
    if (locals->err != ERR_ok) {
    signal(locals->err);
    }
    }
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            locals->body_ctrl_req = true;
            {signal(ERR_iteriterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end streamOPall_scripts_IB_1 */

/**** END ITERATOR BODIES for all_scripts ****/


/**** BEGIN ITERATOR scripts ****/

errcode streamOPscripts(st, proc, user_locals, iecode)
CLUREF st;
errcode (*proc)();
char **user_locals;
errcode *iecode;
    {
    errcode ecode;
    errcode err;
    errcode ecode2;
    bool body_ctrl_req;
    CLUREF scr;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(329);

  LINE(330);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = st.vec->data[3];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            scr.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(331);
            {
            err = proc(scr, user_locals, iecode);
            if (err != ERR_ok) {
            if (err == ERR_break) {signal(ERR_break);}
            if (err == ERR_iterbodyreturn) {signal(ERR_iterbodyreturn);}
            if (err == ERR_iterbodyexit) {signal(ERR_iterbodyexit);}
            if (err == ERR_iterbodysignal) {signal(ERR_iterbodysignal);}
            {signal(err);
                }}
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END ITERATOR scripts ****/


/**** BEGIN PROCEDURE rem_script ****/

errcode streamOPrem_script(st1, st2)
CLUREF st1;
CLUREF st2;
    {
    errcode err;
    errcode ecode2;
    CLUREF scrs;
    CLUREF i;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(335);

  LINE(336);
    {
        {CLUREF T_1_1;
        T_1_1.num = st1.vec->data[3];
        scrs.num = T_1_1.num;
        }
        }

  LINE(337);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = scrs.vec->size; 
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(338);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            if (i.num < 1 || i.num > scrs.vec->size ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = scrs.vec->data[i.num - 1];
            err = streamOPequal(T_2_1, st2, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            if (T_2_2.num == true) {

  LINE(339);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CLUREF T_3_4;
                CLUREF T_3_5;
                CLUREF T_3_6;
                T_3_1.num = i.num - 1;
                 if ((T_3_1.num >= 0 && i.num < 0 && (-1) < 0) || 
                     (T_3_1.num <= 0 && i.num > 0 && (-1) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                err = sequenceOPsubseq(scrs, CLU_1, T_3_1, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_3.num = i.num + 1;
                 if ((T_3_3.num > 0 && i.num < 0 && 1 < 0) || 
                     (T_3_3.num < 0 && i.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                T_3_4.num = scrs.vec->size;
                err = sequenceOPsubseq(scrs, T_3_3, T_3_4, &T_3_5);
                if (err != ERR_ok) goto ex_0;
                err = sequenceOPconcat(T_3_2, T_3_5, &T_3_6);
                if (err != ERR_ok) goto ex_0;
                st1.vec->data[3]  = T_3_6.num;
                }

  LINE(341);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                T_3_1.num = st1.vec->data[3];
                err = sequenceOPempty(T_3_1, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_3.num = T_3_2.num ^ 1;
                st1.vec->data[2]  = T_3_3.num;
                }

  LINE(342);
                {
                {signal (ERR_ok);}}
                }
                }/* end if */
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE rem_script ****/


/**** BEGIN PROCEDURE unscript ****/

errcode streamOPunscript(st)
CLUREF st;
    {
    errcode err;
    errcode ecode2;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(347);

  LINE(348);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    st.vec->data[3]  = T_1_1.num;
    }

  LINE(349);
    {
    st.vec->data[2]  = false;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE unscript ****/


/**** BEGIN PROCEDURE can_read ****/

errcode streamOPcan_read(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(352);

  LINE(353);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 7: 
    case 4: 
    case 1: 
         {

  LINE(355);
            {
            {
            ret_1->tf = false;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(357);
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE can_read ****/


/**** BEGIN PROCEDURE can_write ****/

errcode streamOPcan_write(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(361);

  LINE(362);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: 
    case 2: 
    case 1: 
         {

  LINE(364);
            {
            {
            ret_1->tf = false;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(366);
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE can_write ****/

static int streamOPgetc_own_init = 0;

/**** BEGIN PROCEDURE getc ****/

errcode streamOPgetc(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF c;
    CLUREF rb;
    CLUREF index;
    CLUREF tb;
    CLUREF sb;
        if (streamOPgetc_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPgetc_own_init = 1;
    }
    enter_proc(370);

  LINE(373);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(375);
            {
                {CLUREF T_3_1;
                T_3_1.num = rb.vec->data[2];
                index.num = T_3_1.num;
                }
                }

  LINE(376);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = rb.vec->data[4];
            T_3_2.num = (index.num > T_3_1.num)? true : false;
            if (T_3_2.num == true) {

  LINE(377);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                T_4_1.num = rb.vec->data[1];
                T_4_2.num = rb.vec->data[0];
                err = _chanOPgetb(T_4_1, T_4_2, &T_4_3);
                if (err != ERR_ok) goto ex_1;
                rb.vec->data[4]  = T_4_3.num;
                }

  LINE(378);
                {
                index.num = 1;
                }
                }
                }/* end if */

  LINE(380);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = rb.vec->data[0];
            if (index.num < 1 || index.num > T_3_1.str->size ) {
                err = ERR_bounds;
                goto ex_1;}
            T_3_2.ch = T_3_1.str->data[index.num - 1];
            c.num = T_3_2.num;
            }

  LINE(381);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.ch = '\n';
            T_3_2.num = (c.ch == T_3_1.ch)? true : false;
            if (T_3_2.num == true) {

  LINE(382);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = rb.vec->data[3];
                T_4_2.num = T_4_1.num + 1;
                 if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) || 
                     (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                rb.vec->data[3]  = T_4_2.num;
                }
                }
                }/* end if */

  LINE(383);
            {
            CLUREF T_3_1;
            T_3_1.num = index.num + 1;
             if ((T_3_1.num > 0 && index.num < 0 && 1 < 0) || 
                 (T_3_1.num < 0 && index.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            rb.vec->data[2]  = T_3_1.num;
            }
            break;
            }
    case 6: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(385);
            {
            err = streamOPflush(st);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(386);
            {
            CLUREF T_3_1;
            err = streamOPtty_get1(tb, CLU_0, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            c.num = T_3_1.num;
            }

  LINE(387);
            {
            err = streamOPtty_put1(tb, c);
            if (err != ERR_ok) goto ex_1;
            }
            break;
            }
    case 2: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        sb.num = T_2_4.num;

  LINE(389);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = sb.vec->data[0];
            T_4_2.num = sb.vec->data[1];
            err = stringOPfetch(T_4_1, T_4_2, &T_4_3);
            if (err != ERR_ok) goto ex_2;
            c.num = T_4_3.num;
            }
                goto end_2;
                ex_2:
                    if ((err == ERR_bounds)) {

  LINE(391);
                        {
                        CLUREF T_4_1;
                        T_4_1.num = sb.vec->data[3];
                        c.num = T_4_1.num;
                        }

  LINE(392);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        T_4_1.ch = ' ';
                        T_4_2.num = (c.ch == T_4_1.ch)? true : false;
                        if (T_4_2.num == true) {

  LINE(393);
                            {
                            {signal (ERR_end_of_file);}}
                            }
                            }/* end if */

  LINE(394);
                        {
                        CLUREF T_4_1;
                        T_4_1.ch = ' ';
                        sb.vec->data[3]  = T_4_1.num;
                        }
                    }
                    else {
                        goto ex_1;
                    }
                end_2:;

  LINE(396);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = sb.vec->data[1];
            T_3_2.num = T_3_1.num + 1;
             if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) || 
                 (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            sb.vec->data[1]  = T_3_2.num;
            }

  LINE(397);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.ch = '\n';
            T_3_2.num = (c.ch == T_3_1.ch)? true : false;
            if (T_3_2.num == true) {

  LINE(398);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = sb.vec->data[2];
                T_4_2.num = T_4_1.num + 1;
                 if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) || 
                     (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                sb.vec->data[2]  = T_4_2.num;
                }
                }
                }/* end if */
            break;
            }
    case 3: 
         {

  LINE(400);
            {
            {signal (ERR_end_of_file);}}
            break;
            }
    case 7: 
    case 4: 
    case 1: 
         {

  LINE(402);
            {
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
        else if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(404);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) {

  LINE(405);
        {
        CLUREF T_2_1;
        err = stringOPc2s(c, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = streamOPscript(st, T_2_1, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(406);
    {
    {
    ret_1->num = c.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE getc ****/

static int streamOPgetc_image_own_init = 0;

/**** BEGIN PROCEDURE getc_image ****/

errcode streamOPgetc_image(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF c;
    CLUREF rb;
    CLUREF index;
    CLUREF tb;
    CLUREF sb;
        if (streamOPgetc_image_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPgetc_image_own_init = 1;
    }
    enter_proc(409);

  LINE(412);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(414);
            {
                {CLUREF T_3_1;
                T_3_1.num = rb.vec->data[2];
                index.num = T_3_1.num;
                }
                }

  LINE(415);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = rb.vec->data[4];
            T_3_2.num = (index.num > T_3_1.num)? true : false;
            if (T_3_2.num == true) {

  LINE(416);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                T_4_1.num = rb.vec->data[1];
                T_4_2.num = rb.vec->data[0];
                err = _chanOPgetb(T_4_1, T_4_2, &T_4_3);
                if (err != ERR_ok) goto ex_1;
                rb.vec->data[4]  = T_4_3.num;
                }

  LINE(417);
                {
                index.num = 1;
                }
                }
                }/* end if */

  LINE(419);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = rb.vec->data[0];
            if (index.num < 1 || index.num > T_3_1.str->size ) {
                err = ERR_bounds;
                goto ex_1;}
            T_3_2.ch = T_3_1.str->data[index.num - 1];
            c.num = T_3_2.num;
            }

  LINE(420);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.ch = '\n';
            T_3_2.num = (c.ch == T_3_1.ch)? true : false;
            if (T_3_2.num == true) {

  LINE(421);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = rb.vec->data[3];
                T_4_2.num = T_4_1.num + 1;
                 if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) || 
                     (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                rb.vec->data[3]  = T_4_2.num;
                }
                }
                }/* end if */

  LINE(422);
            {
            CLUREF T_3_1;
            T_3_1.num = index.num + 1;
             if ((T_3_1.num > 0 && index.num < 0 && 1 < 0) || 
                 (T_3_1.num < 0 && index.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            rb.vec->data[2]  = T_3_1.num;
            }
            break;
            }
    case 6: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(424);
            {
            err = streamOPflush(st);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(425);
            {
            CLUREF T_3_1;
            err = streamOPtty_get1(tb, CLU_1, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            c.num = T_3_1.num;
            }
            break;
            }
    case 2: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        sb.num = T_2_4.num;

  LINE(427);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = sb.vec->data[0];
            T_4_2.num = sb.vec->data[1];
            err = stringOPfetch(T_4_1, T_4_2, &T_4_3);
            if (err != ERR_ok) goto ex_2;
            c.num = T_4_3.num;
            }
                goto end_2;
                ex_2:
                    if ((err == ERR_bounds)) {

  LINE(429);
                        {
                        CLUREF T_4_1;
                        T_4_1.num = sb.vec->data[3];
                        c.num = T_4_1.num;
                        }

  LINE(430);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        T_4_1.ch = ' ';
                        T_4_2.num = (c.ch == T_4_1.ch)? true : false;
                        if (T_4_2.num == true) {

  LINE(431);
                            {
                            {signal (ERR_end_of_file);}}
                            }
                            }/* end if */

  LINE(432);
                        {
                        CLUREF T_4_1;
                        T_4_1.ch = ' ';
                        sb.vec->data[3]  = T_4_1.num;
                        }
                    }
                    else {
                        goto ex_1;
                    }
                end_2:;

  LINE(434);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = sb.vec->data[1];
            T_3_2.num = T_3_1.num + 1;
             if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) || 
                 (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            sb.vec->data[1]  = T_3_2.num;
            }

  LINE(435);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.ch = '\n';
            T_3_2.num = (c.ch == T_3_1.ch)? true : false;
            if (T_3_2.num == true) {

  LINE(436);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = sb.vec->data[2];
                T_4_2.num = T_4_1.num + 1;
                 if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) || 
                     (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                sb.vec->data[2]  = T_4_2.num;
                }
                }
                }/* end if */
            break;
            }
    case 3: 
         {

  LINE(438);
            {
            {signal (ERR_end_of_file);}}
            break;
            }
    case 7: 
    case 4: 
    case 1: 
         {

  LINE(440);
            {
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
        else if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(442);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) {

  LINE(443);
        {
        CLUREF T_2_1;
        err = stringOPc2s(c, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = streamOPscript(st, T_2_1, CLU_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(444);
    {
    {
    ret_1->num = c.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE getc_image ****/

static int streamOPpeekc_own_init = 0;

/**** BEGIN PROCEDURE peekc ****/

errcode streamOPpeekc(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF index;
    CLUREF tb;
    CLUREF c;
    CLUREF sb;
        if (streamOPpeekc_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPpeekc_own_init = 1;
    }
    enter_proc(447);

  LINE(449);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(451);
            {
                {CLUREF T_3_1;
                T_3_1.num = rb.vec->data[2];
                index.num = T_3_1.num;
                }
                }

  LINE(452);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = rb.vec->data[4];
            T_3_2.num = (index.num > T_3_1.num)? true : false;
            if (T_3_2.num == true) {

  LINE(453);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                T_4_1.num = rb.vec->data[1];
                T_4_2.num = rb.vec->data[0];
                err = _chanOPgetb(T_4_1, T_4_2, &T_4_3);
                if (err != ERR_ok) goto ex_1;
                rb.vec->data[4]  = T_4_3.num;
                }

  LINE(454);
                {
                rb.vec->data[2]  = 1;
                }

  LINE(455);
                {
                index.num = 1;
                }
                }
                }/* end if */

  LINE(457);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = rb.vec->data[0];
            if (index.num < 1 || index.num > T_3_1.str->size ) {
                err = ERR_bounds;
                goto ex_1;}
            T_3_2.ch = T_3_1.str->data[index.num - 1];
            ret_1->num = T_3_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 6: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(459);
            {
            err = streamOPflush(st);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(460);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_2.num = tb.vec->data[7];
            T_3_1.num = T_3_2.num;
            if (T_3_2.num) {
                T_3_3.num = tb.vec->data[8];
                T_3_1.num = T_3_3.num;
            }
            if (T_3_1.num == true) {

  LINE(461);
                {
                {signal (ERR_end_of_file);}}
                }
                }/* end if */

  LINE(462);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = tb.vec->data[18];
            T_3_2.num = (T_3_1.array->ext_size == 0)? true : false;
            if (T_3_2.num == true) {

  LINE(463);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    T_4_1.num = tb.vec->data[2];
                    err = _chanOPgetc(T_4_1, CLU_1, &T_4_2);
                    if (err != ERR_ok) goto ex_1;
                    c.num = T_4_2.num;
                    }
                    }

  LINE(464);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                CLUREF T_4_4;
                T_4_2.ch = '\004';
                T_4_3.num = (c.ch == T_4_2.ch)? true : false;
                T_4_1.num = T_4_3.num;
                if (T_4_3.num) {
                    T_4_4.num = tb.vec->data[8];
                    T_4_1.num = T_4_4.num;
                }
                if (T_4_1.num == true) {

  LINE(465);
                    {
                    tb.vec->data[7]  = true;
                    }

  LINE(466);
                    {
                    {signal (ERR_end_of_file);}}
                    }
                    }/* end if */

  LINE(468);
                {
                CLUREF T_4_1;
                T_4_1.num = tb.vec->data[18];
                {
                if ((T_4_1.array->int_low + T_4_1.array->ext_size + 1) < T_4_1.array->int_size) {
                    T_4_1.array->store->data[T_4_1.array->int_low + T_4_1.array->ext_size] = c.num;
                    T_4_1.array->ext_size++; T_4_1.array->ext_high++;}
                else {
                    err = arrayOPaddh(T_4_1, c);
                    if (err != ERR_ok) goto ex_1;}
                }
                }

  LINE(469);
                {
                tb.vec->data[5]  = true;
                }
                }
                }/* end if */

  LINE(471);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = tb.vec->data[18];
            err = arrayOPbottom(T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            ret_1->num = T_3_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 2: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        sb.num = T_2_4.num;

  LINE(473);
            {
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = sb.vec->data[0];
            T_4_2.num = sb.vec->data[1];
            err = stringOPfetch(T_4_1, T_4_2, &T_4_3);
            if (err != ERR_ok) goto ex_2;
            ret_1->num = T_4_3.num;
            }
            {signal (ERR_ok);}}
                goto end_2;
                ex_2:
                    if ((err == ERR_bounds)) {

  LINE(475);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        CLUREF T_4_3;
                        T_4_1.num = sb.vec->data[3];
                        T_4_2.ch = ' ';
                        T_4_3.num = (T_4_1.ch == T_4_2.ch)? true : false;
                        if (T_4_3.num == true) {

  LINE(476);
                            {
                            {signal (ERR_end_of_file);}}
                            }
                            }/* end if */

  LINE(477);
                        {
                        {
                        CLUREF T_4_1;
                        T_4_1.ch = '\n';
                        ret_1->num = T_4_1.num;
                        }
                        {signal (ERR_ok);}}
                    }
                    else {
                        goto ex_1;
                    }
                end_2:;
            break;
            }
    case 3: 
         {

  LINE(480);
            {
            {signal (ERR_end_of_file);}}
            break;
            }
    case 7: 
    case 4: 
    case 1: 
         {

  LINE(482);
            {
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
        else if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE peekc ****/


/**** BEGIN PROCEDURE pending ****/

errcode streamOPpending(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(486);

  LINE(487);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 6: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        tb.num = T_2_2.num;

  LINE(489);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            CLUREF T_3_6;
            CLUREF T_3_7;
            CLUREF T_3_8;
            CLUREF T_3_9;
            CLUREF T_3_10;
            CLUREF T_3_11;
            T_3_3.num = tb.vec->data[7];
            T_3_2.num = T_3_3.num;
            if (T_3_3.num) {
                T_3_4.num = tb.vec->data[8];
                T_3_2.num = T_3_4.num;
            }
            T_3_5.num = T_3_2.num ^ 1;
            T_3_1.num = T_3_5.num;
            if (T_3_5.num) {
                T_3_7.num = tb.vec->data[18];
                T_3_8.num = (T_3_7.array->ext_size == 0)? true : false;
                T_3_9.num = T_3_8.num ^ 1;
                T_3_6.num = T_3_9.num;
                if (!T_3_9.num) {
                    T_3_10.num = tb.vec->data[2];
                    err = _chanOPpending(T_3_10, CLU_0, &T_3_11);
                    if (err != ERR_ok) goto ex_1;
                    T_3_6.num = T_3_11.num;
                }
                T_3_1.num = T_3_6.num;
            }
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(493);
        {
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = streamOPempty(st, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        T_3_2.num = T_3_1.num ^ 1;
        ret_1->num = T_3_2.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE pending ****/

static int streamOPempty_own_init = 0;

/**** BEGIN PROCEDURE empty ****/

errcode streamOPempty(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF tb;
    CLUREF sb;
        if (streamOPempty_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPempty_own_init = 1;
    }
    enter_proc(497);

  LINE(498);
    {
    CLUREF T_3_1;
    T_3_1.num = st.vec->data[0];
    switch (T_3_1.cell->tag) {
    case 5: 
         {CLUREF T_3_2;
        T_3_2.num = T_3_1.cell->value;
        rb.num = T_3_2.num;

  LINE(500);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = rb.vec->data[2];
            T_4_2.num = rb.vec->data[4];
            T_4_3.num = (T_4_1.num > T_4_2.num)? true : false;
            if (T_4_3.num == true) {

  LINE(501);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                T_5_1.num = rb.vec->data[1];
                T_5_2.num = rb.vec->data[0];
                err = _chanOPgetb(T_5_1, T_5_2, &T_5_3);
                if (err != ERR_ok) goto ex_2;
                rb.vec->data[4]  = T_5_3.num;
                }

  LINE(502);
                {
                rb.vec->data[2]  = 1;
                }
                }
                }/* end if */

  LINE(504);
            {
            {
            ret_1->tf = false;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 6: 
         {CLUREF T_3_3;
        T_3_3.num = T_3_1.cell->value;
        tb.num = T_3_3.num;

  LINE(506);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = tb.vec->data[8];
            T_4_2.num = T_4_1.num ^ 1;
            if (T_4_2.num == true) {

  LINE(507);
                {
                {
                ret_1->tf = false;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */

  LINE(508);
            {
            CLUREF T_4_1;
            err = streamOPpeekc(st, &T_4_1);
            if (err != ERR_ok) goto ex_2;
            }

  LINE(509);
            {
            {
            ret_1->tf = false;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 2: 
         {CLUREF T_3_4;
        T_3_4.num = T_3_1.cell->value;
        sb.num = T_3_4.num;

  LINE(511);
            {
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            CLUREF T_4_6;
            CLUREF T_4_7;
            CLUREF T_4_8;
            T_4_2.num = sb.vec->data[1];
            T_4_3.num = sb.vec->data[0];
            err = stringOPsize(T_4_3, &T_4_4);
            if (err != ERR_ok) goto ex_2;
            T_4_5.num = (T_4_2.num > T_4_4.num)? true : false;
            T_4_1.num = T_4_5.num;
            if (T_4_5.num) {
                T_4_6.num = sb.vec->data[3];
                T_4_7.ch = ' ';
                T_4_8.num = (T_4_6.ch == T_4_7.ch)? true : false;
                T_4_1.num = T_4_8.num;
            }
            ret_1->num = T_4_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 3: 
         {

  LINE(513);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 7: 
    case 4: 
    case 1: 
         {

  LINE(515);
            {
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_1;}
    end_2:;
        goto end_1;
        ex_1:
            if ((err == ERR_end_of_file)) {

  LINE(517);
                {
                {
                ret_1->tf = true;
                }
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE empty ****/

static int streamOPputc_own_init = 0;

/**** BEGIN PROCEDURE putc ****/

errcode streamOPputc(st, c)
CLUREF st;
CLUREF c;
    {
    errcode err;
    errcode ecode2;
    CLUREF wb;
    CLUREF low;
    CLUREF index;
    CLUREF tb;
    CLUREF chars;
        if (streamOPputc_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPputc_own_init = 1;
    }
    enter_proc(520);

  LINE(521);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 7: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(523);
            {
            CLUREF T_3_1;
            T_3_1.num = wb.vec->data[3];
            if (T_3_1.num == true) {

  LINE(524);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    CLUREF T_4_3;
                    CLUREF T_4_4;
                    CLUREF T_4_5;
                    CLUREF T_4_6;
                    T_4_1.num = wb.vec->data[1];
                    T_4_2.num = wb.vec->data[0];
                    T_4_3.num = wb.vec->data[2];
                    err = stringOPc2s(c, &T_4_4);
                    if (err != ERR_ok) goto ex_1;
                    err = _chanOPput(T_4_1, T_4_2, CLU_1, T_4_3, T_4_4, CLU_0, &T_4_5, &T_4_6);
                    if (err != ERR_ok) goto ex_1;
                    low.num = T_4_5.num;
                    index.num = T_4_6.num;
                    }
                    }

  LINE(527);
                {
                wb.vec->data[2]  = index.num;
                }
                }
            else {

  LINE(528);
                {
                CLUREF T_4_1;
                T_4_1.num = wb.vec->data[1];
                err = _chanOPputc(T_4_1, c, CLU_0);
                if (err != ERR_ok) goto ex_1;
                }
                }}/* end if */
            break;
            }
    case 6: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(531);
            {
            CLUREF T_3_1;
            err = stringOPc2s(c, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            err = streamOPtty_put(tb, T_3_1, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
            break;
            }
    case 4: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        chars.num = T_2_4.num;

  LINE(533);
            {
            {
            if ((chars.array->int_low + chars.array->ext_size + 1) < chars.array->int_size) {
                chars.array->store->data[chars.array->int_low + chars.array->ext_size] = c.num;
                chars.array->ext_size++; chars.array->ext_high++;}
            else {
                err = arrayOPaddh(chars, c);
                if (err != ERR_ok) goto ex_1;}
            }
            }
            break;
            }
    case 3: 
         {
            break;
            }
    case 5: 
    case 2: 
    case 1: 
         {

  LINE(536);
            {
            elist[0] = STR_cannot_040write_040to_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(538);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) {

  LINE(539);
        {
        CLUREF T_2_1;
        err = stringOPc2s(c, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = streamOPscript(st, T_2_1, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE putc ****/

static int streamOPputc_image_own_init = 0;

/**** BEGIN PROCEDURE putc_image ****/

errcode streamOPputc_image(st, c)
CLUREF st;
CLUREF c;
    {
    errcode err;
    errcode ecode2;
    CLUREF wb;
    CLUREF low;
    CLUREF index;
    CLUREF tb;
    CLUREF chars;
        if (streamOPputc_image_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPputc_image_own_init = 1;
    }
    enter_proc(542);

  LINE(543);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 7: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(545);
            {
            CLUREF T_3_1;
            T_3_1.num = wb.vec->data[3];
            if (T_3_1.num == true) {

  LINE(546);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    CLUREF T_4_3;
                    CLUREF T_4_4;
                    CLUREF T_4_5;
                    CLUREF T_4_6;
                    T_4_1.num = wb.vec->data[1];
                    T_4_2.num = wb.vec->data[0];
                    T_4_3.num = wb.vec->data[2];
                    err = stringOPc2s(c, &T_4_4);
                    if (err != ERR_ok) goto ex_1;
                    err = _chanOPput(T_4_1, T_4_2, CLU_1, T_4_3, T_4_4, CLU_1, &T_4_5, &T_4_6);
                    if (err != ERR_ok) goto ex_1;
                    low.num = T_4_5.num;
                    index.num = T_4_6.num;
                    }
                    }

  LINE(549);
                {
                wb.vec->data[2]  = index.num;
                }
                }
            else {

  LINE(550);
                {
                CLUREF T_4_1;
                T_4_1.num = wb.vec->data[1];
                err = _chanOPputc(T_4_1, c, CLU_1);
                if (err != ERR_ok) goto ex_1;
                }
                }}/* end if */
            break;
            }
    case 6: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(553);
            {
            CLUREF T_3_1;
            err = stringOPc2s(c, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            err = streamOPtty_put(tb, T_3_1, CLU_1);
            if (err != ERR_ok) goto ex_1;
            }
            break;
            }
    case 4: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        chars.num = T_2_4.num;

  LINE(555);
            {
            {
            if ((chars.array->int_low + chars.array->ext_size + 1) < chars.array->int_size) {
                chars.array->store->data[chars.array->int_low + chars.array->ext_size] = c.num;
                chars.array->ext_size++; chars.array->ext_high++;}
            else {
                err = arrayOPaddh(chars, c);
                if (err != ERR_ok) goto ex_1;}
            }
            }
            break;
            }
    case 3: 
         {
            break;
            }
    case 5: 
    case 2: 
    case 1: 
         {

  LINE(558);
            {
            elist[0] = STR_cannot_040write_040to_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(560);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) {

  LINE(561);
        {
        CLUREF T_2_1;
        err = stringOPc2s(c, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = streamOPscript(st, T_2_1, CLU_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE putc_image ****/

static int streamOPget_lineno_own_init = 0;

/**** BEGIN PROCEDURE get_lineno ****/

errcode streamOPget_lineno(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF tb;
    CLUREF sb;
        if (streamOPget_lineno_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPget_lineno_own_init = 1;
    }
    enter_proc(564);

  LINE(565);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        rb.num = T_1_2.num;

  LINE(567);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = rb.vec->data[3];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 6: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        tb.num = T_1_3.num;

  LINE(569);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = tb.vec->data[13];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 2: 
         {CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        sb.num = T_1_4.num;

  LINE(571);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = sb.vec->data[2];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(573);
        {
        elist[0] = STR_no_040line_040numbers;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_lineno ****/


/**** BEGIN PROCEDURE set_lineno ****/

errcode streamOPset_lineno(st, ln)
CLUREF st;
CLUREF ln;
    {
    errcode err;
    errcode ecode2;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(577);
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_lineno ****/


/**** BEGIN PROCEDURE reset ****/

errcode streamOPreset(st)
CLUREF st;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF wb;
    CLUREF tb;
    CLUREF sb;
    CLUREF chars;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(580);

  LINE(581);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(583);
            {
            CLUREF T_3_1;
            T_3_1.num = rb.vec->data[1];
            err = _chanOPreset(T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(584);
            {
            rb.vec->data[3]  = 1;
            }

  LINE(585);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = rb.vec->data[4];
            T_3_2.num = T_3_1.num + 1;
             if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) || 
                 (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            rb.vec->data[2]  = T_3_2.num;
            }
            break;
            }
    case 7: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(587);
            {
            CLUREF T_3_1;
            T_3_1.num = wb.vec->data[1];
            err = _chanOPreset(T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(588);
            {
            wb.vec->data[2]  = 0;
            }
            break;
            }
    case 6: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        tb.num = T_2_4.num;

  LINE(590);
            {
            CLUREF T_3_1;
            T_3_1.num = tb.vec->data[2];
            err = _chanOPreset(T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(591);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_2.num = tb.vec->data[4];
            T_3_3.num = (T_3_2.num > 1)? true : false;
            T_3_1.num = T_3_3.num;
            if (!T_3_3.num) {
                T_3_4.num = tb.vec->data[7];
                T_3_1.num = T_3_4.num;
            }
            if (T_3_1.num == true) {

  LINE(592);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                T_5_1.num = tb.vec->data[2];
                T_5_2.ch = '\n';
                err = _chanOPputc(T_5_1, T_5_2, CLU_0);
                if (err != ERR_ok) goto ex_2;
                }
                    goto end_2;
                    ex_2:
                        if ((err == ERR_not_possible)) {
                        }
                        else {
                            goto ex_1;
                        }
                    end_2:;
                }
                }/* end if */

  LINE(595);
            {
            tb.vec->data[4]  = 1;
            }

  LINE(596);
            {
            tb.vec->data[11]  = 0;
            }

  LINE(597);
            {
            CLUREF T_3_1;
            T_3_1.num = tb.vec->data[18];
            err = arrayOPset_low(T_3_1, CLU_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(598);
            {
            CLUREF T_3_1;
            T_3_1.num = tb.vec->data[18];
            err = arrayOPtrim(T_3_1, CLU_1, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(599);
            {
            tb.vec->data[5]  = false;
            }

  LINE(600);
            {
            tb.vec->data[7]  = false;
            }

  LINE(601);
            {
            tb.vec->data[13]  = 1;
            }
            break;
            }
    case 2: 
         {CLUREF T_2_5;
        T_2_5.num = T_2_1.cell->value;
        sb.num = T_2_5.num;

  LINE(603);
            {
            sb.vec->data[1]  = 1;
            }

  LINE(604);
            {
            sb.vec->data[2]  = 1;
            }

  LINE(605);
            {
            CLUREF T_3_1;
            T_3_1.ch = ' ';
            sb.vec->data[3]  = T_3_1.num;
            }

  LINE(606);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            CLUREF T_4_6;
            CLUREF T_4_7;
            T_4_1.num = sb.vec->data[0];
            T_4_2.num = sb.vec->data[0];
            err = stringOPsize(T_4_2, &T_4_3);
            if (err != ERR_ok) goto ex_3;
            err = stringOPfetch(T_4_1, T_4_3, &T_4_4);
            if (err != ERR_ok) goto ex_3;
            T_4_5.ch = '\n';
            T_4_6.num = (T_4_4.ch == T_4_5.ch)? true : false;
            T_4_7.num = T_4_6.num ^ 1;
            if (T_4_7.num == true) {

  LINE(607);
                {
                CLUREF T_5_1;
                T_5_1.ch = '\n';
                sb.vec->data[3]  = T_5_1.num;
                }
                }
                }/* end if */
                goto end_3;
                ex_3:
                    if ((err == ERR_bounds)) {
                    }
                    else {
                        goto ex_1;
                    }
                end_3:;
            break;
            }
    case 4: 
         {CLUREF T_2_6;
        T_2_6.num = T_2_1.cell->value;
        chars.num = T_2_6.num;

  LINE(610);
            {
            err = arrayOPtrim(chars, CLU_1, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
            break;
            }
    case 3: 
    case 1: 
         {
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE reset ****/


/**** BEGIN PROCEDURE flush ****/

errcode streamOPflush(st)
CLUREF st;
    {
    errcode err;
    errcode ecode2;
    CLUREF wb;
    CLUREF tb;
    CLUREF scr;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(615);

  LINE(616);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 7: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(618);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = wb.vec->data[1];
            T_3_2.num = wb.vec->data[0];
            T_3_3.num = wb.vec->data[2];
            err = _chanOPputb(T_3_1, T_3_2, CLU_1, T_3_3, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(619);
            {
            wb.vec->data[2]  = 0;
            }
            break;
            }
    case 6: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(621);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            T_3_1.num = tb.vec->data[2];
            T_3_2.num = tb.vec->data[1];
            T_3_3.num = tb.vec->data[4];
            T_3_4.num = tb.vec->data[11];
            T_3_5.num = tb.vec->data[10];
            err = _chanOPputb(T_3_1, T_3_2, T_3_3, T_3_4, T_3_5);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(622);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = tb.vec->data[11];
            T_3_2.num = T_3_1.num + 1;
             if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) || 
                 (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            tb.vec->data[4]  = T_3_2.num;
            }

  LINE(623);
            {
            tb.vec->data[10]  = false;
            }
            break;
            }
    case 5: 
    case 2: 
    case 4: 
    case 3: 
         {
            break;
            }
    case 1: 
         {

  LINE(626);
            {
            {signal (ERR_ok);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(628);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) {

  LINE(629);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
            T_3_1.num = st.vec->data[3];
            T_3_3.num = T_3_1.vec->size; 
            T_3_4 = T_3_1;
            for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                scr.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(630);
                {
                err = streamOPflush(scr);
                if (err != ERR_ok) goto ex_2;
                }
            }
        }
        end_inline_for_1:;
        goto end_2;
        ex_2:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_0;}
        end_2:;
        }
        }/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE flush ****/


/**** BEGIN PROCEDURE get_line_length ****/

errcode streamOPget_line_length(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(635);

  LINE(636);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(638);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = tb.vec->data[14];
            T_2_2.num = (T_2_1.num > 0)? true : false;
            if (T_2_2.num == true) {

  LINE(639);
                {
                {
                CLUREF T_3_1;
                T_3_1.num = tb.vec->data[14];
                ret_1->num = T_3_1.num;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */
            break;
            }
    default: {
    }
    }
    }

  LINE(642);
    {
    {signal (ERR_no_limit);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_line_length ****/


/**** BEGIN PROCEDURE get_page_length ****/

errcode streamOPget_page_length(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(645);

  LINE(646);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(648);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = tb.vec->data[16];
            T_2_2.num = (T_2_1.num > 0)? true : false;
            if (T_2_2.num == true) {

  LINE(649);
                {
                {
                CLUREF T_3_1;
                T_3_1.num = tb.vec->data[16];
                ret_1->num = T_3_1.num;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */
            break;
            }
    default: {
    }
    }
    }

  LINE(652);
    {
    {signal (ERR_no_limit);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_page_length ****/

static int streamOPget_date_own_init = 0;

/**** BEGIN PROCEDURE get_date ****/

errcode streamOPget_date(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF wb;
        if (streamOPget_date_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPget_date_own_init = 1;
    }
    enter_proc(655);

  LINE(656);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(658);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = rb.vec->data[1];
            err = _chanOPget_date(T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            ret_1->num = T_3_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 7: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(660);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = wb.vec->data[1];
            err = _chanOPget_date(T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            ret_1->num = T_3_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(662);
        {
        elist[0] = STR_cannot_040get_040date;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_date ****/

static int streamOPset_date_own_init = 0;

/**** BEGIN PROCEDURE set_date ****/

errcode streamOPset_date(st, ndate)
CLUREF st;
CLUREF ndate;
    {
    errcode err;
    errcode ecode2;
        if (streamOPset_date_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPset_date_own_init = 1;
    }
    enter_proc(666);

  LINE(667);
    {
    elist[0] = STR_cannot_040set_040date;
    {signal (ERR_not_possible);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_date ****/

static int streamOPget_name_own_init = 0;

/**** BEGIN PROCEDURE get_name ****/

errcode streamOPget_name(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (streamOPget_name_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPget_name_own_init = 1;
    }
    enter_proc(670);

  LINE(671);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 2: 
    case 4: 
         {

  LINE(673);
            {
            elist[0] = STR_no_040name_040for_040string_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    default: {

  LINE(675);
        {
        {
        CLUREF T_2_1;
        T_2_1.num = st.vec->data[1];
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_name ****/


/**** BEGIN PROCEDURE close ****/

errcode streamOPclose(st)
CLUREF st;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF wb;
    CLUREF tb;
    CLUREF opens;
    CLUREF i;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(679);

  LINE(680);
    {
    err = streamOPflush(st);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(682);
    {
    CLUREF T_3_1;
    T_3_1.num = st.vec->data[0];
    switch (T_3_1.cell->tag) {
    case 5: 
         {CLUREF T_3_2;
        T_3_2.num = T_3_1.cell->value;
        rb.num = T_3_2.num;

  LINE(684);
            {
            CLUREF T_4_1;
            T_4_1.num = rb.vec->data[1];
            err = _chanOPclose(T_4_1);
            if (err != ERR_ok) goto ex_3;
            }

  LINE(685);
            {
            CLUREF T_4_1;
            T_4_1.num = rb.vec->data[0];
            streamOPfreebuf.num = T_4_1.num;
            }

  LINE(686);
            {
            streamOPfree.tf = true;
            }
            break;
            }
    case 7: 
         {CLUREF T_3_3;
        T_3_3.num = T_3_1.cell->value;
        wb.num = T_3_3.num;

  LINE(688);
            {
            CLUREF T_4_1;
            T_4_1.num = wb.vec->data[1];
            err = _chanOPclose(T_4_1);
            if (err != ERR_ok) goto ex_3;
            }

  LINE(689);
            {
            CLUREF T_4_1;
            T_4_1.num = wb.vec->data[0];
            streamOPfreebuf.num = T_4_1.num;
            }

  LINE(690);
            {
            streamOPfree.tf = true;
            }
            break;
            }
    case 6: 
         {CLUREF T_3_4;
        T_3_4.num = T_3_1.cell->value;
        tb.num = T_3_4.num;

  LINE(692);
            {
            CLUREF T_4_1;
            T_4_1.num = tb.vec->data[2];
            err = _chanOPclose(T_4_1);
            if (err != ERR_ok) goto ex_3;
            }

  LINE(693);
            {
            CLUREF T_4_1;
            T_4_1.num = tb.vec->data[1];
            streamOPfreebuf.num = T_4_1.num;
            }

  LINE(694);
            {
            streamOPfree.tf = true;
            }
            break;
            }
    case 3: 
    case 2: 
    case 4: 
         {
            break;
            }
    case 1: 
         {

  LINE(697);
            {
            {signal (ERR_ok);}}
            break;
            }
    }
    }
    goto end_3;
    ex_3:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_2;}
    end_3:;
        goto end_2;
        ex_2:
            if ((err == ERR_permanent)) {

  LINE(699);
                {
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_2:;

  LINE(700);
    {
    CLUREF T_1_1;
    CellAlloc(1, nil, T_1_1);
    st.vec->data[0]  = T_1_1.num;
    }

  LINE(701);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    st.vec->data[3]  = T_1_1.num;
    }

  LINE(702);
    {
    st.vec->data[2]  = false;
    }

  LINE(703);
    {
        {CLUREF T_1_1;
        err = streamOPopen_streams(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        opens.num = T_1_1.num;
        }
        }

  LINE(704);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = opens.array->ext_high; 
        for (T_1_1.num = opens.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(705);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            if (i.num < opens.array->ext_low || i.num > opens.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = opens.array->store->data[i.num - opens.array->ext_low + opens.array->int_low];
            T_2_2.num = (st.num == T_2_1.num)? true : false;
            if (T_2_2.num == true) {

  LINE(706);
                {
                CLUREF T_4_1;
                err = arrayOPremh(opens, &T_4_1);
                if (err != ERR_ok) goto ex_4;
                {
                if (i.num < opens.array->ext_low || i.num > opens.array->ext_high) {
                    err = ERR_bounds;
                    goto ex_4;}
                opens.array->store->data[i.num + opens.array->int_low - opens.array->ext_low] = T_4_1.num;
                }
                }
                    goto end_4;
                    ex_4:
                        if ((err == ERR_bounds)) {
                        }
                        else {
                            goto ex_0;
                        }
                    end_4:;

  LINE(708);
                {
                {signal (ERR_ok);}}
                }
                }/* end if */
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE close ****/


/**** BEGIN PROCEDURE abort ****/

errcode streamOPabort(st)
CLUREF st;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF wb;
    CLUREF tb;
    CLUREF opens;
    CLUREF i;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(713);

  LINE(714);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(716);
            {
            CLUREF T_3_1;
            T_3_1.num = rb.vec->data[1];
            err = _chanOPabort(T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(717);
            {
            CLUREF T_3_1;
            T_3_1.num = rb.vec->data[0];
            streamOPfreebuf.num = T_3_1.num;
            }

  LINE(718);
            {
            streamOPfree.tf = true;
            }
            break;
            }
    case 7: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(720);
            {
            CLUREF T_3_1;
            T_3_1.num = wb.vec->data[1];
            err = _chanOPabort(T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(721);
            {
            CLUREF T_3_1;
            T_3_1.num = wb.vec->data[0];
            streamOPfreebuf.num = T_3_1.num;
            }

  LINE(722);
            {
            streamOPfree.tf = true;
            }
            break;
            }
    case 6: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        tb.num = T_2_4.num;

  LINE(724);
            {
            CLUREF T_3_1;
            T_3_1.num = tb.vec->data[2];
            err = _chanOPabort(T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(725);
            {
            CLUREF T_3_1;
            T_3_1.num = tb.vec->data[1];
            streamOPfreebuf.num = T_3_1.num;
            }

  LINE(726);
            {
            streamOPfree.tf = true;
            }
            break;
            }
    case 3: 
    case 2: 
    case 4: 
         {
            break;
            }
    case 1: 
         {

  LINE(729);
            {
            {signal (ERR_ok);}}
            break;
            }
    }
    }
        goto end_1;
        ex_1:
            if ((err == ERR_permanent)
             || (err == ERR_not_possible)) {

  LINE(730);
                {
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(731);
    {
    CLUREF T_1_1;
    CellAlloc(1, nil, T_1_1);
    st.vec->data[0]  = T_1_1.num;
    }

  LINE(732);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    st.vec->data[3]  = T_1_1.num;
    }

  LINE(733);
    {
    st.vec->data[2]  = false;
    }

  LINE(734);
    {
        {CLUREF T_1_1;
        err = streamOPopen_streams(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        opens.num = T_1_1.num;
        }
        }

  LINE(735);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = opens.array->ext_high; 
        for (T_1_1.num = opens.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(736);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            if (i.num < opens.array->ext_low || i.num > opens.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = opens.array->store->data[i.num - opens.array->ext_low + opens.array->int_low];
            T_2_2.num = (st.num == T_2_1.num)? true : false;
            if (T_2_2.num == true) {

  LINE(737);
                {
                CLUREF T_4_1;
                err = arrayOPremh(opens, &T_4_1);
                if (err != ERR_ok) goto ex_2;
                {
                if (i.num < opens.array->ext_low || i.num > opens.array->ext_high) {
                    err = ERR_bounds;
                    goto ex_2;}
                opens.array->store->data[i.num + opens.array->int_low - opens.array->ext_low] = T_4_1.num;
                }
                }
                    goto end_2;
                    ex_2:
                        if ((err == ERR_bounds)) {
                        }
                        else {
                            goto ex_0;
                        }
                    end_2:;

  LINE(739);
                {
                {signal (ERR_ok);}}
                }
                }/* end if */
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE abort ****/


/**** BEGIN PROCEDURE is_closed ****/

errcode streamOPis_closed(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(744);

  LINE(745);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = st.vec->data[0];
    if (T_1_1.cell->tag == 1) T_1_2.num = true; else T_1_2.num = false;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE is_closed ****/


/**** BEGIN PROCEDURE is_terminal ****/

errcode streamOPis_terminal(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(748);

  LINE(749);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = st.vec->data[0];
    if (T_1_1.cell->tag == 6) T_1_2.num = true; else T_1_2.num = false;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE is_terminal ****/

static int streamOPgetl_own_init = 0;

/**** BEGIN PROCEDURE getl ****/

errcode streamOPgetl(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF line;
    CLUREF rb;
    CLUREF index;
    CLUREF tb;
    CLUREF sb;
        if (streamOPgetl_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPgetl_own_init = 1;
    }
    enter_proc(752);

  LINE(754);
    {
        {CLUREF T_2_1;
        err = streamOPgets(st, STR__012, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        line.num = T_2_1.num;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
        else if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(756);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        rb.num = T_1_2.num;

  LINE(758);
            {
                {CLUREF T_2_1;
                T_2_1.num = rb.vec->data[2];
                index.num = T_2_1.num;
                }
                }

  LINE(759);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = rb.vec->data[4];
            T_2_2.num = (index.num > T_2_1.num)? true : false;
            if (T_2_2.num == true) {

  LINE(760);
                {
                {
                ret_1->num = line.num;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */

  LINE(761);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = rb.vec->data[3];
            T_2_2.num = T_2_1.num + 1;
             if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
                 (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            rb.vec->data[3]  = T_2_2.num;
            }

  LINE(762);
            {
            CLUREF T_2_1;
            T_2_1.num = index.num + 1;
             if ((T_2_1.num > 0 && index.num < 0 && 1 < 0) || 
                 (T_2_1.num < 0 && index.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            rb.vec->data[2]  = T_2_1.num;
            }
            break;
            }
    case 6: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        tb.num = T_1_3.num;

  LINE(764);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = tb.vec->data[18];
            err = arrayOPreml(T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_2;
            }
                goto end_2;
                ex_2:
                    if ((err == ERR_bounds)) {

  LINE(765);
                        {
                        {
                        ret_1->num = line.num;
                        }
                        {signal (ERR_ok);}}
                    }
                    else {
                        goto ex_0;
                    }
                end_2:;

  LINE(766);
            {
            CLUREF T_3_1;
            T_3_1.num = tb.vec->data[5];
            if (T_3_1.num == true) {

  LINE(767);
                {
                tb.vec->data[5]  = false;
                }

  LINE(768);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = tb.vec->data[2];
                T_4_2.ch = '\n';
                err = _chanOPputc(T_4_1, T_4_2, CLU_0);
                if (err != ERR_ok) goto ex_3;
                }
                }
                }/* end if */
                goto end_3;
                ex_3:
                    if ((err == ERR_not_possible)) {
                    }
                    else {
                        goto ex_0;
                    }
                end_3:;

  LINE(770);
            {
            tb.vec->data[11]  = 0;
            }

  LINE(771);
            {
            tb.vec->data[4]  = 1;
            }
            break;
            }
    case 2: 
         {CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        sb.num = T_1_4.num;

  LINE(773);
            {
                {CLUREF T_2_1;
                T_2_1.num = sb.vec->data[1];
                index.num = T_2_1.num;
                }
                }

  LINE(774);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            T_2_1.num = sb.vec->data[0];
            err = stringOPsize(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            T_2_3.num = (index.num > T_2_2.num)? true : false;
            if (T_2_3.num == true) {

  LINE(775);
                {
                CLUREF T_3_1;
                T_3_1.ch = ' ';
                sb.vec->data[3]  = T_3_1.num;
                }

  LINE(776);
                {
                {
                ret_1->num = line.num;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */

  LINE(778);
            {
            CLUREF T_2_1;
            T_2_1.num = index.num + 1;
             if ((T_2_1.num > 0 && index.num < 0 && 1 < 0) || 
                 (T_2_1.num < 0 && index.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            sb.vec->data[1]  = T_2_1.num;
            }

  LINE(779);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = sb.vec->data[2];
            T_2_2.num = T_2_1.num + 1;
             if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
                 (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            sb.vec->data[2]  = T_2_2.num;
            }
            break;
            }
    default: {
    }
    }
    }

  LINE(782);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) {

  LINE(783);
        {
        err = streamOPscript(st, STR__012, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(784);
    {
    {
    ret_1->num = line.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE getl ****/


/**** BEGIN PROCEDURE putl ****/

errcode streamOPputl(st, line)
CLUREF st;
CLUREF line;
    {
    errcode err;
    errcode ecode2;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(787);

  LINE(788);
    {

  LINE(789);
        {
        err = streamOPputs(st, line);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(790);
        {
        CLUREF T_3_1;
        T_3_1.ch = '\n';
        err = streamOPputc(st, T_3_1);
        if (err != ERR_ok) goto ex_1;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE putl ****/

static int streamOPgets_own_init = 0;

/**** BEGIN PROCEDURE gets ****/

errcode streamOPgets(st, term, ret_1)
CLUREF st;
CLUREF term;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
    CLUREF rb;
    CLUREF index;
    CLUREF max;
    CLUREF i;
    CLUREF tb;
    CLUREF sb;
        if (streamOPgets_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPgets_own_init = 1;
    }
    enter_proc(794);

  LINE(797);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(800);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            CLUREF T_3_6;
            CLUREF T_3_7;
            T_3_1.num = rb.vec->data[1];
            T_3_2.num = rb.vec->data[0];
            T_3_3.num = rb.vec->data[2];
            T_3_4.num = rb.vec->data[4];
            err = _chanOPget(T_3_1, T_3_2, T_3_3, T_3_4, term, CLU_0, &T_3_5, &T_3_6, &T_3_7);
            if (err != ERR_ok) goto ex_1;
            s.num = T_3_5.num;
            index.num = T_3_6.num;
            max.num = T_3_7.num;
            }

  LINE(802);
            {
            rb.vec->data[2]  = index.num;
            }

  LINE(803);
            {
            rb.vec->data[4]  = max.num;
            }

  LINE(804);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.ch = '\n';
            err = stringOPindexc(T_3_1, term, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            T_3_3.num = (T_3_2.num == 0)? true : false;
            if (T_3_3.num == true) {

  LINE(805);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    T_4_1.ch = '\n';
                    err = stringOPindexc(T_4_1, s, &T_4_2);
                    if (err != ERR_ok) goto ex_1;
                    i.num = T_4_2.num;
                    }
                    }

  LINE(806);
                {
                CLUREF T_4_1;
                T_4_1.num = (i.num > 0)? true : false;
                if (T_4_1.num == true) {

  LINE(807);
                    {
                    CLUREF T_5_1;
                    CLUREF T_5_2;
                    CLUREF T_5_3;
                    T_5_1.num = rb.vec->data[3];
                    err = streamOPlines(s, i, &T_5_2);
                    if (err != ERR_ok) goto ex_1;
                    T_5_3.num = T_5_1.num + T_5_2.num;
                     if ((T_5_3.num > 0 && T_5_1.num < 0 && T_5_2.num < 0) || 
                         (T_5_3.num < 0 && T_5_1.num > 0 && T_5_2.num > 0)) {
                        err = ERR_overflow;
                        goto ex_1;}
                    rb.vec->data[3]  = T_5_3.num;
                    }
                    }
                    }/* end if */
                }
                }/* end if */
            break;
            }
    case 6: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(810);
            {
            err = streamOPflush(st);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(811);
            {
            CLUREF T_3_1;
            T_3_1.num = tb.vec->data[9];
            if (T_3_1.num == true) {

  LINE(812);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                CLUREF T_4_4;
                CLUREF T_4_5;
                CLUREF T_4_6;
                T_4_2.num = st.vec->data[2];
                T_4_1.num = T_4_2.num;
                if (T_4_2.num) {
                    T_4_4.num = tb.vec->data[11];
                    T_4_5.num = (T_4_4.num == 0)? true : false;
                    T_4_3.num = T_4_5.num;
                    if (!T_4_5.num) {
                        T_4_6.num = tb.vec->data[10];
                        T_4_3.num = T_4_6.num;
                    }
                    T_4_1.num = T_4_3.num;
                }
                if (T_4_1.num == true) {

  LINE(813);
                    {
                    CLUREF T_5_1;
                    T_5_1.num = tb.vec->data[17];
                    err = streamOPscript(st, T_5_1, CLU_0);
                    if (err != ERR_ok) goto ex_1;
                    }
                    }
                    }/* end if */

  LINE(814);
                {
                CLUREF T_4_1;
                err = streamOPedit(tb, term, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                s.num = T_4_1.num;
                }
                }
            else {

  LINE(815);
                {
                CLUREF T_4_1;
                err = streamOPtty_get(tb, term, CLU_0, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                s.num = T_4_1.num;
                }
                }}/* end if */
            break;
            }
    case 2: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        sb.num = T_2_4.num;

  LINE(818);
            {
            CLUREF T_3_1;
            err = streamOPstr_get(sb, term, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            s.num = T_3_1.num;
            }
            break;
            }
    case 3: 
         {

  LINE(820);
            {
            {signal (ERR_end_of_file);}}
            break;
            }
    case 7: 
    case 4: 
    case 1: 
         {

  LINE(822);
            {
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
        else if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(824);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) {

  LINE(825);
        {
        err = streamOPscript(st, s, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(826);
    {
    {
    ret_1->num = s.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE gets ****/

static int streamOPgets_image_own_init = 0;

/**** BEGIN PROCEDURE gets_image ****/

errcode streamOPgets_image(st, term, ret_1)
CLUREF st;
CLUREF term;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
    CLUREF rb;
    CLUREF index;
    CLUREF max;
    CLUREF i;
    CLUREF tb;
    CLUREF sb;
        if (streamOPgets_image_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPgets_image_own_init = 1;
    }
    enter_proc(829);

  LINE(832);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(835);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            CLUREF T_3_6;
            CLUREF T_3_7;
            T_3_1.num = rb.vec->data[1];
            T_3_2.num = rb.vec->data[0];
            T_3_3.num = rb.vec->data[2];
            T_3_4.num = rb.vec->data[4];
            err = _chanOPget(T_3_1, T_3_2, T_3_3, T_3_4, term, CLU_1, &T_3_5, &T_3_6, &T_3_7);
            if (err != ERR_ok) goto ex_1;
            s.num = T_3_5.num;
            index.num = T_3_6.num;
            max.num = T_3_7.num;
            }

  LINE(837);
            {
            rb.vec->data[2]  = index.num;
            }

  LINE(838);
            {
            rb.vec->data[4]  = max.num;
            }

  LINE(839);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.ch = '\n';
            err = stringOPindexc(T_3_1, term, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            T_3_3.num = (T_3_2.num == 0)? true : false;
            if (T_3_3.num == true) {

  LINE(840);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    T_4_1.ch = '\n';
                    err = stringOPindexc(T_4_1, s, &T_4_2);
                    if (err != ERR_ok) goto ex_1;
                    i.num = T_4_2.num;
                    }
                    }

  LINE(841);
                {
                CLUREF T_4_1;
                T_4_1.num = (i.num > 0)? true : false;
                if (T_4_1.num == true) {

  LINE(842);
                    {
                    CLUREF T_5_1;
                    CLUREF T_5_2;
                    CLUREF T_5_3;
                    T_5_1.num = rb.vec->data[3];
                    err = streamOPlines(s, i, &T_5_2);
                    if (err != ERR_ok) goto ex_1;
                    T_5_3.num = T_5_1.num + T_5_2.num;
                     if ((T_5_3.num > 0 && T_5_1.num < 0 && T_5_2.num < 0) || 
                         (T_5_3.num < 0 && T_5_1.num > 0 && T_5_2.num > 0)) {
                        err = ERR_overflow;
                        goto ex_1;}
                    rb.vec->data[3]  = T_5_3.num;
                    }
                    }
                    }/* end if */
                }
                }/* end if */
            break;
            }
    case 6: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(845);
            {
            err = streamOPflush(st);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(846);
            {
            CLUREF T_3_1;
            err = streamOPtty_get(tb, term, CLU_1, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            s.num = T_3_1.num;
            }
            break;
            }
    case 2: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        sb.num = T_2_4.num;

  LINE(848);
            {
            CLUREF T_3_1;
            err = streamOPstr_get(sb, term, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            s.num = T_3_1.num;
            }
            break;
            }
    case 3: 
         {

  LINE(850);
            {
            {signal (ERR_end_of_file);}}
            break;
            }
    case 7: 
    case 4: 
    case 1: 
         {

  LINE(852);
            {
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
        else if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(854);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) {

  LINE(855);
        {
        err = streamOPscript(st, s, CLU_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(856);
    {
    {
    ret_1->num = s.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE gets_image ****/


/**** BEGIN PROCEDURE tty_get1 ****/

errcode streamOPtty_get1(tb, image, ret_1)
CLUREF tb;
CLUREF image;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF c;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(859);

  LINE(861);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = tb.vec->data[7];
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        T_1_3.num = tb.vec->data[8];
        T_1_1.num = T_1_3.num;
    }
    if (T_1_1.num == true) {

  LINE(862);
        {
        {signal (ERR_end_of_file);}}
        }
        }/* end if */

  LINE(864);
    {
    CLUREF T_3_1;
    CLUREF T_3_2;
    CLUREF T_3_3;
    T_3_1.num = tb.vec->data[18];
    T_3_2.num = (T_3_1.array->ext_size == 0)? true : false;
    T_3_3.num = T_3_2.num ^ 1;
    if (T_3_3.num == true) {

  LINE(865);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        T_4_1.num = tb.vec->data[18];
        err = arrayOPreml(T_4_1, &T_4_2);
        if (err != ERR_ok) goto ex_2;
        c.num = T_4_2.num;
        }

  LINE(866);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_2.num = tb.vec->data[5];
        T_4_1.num = T_4_2.num;
        if (T_4_2.num) {
            T_4_3.num = image.num ^ 1;
            T_4_1.num = T_4_3.num;
        }
        if (T_4_1.num == true) {

  LINE(867);
            {
            CLUREF T_5_1;
            T_5_1.num = tb.vec->data[2];
            err = streamOPecho(T_5_1, c);
            if (err != ERR_ok) goto ex_2;
            }
            }
            }/* end if */

  LINE(868);
        {
        tb.vec->data[5]  = false;
        }
        }
    else {

  LINE(869);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        T_4_1.num = tb.vec->data[2];
        err = _chanOPgetc(T_4_1, image, &T_4_2);
        if (err != ERR_ok) goto ex_2;
        c.num = T_4_2.num;
        }
        }}/* end if */
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_1;}
    end_2:;
        goto end_1;
        ex_1:
            if ((err == ERR_end_of_file)) {

  LINE(873);
                {
                tb.vec->data[7]  = true;
                }

  LINE(874);
                {
                {signal (ERR_end_of_file);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(876);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = '\n';
    T_1_2.num = (c.ch == T_1_1.ch)? true : false;
    if (T_1_2.num == true) {

  LINE(877);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[13];
        T_2_2.num = T_2_1.num + 1;
         if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
             (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        tb.vec->data[13]  = T_2_2.num;
        }

  LINE(878);
        {
        {
        ret_1->num = c.num;
        }
        {signal (ERR_ok);}}
        }
    else {
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    T_1_4.ch = '\004';
    T_1_5.num = (c.ch == T_1_4.ch)? true : false;
    T_1_3.num = T_1_5.num;
    if (T_1_5.num) {
        T_1_6.num = tb.vec->data[8];
        T_1_3.num = T_1_6.num;
    }
    T_1_7.num = T_1_3.num ^ 1;
    if (T_1_7.num == true) {

  LINE(880);
        {
        {
        ret_1->num = c.num;
        }
        {signal (ERR_ok);}}
        }
        }}/* end if */

  LINE(881);
    {
    tb.vec->data[7]  = true;
    }

  LINE(882);
    {
    {signal (ERR_end_of_file);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE tty_get1 ****/

static int streamOPtty_get_own_init = 0;
CLUREF streamOPtty_getOPtmp;
CLUREF streamOPtty_getOPinuse;

/**** BEGIN PROCEDURE tty_get ****/

errcode streamOPtty_get(tb, term, image, ret_1)
CLUREF tb;
CLUREF term;
CLUREF image;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF temp;
    CLUREF used;
    CLUREF c;
    CLUREF s;
        if (streamOPtty_get_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPtty_get_own_init = 1;
        {
            {CLUREF T_0_1;
            err = arrayOPnew(&T_0_1);
            if (err != ERR_ok) goto ex_0;
            streamOPtty_getOPtmp.num = T_0_1.num;
            }
            }
        {
            {streamOPtty_getOPinuse.tf = false;
            }
            }
    }
    enter_proc(885);

  LINE(889);
    {
        {temp.num = streamOPtty_getOPtmp.num;
        }
        }

  LINE(890);
    {
        {used.num = streamOPtty_getOPinuse.num;
        }
        }

  LINE(891);
    {
    streamOPtty_getOPinuse.tf = true;
    }

  LINE(892);
    {
    if (used.num == true) {

  LINE(893);
        {
        CLUREF T_2_1;
        err = arrayOPnew(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        temp.num = T_2_1.num;
        }
        }
    else {

  LINE(894);
        {
        err = arrayOPtrim(temp, CLU_1, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(896);
    for (;;) {
        if (true != true) { break; }

  LINE(897);
        {
            {CLUREF T_4_1;
            err = streamOPtty_get1(tb, image, &T_4_1);
            if (err != ERR_ok) goto ex_2;
            c.num = T_4_1.num;
            }
            }

  LINE(898);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        err = stringOPindexc(c, term, &T_4_1);
        if (err != ERR_ok) goto ex_2;
        T_4_2.num = (T_4_1.num > 0)? true : false;
        if (T_4_2.num == true) {

  LINE(899);
            {
            CLUREF T_5_1;
            T_5_1.num = tb.vec->data[18];
            err = arrayOPaddl(T_5_1, c);
            if (err != ERR_ok) goto ex_2;
            }

  LINE(900);
            goto end_while_1;
            }
            }/* end if */

  LINE(902);
        {
        CLUREF T_4_1;
        T_4_1.num = image.num ^ 1;
        if (T_4_1.num == true) {

  LINE(903);
            {
            err = streamOPtty_put1(tb, c);
            if (err != ERR_ok) goto ex_2;
            }
            }
            }/* end if */

  LINE(904);
        {
        {
        if ((temp.array->int_low + temp.array->ext_size + 1) < temp.array->int_size) {
            temp.array->store->data[temp.array->int_low + temp.array->ext_size] = c.num;
            temp.array->ext_size++; temp.array->ext_high++;}
        else {
            err = arrayOPaddh(temp, c);
            if (err != ERR_ok) goto ex_2;}
        }
        }
        }
        end_while_1:;
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_1;}
    end_2:;
        goto end_1;
        ex_1:
            if ((err == ERR_end_of_file)) {

  LINE(907);
                {
                CLUREF T_2_1;
                T_2_1.num = (temp.array->ext_size == 0)? true : false;
                if (T_2_1.num == true) {

  LINE(908);
                    {
                    streamOPtty_getOPinuse.num = used.num;
                    }

  LINE(909);
                    {
                    {signal (ERR_end_of_file);}}
                    }
                    }/* end if */
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(912);
    {
        {CLUREF T_1_1;
        err = stringOPac2s(temp, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        s.num = T_1_1.num;
        }
        }

  LINE(913);
    {
    err = arrayOPtrim(temp, CLU_1, CLU_0);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(914);
    {
    streamOPtty_getOPinuse.num = used.num;
    }

  LINE(915);
    {
    {
    ret_1->num = s.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE tty_get ****/

static int streamOPstr_get_own_init = 0;

/**** BEGIN PROCEDURE str_get ****/

errcode streamOPstr_get(sb, term, ret_1)
CLUREF sb;
CLUREF term;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF first;
    CLUREF chars;
    CLUREF last;
    CLUREF s;
        if (streamOPstr_get_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPstr_get_own_init = 1;
    }
    enter_proc(918);

  LINE(919);
    {
        {CLUREF T_1_1;
        T_1_1.num = sb.vec->data[1];
        first.num = T_1_1.num;
        }
        }

  LINE(920);
    {
        {CLUREF T_1_1;
        T_1_1.num = sb.vec->data[0];
        chars.num = T_1_1.num;
        }
        }

  LINE(921);
    {
        {last.num = first.num;
        }
        }

  LINE(922);
    for (;;) {
        if (true != true) { break; }

  LINE(923);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        err = stringOPfetch(chars, last, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        err = stringOPindexc(T_3_1, term, &T_3_2);
        if (err != ERR_ok) goto ex_1;
        T_3_3.num = (T_3_2.num > 0)? true : false;
        if (T_3_3.num == true) {

  LINE(924);
            {
            sb.vec->data[1]  = last.num;
            }

  LINE(925);
            {
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = last.num - first.num;
             if ((T_4_1.num >= 0 && last.num < 0 && (-first.num) < 0) || 
                 (T_4_1.num <= 0 && last.num > 0 && (-first.num) > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            err = stringOPsubstr(chars, first, T_4_1, &T_4_2);
            if (err != ERR_ok) goto ex_1;
            ret_1->num = T_4_2.num;
            }
            {signal (ERR_ok);}}
            }
        else {
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        err = stringOPfetch(chars, last, &T_3_4);
        if (err != ERR_ok) goto ex_1;
        T_3_5.ch = '\n';
        T_3_6.num = (T_3_4.ch == T_3_5.ch)? true : false;
        if (T_3_6.num == true) {

  LINE(927);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = sb.vec->data[2];
            T_4_2.num = T_4_1.num + 1;
             if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) || 
                 (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            sb.vec->data[2]  = T_4_2.num;
            }
            }
            }}/* end if */

  LINE(928);
        {
        CLUREF T_3_1;
        T_3_1.num = last.num + 1;
         if ((T_3_1.num > 0 && last.num < 0 && 1 < 0) || 
             (T_3_1.num < 0 && last.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        last.num = T_3_1.num;
        }
        }
        end_while_1:;
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(931);
    {
    CLUREF T_1_1;
    T_1_1.num = (first.num == last.num)? true : false;
    if (T_1_1.num == true) {

  LINE(932);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = sb.vec->data[3];
        T_2_2.ch = ' ';
        T_2_3.num = (T_2_1.ch == T_2_2.ch)? true : false;
        if (T_2_3.num == true) {

  LINE(933);
            {
            {signal (ERR_end_of_file);}}
            }
            }/* end if */

  LINE(934);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.ch = '\n';
        err = stringOPindexc(T_2_1, term, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_3.num = (T_2_2.num > 0)? true : false;
        if (T_2_3.num == true) {

  LINE(935);
            {
            {
            ret_1->str = STR_.str;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(936);
        {
        CLUREF T_2_1;
        T_2_1.ch = ' ';
        sb.vec->data[3]  = T_2_1.num;
        }

  LINE(937);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = sb.vec->data[2];
        T_2_2.num = T_2_1.num + 1;
         if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
             (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        sb.vec->data[2]  = T_2_2.num;
        }

  LINE(938);
        {
        {
        ret_1->str = STR__012.str;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(940);
    {
    sb.vec->data[1]  = last.num;
    }

  LINE(941);
    {
        {CLUREF T_1_1;
        err = stringOPrest(chars, first, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        s.num = T_1_1.num;
        }
        }

  LINE(942);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.ch = '\n';
    err = stringOPindexc(T_1_1, term, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_3.num = (T_1_2.num == 0)? true : false;
    if (T_1_3.num == true) {

  LINE(943);
        {
        CLUREF T_2_1;
        T_2_1.ch = ' ';
        sb.vec->data[3]  = T_2_1.num;
        }

  LINE(944);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = sb.vec->data[2];
        T_2_2.num = T_2_1.num + 1;
         if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
             (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        sb.vec->data[2]  = T_2_2.num;
        }

  LINE(945);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.ch = '\n';
        err = stringOPappend(s, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        s.num = T_2_2.num;
        }
        }
        }/* end if */

  LINE(947);
    {
    {
    ret_1->num = s.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE str_get ****/

extern errcode streamOPputs_IB_1();
static int streamOPputs_own_init = 0;

/**** BEGIN PROCEDURE puts ****/

errcode streamOPputs(st, s)
CLUREF st;
CLUREF s;
    {
    struct {
        errcode err;
        errcode ecode2;
        CLUREF wb;
        CLUREF low;
        CLUREF index;
        CLUREF tb;
        CLUREF chars;
        CLUREF c;
        CLUREF st;
        CLUREF s;
        } locals;
    locals.st = st;
    locals.s = s;
        if (streamOPputs_own_init == 0) {
        if (stream_own_init == 0) {
            locals.err = stream_own_init_proc();
            if (locals.err != ERR_ok) goto ex_0;
            }
        streamOPputs_own_init = 1;
    }
    enter_proc(950);

  LINE(951);
    {
    CLUREF T_2_1;
    T_2_1.num = locals.st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 7: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        locals.wb.num = T_2_2.num;

  LINE(953);
            {
                {CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CLUREF T_3_4;
                CLUREF T_3_5;
                T_3_1.num = locals.wb.vec->data[1];
                T_3_2.num = locals.wb.vec->data[0];
                T_3_3.num = locals.wb.vec->data[2];
                locals.err = _chanOPput(T_3_1, T_3_2, CLU_1, T_3_3, locals.s, CLU_0, &T_3_4, &T_3_5);
                if (locals.err != ERR_ok) goto ex_1;
                locals.low.num = T_3_4.num;
                locals.index.num = T_3_5.num;
                }
                }

  LINE(955);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = locals.wb.vec->data[3];
            T_3_2.num = T_3_1.num ^ 1;
            if (T_3_2.num == true) {

  LINE(956);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = locals.wb.vec->data[1];
                T_4_2.num = locals.wb.vec->data[0];
                locals.err = _chanOPputb(T_4_1, T_4_2, CLU_1, locals.index, CLU_0);
                if (locals.err != ERR_ok) goto ex_1;
                }

  LINE(957);
                {
                locals.index.num = 0;
                }
                }
                }/* end if */

  LINE(959);
            {
            locals.wb.vec->data[2]  = locals.index.num;
            }
            break;
            }
    case 6: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        locals.tb.num = T_2_3.num;

  LINE(961);
            {
            locals.err = streamOPtty_put(locals.tb, locals.s, CLU_0);
            if (locals.err != ERR_ok) goto ex_1;
            }
            break;
            }
    case 4: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        locals.chars.num = T_2_4.num;

  LINE(963);
            {
                locals.err = stringOPchars(locals.s, streamOPputs_IB_1, &locals, &locals.ecode2);
                if (locals.err == ERR_iterbodyreturn) {
                signal(ERR_ok);}
                if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
                if (locals.err == ERR_break) locals.err = ERR_ok;
                if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
                if (locals.err != ERR_ok) goto ex_1;
                }
            break;
            }
    case 3: 
         {
            break;
            }
    case 5: 
    case 2: 
    case 1: 
         {

  LINE(968);
            {
            elist[0] = STR_cannot_040write_040to_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (locals.err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(970);
    {
    CLUREF T_1_1;
    T_1_1.num = locals.st.vec->data[2];
    if (T_1_1.num == true) {

  LINE(971);
        {
        locals.err = streamOPscript(locals.st, locals.s, CLU_0);
        if (locals.err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE puts ****/


/**** BEGIN ITERATOR BODIES for puts ****/

errcode streamOPputs_IB_1(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    errcode err;
    errcode ecode2;
    CLUREF wb;
    CLUREF low;
    CLUREF index;
    CLUREF tb;
    CLUREF chars;
    CLUREF c;
    CLUREF st;
    CLUREF s;
    } *locals;
{
    locals->c.num = iv_1.num;
    enter_iter_body_proc(964);

  FB_LINE(964);
    {
    {
    if ((locals->chars.array->int_low + locals->chars.array->ext_size + 1) < locals->chars.array->int_size) {
        locals->chars.array->store->data[locals->chars.array->int_low + locals->chars.array->ext_size] = locals->c.num;
        locals->chars.array->ext_size++; locals->chars.array->ext_high++;}
    else {
        locals->err = arrayOPaddh(locals->chars, locals->c);
        if (locals->err != ERR_ok) goto ex_0;}
    }
    }
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end streamOPputs_IB_1 */

/**** END ITERATOR BODIES for puts ****/

extern errcode streamOPputs_image_IB_1();
static int streamOPputs_image_own_init = 0;

/**** BEGIN PROCEDURE puts_image ****/

errcode streamOPputs_image(st, s)
CLUREF st;
CLUREF s;
    {
    struct {
        errcode err;
        errcode ecode2;
        CLUREF wb;
        CLUREF low;
        CLUREF index;
        CLUREF tb;
        CLUREF chars;
        CLUREF c;
        CLUREF st;
        CLUREF s;
        } locals;
    locals.st = st;
    locals.s = s;
        if (streamOPputs_image_own_init == 0) {
        if (stream_own_init == 0) {
            locals.err = stream_own_init_proc();
            if (locals.err != ERR_ok) goto ex_0;
            }
        streamOPputs_image_own_init = 1;
    }
    enter_proc(974);

  LINE(975);
    {
    CLUREF T_2_1;
    T_2_1.num = locals.st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 7: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        locals.wb.num = T_2_2.num;

  LINE(977);
            {
            CLUREF T_3_1;
            T_3_1.num = locals.wb.vec->data[3];
            if (T_3_1.num == true) {

  LINE(978);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    CLUREF T_4_3;
                    CLUREF T_4_4;
                    CLUREF T_4_5;
                    T_4_1.num = locals.wb.vec->data[1];
                    T_4_2.num = locals.wb.vec->data[0];
                    T_4_3.num = locals.wb.vec->data[2];
                    locals.err = _chanOPput(T_4_1, T_4_2, CLU_1, T_4_3, locals.s, CLU_1, &T_4_4, &T_4_5);
                    if (locals.err != ERR_ok) goto ex_1;
                    locals.low.num = T_4_4.num;
                    locals.index.num = T_4_5.num;
                    }
                    }

  LINE(980);
                {
                locals.wb.vec->data[2]  = locals.index.num;
                }
                }
            else {

  LINE(981);
                {
                CLUREF T_4_1;
                T_4_1.num = locals.wb.vec->data[1];
                locals.err = _chanOPputs(T_4_1, locals.s, CLU_1);
                if (locals.err != ERR_ok) goto ex_1;
                }
                }}/* end if */
            break;
            }
    case 6: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        locals.tb.num = T_2_3.num;

  LINE(984);
            {
            locals.err = streamOPtty_put(locals.tb, locals.s, CLU_1);
            if (locals.err != ERR_ok) goto ex_1;
            }
            break;
            }
    case 4: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        locals.chars.num = T_2_4.num;

  LINE(986);
            {
                locals.err = stringOPchars(locals.s, streamOPputs_image_IB_1, &locals, &locals.ecode2);
                if (locals.err == ERR_iterbodyreturn) {
                signal(ERR_ok);}
                if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
                if (locals.err == ERR_break) locals.err = ERR_ok;
                if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
                if (locals.err != ERR_ok) goto ex_1;
                }
            break;
            }
    case 3: 
         {
            break;
            }
    case 5: 
    case 2: 
    case 1: 
         {

  LINE(991);
            {
            elist[0] = STR_cannot_040write_040to_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (locals.err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(993);
    {
    CLUREF T_1_1;
    T_1_1.num = locals.st.vec->data[2];
    if (T_1_1.num == true) {

  LINE(994);
        {
        locals.err = streamOPscript(locals.st, locals.s, CLU_1);
        if (locals.err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE puts_image ****/


/**** BEGIN ITERATOR BODIES for puts_image ****/

errcode streamOPputs_image_IB_1(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    errcode err;
    errcode ecode2;
    CLUREF wb;
    CLUREF low;
    CLUREF index;
    CLUREF tb;
    CLUREF chars;
    CLUREF c;
    CLUREF st;
    CLUREF s;
    } *locals;
{
    locals->c.num = iv_1.num;
    enter_iter_body_proc(987);

  FB_LINE(987);
    {
    {
    if ((locals->chars.array->int_low + locals->chars.array->ext_size + 1) < locals->chars.array->int_size) {
        locals->chars.array->store->data[locals->chars.array->int_low + locals->chars.array->ext_size] = locals->c.num;
        locals->chars.array->ext_size++; locals->chars.array->ext_high++;}
    else {
        locals->err = arrayOPaddh(locals->chars, locals->c);
        if (locals->err != ERR_ok) goto ex_0;}
    }
    }
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end streamOPputs_image_IB_1 */

/**** END ITERATOR BODIES for puts_image ****/


/**** BEGIN PROCEDURE tty_put1 ****/

errcode streamOPtty_put1(tb, c)
CLUREF tb;
CLUREF c;
    {
    errcode err;
    errcode ecode2;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(997);

  LINE(998);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.ch = '\n';
    T_2_2.num = (c.ch == T_2_1.ch)? true : false;
    if (T_2_2.num == true) {

  LINE(999);
        {
        tb.vec->data[11]  = 0;
        }

  LINE(1000);
        {
        tb.vec->data[4]  = 1;
        }
        }
    else {

  LINE(1001);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = tb.vec->data[11];
        T_3_2.num = T_3_1.num + 1;
         if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) || 
             (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        tb.vec->data[11]  = T_3_2.num;
        }

  LINE(1002);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = tb.vec->data[1];
        T_3_2.num = tb.vec->data[11];
        err = _bytevecOPstore(T_3_1, T_3_2, c);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(1003);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = tb.vec->data[11];
        T_3_2.num = T_3_1.num + 1;
         if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) || 
             (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        tb.vec->data[4]  = T_3_2.num;
        }
        }}/* end if */
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {

  LINE(1004);
                {
                CLUREF T_2_1;
                CLUREF T_2_2;
                T_2_1.num = tb.vec->data[11];
                T_2_2.num = T_2_1.num - 1;
                 if ((T_2_2.num >= 0 && T_2_1.num < 0 && (-1) < 0) || 
                     (T_2_2.num <= 0 && T_2_1.num > 0 && (-1) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                tb.vec->data[11]  = T_2_2.num;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE tty_put1 ****/


/**** BEGIN PROCEDURE tty_put ****/

errcode streamOPtty_put(tb, s, image)
CLUREF tb;
CLUREF s;
CLUREF image;
    {
    errcode err;
    errcode ecode2;
    CLUREF disp;
    CLUREF index;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1007);

  LINE(1009);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = tb.vec->data[10];
    T_1_2.num = (image.tf == T_1_1.tf)? true : false;
    T_1_3.num = T_1_2.num ^ 1;
    if (T_1_3.num == true) {

  LINE(1010);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_1.num = tb.vec->data[2];
        T_2_2.num = tb.vec->data[1];
        T_2_3.num = tb.vec->data[4];
        T_2_4.num = tb.vec->data[11];
        T_2_5.num = tb.vec->data[10];
        err = _chanOPputb(T_2_1, T_2_2, T_2_3, T_2_4, T_2_5);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(1011);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[11];
        T_2_2.num = T_2_1.num + 1;
         if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
             (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        tb.vec->data[4]  = T_2_2.num;
        }

  LINE(1012);
        {
        tb.vec->data[10]  = image.num;
        }
        }
        }/* end if */

  LINE(1014);
    {
        {CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        T_2_1.num = tb.vec->data[2];
        T_2_2.num = tb.vec->data[1];
        T_2_3.num = tb.vec->data[4];
        T_2_4.num = tb.vec->data[11];
        err = _chanOPput(T_2_1, T_2_2, T_2_3, T_2_4, s, image, &T_2_5, &T_2_6);
        if (err != ERR_ok) goto ex_1;
        disp.num = T_2_5.num;
        index.num = T_2_6.num;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(1017);
    {
    tb.vec->data[11]  = index.num;
    }

  LINE(1018);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[15];
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(1019);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[2];
        T_2_2.num = tb.vec->data[1];
        err = _chanOPputb(T_2_1, T_2_2, disp, index, image);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(1020);
        {
        CLUREF T_2_1;
        T_2_1.num = index.num + 1;
         if ((T_2_1.num > 0 && index.num < 0 && 1 < 0) || 
             (T_2_1.num < 0 && index.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        disp.num = T_2_1.num;
        }
        }
        }/* end if */

  LINE(1022);
    {
    tb.vec->data[4]  = disp.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE tty_put ****/

extern errcode streamOPputzero_IB_1();

/**** BEGIN PROCEDURE putzero ****/

errcode streamOPputzero(st, s, size)
CLUREF st;
CLUREF s;
CLUREF size;
    {
    struct {
        errcode err;
        errcode ecode2;
        CLUREF not_inserted;
        CLUREF diff;
        CLUREF c;
        CLUREF st;
        CLUREF s;
        CLUREF size;
        } locals;
    locals.st = st;
    locals.s = s;
    locals.size = size;
        if (stream_own_init == 0) {
            locals.err = stream_own_init_proc();
            if (locals.err != ERR_ok) goto ex_0;
            }
    enter_proc(1025);

  LINE(1027);
    {
    CLUREF T_1_1;
    T_1_1.num = (locals.size.num < 0)? true : false;
    if (T_1_1.num == true) {

  LINE(1028);
        {
        {signal (ERR_negative_field_width);}}
        }
        }/* end if */

  LINE(1029);
    {
        {locals.not_inserted.tf = true;
        }
        }

  LINE(1030);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        locals.err = stringOPsize(locals.s, &T_1_1);
        if (locals.err != ERR_ok) goto ex_0;
        T_1_2.num = locals.size.num - T_1_1.num;
         if ((T_1_2.num >= 0 && locals.size.num < 0 && (-T_1_1.num) < 0) || 
             (T_1_2.num <= 0 && locals.size.num > 0 && (-T_1_1.num) > 0)) {
            locals.err = ERR_overflow;
            goto ex_0;}
        locals.diff.num = T_1_2.num;
        }
        }

  LINE(1031);
    {
        locals.err = stringOPchars(locals.s, streamOPputzero_IB_1, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {
        signal(ERR_ok);}
        if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
        if (locals.err == ERR_break) locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
        if (locals.err != ERR_ok) goto ex_1;
        }
    goto end_1;
    ex_1:
        if (locals.err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(1043);
    {
    if (locals.not_inserted.num == true) {

  LINE(1044);
        for (;;) {
            CLUREF T_3_1;
            T_3_1.num = (locals.diff.num > 0)? true : false;
            if (T_3_1.num != true) { break; }

  LINE(1045);
            {
            CLUREF T_4_1;
            T_4_1.ch = '0';
            locals.err = streamOPputc(locals.st, T_4_1);
            if (locals.err != ERR_ok) goto ex_2;
            }

  LINE(1046);
            {
            CLUREF T_4_1;
            T_4_1.num = locals.diff.num - 1;
             if ((T_4_1.num >= 0 && locals.diff.num < 0 && (-1) < 0) || 
                 (T_4_1.num <= 0 && locals.diff.num > 0 && (-1) > 0)) {
                locals.err = ERR_overflow;
                goto ex_2;}
            locals.diff.num = T_4_1.num;
            }
            }
            end_while_1:;
        goto end_2;
        ex_2:
            if (locals.err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_0;}
        end_2:;
        }
        }/* end if */
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE putzero ****/


/**** BEGIN ITERATOR BODIES for putzero ****/

errcode streamOPputzero_IB_1(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    errcode err;
    errcode ecode2;
    CLUREF not_inserted;
    CLUREF diff;
    CLUREF c;
    CLUREF st;
    CLUREF s;
    CLUREF size;
    } *locals;
{
    locals->c.num = iv_1.num;
    enter_iter_body_proc(1032);

  FB_LINE(1032);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    CLUREF T_1_8;
    CLUREF T_1_9;
    T_1_1.num = locals->not_inserted.num;
    if (locals->not_inserted.num) {
        T_1_3.ch = '.';
        T_1_4.num = (locals->c.ch == T_1_3.ch)? true : false;
        T_1_2.num = T_1_4.num;
        if (!T_1_4.num) {
            T_1_6.ch = '0';
            locals->err = charOPge(locals->c, T_1_6, &T_1_7);
            if (locals->err != ERR_ok) goto ex_0;
            T_1_5.num = T_1_7.num;
            if (T_1_7.num) {
                T_1_8.ch = '9';
                locals->err = charOPle(locals->c, T_1_8, &T_1_9);
                if (locals->err != ERR_ok) goto ex_0;
                T_1_5.num = T_1_9.num;
            }
            T_1_2.num = T_1_5.num;
        }
        T_1_1.num = T_1_2.num;
    }
    if (T_1_1.num == true) {

  FB_LINE(1034);
        {
        locals->not_inserted.tf = false;
        }

  FB_LINE(1035);
        for (;;) {
            CLUREF T_2_1;
            T_2_1.num = (locals->diff.num > 0)? true : false;
            if (T_2_1.num != true) { break; }

  FB_LINE(1036);
            {
            CLUREF T_3_1;
            T_3_1.ch = '0';
            locals->err = streamOPputc(locals->st, T_3_1);
            if (locals->err != ERR_ok) goto ex_0;
            }

  FB_LINE(1037);
            {
            CLUREF T_3_1;
            T_3_1.num = locals->diff.num - 1;
             if ((T_3_1.num >= 0 && locals->diff.num < 0 && (-1) < 0) || 
                 (T_3_1.num <= 0 && locals->diff.num > 0 && (-1) > 0)) {
                locals->err = ERR_overflow;
                goto ex_0;}
            locals->diff.num = T_3_1.num;
            }
            }
            end_while_2:;
        }
        }/* end if */

  FB_LINE(1040);
    {
    locals->err = streamOPputc(locals->st, locals->c);
    if (locals->err != ERR_ok) goto ex_0;
    }
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end streamOPputzero_IB_1 */

/**** END ITERATOR BODIES for putzero ****/


/**** BEGIN PROCEDURE putleft ****/

errcode streamOPputleft(st, s, size)
CLUREF st;
CLUREF s;
CLUREF size;
    {
    errcode err;
    errcode ecode2;
    CLUREF diff;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1052);

  LINE(1054);
    {
    CLUREF T_1_1;
    T_1_1.num = (size.num < 0)? true : false;
    if (T_1_1.num == true) {

  LINE(1055);
        {
        {signal (ERR_negative_field_width);}}
        }
        }/* end if */

  LINE(1056);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = stringOPsize(s, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = size.num - T_1_1.num;
         if ((T_1_2.num >= 0 && size.num < 0 && (-T_1_1.num) < 0) || 
             (T_1_2.num <= 0 && size.num > 0 && (-T_1_1.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        diff.num = T_1_2.num;
        }
        }

  LINE(1057);
    {

  LINE(1058);
        {
        err = streamOPputs(st, s);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(1059);
        {
        CLUREF T_3_1;
        T_3_1.num = (diff.num > 0)? true : false;
        if (T_3_1.num == true) {

  LINE(1060);
            {
            err = streamOPputspace(st, diff);
            if (err != ERR_ok) goto ex_1;
            }
            }
            }/* end if */
        }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE putleft ****/


/**** BEGIN PROCEDURE putright ****/

errcode streamOPputright(st, s, size)
CLUREF st;
CLUREF s;
CLUREF size;
    {
    errcode err;
    errcode ecode2;
    CLUREF diff;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1064);

  LINE(1066);
    {
    CLUREF T_1_1;
    T_1_1.num = (size.num < 0)? true : false;
    if (T_1_1.num == true) {

  LINE(1067);
        {
        {signal (ERR_negative_field_width);}}
        }
        }/* end if */

  LINE(1068);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = stringOPsize(s, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = size.num - T_1_1.num;
         if ((T_1_2.num >= 0 && size.num < 0 && (-T_1_1.num) < 0) || 
             (T_1_2.num <= 0 && size.num > 0 && (-T_1_1.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        diff.num = T_1_2.num;
        }
        }

  LINE(1069);
    {

  LINE(1070);
        {
        CLUREF T_3_1;
        T_3_1.num = (diff.num > 0)? true : false;
        if (T_3_1.num == true) {

  LINE(1071);
            {
            err = streamOPputspace(st, diff);
            if (err != ERR_ok) goto ex_1;
            }
            }
            }/* end if */

  LINE(1072);
        {
        err = streamOPputs(st, s);
        if (err != ERR_ok) goto ex_1;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE putright ****/


/**** BEGIN PROCEDURE putspace ****/

errcode streamOPputspace(st, len)
CLUREF st;
CLUREF len;
    {
    errcode err;
    errcode ecode2;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1076);

  LINE(1078);
    {
    CLUREF T_1_1;
    T_1_1.num = (len.num < 0)? true : false;
    if (T_1_1.num == true) {

  LINE(1079);
        {
        {signal (ERR_negative_field_width);}}
        }
        }/* end if */

  LINE(1080);
    for (;;) {
        CLUREF T_2_1;
        T_2_1.num = (len.num > 0)? true : false;
        if (T_2_1.num != true) { break; }

  LINE(1081);
        {
        CLUREF T_3_1;
        T_3_1.ch = ' ';
        err = streamOPputc(st, T_3_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(1082);
        {
        CLUREF T_3_1;
        T_3_1.num = len.num - 1;
         if ((T_3_1.num >= 0 && len.num < 0 && (-1) < 0) || 
             (T_3_1.num <= 0 && len.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        len.num = T_3_1.num;
        }
        }
        end_while_1:;
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE putspace ****/

static int streamOPcreate_input_own_init = 0;

/**** BEGIN PROCEDURE create_input ****/

errcode streamOPcreate_input(s, ret_1)
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF newln;
        if (streamOPcreate_input_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPcreate_input_own_init = 1;
    }
    enter_proc(1087);

  LINE(1088);
    {
        {CLUREF T_1_1;
        T_1_1.ch = ' ';
        newln.num = T_1_1.num;
        }
        }

  LINE(1089);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    CLUREF T_2_4;
    CLUREF T_2_5;
    err = stringOPsize(s, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    err = stringOPfetch(s, T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    T_2_3.ch = '\n';
    T_2_4.num = (T_2_2.ch == T_2_3.ch)? true : false;
    T_2_5.num = T_2_4.num ^ 1;
    if (T_2_5.num == true) {

  LINE(1090);
        {
        CLUREF T_3_1;
        T_3_1.ch = '\n';
        newln.num = T_3_1.num;
        }
        }
        }/* end if */
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(1092);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    RecordAlloc(4, T_1_1);
    err = file_nameOPparse(STR_, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[1]  = T_1_2.num;
    err = sequenceOPnew(&T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[3]  = T_1_3.num;
    T_1_1.vec->data[2]  = false;
    RecordAlloc(4, T_1_4);
    T_1_4.vec->data[0]  = s.num;
    T_1_4.vec->data[1]  = 1;
    T_1_4.vec->data[2]  = 1;
    T_1_4.vec->data[3]  = newln.num;
    CellAlloc(2, T_1_4.num, T_1_5);
    T_1_1.vec->data[0]  = T_1_5.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE create_input ****/

static int streamOPcreate_output_own_init = 0;

/**** BEGIN PROCEDURE create_output ****/

errcode streamOPcreate_output(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (streamOPcreate_output_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPcreate_output_own_init = 1;
    }
    enter_proc(1101);

  LINE(1102);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    RecordAlloc(4, T_1_1);
    err = file_nameOPparse(STR_, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[1]  = T_1_2.num;
    err = sequenceOPnew(&T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[3]  = T_1_3.num;
    T_1_1.vec->data[2]  = false;
    err = arrayOPnew(&T_1_4);
    if (err != ERR_ok) goto ex_0;
    CellAlloc(4, T_1_4.num, T_1_5);
    T_1_1.vec->data[0]  = T_1_5.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE create_output ****/

static int streamOPget_contents_own_init = 0;

/**** BEGIN PROCEDURE get_contents ****/

errcode streamOPget_contents(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF chars;
        if (streamOPget_contents_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPget_contents_own_init = 1;
    }
    enter_proc(1108);

  LINE(1109);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 4: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        chars.num = T_1_2.num;

  LINE(1111);
            {
            {
            CLUREF T_2_1;
            err = stringOPac2s(chars, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(1113);
        {
        elist[0] = STR_not_040a_040string_040output_040stream;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_contents ****/

static int streamOPgetbuf_own_init = 0;

/**** BEGIN PROCEDURE getbuf ****/

errcode streamOPgetbuf(st, term, ret_1)
CLUREF st;
CLUREF term;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
    CLUREF rb;
    CLUREF index;
    CLUREF max;
    CLUREF i;
    CLUREF tb;
    CLUREF sb;
        if (streamOPgetbuf_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPgetbuf_own_init = 1;
    }
    enter_proc(1117);

  LINE(1120);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 5: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(1123);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            CLUREF T_3_6;
            CLUREF T_3_7;
            T_3_1.num = rb.vec->data[1];
            T_3_2.num = rb.vec->data[0];
            T_3_3.num = rb.vec->data[2];
            T_3_4.num = rb.vec->data[4];
            err = _chanOPget(T_3_1, T_3_2, T_3_3, T_3_4, term, CLU_0, &T_3_5, &T_3_6, &T_3_7);
            if (err != ERR_ok) goto ex_1;
            s.num = T_3_5.num;
            index.num = T_3_6.num;
            max.num = T_3_7.num;
            }

  LINE(1125);
            {
            rb.vec->data[2]  = index.num;
            }

  LINE(1126);
            {
            rb.vec->data[4]  = max.num;
            }

  LINE(1127);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.ch = '\n';
            err = stringOPindexc(T_3_1, term, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            T_3_3.num = (T_3_2.num == 0)? true : false;
            if (T_3_3.num == true) {

  LINE(1128);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    T_4_1.ch = '\n';
                    err = stringOPindexc(T_4_1, s, &T_4_2);
                    if (err != ERR_ok) goto ex_1;
                    i.num = T_4_2.num;
                    }
                    }

  LINE(1129);
                {
                CLUREF T_4_1;
                T_4_1.num = (i.num > 0)? true : false;
                if (T_4_1.num == true) {

  LINE(1130);
                    {
                    CLUREF T_5_1;
                    CLUREF T_5_2;
                    CLUREF T_5_3;
                    T_5_1.num = rb.vec->data[3];
                    err = streamOPlines(s, i, &T_5_2);
                    if (err != ERR_ok) goto ex_1;
                    T_5_3.num = T_5_1.num + T_5_2.num;
                     if ((T_5_3.num > 0 && T_5_1.num < 0 && T_5_2.num < 0) || 
                         (T_5_3.num < 0 && T_5_1.num > 0 && T_5_2.num > 0)) {
                        err = ERR_overflow;
                        goto ex_1;}
                    rb.vec->data[3]  = T_5_3.num;
                    }
                    }
                    }/* end if */
                }
                }/* end if */
            break;
            }
    case 6: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(1133);
            {
            err = streamOPflush(st);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(1134);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            CLUREF T_3_6;
            T_3_2.num = st.vec->data[2];
            T_3_1.num = T_3_2.num;
            if (T_3_2.num) {
                T_3_4.num = tb.vec->data[11];
                T_3_5.num = (T_3_4.num == 0)? true : false;
                T_3_3.num = T_3_5.num;
                if (!T_3_5.num) {
                    T_3_6.num = tb.vec->data[10];
                    T_3_3.num = T_3_6.num;
                }
                T_3_1.num = T_3_3.num;
            }
            if (T_3_1.num == true) {

  LINE(1135);
                {
                CLUREF T_4_1;
                T_4_1.num = tb.vec->data[17];
                err = streamOPscript(st, T_4_1, CLU_0);
                if (err != ERR_ok) goto ex_1;
                }
                }
                }/* end if */

  LINE(1136);
            {
            CLUREF T_3_1;
            err = streamOPedit(tb, term, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            s.num = T_3_1.num;
            }
            break;
            }
    case 2: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        sb.num = T_2_4.num;

  LINE(1138);
            {
            CLUREF T_3_1;
            err = streamOPstr_get(sb, term, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            s.num = T_3_1.num;
            }
            break;
            }
    case 3: 
         {

  LINE(1140);
            {
            {signal (ERR_end_of_file);}}
            break;
            }
    case 7: 
    case 4: 
    case 1: 
         {

  LINE(1142);
            {
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
        else if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(1144);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[2];
    if (T_1_1.num == true) {

  LINE(1145);
        {
        err = streamOPscript(st, s, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(1146);
    {
    {
    ret_1->num = s.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE getbuf ****/


/**** BEGIN PROCEDURE lines ****/

errcode streamOPlines(s, i, ret_1)
CLUREF s;
CLUREF i;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF cnt;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1149);

  LINE(1150);
    {
        {cnt.num = 0;
        }
        }

  LINE(1151);
    for (;;) {
        CLUREF T_1_1;
        T_1_1.num = (i.num > 0)? true : false;
        if (T_1_1.num != true) { break; }

  LINE(1152);
        {
        CLUREF T_2_1;
        T_2_1.num = cnt.num + 1;
         if ((T_2_1.num > 0 && cnt.num < 0 && 1 < 0) || 
             (T_2_1.num < 0 && cnt.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        cnt.num = T_2_1.num;
        }

  LINE(1153);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.ch = '\n';
        T_2_2.num = s.num;
        T_2_3.num = i.num + 1;
         if ((T_2_3.num > 0 && i.num < 0 && 1 < 0) || 
             (T_2_3.num < 0 && i.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = _bytevecOPindexc(T_2_1, T_2_2, T_2_3, &T_2_4);
        if (err != ERR_ok) goto ex_0;
        i.num = T_2_4.num;
        }
        }
        end_while_1:;

  LINE(1155);
    {
    {
    ret_1->num = cnt.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE lines ****/


/**** BEGIN PROCEDURE script ****/

errcode streamOPscript(st, s, image)
CLUREF st;
CLUREF s;
CLUREF image;
    {
    errcode err;
    errcode ecode2;
    CLUREF scr;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1158);

  LINE(1159);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = st.vec->data[3];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            scr.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(1160);
            {
            if (image.num == true) {

  LINE(1161);
                {
                err = streamOPputs_image(scr, s);
                if (err != ERR_ok) goto ex_1;
                }
                }
            else {

  LINE(1162);
                {
                err = streamOPputs(scr, s);
                if (err != ERR_ok) goto ex_1;
                }
                }}/* end if */
                goto end_1;
                ex_1:
                    if ((err == ERR_not_possible)) {
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE script ****/

static int streamOPedit_own_init = 0;

/**** BEGIN PROCEDURE edit ****/

errcode streamOPedit(tb, term, ret_1)
CLUREF tb;
CLUREF term;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ch;
    CLUREF bvec;
    CLUREF redisp;
    CLUREF c;
    CLUREF doecho;
    CLUREF s;
    CLUREF nl;
    CLUREF lag;
    CLUREF max;
    CLUREF i;
        if (streamOPedit_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPedit_own_init = 1;
    }
    enter_proc(1167);

  LINE(1169);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = tb.vec->data[7];
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        T_1_3.num = tb.vec->data[8];
        T_1_1.num = T_1_3.num;
    }
    if (T_1_1.num == true) {

  LINE(1170);
        {
        {signal (ERR_end_of_file);}}
        }
        }/* end if */

  LINE(1171);
    {
    err = _eventOPdefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(1172);
    {
        {CLUREF T_1_1;
        T_1_1.num = tb.vec->data[2];
        ch.num = T_1_1.num;
        }
        }

  LINE(1173);
    {
        {CLUREF T_1_1;
        T_1_1.num = tb.vec->data[1];
        bvec.num = T_1_1.num;
        }
        }

  LINE(1175);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_2.num = tb.vec->data[11];
    T_1_3.num = (T_1_2.num == 0)? true : false;
    T_1_1.num = T_1_3.num;
    if (!T_1_3.num) {
        T_1_4.num = tb.vec->data[10];
        T_1_1.num = T_1_4.num;
    }
    if (T_1_1.num == true) {

  LINE(1176);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[17];
        err = stringOPsize(T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        tb.vec->data[11]  = T_2_2.num;
        }

  LINE(1177);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = tb.vec->data[17];
        T_2_2.num = T_2_1.str;
        T_2_3.num = tb.vec->data[11];
        err = _bytevecOPmove_lr(T_2_2, CLU_1, bvec, CLU_1, T_2_3);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(1179);
        {
        redisp.num = 1;
        }
        }
    else {

  LINE(1180);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[4];
        T_2_2.num = tb.vec->data[11];
        err = _chanOPputb(ch, bvec, T_2_1, T_2_2, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(1181);
        {
        redisp.num = 0;
        }
        }}/* end if */

  LINE(1183);
    {
    CLUREF T_1_1;
    T_1_1.num = tb.vec->data[11];
    tb.vec->data[4]  = T_1_1.num;
    }

  LINE(1185);
    for (;;) {
        if (true != true) { break; }

  LINE(1186);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        T_4_1.num = (redisp.num == 0)? true : false;
        T_4_2.num = T_4_1.num ^ 1;
        if (T_4_2.num == true) {

  LINE(1187);
            {
            CLUREF T_5_1;
            T_5_1.num = (redisp.num < 0)? true : false;
            if (T_5_1.num == true) {

  LINE(1188);
                {
                CLUREF T_6_1;
                T_6_1.num = tb.vec->data[4];
                redisp.num = T_6_1.num;
                }

  LINE(1189);
                for (;;) {
                    if (true != true) { break; }

  LINE(1190);
                    {
                    CLUREF T_8_1;
                    if (redisp.num < 1 || redisp.num > bvec.str->size ) {
                        err = ERR_bounds;
                        goto ex_3;}
                    T_8_1.ch = bvec.str->data[redisp.num - 1];
                    c.num = T_8_1.num;
                    }

  LINE(1191);
                    {
                    CLUREF T_8_1;
                    CLUREF T_8_2;
                    CLUREF T_8_3;
                    CLUREF T_8_4;
                    CLUREF T_8_5;
                    T_8_2.ch = '\034';
                    T_8_3.num = (c.ch == T_8_2.ch)? true : false;
                    T_8_1.num = T_8_3.num;
                    if (!T_8_3.num) {
                        T_8_4.ch = '\n';
                        T_8_5.num = (c.ch == T_8_4.ch)? true : false;
                        T_8_1.num = T_8_5.num;
                    }
                    if (T_8_1.num == true) {

  LINE(1192);
                        goto end_while_2;
                        }
                        }/* end if */

  LINE(1193);
                    {
                    CLUREF T_8_1;
                    T_8_1.num = redisp.num - 1;
                     if ((T_8_1.num >= 0 && redisp.num < 0 && (-1) < 0) || 
                         (T_8_1.num <= 0 && redisp.num > 0 && (-1) > 0)) {
                        err = ERR_overflow;
                        goto ex_3;}
                    redisp.num = T_8_1.num;
                    }
                    }
                    end_while_2:;
                    goto end_3;
                    ex_3:
                        if ((err == ERR_bounds)) {
                        }
                        else {
                            goto ex_2;
                        }
                    end_3:;
                }
            else {

  LINE(1195);
                {
                redisp.num = 0;
                }
                }}/* end if */

  LINE(1197);
            for (;;) {
                CLUREF T_5_1;
                CLUREF T_5_2;
                T_5_1.num = tb.vec->data[4];
                T_5_2.num = (redisp.num < T_5_1.num)? true : false;
                if (T_5_2.num != true) { break; }

  LINE(1198);
                {
                CLUREF T_6_1;
                T_6_1.num = redisp.num + 1;
                 if ((T_6_1.num > 0 && redisp.num < 0 && 1 < 0) || 
                     (T_6_1.num < 0 && redisp.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_2;}
                redisp.num = T_6_1.num;
                }

  LINE(1199);
                {
                CLUREF T_6_1;
                if (redisp.num < 1 || redisp.num > bvec.str->size ) {
                    err = ERR_bounds;
                    goto ex_2;}
                T_6_1.ch = bvec.str->data[redisp.num - 1];
                c.num = T_6_1.num;
                }

  LINE(1200);
                {
                err = streamOPecho(ch, c);
                if (err != ERR_ok) goto ex_2;
                }

  LINE(1201);
                {
                CLUREF T_6_1;
                CLUREF T_6_2;
                T_6_1.ch = '\034';
                T_6_2.num = (c.ch == T_6_1.ch)? true : false;
                if (T_6_2.num == true) {

  LINE(1202);
                    {
                    CLUREF T_7_1;
                    T_7_1.ch = '\n';
                    err = _chanOPputc(ch, T_7_1, CLU_0);
                    if (err != ERR_ok) goto ex_2;
                    }
                    }
                    }/* end if */
                }
                end_while_3:;

  LINE(1204);
            {
            redisp.num = 0;
            }
            }
            }/* end if */

  LINE(1207);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_1.num = tb.vec->data[18];
        T_4_2.num = (T_4_1.array->ext_size == 0)? true : false;
        T_4_3.num = T_4_2.num ^ 1;
        if (T_4_3.num == true) {

  LINE(1208);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            T_5_1.num = tb.vec->data[18];
            err = arrayOPreml(T_5_1, &T_5_2);
            if (err != ERR_ok) goto ex_2;
            c.num = T_5_2.num;
            }

  LINE(1209);
            {
            CLUREF T_5_1;
            T_5_1.num = tb.vec->data[5];
            doecho.num = T_5_1.num;
            }

  LINE(1210);
            {
            tb.vec->data[5]  = false;
            }
            }
        else {

  LINE(1211);
            {
            CLUREF T_5_1;
            err = _chanOPgetc(ch, CLU_1, &T_5_1);
            if (err != ERR_ok) goto ex_2;
            c.num = T_5_1.num;
            }

  LINE(1212);
            {
            doecho.tf = true;
            }
            }}/* end if */

  LINE(1214);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        T_4_1.ch = '\n';
        T_4_2.num = (c.ch == T_4_1.ch)? true : false;
        if (T_4_2.num == true) {

  LINE(1215);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            T_5_1.num = tb.vec->data[13];
            T_5_2.num = T_5_1.num + 1;
             if ((T_5_2.num > 0 && T_5_1.num < 0 && 1 < 0) || 
                 (T_5_2.num < 0 && T_5_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_2;}
            tb.vec->data[13]  = T_5_2.num;
            }
            }
            }/* end if */

  LINE(1216);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        err = stringOPindexc(c, term, &T_4_1);
        if (err != ERR_ok) goto ex_2;
        T_4_2.num = (T_4_1.num > 0)? true : false;
        if (T_4_2.num == true) {

  LINE(1217);
            {
            tb.vec->data[5]  = doecho.num;
            }

  LINE(1218);
            {
            CLUREF T_5_1;
            T_5_1.num = tb.vec->data[18];
            err = arrayOPaddl(T_5_1, c);
            if (err != ERR_ok) goto ex_2;
            }

  LINE(1219);
            goto end_while_1;
            }
        else {
        CLUREF T_4_3;
        CLUREF T_4_4;
        T_4_3.ch = '\177';
        T_4_4.num = (c.ch == T_4_3.ch)? true : false;
        if (T_4_4.num == true) {

  LINE(1222);
            {
            CLUREF T_5_1;
            err = streamOPrubout(tb, &T_5_1);
            if (err != ERR_ok) goto ex_2;
            redisp.num = T_5_1.num;
            }
            }
        else {
        CLUREF T_4_5;
        CLUREF T_4_6;
        CLUREF T_4_7;
        CLUREF T_4_8;
        T_4_6.ch = '\004';
        T_4_7.num = (c.ch == T_4_6.ch)? true : false;
        T_4_5.num = T_4_7.num;
        if (T_4_7.num) {
            T_4_8.num = tb.vec->data[8];
            T_4_5.num = T_4_8.num;
        }
        if (T_4_5.num == true) {

  LINE(1224);
            {
            if (doecho.num == true) {

  LINE(1225);
                {
                err = streamOPecho(ch, c);
                if (err != ERR_ok) goto ex_2;
                }
                }
                }/* end if */

  LINE(1226);
            {
                err = ERR_end_of_file;
                goto ex_2;
                }
            }
        else {
        CLUREF T_4_9;
        CLUREF T_4_10;
        T_4_9.ch = '\030';
        T_4_10.num = (c.ch == T_4_9.ch)? true : false;
        if (T_4_10.num == true) {

  LINE(1229);
            {
            CLUREF T_5_1;
            T_5_1.num = tb.vec->data[11];
            tb.vec->data[4]  = T_5_1.num;
            }

  LINE(1230);
            {
            CLUREF T_5_1;
            T_5_1.ch = '\n';
            err = _chanOPputc(ch, T_5_1, CLU_0);
            if (err != ERR_ok) goto ex_2;
            }

  LINE(1231);
            {
            redisp.num = 1;
            }
            }
        else {
        CLUREF T_4_11;
        CLUREF T_4_12;
        T_4_11.ch = '\f';
        T_4_12.num = (c.ch == T_4_11.ch)? true : false;
        if (T_4_12.num == true) {

  LINE(1234);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            T_5_1.num = tb.vec->data[2];
            T_5_2.num = tb.vec->data[3];
            err = _chanOPputs(T_5_1, T_5_2, CLU_0);
            if (err != ERR_ok) goto ex_2;
            }

  LINE(1235);
            {
            redisp.num = 1;
            }
            }
        else {
        CLUREF T_4_13;
        CLUREF T_4_14;
        T_4_13.ch = '\022';
        T_4_14.num = (c.ch == T_4_13.ch)? true : false;
        if (T_4_14.num == true) {

  LINE(1238);
            {
            CLUREF T_5_1;
            T_5_1.ch = '\n';
            err = _chanOPputc(ch, T_5_1, CLU_0);
            if (err != ERR_ok) goto ex_2;
            }

  LINE(1239);
            {
            redisp.num = 1;
            }
            }
        else {
        CLUREF T_4_15;
        CLUREF T_4_16;
        T_4_15.ch = '\025';
        T_4_16.num = (c.ch == T_4_15.ch)? true : false;
        if (T_4_16.num == true) {

  LINE(1242);
            {
            CLUREF T_5_1;
            err = streamOPerase(tb, CLU_1, &T_5_1);
            if (err != ERR_ok) goto ex_2;
            redisp.num = T_5_1.num;
            }
            }
        else {
        CLUREF T_4_17;
        CLUREF T_4_18;
        T_4_17.ch = '\027';
        T_4_18.num = (c.ch == T_4_17.ch)? true : false;
        if (T_4_18.num == true) {

  LINE(1245);
            {
            CLUREF T_5_1;
            err = streamOPerase(tb, CLU_0, &T_5_1);
            if (err != ERR_ok) goto ex_2;
            redisp.num = T_5_1.num;
            }
            }
        else {

  LINE(1246);
            {
            if (doecho.num == true) {

  LINE(1247);
                {
                err = streamOPecho(ch, c);
                if (err != ERR_ok) goto ex_2;
                }
                }
                }/* end if */

  LINE(1248);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            T_5_1.ch = '\034';
            T_5_2.num = (c.ch == T_5_1.ch)? true : false;
            if (T_5_2.num == true) {

  LINE(1249);
                {
                CLUREF T_6_1;
                T_6_1.ch = '\n';
                err = _chanOPputc(ch, T_6_1, CLU_0);
                if (err != ERR_ok) goto ex_2;
                }
                }
                }/* end if */

  LINE(1250);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            T_5_1.num = tb.vec->data[4];
            T_5_2.num = T_5_1.num + 1;
             if ((T_5_2.num > 0 && T_5_1.num < 0 && 1 < 0) || 
                 (T_5_2.num < 0 && T_5_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_2;}
            tb.vec->data[4]  = T_5_2.num;
            }

  LINE(1251);
            {
            CLUREF T_5_1;
            T_5_1.num = tb.vec->data[4];
            err = _bytevecOPstore(bvec, T_5_1, c);
            if (err != ERR_ok) goto ex_2;
            }
            }}}}}}}}}/* end if */
        }
        end_while_1:;
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_1;}
    end_2:;
        goto end_1;
        ex_1:
            if ((err == ERR_end_of_file)) {

  LINE(1256);
                {
                tb.vec->data[7]  = true;
                }

  LINE(1257);
                {
                CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                T_2_1.num = tb.vec->data[4];
                T_2_2.num = tb.vec->data[11];
                T_2_3.num = (T_2_1.num == T_2_2.num)? true : false;
                if (T_2_3.num == true) {

  LINE(1258);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    T_3_1.num = tb.vec->data[11];
                    T_3_2.num = T_3_1.num + 1;
                     if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) || 
                         (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    tb.vec->data[4]  = T_3_2.num;
                    }

  LINE(1259);
                    {
                    {signal (ERR_end_of_file);}}
                    }
                    }/* end if */
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(1262);
    {
        {s = STR_;
        }
        }

  LINE(1263);
    {
        {nl.num = 0;
        }
        }

  LINE(1264);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = tb.vec->data[11];
        T_1_2.num = T_1_1.num + 1;
         if ((T_1_2.num > 0 && T_1_1.num < 0 && 1 < 0) || 
             (T_1_2.num < 0 && T_1_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        lag.num = T_1_2.num;
        }
        }

  LINE(1265);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = tb.vec->data[4];
        T_1_2.num = T_1_1.num + 1;
         if ((T_1_2.num > 0 && T_1_1.num < 0 && 1 < 0) || 
             (T_1_2.num < 0 && T_1_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        max.num = T_1_2.num;
        }
        }

  LINE(1266);
    {
    CLUREF T_1_1;
    T_1_1.ch = '\034';
    err = _bytevecOPstore(bvec, max, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(1267);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = max.num;
        for (T_1_1.num = lag.num; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(1268);
            {
            CLUREF T_2_1;
            if (i.num < 1 || i.num > bvec.str->size ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.ch = bvec.str->data[i.num - 1];
            c.num = T_2_1.num;
            }

  LINE(1269);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.ch = '\034';
            T_2_2.num = (c.ch == T_2_1.ch)? true : false;
            if (T_2_2.num == true) {

  LINE(1270);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CLUREF T_3_4;
                T_3_1.num = bvec.num;
                T_3_2.num = i.num - lag.num;
                 if ((T_3_2.num >= 0 && i.num < 0 && (-lag.num) < 0) || 
                     (T_3_2.num <= 0 && i.num > 0 && (-lag.num) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                err = stringOPsubstr(T_3_1, lag, T_3_2, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                err = stringOPconcat(s, T_3_3, &T_3_4);
                if (err != ERR_ok) goto ex_0;
                s.num = T_3_4.num;
                }

  LINE(1272);
                {
                CLUREF T_3_1;
                T_3_1.num = i.num + 1;
                 if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) || 
                     (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                lag.num = T_3_1.num;
                }

  LINE(1273);
                {
                CLUREF T_3_1;
                T_3_1.num = (lag.num < max.num)? true : false;
                if (T_3_1.num == true) {

  LINE(1274);
                    {
                    nl.num = lag.num;
                    }
                    }
                    }/* end if */
                }
            else {
            CLUREF T_2_3;
            CLUREF T_2_4;
            T_2_3.ch = '\n';
            T_2_4.num = (c.ch == T_2_3.ch)? true : false;
            if (T_2_4.num == true) {

  LINE(1276);
                {
                CLUREF T_3_1;
                T_3_1.num = i.num + 1;
                 if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) || 
                     (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                nl.num = T_3_1.num;
                }
                }
                }}/* end if */
        }
    }
    end_inline_for_1:;

  LINE(1278);
    {
    CLUREF T_1_1;
    T_1_1.num = (nl.num > 0)? true : false;
    if (T_1_1.num == true) {

  LINE(1279);
        {
        CLUREF T_2_1;
        T_2_1.num = max.num - nl.num;
         if ((T_2_1.num >= 0 && max.num < 0 && (-nl.num) < 0) || 
             (T_2_1.num <= 0 && max.num > 0 && (-nl.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        tb.vec->data[11]  = T_2_1.num;
        }

  LINE(1280);
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[11];
        err = _bytevecOPmove_lr(bvec, nl, bvec, CLU_1, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(1281);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[11];
        T_2_2.num = T_2_1.num + 1;
         if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
             (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        tb.vec->data[4]  = T_2_2.num;
        }
        }
    else {

  LINE(1282);
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[4];
        tb.vec->data[11]  = T_2_1.num;
        }

  LINE(1283);
        {
        tb.vec->data[4]  = max.num;
        }
        }}/* end if */

  LINE(1285);
    {
    err = _eventOPundefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(1286);
    {
    {
    ret_1->num = s.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE edit ****/

static int streamOPecho_own_init = 0;

/**** BEGIN PROCEDURE echo ****/

errcode streamOPecho(ch, c)
CLUREF ch;
CLUREF c;
    {
    errcode err;
    errcode ecode2;
        if (streamOPecho_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPecho_own_init = 1;
    }
    enter_proc(1289);

  LINE(1290);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.ch = '\177';
    err = charOPge(c, T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    if (T_2_2.num == true) {

  LINE(1291);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.ch = '\177';
        T_3_2.num = (c.ch == T_3_1.ch)? true : false;
        if (T_3_2.num == true) {

  LINE(1292);
            {
            err = _chanOPputs(ch, STR__136_077, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
            }
        else {
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        CLUREF T_3_7;
        CLUREF T_3_8;
        CLUREF T_3_9;
        T_3_4.num = (long)(c.ch & 0xff);
        T_3_5.num = 160;
        T_3_6.num = (T_3_4.num < T_3_5.num)? true : false;
        T_3_3.num = T_3_6.num;
        if (!T_3_6.num) {
            T_3_7.num = (long)(c.ch & 0xff);
            T_3_8.num = 255;
            T_3_9.num = (T_3_7.num == T_3_8.num)? true : false;
            T_3_3.num = T_3_9.num;
        }
        if (T_3_3.num == true) {

  LINE(1295);
            {
            CLUREF T_4_1;
            T_4_1.ch = '!';
            err = _chanOPputc(ch, T_4_1, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(1296);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            T_4_1.num = (long)(c.ch & 0xff);
            T_4_2.num = 64;
            T_4_3.num = T_4_1.num - T_4_2.num;
             if ((T_4_3.num >= 0 && T_4_1.num < 0 && (-T_4_2.num) < 0) || 
                 (T_4_3.num <= 0 && T_4_1.num > 0 && (-T_4_2.num) > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            T_4_4.num = 128;
            err = intOPmod(T_4_3, T_4_4, &T_4_5);
            if (err != ERR_ok) goto ex_1;
            err = _chanOPputi(ch, T_4_5, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
            }
        else {

  LINE(1297);
            {
            CLUREF T_4_1;
            T_4_1.ch = '&';
            err = _chanOPputc(ch, T_4_1, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(1298);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = (long)(c.ch & 0xff);
            T_4_2.num = 128;
            T_4_3.num = T_4_1.num - T_4_2.num;
             if ((T_4_3.num >= 0 && T_4_1.num < 0 && (-T_4_2.num) < 0) || 
                 (T_4_3.num <= 0 && T_4_1.num > 0 && (-T_4_2.num) > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            err = _chanOPputi(ch, T_4_3, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
            }}}/* end if */
        }
    else {
    CLUREF T_2_3;
    CLUREF T_2_4;
    CLUREF T_2_5;
    CLUREF T_2_6;
    CLUREF T_2_7;
    CLUREF T_2_8;
    CLUREF T_2_9;
    CLUREF T_2_10;
    T_2_5.ch = ' ';
    err = charOPge(c, T_2_5, &T_2_6);
    if (err != ERR_ok) goto ex_1;
    T_2_4.num = T_2_6.num;
    if (!T_2_6.num) {
        T_2_7.ch = '\n';
        T_2_8.num = (c.ch == T_2_7.ch)? true : false;
        T_2_4.num = T_2_8.num;
    }
    T_2_3.num = T_2_4.num;
    if (!T_2_4.num) {
        T_2_9.ch = '\t';
        T_2_10.num = (c.ch == T_2_9.ch)? true : false;
        T_2_3.num = T_2_10.num;
    }
    if (T_2_3.num == true) {

  LINE(1301);
        {
        err = _chanOPputc(ch, c, CLU_0);
        if (err != ERR_ok) goto ex_1;
        }
        }
    else {

  LINE(1302);
        {
        CLUREF T_3_1;
        T_3_1.ch = '^';
        err = _chanOPputc(ch, T_3_1, CLU_0);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(1303);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        T_3_1.num = (long)(c.ch & 0xff);
        T_3_2.num = 64;
        T_3_3.num = T_3_1.num + T_3_2.num;
         if ((T_3_3.num > 0 && T_3_1.num < 0 && T_3_2.num < 0) || 
             (T_3_3.num < 0 && T_3_1.num > 0 && T_3_2.num > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        err = _chanOPputi(ch, T_3_3, CLU_0);
        if (err != ERR_ok) goto ex_1;
        }
        }}}/* end if */
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE echo ****/


/**** BEGIN PROCEDURE rubout ****/

errcode streamOPrubout(tb, ret_1)
CLUREF tb;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF c;
    CLUREF cnt;
    CLUREF i;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1307);

  LINE(1308);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = tb.vec->data[4];
    T_1_2.num = tb.vec->data[11];
    T_1_3.num = (T_1_1.num <= T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(1309);
        {
        {
        ret_1->num = 0;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(1310);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = tb.vec->data[1];
        T_1_2.num = tb.vec->data[4];
        if (T_1_2.num < 1 || T_1_2.num > T_1_1.str->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_3.ch = T_1_1.str->data[T_1_2.num - 1];
        c.num = T_1_3.num;
        }
        }

  LINE(1311);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[4];
    T_1_2.num = T_1_1.num - 1;
     if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-1) < 0) || 
         (T_1_2.num <= 0 && T_1_1.num > 0 && (-1) > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    tb.vec->data[4]  = T_1_2.num;
    }

  LINE(1312);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[6];
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(1313);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_2.ch = '\034';
        T_2_3.num = (c.ch == T_2_2.ch)? true : false;
        T_2_1.num = T_2_3.num;
        if (!T_2_3.num) {
            T_2_4.ch = '\n';
            T_2_5.num = (c.ch == T_2_4.ch)? true : false;
            T_2_1.num = T_2_5.num;
        }
        if (T_2_1.num == true) {

  LINE(1314);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = tb.vec->data[2];
            T_3_2.ch = '\n';
            err = _chanOPputc(T_3_1, T_3_2, CLU_0);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(1315);
            {
            {
            ret_1->num = -1;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(1317);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[2];
        T_2_2.ch = '\\';
        err = _chanOPputc(T_2_1, T_2_2, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(1318);
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[2];
        err = _chanOPputc(T_2_1, c, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(1319);
        {
        {
        ret_1->num = 0;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(1322);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    T_1_2.ch = ' ';
    err = charOPge(c, T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_1.num = T_1_3.num;
    if (T_1_3.num) {
        T_1_4.ch = '\177';
        err = charOPlt(c, T_1_4, &T_1_5);
        if (err != ERR_ok) goto ex_0;
        T_1_1.num = T_1_5.num;
    }
    if (T_1_1.num == true) {

  LINE(1323);
        {
        cnt.num = 1;
        }
        }
    else {
    CLUREF T_1_6;
    CLUREF T_1_7;
    T_1_6.ch = '\t';
    T_1_7.num = (c.ch == T_1_6.ch)? true : false;
    if (T_1_7.num == true) {

  LINE(1325);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = streamOPcalc_pos(tb, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = intOPmod(T_2_1, CLU_8, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_3.num = 8 - T_2_2.num;
         if ((T_2_3.num >= 0 && 8 < 0 && (-T_2_2.num) < 0) || 
             (T_2_3.num <= 0 && 8 > 0 && (-T_2_2.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        cnt.num = T_2_3.num;
        }
        }
    else {
    CLUREF T_1_8;
    CLUREF T_1_9;
    CLUREF T_1_10;
    CLUREF T_1_11;
    CLUREF T_1_12;
    T_1_9.ch = '\034';
    T_1_10.num = (c.ch == T_1_9.ch)? true : false;
    T_1_8.num = T_1_10.num;
    if (!T_1_10.num) {
        T_1_11.ch = '\n';
        T_1_12.num = (c.ch == T_1_11.ch)? true : false;
        T_1_8.num = T_1_12.num;
    }
    if (T_1_8.num == true) {

  LINE(1327);
        {
        {
        ret_1->num = -1;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(1328);
        {
        cnt.num = 2;
        }
        }}}}/* end if */

  LINE(1329);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = 1;
        T_1_3.num = -1;
        for (T_1_1.num = cnt.num; ((T_1_3.num == 0) || ((T_1_3.num > 0)? (T_1_1.num <= T_1_2.num) : (T_1_1.num >= T_1_2.num))); T_1_1.num += T_1_3.num) {
            i.num = T_1_1.num;

  LINE(1330);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = tb.vec->data[2];
            T_2_2.num = tb.vec->data[0];
            err = _chanOPputs(T_2_1, T_2_2, CLU_0);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(1332);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[2];
    T_1_2.num = tb.vec->data[12];
    err = _chanOPputs(T_1_1, T_1_2, CLU_0);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(1333);
    {
    {
    ret_1->num = 0;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE rubout ****/


/**** BEGIN PROCEDURE erase ****/

errcode streamOPerase(tb, all, ret_1)
CLUREF tb;
CLUREF all;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF redisp;
    CLUREF pre;
    CLUREF post;
    CLUREF c;
    CLUREF wchar;
    CLUREF i;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1336);

  LINE(1337);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = tb.vec->data[4];
    T_1_2.num = tb.vec->data[11];
    T_1_3.num = (T_1_1.num <= T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(1338);
        {
        {
        ret_1->num = 0;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(1339);
    {
        {redisp.num = 0;
        }
        }

  LINE(1340);
    {
        {CLUREF T_1_1;
        err = streamOPcalc_pos(tb, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        pre.num = T_1_1.num;
        }
        }

  LINE(1342);
    {
    if (all.num == true) {

  LINE(1343);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_1.ch = '\034';
        T_2_2.num = tb.vec->data[1];
        T_2_3.num = tb.vec->data[11];
        T_2_4.num = T_2_3.num + 1;
         if ((T_2_4.num > 0 && T_2_3.num < 0 && 1 < 0) || 
             (T_2_4.num < 0 && T_2_3.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = _bytevecOPindexc(T_2_1, T_2_2, T_2_4, &T_2_5);
        if (err != ERR_ok) goto ex_0;
        post.num = T_2_5.num;
        }

  LINE(1344);
        {
        CLUREF T_2_1;
        T_2_1.num = (post.num == 0)? true : false;
        if (T_2_1.num == true) {

  LINE(1345);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            T_3_1.ch = '\n';
            T_3_2.num = tb.vec->data[1];
            T_3_3.num = tb.vec->data[11];
            T_3_4.num = T_3_3.num + 1;
             if ((T_3_4.num > 0 && T_3_3.num < 0 && 1 < 0) || 
                 (T_3_4.num < 0 && T_3_3.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            err = _bytevecOPindexc(T_3_1, T_3_2, T_3_4, &T_3_5);
            if (err != ERR_ok) goto ex_0;
            post.num = T_3_5.num;
            }
            }
            }/* end if */

  LINE(1347);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_2.num = (post.num > 0)? true : false;
        T_2_1.num = T_2_2.num;
        if (T_2_2.num) {
            T_2_3.num = tb.vec->data[4];
            T_2_4.num = (post.num <= T_2_3.num)? true : false;
            T_2_1.num = T_2_4.num;
        }
        if (T_2_1.num == true) {

  LINE(1348);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = tb.vec->data[2];
            T_3_2.ch = '\n';
            err = _chanOPputc(T_3_1, T_3_2, CLU_0);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(1349);
            {
            CLUREF T_3_1;
            T_3_1.num = tb.vec->data[11];
            tb.vec->data[4]  = T_3_1.num;
            }

  LINE(1350);
            {
            {
            ret_1->num = -1;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(1352);
        {
        CLUREF T_2_1;
        T_2_1.num = tb.vec->data[11];
        tb.vec->data[4]  = T_2_1.num;
        }

  LINE(1353);
        {
        CLUREF T_2_1;
        err = streamOPcalc_pos(tb, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        post.num = T_2_1.num;
        }
        }
    else {

  LINE(1354);
        for (;;) {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            T_2_1.num = tb.vec->data[4];
            T_2_2.num = tb.vec->data[11];
            T_2_3.num = (T_2_1.num > T_2_2.num)? true : false;
            if (T_2_3.num != true) { break; }

  LINE(1355);
            {
                {CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                T_3_1.num = tb.vec->data[1];
                T_3_2.num = tb.vec->data[4];
                if (T_3_2.num < 1 || T_3_2.num > T_3_1.str->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_3_3.ch = T_3_1.str->data[T_3_2.num - 1];
                c.num = T_3_3.num;
                }
                }

  LINE(1356);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.ch = '\034';
            T_3_2.num = (c.ch == T_3_1.ch)? true : false;
            if (T_3_2.num == true) {

  LINE(1357);
                {
                redisp.num = -1;
                }

  LINE(1358);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = tb.vec->data[4];
                T_4_2.num = T_4_1.num - 1;
                 if ((T_4_2.num >= 0 && T_4_1.num < 0 && (-1) < 0) || 
                     (T_4_2.num <= 0 && T_4_1.num > 0 && (-1) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                tb.vec->data[4]  = T_4_2.num;
                }

  LINE(1359);
                continue;
                }
            else {
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_3.ch = '\n';
            T_3_4.num = (c.ch == T_3_3.ch)? true : false;
            if (T_3_4.num == true) {

  LINE(1361);
                {
                redisp.num = -1;
                }
                }
                }}/* end if */

  LINE(1362);
            {
                {CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CLUREF T_3_4;
                CLUREF T_3_5;
                CLUREF T_3_6;
                CLUREF T_3_7;
                CLUREF T_3_8;
                CLUREF T_3_9;
                CLUREF T_3_10;
                CLUREF T_3_11;
                CLUREF T_3_12;
                CLUREF T_3_13;
                CLUREF T_3_14;
                CLUREF T_3_15;
                CLUREF T_3_16;
                CLUREF T_3_17;
                CLUREF T_3_18;
                CLUREF T_3_19;
                CLUREF T_3_20;
                T_3_5.ch = 'a';
                err = charOPge(c, T_3_5, &T_3_6);
                if (err != ERR_ok) goto ex_0;
                T_3_4.num = T_3_6.num;
                if (T_3_6.num) {
                    T_3_7.ch = 'z';
                    err = charOPle(c, T_3_7, &T_3_8);
                    if (err != ERR_ok) goto ex_0;
                    T_3_4.num = T_3_8.num;
                }
                T_3_3.num = T_3_4.num;
                if (!T_3_4.num) {
                    T_3_10.ch = '0';
                    err = charOPge(c, T_3_10, &T_3_11);
                    if (err != ERR_ok) goto ex_0;
                    T_3_9.num = T_3_11.num;
                    if (T_3_11.num) {
                        T_3_12.ch = '9';
                        err = charOPle(c, T_3_12, &T_3_13);
                        if (err != ERR_ok) goto ex_0;
                        T_3_9.num = T_3_13.num;
                    }
                    T_3_3.num = T_3_9.num;
                }
                T_3_2.num = T_3_3.num;
                if (!T_3_3.num) {
                    T_3_15.ch = 'A';
                    err = charOPge(c, T_3_15, &T_3_16);
                    if (err != ERR_ok) goto ex_0;
                    T_3_14.num = T_3_16.num;
                    if (T_3_16.num) {
                        T_3_17.ch = 'Z';
                        err = charOPle(c, T_3_17, &T_3_18);
                        if (err != ERR_ok) goto ex_0;
                        T_3_14.num = T_3_18.num;
                    }
                    T_3_2.num = T_3_14.num;
                }
                T_3_1.num = T_3_2.num;
                if (!T_3_2.num) {
                    T_3_19.ch = '_';
                    T_3_20.num = (c.ch == T_3_19.ch)? true : false;
                    T_3_1.num = T_3_20.num;
                }
                wchar.num = T_3_1.num;
                }
                }

  LINE(1366);
            {
            CLUREF T_3_1;
            T_3_1.num = all.num ^ 1;
            if (T_3_1.num == true) {

  LINE(1367);
                {
                all.num = wchar.num;
                }
                }
            else {
            CLUREF T_3_2;
            T_3_2.num = wchar.num ^ 1;
            if (T_3_2.num == true) {

  LINE(1369);
                goto end_while_1;
                }
                }}/* end if */

  LINE(1370);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = tb.vec->data[4];
            T_3_2.num = T_3_1.num - 1;
             if ((T_3_2.num >= 0 && T_3_1.num < 0 && (-1) < 0) || 
                 (T_3_2.num <= 0 && T_3_1.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            tb.vec->data[4]  = T_3_2.num;
            }
            }
            end_while_1:;

  LINE(1372);
        {
        CLUREF T_2_1;
        T_2_1.num = (redisp.num < 0)? true : false;
        if (T_2_1.num == true) {

  LINE(1373);
            {
            post.num = 0;
            }
            }
        else {

  LINE(1374);
            {
            CLUREF T_3_1;
            err = streamOPcalc_pos(tb, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            post.num = T_3_1.num;
            }
            }}/* end if */
        }}/* end if */

  LINE(1377);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[6];
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(1378);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = tb.vec->data[2];
        T_2_2.ch = '\n';
        err = _chanOPputc(T_2_1, T_2_2, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(1379);
        {
        {
        ret_1->num = -1;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(1381);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = pre.num - post.num;
         if ((T_1_1.num >= 0 && pre.num < 0 && (-post.num) < 0) || 
             (T_1_1.num <= 0 && pre.num > 0 && (-post.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        T_1_3.num = 1;
        T_1_4.num = -1;
        for (T_1_2.num = T_1_1.num; ((T_1_4.num == 0) || ((T_1_4.num > 0)? (T_1_2.num <= T_1_3.num) : (T_1_2.num >= T_1_3.num))); T_1_2.num += T_1_4.num) {
            i.num = T_1_2.num;

  LINE(1382);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = tb.vec->data[2];
            T_2_2.num = tb.vec->data[0];
            err = _chanOPputs(T_2_1, T_2_2, CLU_0);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(1384);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[2];
    T_1_2.num = tb.vec->data[12];
    err = _chanOPputs(T_1_1, T_1_2, CLU_0);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(1385);
    {
    {
    ret_1->num = redisp.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE erase ****/


/**** BEGIN PROCEDURE calc_pos ****/

errcode streamOPcalc_pos(tb, ret_1)
CLUREF tb;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF pos;
    CLUREF i;
    CLUREF c;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1388);

  LINE(1389);
    {
        {pos.num = 0;
        }
        }

  LINE(1390);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_1.num = tb.vec->data[4];
        T_1_3.num = T_1_1.num;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            i.num = T_1_2.num;

  LINE(1391);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                T_2_1.num = tb.vec->data[1];
                if (i.num < 1 || i.num > T_2_1.str->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_2.ch = T_2_1.str->data[i.num - 1];
                c.num = T_2_2.num;
                }
                }

  LINE(1392);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            T_2_2.ch = ' ';
            err = charOPge(c, T_2_2, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            T_2_1.num = T_2_3.num;
            if (T_2_3.num) {
                T_2_4.ch = '\177';
                err = charOPlt(c, T_2_4, &T_2_5);
                if (err != ERR_ok) goto ex_0;
                T_2_1.num = T_2_5.num;
            }
            if (T_2_1.num == true) {

  LINE(1393);
                {
                CLUREF T_3_1;
                T_3_1.num = pos.num + 1;
                 if ((T_3_1.num > 0 && pos.num < 0 && 1 < 0) || 
                     (T_3_1.num < 0 && pos.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                pos.num = T_3_1.num;
                }
                }
            else {
            CLUREF T_2_6;
            CLUREF T_2_7;
            T_2_6.ch = '\t';
            T_2_7.num = (c.ch == T_2_6.ch)? true : false;
            if (T_2_7.num == true) {

  LINE(1395);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                T_3_1.num = pos.num + 8;
                 if ((T_3_1.num > 0 && pos.num < 0 && 8 < 0) || 
                     (T_3_1.num < 0 && pos.num > 0 && 8 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                err = intOPmod(pos, CLU_8, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_3.num = T_3_1.num - T_3_2.num;
                 if ((T_3_3.num >= 0 && T_3_1.num < 0 && (-T_3_2.num) < 0) || 
                     (T_3_3.num <= 0 && T_3_1.num > 0 && (-T_3_2.num) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                pos.num = T_3_3.num;
                }
                }
            else {
            CLUREF T_2_8;
            CLUREF T_2_9;
            CLUREF T_2_10;
            CLUREF T_2_11;
            CLUREF T_2_12;
            T_2_9.ch = '\034';
            T_2_10.num = (c.ch == T_2_9.ch)? true : false;
            T_2_8.num = T_2_10.num;
            if (!T_2_10.num) {
                T_2_11.ch = '\n';
                T_2_12.num = (c.ch == T_2_11.ch)? true : false;
                T_2_8.num = T_2_12.num;
            }
            if (T_2_8.num == true) {

  LINE(1397);
                {
                pos.num = 0;
                }
                }
            else {

  LINE(1398);
                {
                CLUREF T_3_1;
                T_3_1.num = pos.num + 2;
                 if ((T_3_1.num > 0 && pos.num < 0 && 2 < 0) || 
                     (T_3_1.num < 0 && pos.num > 0 && 2 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                pos.num = T_3_1.num;
                }
                }}}}/* end if */
        }
    }
    end_inline_for_1:;

  LINE(1400);
    {
    {
    ret_1->num = pos.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE calc_pos ****/

static int streamOPdisplay_own_init = 0;

/**** BEGIN PROCEDURE display ****/

errcode streamOPdisplay(st, s, ret_1)
CLUREF st;
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
        if (streamOPdisplay_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPdisplay_own_init = 1;
    }
    enter_proc(1403);

  LINE(1405);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 6: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        tb.num = T_2_2.num;

  LINE(1407);
            {
            err = streamOPflush(st);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(1408);
            {
            {
            CLUREF T_3_1;
            err = streamOPttydsp(tb, s, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 7: 
    case 3: 
    case 4: 
         {

  LINE(1410);
            {
            {
            ret_1->tf = false;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 5: 
    case 2: 
    case 1: 
         {

  LINE(1412);
            {
            elist[0] = STR_cannot_040write_040to_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE display ****/

static int streamOPmodify_display_own_init = 0;

/**** BEGIN PROCEDURE modify_display ****/

errcode streamOPmodify_display(st, term)
CLUREF st;
CLUREF term;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
        if (streamOPmodify_display_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPmodify_display_own_init = 1;
    }
    enter_proc(1416);

  LINE(1417);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1419);
            {
            tb.vec->data[6]  = false;
            }

  LINE(1420);
            {
            tb.vec->data[0]  = STR_.num;
            }

  LINE(1421);
            {
            tb.vec->data[12]  = STR_.num;
            }

  LINE(1422);
            {
            tb.vec->data[3]  = STR_.num;
            }

  LINE(1423);
            {
            err = streamOPtermcap(tb, term);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(1425);
        {
        elist[0] = STR_not_040a_040terminal_040stream;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE modify_display ****/


/**** BEGIN PROCEDURE ttydsp ****/

errcode streamOPttydsp(tb, s, ret_1)
CLUREF tb;
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ch;
    CLUREF i;
    CLUREF max;
    CLUREF c;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1429);

  LINE(1430);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tb.vec->data[6];
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(1431);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(1432);
    {
        {CLUREF T_1_1;
        T_1_1.num = tb.vec->data[2];
        ch.num = T_1_1.num;
        }
        }

  LINE(1433);
    {
        {i.num = 1;
        }
        }

  LINE(1434);
    {
        {CLUREF T_1_1;
        err = stringOPsize(s, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        max.num = T_1_1.num;
        }
        }

  LINE(1435);
    for (;;) {
        CLUREF T_2_1;
        T_2_1.num = (i.num <= max.num)? true : false;
        if (T_2_1.num != true) { break; }

  LINE(1436);
        {
            {CLUREF T_3_1;
            err = stringOPfetch(s, i, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            c.num = T_3_1.num;
            }
            }

  LINE(1437);
        {
        CLUREF T_3_1;
        T_3_1.num = i.num + 1;
         if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) || 
             (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        i.num = T_3_1.num;
        }

  LINE(1438);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        T_3_2.ch = '\020';
        T_3_3.num = (c.ch == T_3_2.ch)? true : false;
        T_3_1.num = T_3_3.num;
        if (T_3_3.num) {
            T_3_4.num = (i.num <= max.num)? true : false;
            T_3_1.num = T_3_4.num;
        }
        T_3_5.num = T_3_1.num ^ 1;
        if (T_3_5.num == true) {

  LINE(1439);
            {
            err = _chanOPputc(ch, c, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(1440);
            continue;
            }
            }/* end if */

  LINE(1442);
        {
        CLUREF T_3_1;
        err = stringOPfetch(s, i, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        c.num = T_3_1.num;
        }

  LINE(1443);
        {
        CLUREF T_3_1;
        T_3_1.num = i.num + 1;
         if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) || 
             (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        i.num = T_3_1.num;
        }

  LINE(1444);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.ch = 'C';
        T_3_2.num = (c.ch == T_3_1.ch)? true : false;
        if (T_3_2.num == true) {

  LINE(1445);
            {
            CLUREF T_4_1;
            T_4_1.num = tb.vec->data[3];
            err = _chanOPputs(ch, T_4_1, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
            }
        else {
        CLUREF T_3_3;
        CLUREF T_3_4;
        T_3_3.ch = 'B';
        T_3_4.num = (c.ch == T_3_3.ch)? true : false;
        if (T_3_4.num == true) {

  LINE(1447);
            {
            CLUREF T_4_1;
            T_4_1.num = tb.vec->data[0];
            err = _chanOPputs(ch, T_4_1, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
            }
        else {
        CLUREF T_3_5;
        CLUREF T_3_6;
        T_3_5.ch = 'L';
        T_3_6.num = (c.ch == T_3_5.ch)? true : false;
        if (T_3_6.num == true) {

  LINE(1449);
            {
            CLUREF T_4_1;
            T_4_1.num = tb.vec->data[12];
            err = _chanOPputs(ch, T_4_1, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
            }
        else {

  LINE(1450);
            {
            CLUREF T_4_1;
            T_4_1.ch = '\020';
            err = _chanOPputc(ch, T_4_1, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(1451);
            {
            err = _chanOPputc(ch, c, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
            }}}}/* end if */
        }
        end_while_1:;
        goto end_1;
        ex_1:
            if ((err == ERR_not_possible)) {

  LINE(1453);
                {
                {
                ret_1->tf = false;
                }
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(1454);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE ttydsp ****/

static int streamOPget_prompt_own_init = 0;

/**** BEGIN PROCEDURE get_prompt ****/

errcode streamOPget_prompt(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
        if (streamOPget_prompt_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPget_prompt_own_init = 1;
    }
    enter_proc(1457);

  LINE(1458);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1460);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = tb.vec->data[17];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(1462);
        {
        {
        ret_1->str = STR_.str;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_prompt ****/


/**** BEGIN PROCEDURE set_prompt ****/

errcode streamOPset_prompt(st, prompt)
CLUREF st;
CLUREF prompt;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1466);

  LINE(1467);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1469);
            {
            tb.vec->data[17]  = prompt.num;
            }
            break;
            }
    default: {
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_prompt ****/

static int streamOPget_rescan_own_init = 0;

/**** BEGIN PROCEDURE get_rescan ****/

errcode streamOPget_rescan(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
    CLUREF s;
        if (streamOPget_rescan_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPget_rescan_own_init = 1;
    }
    enter_proc(1474);

  LINE(1475);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1477);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                T_2_1.num = tb.vec->data[18];
                err = stringOPac2s(T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                s.num = T_2_2.num;
                }
                }

  LINE(1478);
            {
            CLUREF T_2_1;
            T_2_1.num = tb.vec->data[5];
            if (T_2_1.num == true) {

  LINE(1479);
                {
                CLUREF T_3_1;
                err = stringOPrest(s, CLU_2, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                s.num = T_3_1.num;
                }
                }
                }/* end if */

  LINE(1480);
            {
            {
            ret_1->num = s.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(1482);
        {
        {
        ret_1->str = STR_.str;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_rescan ****/

static int streamOPset_rescan_own_init = 0;

/**** BEGIN PROCEDURE set_rescan ****/

errcode streamOPset_rescan(st, s)
CLUREF st;
CLUREF s;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
    CLUREF scan;
        if (streamOPset_rescan_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPset_rescan_own_init = 1;
    }
    enter_proc(1486);

  LINE(1487);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1489);
            {
                {CLUREF T_2_1;
                err = stringOPs2ac(s, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                scan.num = T_2_1.num;
                }
                }

  LINE(1490);
            {
            CLUREF T_2_1;
            T_2_1.num = tb.vec->data[5];
            if (T_2_1.num == true) {

  LINE(1491);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = tb.vec->data[18];
                err = arrayOPbottom(T_3_1, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                err = arrayOPaddl(scan, T_3_2);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */

  LINE(1492);
            {
            tb.vec->data[18]  = scan.num;
            }
            break;
            }
    default: {

  LINE(1494);
        {
        elist[0] = STR_cannot_040rescan_040on_040this_040stream;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_rescan ****/


/**** BEGIN PROCEDURE get_input_buffered ****/

errcode streamOPget_input_buffered(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1498);

  LINE(1499);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: 
    case 2: 
    case 3: 
         {

  LINE(1501);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1503);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = tb.vec->data[9];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 7: 
    case 4: 
    case 1: 
         {

  LINE(1505);
            {
            {
            ret_1->tf = false;
            }
            {signal (ERR_ok);}}
            break;
            }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_input_buffered ****/

static int streamOPset_input_buffered_own_init = 0;

/**** BEGIN PROCEDURE set_input_buffered ****/

errcode streamOPset_input_buffered(st, flag)
CLUREF st;
CLUREF flag;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
        if (streamOPset_input_buffered_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPset_input_buffered_own_init = 1;
    }
    enter_proc(1509);

  LINE(1510);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: 
    case 2: 
    case 3: 
         {

  LINE(1512);
            {
            CLUREF T_2_1;
            T_2_1.num = flag.num ^ 1;
            if (T_2_1.num == true) {

  LINE(1513);
                {
                elist[0] = STR_input_040is_040always_040buffered;
                {signal (ERR_not_possible);}}
                }
                }/* end if */
            break;
            }
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1515);
            {
            tb.vec->data[9]  = flag.num;
            }
            break;
            }
    case 7: 
    case 4: 
    case 1: 
         {

  LINE(1517);
            {
            elist[0] = STR_cannot_040read_040from_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_input_buffered ****/


/**** BEGIN PROCEDURE get_output_buffered ****/

errcode streamOPget_output_buffered(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF wb;
    CLUREF tb;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1521);

  LINE(1522);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 7: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        wb.num = T_1_2.num;

  LINE(1524);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = wb.vec->data[3];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 6: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        tb.num = T_1_3.num;

  LINE(1526);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = tb.vec->data[15];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 4: 
    case 3: 
         {

  LINE(1528);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 5: 
    case 2: 
    case 1: 
         {

  LINE(1530);
            {
            {
            ret_1->tf = false;
            }
            {signal (ERR_ok);}}
            break;
            }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_output_buffered ****/

static int streamOPset_output_buffered_own_init = 0;

/**** BEGIN PROCEDURE set_output_buffered ****/

errcode streamOPset_output_buffered(st, flag)
CLUREF st;
CLUREF flag;
    {
    errcode err;
    errcode ecode2;
    CLUREF wb;
    CLUREF tb;
        if (streamOPset_output_buffered_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPset_output_buffered_own_init = 1;
    }
    enter_proc(1534);

  LINE(1535);
    {
    CLUREF T_2_1;
    T_2_1.num = st.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 7: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(1537);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_2.num = flag.num ^ 1;
            T_3_1.num = T_3_2.num;
            if (T_3_2.num) {
                T_3_3.num = wb.vec->data[3];
                T_3_1.num = T_3_3.num;
            }
            if (T_3_1.num == true) {

  LINE(1538);
                {
                err = streamOPflush(st);
                if (err != ERR_ok) goto ex_1;
                }
                }
                }/* end if */

  LINE(1539);
            {
            wb.vec->data[3]  = flag.num;
            }
            break;
            }
    case 6: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        tb.num = T_2_3.num;

  LINE(1541);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_2.num = flag.num ^ 1;
            T_3_1.num = T_3_2.num;
            if (T_3_2.num) {
                T_3_3.num = tb.vec->data[15];
                T_3_1.num = T_3_3.num;
            }
            if (T_3_1.num == true) {

  LINE(1542);
                {
                err = streamOPflush(st);
                if (err != ERR_ok) goto ex_1;
                }
                }
                }/* end if */

  LINE(1543);
            {
            tb.vec->data[15]  = flag.num;
            }
            break;
            }
    case 4: 
    case 3: 
         {

  LINE(1545);
            {
            elist[0] = STR_output_040is_040always_040buffered;
            {signal (ERR_not_possible);}}
            break;
            }
    case 5: 
    case 2: 
    case 1: 
         {

  LINE(1547);
            {
            elist[0] = STR_cannot_040write_040to_040this_040stream;
            {signal (ERR_not_possible);}}
            break;
            }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_output_buffered ****/


/**** BEGIN PROCEDURE get_eof_flag ****/

errcode streamOPget_eof_flag(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1551);

  LINE(1552);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1554);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = tb.vec->data[8];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 5: 
    case 2: 
    case 1: 
         {

  LINE(1556);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(1558);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_eof_flag ****/

static int streamOPset_eof_flag_own_init = 0;

/**** BEGIN PROCEDURE set_eof_flag ****/

errcode streamOPset_eof_flag(st, eofok)
CLUREF st;
CLUREF eofok;
    {
    errcode err;
    errcode ecode2;
    CLUREF tb;
        if (streamOPset_eof_flag_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPset_eof_flag_own_init = 1;
    }
    enter_proc(1562);

  LINE(1563);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        tb.num = T_1_2.num;

  LINE(1565);
            {
            tb.vec->data[8]  = eofok.num;
            }
            break;
            }
    case 5: 
    case 2: 
    case 1: 
         {

  LINE(1567);
            {
            CLUREF T_2_1;
            T_2_1.num = eofok.num ^ 1;
            if (T_2_1.num == true) {

  LINE(1568);
                {
                elist[0] = STR_cannot_040disable_040eof_040on_040this_040stream;
                {signal (ERR_not_possible);}}
                }
                }/* end if */
            break;
            }
    default: {

  LINE(1571);
        {
        if (eofok.num == true) {

  LINE(1572);
            {
            elist[0] = STR_cannot_040enable_040eof_040on_040this_040stream;
            {signal (ERR_not_possible);}}
            }
            }/* end if */
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_eof_flag ****/


/**** BEGIN PROCEDURE equal ****/

errcode streamOPequal(x, y, ret_1)
CLUREF x;
CLUREF y;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1577);

  LINE(1578);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = (x.num == y.num)? true : false;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE equal ****/


/**** BEGIN PROCEDURE similar ****/

errcode streamOPsimilar(x, y, ret_1)
CLUREF x;
CLUREF y;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1581);

  LINE(1582);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = (x.num == y.num)? true : false;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE similar ****/


/**** BEGIN PROCEDURE copy ****/

errcode streamOPcopy(x, ret_1)
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1585);

  LINE(1586);
    {
    {
    ret_1->num = x.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE copy ****/

static int streamOPprint_own_init = 0;

/**** BEGIN PROCEDURE print ****/

errcode streamOPprint(x, ps)
CLUREF x;
CLUREF ps;
    {
    errcode err;
    errcode ecode2;
        if (streamOPprint_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPprint_own_init = 1;
    }
    enter_proc(1589);

  LINE(1590);
    {
    CLUREF T_1_1;
    err = pstreamOPtext(ps, STR_stream_133, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(1591);
    {
    CLUREF T_1_1;
    err = streamOPcan_read(x, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(1592);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.ch = 'R';
        err = pstreamOPtextc(ps, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(1593);
    {
    CLUREF T_1_1;
    err = streamOPcan_write(x, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(1594);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.ch = 'W';
        err = pstreamOPtextc(ps, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(1595);
    {
    CLUREF T_1_1;
    err = streamOPis_closed(x, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(1596);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.ch = 'C';
        err = pstreamOPtextc(ps, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(1597);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = ' ';
    err = pstreamOPtextc(ps, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(1598);
    {
    CLUREF T_2_1;
    err = streamOPget_name(x, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    err = file_nameOPprint(T_2_1, ps);
    if (err != ERR_ok) goto ex_1;
    }
        goto end_1;
        ex_1:
            if ((err == ERR_not_possible)) {

  LINE(1599);
                {
                CLUREF T_2_1;
                err = pstreamOPtext(ps, STR__050internal_051, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(1600);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = ']';
    err = pstreamOPtextc(ps, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE print ****/

static int streamOPget_chan_own_init = 0;

/**** BEGIN PROCEDURE get_chan ****/

errcode streamOPget_chan(st, ret_1)
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF wb;
    CLUREF tb;
        if (streamOPget_chan_own_init == 0) {
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        streamOPget_chan_own_init = 1;
    }
    enter_proc(1603);

  LINE(1604);
    {
    CLUREF T_1_1;
    T_1_1.num = st.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 5: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        rb.num = T_1_2.num;

  LINE(1606);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = rb.vec->data[1];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 7: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        wb.num = T_1_3.num;

  LINE(1608);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = wb.vec->data[1];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 6: 
         {CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        tb.num = T_1_4.num;

  LINE(1610);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = tb.vec->data[2];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(1612);
        {
        elist[0] = STR_does_040not_040contain_040a_040_137chan;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_chan ****/


/**** BEGIN ITERATOR _open_streams ****/

errcode streamOP_open_streams(proc, user_locals, iecode)
errcode (*proc)();
char **user_locals;
errcode *iecode;
    {
    errcode ecode;
    errcode err;
    errcode ecode2;
    bool body_ctrl_req;
    CLUREF s;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1616);

  LINE(1617);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    CLUREF T_2_4;
        err = streamOPopen_streams(&T_2_1);
        if (err != ERR_ok) goto ex_1;
        T_2_3.num = T_2_1.array->ext_high; 
        T_2_4 = T_2_1;
        for (T_2_2.num = T_2_1.array->ext_low; T_2_2.num <= T_2_3.num; T_2_2.num++) {
            if (T_2_2.num > T_2_4.array->ext_high || T_2_2.num < T_2_4.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_1;}
            s.num = T_2_4.array->store->data[T_2_2.num - T_2_4.array->ext_low + T_2_4.array->int_low];

  LINE(1618);
            {
            err = proc(s, user_locals, iecode);
            if (err != ERR_ok) {
            if (err == ERR_break) {signal(ERR_break);}
            if (err == ERR_iterbodyreturn) {signal(ERR_iterbodyreturn);}
            if (err == ERR_iterbodyexit) {signal(ERR_iterbodyexit);}
            if (err == ERR_iterbodysignal) {signal(ERR_iterbodysignal);}
            {signal(err);
                }}
            }
        }
    }
    end_inline_for_1:;
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END ITERATOR _open_streams ****/


/**** BEGIN PROCEDURE _close_all ****/

errcode streamOP_close_all()
    {
    errcode err;
    errcode ecode2;
    CLUREF opens;
    CLUREF st;
    CLUREF i;
        if (stream_own_init == 0) {
            err = stream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(1622);

  LINE(1623);
    {
        {CLUREF T_1_1;
        err = streamOPopen_streams(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        opens.num = T_1_1.num;
        }
        }

  LINE(1624);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = opens.array->ext_high; 
        T_1_3 = opens;
        for (T_1_1.num = opens.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            st.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(1625);
            {
            err = streamOPflush(st);
            if (err != ERR_ok) goto ex_1;
            }
                goto end_1;
                ex_1:
                    if ((err == ERR_not_possible)) {
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;
        }
    }
    end_inline_for_1:;

  LINE(1628);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = opens.array->ext_high; 
        T_1_3 = opens;
        for (T_1_1.num = opens.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            st.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(1629);
            {
            CLUREF T_2_1;
            err = sequenceOPnew(&T_2_1);
            if (err != ERR_ok) goto ex_0;
            st.vec->data[3]  = T_2_1.num;
            }

  LINE(1630);
            {
            st.vec->data[2]  = false;
            }
        }
    }
    end_inline_for_2:;

  LINE(1632);
    {
        {i.num = 1;
        }
        }

  LINE(1633);
    for (;;) {
        if (true != true) { break; }

  LINE(1634);
        {
            {CLUREF T_3_1;
            if (i.num < opens.array->ext_low || i.num > opens.array->ext_high ) {
                err = ERR_bounds;
                goto ex_2;}
            T_3_1.num = opens.array->store->data[i.num - opens.array->ext_low + opens.array->int_low];
            st.num = T_3_1.num;
            }
            }

  LINE(1635);
        {
        err = streamOPclose(st);
        if (err != ERR_ok) goto ex_3;
        }
            goto end_3;
            ex_3:
                if ((err == ERR_not_possible)) {

  LINE(1636);
                    {
                    err = streamOPabort(st);
                    if (err != ERR_ok) goto ex_2;
                    }
                }
                else {
                    goto ex_2;
                }
            end_3:;

  LINE(1637);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        if (i.num < opens.array->ext_low || i.num > opens.array->ext_high ) {
            err = ERR_bounds;
            goto ex_2;}
        T_3_1.num = opens.array->store->data[i.num - opens.array->ext_low + opens.array->int_low];
        err = streamOPequal(st, T_3_1, &T_3_2);
        if (err != ERR_ok) goto ex_2;
        if (T_3_2.num == true) {

  LINE(1638);
            {
            CLUREF T_4_1;
            T_4_1.num = i.num + 1;
             if ((T_4_1.num > 0 && i.num < 0 && 1 < 0) || 
                 (T_4_1.num < 0 && i.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_2;}
            i.num = T_4_1.num;
            }
            }
            }/* end if */
        }
        end_while_1:;
        goto end_2;
        ex_2:
            if ((err == ERR_bounds)) {
            }
            else {
                goto ex_0;
            }
        end_2:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE _close_all ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[62];
} stream_OPS;

CLU_proc stream_oe__close_all = {{0,0,0,0}, streamOP_close_all, 0};
CLU_proc stream_oe__open_streams = {{0,0,0,0}, streamOP_open_streams, 0};
CLU_proc stream_oe_abort = {{0,0,0,0}, streamOPabort, 0};
CLU_proc stream_oe_add_script = {{0,0,0,0}, streamOPadd_script, 0};
CLU_proc stream_oe_can_read = {{0,0,0,0}, streamOPcan_read, 0};
CLU_proc stream_oe_can_write = {{0,0,0,0}, streamOPcan_write, 0};
CLU_proc stream_oe_close = {{0,0,0,0}, streamOPclose, 0};
CLU_proc stream_oe_copy = {{0,0,0,0}, streamOPcopy, 0};
CLU_proc stream_oe_create_input = {{0,0,0,0}, streamOPcreate_input, 0};
CLU_proc stream_oe_create_output = {{0,0,0,0}, streamOPcreate_output, 0};
CLU_proc stream_oe_display = {{0,0,0,0}, streamOPdisplay, 0};
CLU_proc stream_oe_empty = {{0,0,0,0}, streamOPempty, 0};
CLU_proc stream_oe_equal = {{0,0,0,0}, streamOPequal, 0};
CLU_proc stream_oe_error_output = {{0,0,0,0}, streamOPerror_output, 0};
CLU_proc stream_oe_flush = {{0,0,0,0}, streamOPflush, 0};
CLU_proc stream_oe_get_contents = {{0,0,0,0}, streamOPget_contents, 0};
CLU_proc stream_oe_get_date = {{0,0,0,0}, streamOPget_date, 0};
CLU_proc stream_oe_get_eof_flag = {{0,0,0,0}, streamOPget_eof_flag, 0};
CLU_proc stream_oe_get_input_buffered = {{0,0,0,0}, streamOPget_input_buffered, 0};
CLU_proc stream_oe_get_line_length = {{0,0,0,0}, streamOPget_line_length, 0};
CLU_proc stream_oe_get_lineno = {{0,0,0,0}, streamOPget_lineno, 0};
CLU_proc stream_oe_get_name = {{0,0,0,0}, streamOPget_name, 0};
CLU_proc stream_oe_get_output_buffered = {{0,0,0,0}, streamOPget_output_buffered, 0};
CLU_proc stream_oe_get_page_length = {{0,0,0,0}, streamOPget_page_length, 0};
CLU_proc stream_oe_get_prompt = {{0,0,0,0}, streamOPget_prompt, 0};
CLU_proc stream_oe_get_rescan = {{0,0,0,0}, streamOPget_rescan, 0};
CLU_proc stream_oe_getbuf = {{0,0,0,0}, streamOPgetbuf, 0};
CLU_proc stream_oe_getc = {{0,0,0,0}, streamOPgetc, 0};
CLU_proc stream_oe_getc_image = {{0,0,0,0}, streamOPgetc_image, 0};
CLU_proc stream_oe_getl = {{0,0,0,0}, streamOPgetl, 0};
CLU_proc stream_oe_gets = {{0,0,0,0}, streamOPgets, 0};
CLU_proc stream_oe_gets_image = {{0,0,0,0}, streamOPgets_image, 0};
CLU_proc stream_oe_is_closed = {{0,0,0,0}, streamOPis_closed, 0};
CLU_proc stream_oe_is_terminal = {{0,0,0,0}, streamOPis_terminal, 0};
CLU_proc stream_oe_modify_display = {{0,0,0,0}, streamOPmodify_display, 0};
CLU_proc stream_oe_open = {{0,0,0,0}, streamOPopen, 0};
CLU_proc stream_oe_peekc = {{0,0,0,0}, streamOPpeekc, 0};
CLU_proc stream_oe_pending = {{0,0,0,0}, streamOPpending, 0};
CLU_proc stream_oe_primary_input = {{0,0,0,0}, streamOPprimary_input, 0};
CLU_proc stream_oe_primary_output = {{0,0,0,0}, streamOPprimary_output, 0};
CLU_proc stream_oe_print = {{0,0,0,0}, streamOPprint, 0};
CLU_proc stream_oe_putc = {{0,0,0,0}, streamOPputc, 0};
CLU_proc stream_oe_putc_image = {{0,0,0,0}, streamOPputc_image, 0};
CLU_proc stream_oe_putl = {{0,0,0,0}, streamOPputl, 0};
CLU_proc stream_oe_putleft = {{0,0,0,0}, streamOPputleft, 0};
CLU_proc stream_oe_putright = {{0,0,0,0}, streamOPputright, 0};
CLU_proc stream_oe_puts = {{0,0,0,0}, streamOPputs, 0};
CLU_proc stream_oe_puts_image = {{0,0,0,0}, streamOPputs_image, 0};
CLU_proc stream_oe_putspace = {{0,0,0,0}, streamOPputspace, 0};
CLU_proc stream_oe_putzero = {{0,0,0,0}, streamOPputzero, 0};
CLU_proc stream_oe_rem_script = {{0,0,0,0}, streamOPrem_script, 0};
CLU_proc stream_oe_reset = {{0,0,0,0}, streamOPreset, 0};
CLU_proc stream_oe_scripts = {{0,0,0,0}, streamOPscripts, 0};
CLU_proc stream_oe_set_date = {{0,0,0,0}, streamOPset_date, 0};
CLU_proc stream_oe_set_eof_flag = {{0,0,0,0}, streamOPset_eof_flag, 0};
CLU_proc stream_oe_set_input_buffered = {{0,0,0,0}, streamOPset_input_buffered, 0};
CLU_proc stream_oe_set_lineno = {{0,0,0,0}, streamOPset_lineno, 0};
CLU_proc stream_oe_set_output_buffered = {{0,0,0,0}, streamOPset_output_buffered, 0};
CLU_proc stream_oe_set_prompt = {{0,0,0,0}, streamOPset_prompt, 0};
CLU_proc stream_oe_set_rescan = {{0,0,0,0}, streamOPset_rescan, 0};
CLU_proc stream_oe_similar = {{0,0,0,0}, streamOPsimilar, 0};
CLU_proc stream_oe_unscript = {{0,0,0,0}, streamOPunscript, 0};

stream_OPS stream_ops_actual = {62, (OWNPTR)&stream_own_init, (OWNPTR)&stream_own_init, {
    {&stream_oe__close_all, "_close_all"},
    {&stream_oe__open_streams, "_open_streams"},
    {&stream_oe_abort, "abort"},
    {&stream_oe_add_script, "add_script"},
    {&stream_oe_can_read, "can_read"},
    {&stream_oe_can_write, "can_write"},
    {&stream_oe_close, "close"},
    {&stream_oe_copy, "copy"},
    {&stream_oe_create_input, "create_input"},
    {&stream_oe_create_output, "create_output"},
    {&stream_oe_display, "display"},
    {&stream_oe_empty, "empty"},
    {&stream_oe_equal, "equal"},
    {&stream_oe_error_output, "error_output"},
    {&stream_oe_flush, "flush"},
    {&stream_oe_get_contents, "get_contents"},
    {&stream_oe_get_date, "get_date"},
    {&stream_oe_get_eof_flag, "get_eof_flag"},
    {&stream_oe_get_input_buffered, "get_input_buffered"},
    {&stream_oe_get_line_length, "get_line_length"},
    {&stream_oe_get_lineno, "get_lineno"},
    {&stream_oe_get_name, "get_name"},
    {&stream_oe_get_output_buffered, "get_output_buffered"},
    {&stream_oe_get_page_length, "get_page_length"},
    {&stream_oe_get_prompt, "get_prompt"},
    {&stream_oe_get_rescan, "get_rescan"},
    {&stream_oe_getbuf, "getbuf"},
    {&stream_oe_getc, "getc"},
    {&stream_oe_getc_image, "getc_image"},
    {&stream_oe_getl, "getl"},
    {&stream_oe_gets, "gets"},
    {&stream_oe_gets_image, "gets_image"},
    {&stream_oe_is_closed, "is_closed"},
    {&stream_oe_is_terminal, "is_terminal"},
    {&stream_oe_modify_display, "modify_display"},
    {&stream_oe_open, "open"},
    {&stream_oe_peekc, "peekc"},
    {&stream_oe_pending, "pending"},
    {&stream_oe_primary_input, "primary_input"},
    {&stream_oe_primary_output, "primary_output"},
    {&stream_oe_print, "print"},
    {&stream_oe_putc, "putc"},
    {&stream_oe_putc_image, "putc_image"},
    {&stream_oe_putl, "putl"},
    {&stream_oe_putleft, "putleft"},
    {&stream_oe_putright, "putright"},
    {&stream_oe_puts, "puts"},
    {&stream_oe_puts_image, "puts_image"},
    {&stream_oe_putspace, "putspace"},
    {&stream_oe_putzero, "putzero"},
    {&stream_oe_rem_script, "rem_script"},
    {&stream_oe_reset, "reset"},
    {&stream_oe_scripts, "scripts"},
    {&stream_oe_set_date, "set_date"},
    {&stream_oe_set_eof_flag, "set_eof_flag"},
    {&stream_oe_set_input_buffered, "set_input_buffered"},
    {&stream_oe_set_lineno, "set_lineno"},
    {&stream_oe_set_output_buffered, "set_output_buffered"},
    {&stream_oe_set_prompt, "set_prompt"},
    {&stream_oe_set_rescan, "set_rescan"},
    {&stream_oe_similar, "similar"},
    {&stream_oe_unscript, "unscript"}}};

struct OPS *stream_ops = (struct OPS *)&stream_ops_actual;

/**** END CLUSTER stream ****/
