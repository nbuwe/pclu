
/* This file was automatically generated by pclu. */

#include "pclu_err.h"
#include "pclu_sys.h"

/**** BEGIN CLUSTER _error_messages ****/

extern errcode sequenceOPfetch();
extern errcode stringOPconcat();
extern errcode intOPunparse();
extern errcode sequenceOPindexes();
extern errcode stringOPequal();
static CLUREF STR_not_040owner;
static CLUREF STR_no_040such_040file_040or_040directory;
static CLUREF STR_no_040such_040process;
static CLUREF STR_interrupted_040system_040call;
static CLUREF STR_i_057o_040error;
static CLUREF STR_no_040such_040device_040or_040address;
static CLUREF STR_arg_040list_040too_040long;
static CLUREF STR_exec_040format_040error;
static CLUREF STR_bad_040file_040number;
static CLUREF STR_no_040children;
static CLUREF STR_no_040more_040processes;
static CLUREF STR_not_040enough_040core;
static CLUREF STR_permission_040denied;
static CLUREF STR_bad_040address;
static CLUREF STR_block_040device_040required;
static CLUREF STR_mount_040device_040busy;
static CLUREF STR_file_040exists;
static CLUREF STR_cross_055device_040link;
static CLUREF STR_no_040such_040device;
static CLUREF STR_not_040a_040directory;
static CLUREF STR_is_040a_040directory;
static CLUREF STR_invalid_040argument;
static CLUREF STR_file_040table_040overflow;
static CLUREF STR_too_040many_040open_040files;
static CLUREF STR_not_040a_040typewriter;
static CLUREF STR_text_040file_040busy;
static CLUREF STR_file_040too_040large;
static CLUREF STR_no_040space_040left_040on_040device;
static CLUREF STR_illegal_040seek;
static CLUREF STR_read_055only_040file_040system;
static CLUREF STR_too_040many_040links;
static CLUREF STR_broken_040pipe;
static CLUREF STR_math_040argument;
static CLUREF STR_result_040too_040large;
static CLUREF STR_operation_040would_040block;
static CLUREF STR_operation_040now_040in_040progress;
static CLUREF STR_operation_040already_040in_040progress;
static CLUREF STR_socket_040operation_040on_040non_055socket;
static CLUREF STR_destination_040address_040required;
static CLUREF STR_message_040too_040long;
static CLUREF STR_protocol_040wrong_040type_040for_040socket;
static CLUREF STR_bad_040protocol_040option;
static CLUREF STR_protocol_040not_040supported;
static CLUREF STR_socket_040type_040not_040supported;
static CLUREF STR_operation_040not_040supported_040on_040socket;
static CLUREF STR_protocol_040family_040not_040supported;
static CLUREF STR_address_040family_040not_040supported_040by_040protocol_040family;
static CLUREF STR_address_040already_040in_040use;
static CLUREF STR_cannot_040assign_040requested_040address;
static CLUREF STR_network_040is_040down;
static CLUREF STR_network_040is_040unreachable;
static CLUREF STR_network_040dropped_040connection_040on_040reset;
static CLUREF STR_software_040caused_040connection_040abort;
static CLUREF STR_connection_040reset_040by_040peer;
static CLUREF STR_no_040buffer_040space_040available;
static CLUREF STR_socket_040is_040already_040connected;
static CLUREF STR_socket_040is_040not_040connected;
static CLUREF STR_cannot_040send_040after_040socket_040shutdown;
static CLUREF STR_error_04059;
static CLUREF STR_connection_040timed_040out;
static CLUREF STR_connection_040refused;
static CLUREF STR_too_040many_040levels_040of_040symbols_040links;
static CLUREF STR_file_040name_040too_040long;
static CLUREF STR_directory_040not_040empty;
static CLUREF STR_error_040;
static int _error_messages_own_init = 0;
const OWN_req _error_messages_ownreqs = { 0, 0 };
CLUREF _error_messagesOPmsgs;

errcode
_error_messages_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (_error_messages_own_init == 0) {
        stringOPcons("not owner", CLU_1, CLUREF_make_num(9), &STR_not_040owner);
        stringOPcons("no such file or directory", CLU_1, CLUREF_make_num(25), &STR_no_040such_040file_040or_040directory);
        stringOPcons("no such process", CLU_1, CLUREF_make_num(15), &STR_no_040such_040process);
        stringOPcons("interrupted system call", CLU_1, CLUREF_make_num(23), &STR_interrupted_040system_040call);
        stringOPcons("i/o error", CLU_1, CLUREF_make_num(9), &STR_i_057o_040error);
        stringOPcons("no such device or address", CLU_1, CLUREF_make_num(25), &STR_no_040such_040device_040or_040address);
        stringOPcons("arg list too long", CLU_1, CLUREF_make_num(17), &STR_arg_040list_040too_040long);
        stringOPcons("exec format error", CLU_1, CLUREF_make_num(17), &STR_exec_040format_040error);
        stringOPcons("bad file number", CLU_1, CLUREF_make_num(15), &STR_bad_040file_040number);
        stringOPcons("no children", CLU_1, CLUREF_make_num(11), &STR_no_040children);
        stringOPcons("no more processes", CLU_1, CLUREF_make_num(17), &STR_no_040more_040processes);
        stringOPcons("not enough core", CLU_1, CLUREF_make_num(15), &STR_not_040enough_040core);
        stringOPcons("permission denied", CLU_1, CLUREF_make_num(17), &STR_permission_040denied);
        stringOPcons("bad address", CLU_1, CLUREF_make_num(11), &STR_bad_040address);
        stringOPcons("block device required", CLU_1, CLUREF_make_num(21), &STR_block_040device_040required);
        stringOPcons("mount device busy", CLU_1, CLUREF_make_num(17), &STR_mount_040device_040busy);
        stringOPcons("file exists", CLU_1, CLUREF_make_num(11), &STR_file_040exists);
        stringOPcons("cross-device link", CLU_1, CLUREF_make_num(17), &STR_cross_055device_040link);
        stringOPcons("no such device", CLU_1, CLUREF_make_num(14), &STR_no_040such_040device);
        stringOPcons("not a directory", CLU_1, CLUREF_make_num(15), &STR_not_040a_040directory);
        stringOPcons("is a directory", CLU_1, CLUREF_make_num(14), &STR_is_040a_040directory);
        stringOPcons("invalid argument", CLU_1, CLUREF_make_num(16), &STR_invalid_040argument);
        stringOPcons("file table overflow", CLU_1, CLUREF_make_num(19), &STR_file_040table_040overflow);
        stringOPcons("too many open files", CLU_1, CLUREF_make_num(19), &STR_too_040many_040open_040files);
        stringOPcons("not a typewriter", CLU_1, CLUREF_make_num(16), &STR_not_040a_040typewriter);
        stringOPcons("text file busy", CLU_1, CLUREF_make_num(14), &STR_text_040file_040busy);
        stringOPcons("file too large", CLU_1, CLUREF_make_num(14), &STR_file_040too_040large);
        stringOPcons("no space left on device", CLU_1, CLUREF_make_num(23), &STR_no_040space_040left_040on_040device);
        stringOPcons("illegal seek", CLU_1, CLUREF_make_num(12), &STR_illegal_040seek);
        stringOPcons("read-only file system", CLU_1, CLUREF_make_num(21), &STR_read_055only_040file_040system);
        stringOPcons("too many links", CLU_1, CLUREF_make_num(14), &STR_too_040many_040links);
        stringOPcons("broken pipe", CLU_1, CLUREF_make_num(11), &STR_broken_040pipe);
        stringOPcons("math argument", CLU_1, CLUREF_make_num(13), &STR_math_040argument);
        stringOPcons("result too large", CLU_1, CLUREF_make_num(16), &STR_result_040too_040large);
        stringOPcons("operation would block", CLU_1, CLUREF_make_num(21), &STR_operation_040would_040block);
        stringOPcons("operation now in progress", CLU_1, CLUREF_make_num(25), &STR_operation_040now_040in_040progress);
        stringOPcons("operation already in progress", CLU_1, CLUREF_make_num(29), &STR_operation_040already_040in_040progress);
        stringOPcons("socket operation on non-socket", CLU_1, CLUREF_make_num(30), &STR_socket_040operation_040on_040non_055socket);
        stringOPcons("destination address required", CLU_1, CLUREF_make_num(28), &STR_destination_040address_040required);
        stringOPcons("message too long", CLU_1, CLUREF_make_num(16), &STR_message_040too_040long);
        stringOPcons("protocol wrong type for socket", CLU_1, CLUREF_make_num(30), &STR_protocol_040wrong_040type_040for_040socket);
        stringOPcons("bad protocol option", CLU_1, CLUREF_make_num(19), &STR_bad_040protocol_040option);
        stringOPcons("protocol not supported", CLU_1, CLUREF_make_num(22), &STR_protocol_040not_040supported);
        stringOPcons("socket type not supported", CLU_1, CLUREF_make_num(25), &STR_socket_040type_040not_040supported);
        stringOPcons("operation not supported on socket", CLU_1, CLUREF_make_num(33), &STR_operation_040not_040supported_040on_040socket);
        stringOPcons("protocol family not supported", CLU_1, CLUREF_make_num(29), &STR_protocol_040family_040not_040supported);
        stringOPcons("address family not supported by protocol family", CLU_1, CLUREF_make_num(47), &STR_address_040family_040not_040supported_040by_040protocol_040family);
        stringOPcons("address already in use", CLU_1, CLUREF_make_num(22), &STR_address_040already_040in_040use);
        stringOPcons("cannot assign requested address", CLU_1, CLUREF_make_num(31), &STR_cannot_040assign_040requested_040address);
        stringOPcons("network is down", CLU_1, CLUREF_make_num(15), &STR_network_040is_040down);
        stringOPcons("network is unreachable", CLU_1, CLUREF_make_num(22), &STR_network_040is_040unreachable);
        stringOPcons("network dropped connection on reset", CLU_1, CLUREF_make_num(35), &STR_network_040dropped_040connection_040on_040reset);
        stringOPcons("software caused connection abort", CLU_1, CLUREF_make_num(32), &STR_software_040caused_040connection_040abort);
        stringOPcons("connection reset by peer", CLU_1, CLUREF_make_num(24), &STR_connection_040reset_040by_040peer);
        stringOPcons("no buffer space available", CLU_1, CLUREF_make_num(25), &STR_no_040buffer_040space_040available);
        stringOPcons("socket is already connected", CLU_1, CLUREF_make_num(27), &STR_socket_040is_040already_040connected);
        stringOPcons("socket is not connected", CLU_1, CLUREF_make_num(23), &STR_socket_040is_040not_040connected);
        stringOPcons("cannot send after socket shutdown", CLU_1, CLUREF_make_num(33), &STR_cannot_040send_040after_040socket_040shutdown);
        stringOPcons("error 59", CLU_1, CLUREF_make_num(8), &STR_error_04059);
        stringOPcons("connection timed out", CLU_1, CLUREF_make_num(20), &STR_connection_040timed_040out);
        stringOPcons("connection refused", CLU_1, CLUREF_make_num(18), &STR_connection_040refused);
        stringOPcons("too many levels of symbols links", CLU_1, CLUREF_make_num(32), &STR_too_040many_040levels_040of_040symbols_040links);
        stringOPcons("file name too long", CLU_1, CLUREF_make_num(18), &STR_file_040name_040too_040long);
        stringOPcons("directory not empty", CLU_1, CLUREF_make_num(19), &STR_directory_040not_040empty);
        stringOPcons("error ", CLU_1, CLUREF_make_num(6), &STR_error_040);
        _error_messages_own_init = 1;
        {
        CLUREF T_0_1;
        sequenceOPnew2(CLUREF_make_num(64), &T_0_1);
        T_0_1.vec->data[0] = STR_not_040owner.num;
        T_0_1.vec->data[1] = STR_no_040such_040file_040or_040directory.num;
        T_0_1.vec->data[2] = STR_no_040such_040process.num;
        T_0_1.vec->data[3] = STR_interrupted_040system_040call.num;
        T_0_1.vec->data[4] = STR_i_057o_040error.num;
        T_0_1.vec->data[5] = STR_no_040such_040device_040or_040address.num;
        T_0_1.vec->data[6] = STR_arg_040list_040too_040long.num;
        T_0_1.vec->data[7] = STR_exec_040format_040error.num;
        T_0_1.vec->data[8] = STR_bad_040file_040number.num;
        T_0_1.vec->data[9] = STR_no_040children.num;
        T_0_1.vec->data[10] = STR_no_040more_040processes.num;
        T_0_1.vec->data[11] = STR_not_040enough_040core.num;
        T_0_1.vec->data[12] = STR_permission_040denied.num;
        T_0_1.vec->data[13] = STR_bad_040address.num;
        T_0_1.vec->data[14] = STR_block_040device_040required.num;
        T_0_1.vec->data[15] = STR_mount_040device_040busy.num;
        T_0_1.vec->data[16] = STR_file_040exists.num;
        T_0_1.vec->data[17] = STR_cross_055device_040link.num;
        T_0_1.vec->data[18] = STR_no_040such_040device.num;
        T_0_1.vec->data[19] = STR_not_040a_040directory.num;
        T_0_1.vec->data[20] = STR_is_040a_040directory.num;
        T_0_1.vec->data[21] = STR_invalid_040argument.num;
        T_0_1.vec->data[22] = STR_file_040table_040overflow.num;
        T_0_1.vec->data[23] = STR_too_040many_040open_040files.num;
        T_0_1.vec->data[24] = STR_not_040a_040typewriter.num;
        T_0_1.vec->data[25] = STR_text_040file_040busy.num;
        T_0_1.vec->data[26] = STR_file_040too_040large.num;
        T_0_1.vec->data[27] = STR_no_040space_040left_040on_040device.num;
        T_0_1.vec->data[28] = STR_illegal_040seek.num;
        T_0_1.vec->data[29] = STR_read_055only_040file_040system.num;
        T_0_1.vec->data[30] = STR_too_040many_040links.num;
        T_0_1.vec->data[31] = STR_broken_040pipe.num;
        T_0_1.vec->data[32] = STR_math_040argument.num;
        T_0_1.vec->data[33] = STR_result_040too_040large.num;
        T_0_1.vec->data[34] = STR_operation_040would_040block.num;
        T_0_1.vec->data[35] = STR_operation_040now_040in_040progress.num;
        T_0_1.vec->data[36] = STR_operation_040already_040in_040progress.num;
        T_0_1.vec->data[37] = STR_socket_040operation_040on_040non_055socket.num;
        T_0_1.vec->data[38] = STR_destination_040address_040required.num;
        T_0_1.vec->data[39] = STR_message_040too_040long.num;
        T_0_1.vec->data[40] = STR_protocol_040wrong_040type_040for_040socket.num;
        T_0_1.vec->data[41] = STR_bad_040protocol_040option.num;
        T_0_1.vec->data[42] = STR_protocol_040not_040supported.num;
        T_0_1.vec->data[43] = STR_socket_040type_040not_040supported.num;
        T_0_1.vec->data[44] = STR_operation_040not_040supported_040on_040socket.num;
        T_0_1.vec->data[45] = STR_protocol_040family_040not_040supported.num;
        T_0_1.vec->data[46] = STR_address_040family_040not_040supported_040by_040protocol_040family.num;
        T_0_1.vec->data[47] = STR_address_040already_040in_040use.num;
        T_0_1.vec->data[48] = STR_cannot_040assign_040requested_040address.num;
        T_0_1.vec->data[49] = STR_network_040is_040down.num;
        T_0_1.vec->data[50] = STR_network_040is_040unreachable.num;
        T_0_1.vec->data[51] = STR_network_040dropped_040connection_040on_040reset.num;
        T_0_1.vec->data[52] = STR_software_040caused_040connection_040abort.num;
        T_0_1.vec->data[53] = STR_connection_040reset_040by_040peer.num;
        T_0_1.vec->data[54] = STR_no_040buffer_040space_040available.num;
        T_0_1.vec->data[55] = STR_socket_040is_040already_040connected.num;
        T_0_1.vec->data[56] = STR_socket_040is_040not_040connected.num;
        T_0_1.vec->data[57] = STR_cannot_040send_040after_040socket_040shutdown.num;
        T_0_1.vec->data[58] = STR_error_04059.num;
        T_0_1.vec->data[59] = STR_connection_040timed_040out.num;
        T_0_1.vec->data[60] = STR_connection_040refused.num;
        T_0_1.vec->data[61] = STR_too_040many_040levels_040of_040symbols_040links.num;
        T_0_1.vec->data[62] = STR_file_040name_040too_040long.num;
        T_0_1.vec->data[63] = STR_directory_040not_040empty.num;
        _error_messagesOPmsgs.num = T_0_1.num;
        }
        signal(ERR_ok);
      ex_0:
        __CLU_EX_HANDLER;
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE _erstr ****/

static int _error_messagesOP_erstr_own_init = 0;

errcode
_error_messagesOP_erstr(CLUREF num, CLUREF *ret_1)
{
    errcode err;
    if (_error_messagesOP_erstr_own_init == 0) {
        if (_error_messages_own_init == 0) {
            err = _error_messages_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        _error_messagesOP_erstr_own_init = 1;
    }
    enter_proc(72);

  LINE(73);
    { /* return */
    {
    CLUREF T_2_1;
    if (num.num < 1 || num.num > _error_messagesOPmsgs.vec->size) {
        err = ERR_bounds;
        goto ex_1;
    }
    T_2_1.num = _error_messagesOPmsgs.vec->data[num.num - 1];
    ret_1->num = T_2_1.num;
    }
    signal (ERR_ok);
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_bounds) {

  LINE(75);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = intOPunparse(num, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(STR_error_040, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_2.num;
        }
        signal (ERR_ok);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE _erstr ****/


/**** BEGIN PROCEDURE _ernum ****/


errcode
_error_messagesOP_ernum(CLUREF msg, CLUREF *ret_1)
{
    errcode err;
    CLUREF i;
    if (_error_messages_own_init == 0) {
        err = _error_messages_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(79);

  LINE(80);
    { /* for sequence$indexes */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = _error_messagesOPmsgs.vec->size;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        i.num = T_1_1.num;

  LINE(81);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (i.num < 1 || i.num > _error_messagesOPmsgs.vec->size) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.num = _error_messagesOPmsgs.vec->data[i.num - 1];
        T_2_2.num = ((msg.str->size != T_2_1.str->size)? false :
            !(memcmp(msg.str->data, T_2_1.str->data, msg.str->size)));
        if (T_2_2.num == true) { /* if */

  LINE(82);
            { /* return */
            {
            ret_1->num = i.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(85);
    { /* signal */
        signal(ERR_not_found);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE _ernum ****/

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[2];
} _error_messages_OPS;

static CLU_proc _error_messages_oe__ernum = { .proc = _error_messagesOP_ernum };
static CLU_proc _error_messages_oe__erstr = { .proc = _error_messagesOP_erstr };

static _error_messages_OPS _error_messages_ops_actual = {2, (OWNPTR)&_error_messages_own_init, (OWNPTR)&_error_messages_own_init, {
    {&_error_messages_oe__ernum, "_ernum"},
    {&_error_messages_oe__erstr, "_erstr"}}};

struct OPS *_error_messages_ops = (struct OPS *)&_error_messages_ops_actual;

/**** END CLUSTER _error_messages ****/


/**** BEGIN PROCEDURE _erstr ****/

extern errcode _error_messagesOP_erstr();

errcode
_erstr(CLUREF num, CLUREF *ret_1)
{
    errcode err;
    enter_proc(90);

  LINE(91);
    { /* return */
    {
    CLUREF T_1_1;
    err = _error_messagesOP_erstr(num, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE _erstr ****/



/**** BEGIN PROCEDURE _ernum ****/

extern errcode _error_messagesOP_ernum();

errcode
_ernum(CLUREF msg, CLUREF *ret_1)
{
    errcode err;
    enter_proc(94);

  LINE(95);
    { /* return */
    {
    CLUREF T_2_1;
    err = _error_messagesOP_ernum(msg, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    ret_1->num = T_2_1.num;
    }
    signal (ERR_ok);
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_found)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE _ernum ****/

