
/* This file was automatically generated by pclu. */

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER tokentab ****/

extern errcode tableOPcreate();
extern errcode hash();
extern errcode stringOPequal();
extern errcode tableOPalter();
extern errcode oneofOPmake_34();
extern errcode oneofOPmake_1();
extern errcode oneofOPmake_2();
extern errcode oneofOPmake_23();
extern errcode oneofOPmake_4();
extern errcode oneofOPmake_3();
extern errcode oneofOPmake_5();
extern errcode oneofOPmake_14();
extern errcode oneofOPmake_7();
extern errcode oneofOPmake_8();
extern errcode oneofOPmake_9();
extern errcode oneofOPmake_12();
extern errcode oneofOPmake_13();
extern errcode oneofOPmake_15();
extern errcode oneofOPmake_6();
extern errcode oneofOPmake_17();
extern errcode oneofOPmake_18();
extern errcode oneofOPmake_19();
extern errcode oneofOPmake_24();
extern errcode oneofOPmake_29();
extern errcode oneofOPmake_30();
extern errcode oneofOPmake_33();
extern errcode oneofOPmake_35();
extern errcode oneofOPmake_10();
extern errcode oneofOPmake_36();
extern errcode oneofOPmake_39();
extern errcode oneofOPmake_40();
extern errcode oneofOPmake_11();
extern errcode oneofOPmake_41();
extern errcode tokentabOPreset();
extern errcode tokentabOPunhack();
extern errcode tableOPcond_flush();
extern errcode oneofOPis_16();
extern errcode oneofOPmake_37();
extern errcode ceOPget_any_type();
extern errcode oneofOPmake_38();
extern errcode ceOPget_array_();
extern errcode ceOPget_bool_type();
extern errcode ceOPget_char_type();
extern errcode ceOPget_cvt_type();
extern errcode ceOPget_int_type();
extern errcode ceOPget_iter_();
extern errcode ceOPget_null_type();
extern errcode ceOPget_oneof_();
extern errcode ceOPget_proc_();
extern errcode ceOPget_real_type();
extern errcode ceOPget_record_();
extern errcode tokentabOPident();
extern errcode ceOPget_seq_();
extern errcode ceOPget_str_type();
extern errcode ceOPget_struct_();
extern errcode ceOPget_type_type();
extern errcode ceOPget_variant_();
extern errcode idnOPcreate();
extern errcode oneofOPmake_16();
extern errcode tableOPlookup();
extern errcode tableOPbind();
extern struct OPS *null_ops;
extern struct OPS *du_ops;
struct OPS *oneof_applytype__cluster__iter__proc__selector__ops __CLU_COMMON;
extern struct OPS *bool_ops;
extern struct OPS *string_ops;
extern struct OPS *int_ops;
struct OPS *struct_neg_op_prec_ops __CLU_COMMON;
extern const struct REQS * const sequence_of_t_reqs;
extern struct OPS *expr_ops;
extern const OWN_req sequence_ownreqs;
extern struct OPS *sequence_ops;
struct OPS *sequence_of_expr_ops __CLU_COMMON;
struct OPS *oneof_none_one_ops __CLU_COMMON;
extern struct OPS *sequence_of_expr_ops;
extern struct OPS *oneof_none_one_ops;
extern struct OPS *typespec_ops;
struct OPS *record_elts_low_type__ops __CLU_COMMON;
struct OPS *record_gen_parms_ops __CLU_COMMON;
struct OPS *record_left_right_ops __CLU_COMMON;
struct OPS *record_index_object_ops __CLU_COMMON;
struct OPS *record_object_sel_ops __CLU_COMMON;
struct OPS *record_left_neg_op_right_ops __CLU_COMMON;
struct OPS *record_apply_args_ops __CLU_COMMON;
struct OPS *record_name_parms_type__ops __CLU_COMMON;
extern struct OPS *idn_ops;
struct OPS *record_idn_parms_ops __CLU_COMMON;
struct OPS *sequence_of_string_ops __CLU_COMMON;
extern struct OPS *sequence_of_string_ops;
struct OPS *record_line_sels_val_ops __CLU_COMMON;
extern struct OPS *record_line_sels_val_ops;
struct OPS *sequence_of_record_line_sels_val_ops __CLU_COMMON;
extern struct OPS *sequence_of_record_line_sels_val_ops;
struct OPS *record_fields_type__ops __CLU_COMMON;
extern struct OPS *record_elts_low_type__ops;
extern struct OPS *record_gen_parms_ops;
extern struct OPS *record_left_right_ops;
extern struct OPS *char_ops;
extern struct OPS *record_index_object_ops;
extern struct OPS *record_object_sel_ops;
extern struct OPS *record_left_neg_op_right_ops;
extern struct OPS *record_apply_args_ops;
extern struct OPS *record_name_parms_type__ops;
extern struct OPS *real_ops;
extern struct OPS *record_idn_parms_ops;
extern struct OPS *record_fields_type__ops;
struct OPS *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_down__force__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_begin__break__continue__exit__for__if__own__return__signal__tagcase__while__yield__ops __CLU_COMMON;
struct OPS *oneof_applytype__cluster__rep__selector__ops __CLU_COMMON;
extern struct OPS *oneof_applytype__cluster__iter__proc__selector__ops;
extern struct OPS *struct_neg_op_prec_ops;
extern struct OPS *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops;
extern struct OPS *oneof_down__force__type_of__up__ops;
extern struct OPS *oneof_begin__break__continue__exit__for__if__own__return__signal__tagcase__while__yield__ops;
extern struct OPS *oneof_applytype__cluster__rep__selector__ops;
struct OPS *oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
extern const struct REQS * const table_of_key_reqs;
extern const struct REQS * const table_of_val_reqs;
extern struct OPS *oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops;
extern const OWN_req table_ownreqs;
extern struct OPS *table_ops;
struct OPS *table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
static CLUREF STR_begin;
static CLUREF STR_break;
static CLUREF STR_cand;
static CLUREF STR_cluster;
static CLUREF STR_continue;
static CLUREF STR_cor;
static CLUREF STR_do;
static CLUREF STR_down;
static CLUREF STR_else;
static CLUREF STR_elseif;
static CLUREF STR_end;
static CLUREF STR_except;
static CLUREF STR_exit;
static CLUREF STR_false;
static CLUREF STR_for;
static CLUREF STR_force;
static CLUREF STR_has;
static CLUREF STR_if;
static CLUREF STR_in;
static CLUREF STR_is;
static CLUREF STR_nil;
static CLUREF STR_others;
static CLUREF STR_own;
static CLUREF STR_resignal;
static CLUREF STR_return;
static CLUREF STR_returns;
static CLUREF STR_signal;
static CLUREF STR_signals;
static CLUREF STR_tag;
static CLUREF STR_tagcase;
static CLUREF STR_then;
static CLUREF STR_true;
static CLUREF STR_up;
static CLUREF STR_when;
static CLUREF STR_where;
static CLUREF STR_while;
static CLUREF STR_yield;
static CLUREF STR_yields;
static CLUREF STR_any;
static CLUREF STR_array;
static CLUREF STR_bool;
static CLUREF STR_char;
static CLUREF STR_cvt;
static CLUREF STR_int;
static CLUREF STR_iter;
static CLUREF STR_itertype;
static CLUREF STR_null;
static CLUREF STR_oneof;
static CLUREF STR_proc;
static CLUREF STR_proctype;
static CLUREF STR_real;
static CLUREF STR_record;
static CLUREF STR_rep;
static CLUREF STR_REP;
static CLUREF STR_sequence;
static CLUREF STR_string;
static CLUREF STR_struct;
static CLUREF STR_type;
static CLUREF STR_variant;
static CLUREF STR_applytype;
static CLUREF STR_selector;
static CLUREF STR_type_137of;
static CLUREF STR_monitor;
static int tokentab_own_init = 0;
const OWN_req tokentab_ownreqs = { 0, 0 };

errcode
tokentab_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (tokentab_own_init == 0) {
        add_selector_info("applytype_", 0, (struct OPS *)null_ops);
        add_selector_info("cluster_", 1, (struct OPS *)null_ops);
        add_selector_info("iter_", 2, (struct OPS *)du_ops);
        add_selector_info("proc_", 3, (struct OPS *)du_ops);
        add_selector_info("selector_", 4, (struct OPS *)null_ops);
        find_selector_ops("oneof", 5, &(oneof_applytype__cluster__iter__proc__selector__ops));
        add_selector_info("neg", 0, (struct OPS *)bool_ops);
        add_selector_info("op", 1, (struct OPS *)string_ops);
        add_selector_info("prec", 2, (struct OPS *)int_ops);
        find_selector_ops("struct", 3, &(struct_neg_op_prec_ops));
        add_parm_info_type(0, (const struct OPS *)expr_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_expr_ops));
        add_selector_info("none", 0, (struct OPS *)null_ops);
        add_selector_info("one", 1, (struct OPS *)expr_ops);
        find_selector_ops("oneof", 2, &(oneof_none_one_ops));
        add_selector_info("elts", 0, (struct OPS *)sequence_of_expr_ops);
        add_selector_info("low", 1, (struct OPS *)oneof_none_one_ops);
        add_selector_info("type_", 2, (struct OPS *)typespec_ops);
        find_selector_ops("record", 3, &(record_elts_low_type__ops));
        add_selector_info("gen", 0, (struct OPS *)du_ops);
        add_selector_info("parms", 1, (struct OPS *)sequence_of_expr_ops);
        find_selector_ops("record", 2, &(record_gen_parms_ops));
        add_selector_info("left", 0, (struct OPS *)expr_ops);
        add_selector_info("right", 1, (struct OPS *)expr_ops);
        find_selector_ops("record", 2, &(record_left_right_ops));
        add_selector_info("index", 0, (struct OPS *)expr_ops);
        add_selector_info("object", 1, (struct OPS *)expr_ops);
        find_selector_ops("record", 2, &(record_index_object_ops));
        add_selector_info("object", 0, (struct OPS *)expr_ops);
        add_selector_info("sel", 1, (struct OPS *)string_ops);
        find_selector_ops("record", 2, &(record_object_sel_ops));
        add_selector_info("left", 0, (struct OPS *)expr_ops);
        add_selector_info("neg", 1, (struct OPS *)bool_ops);
        add_selector_info("op", 2, (struct OPS *)string_ops);
        add_selector_info("right", 3, (struct OPS *)expr_ops);
        find_selector_ops("record", 4, &(record_left_neg_op_right_ops));
        add_selector_info("apply", 0, (struct OPS *)expr_ops);
        add_selector_info("args", 1, (struct OPS *)sequence_of_expr_ops);
        find_selector_ops("record", 2, &(record_apply_args_ops));
        add_selector_info("name", 0, (struct OPS *)string_ops);
        add_selector_info("parms", 1, (struct OPS *)sequence_of_expr_ops);
        add_selector_info("type_", 2, (struct OPS *)typespec_ops);
        find_selector_ops("record", 3, &(record_name_parms_type__ops));
        add_selector_info("idn", 0, (struct OPS *)idn_ops);
        add_selector_info("parms", 1, (struct OPS *)sequence_of_expr_ops);
        find_selector_ops("record", 2, &(record_idn_parms_ops));
        add_parm_info_type(0, (const struct OPS *)string_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_string_ops));
        add_selector_info("line", 0, (struct OPS *)int_ops);
        add_selector_info("sels", 1, (struct OPS *)sequence_of_string_ops);
        add_selector_info("val", 2, (struct OPS *)expr_ops);
        find_selector_ops("record", 3, &(record_line_sels_val_ops));
        add_parm_info_type(0, (const struct OPS *)record_line_sels_val_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_line_sels_val_ops));
        add_selector_info("fields", 0, (struct OPS *)sequence_of_record_line_sels_val_ops);
        add_selector_info("type_", 1, (struct OPS *)typespec_ops);
        find_selector_ops("record", 2, &(record_fields_type__ops));
        add_selector_info("a_cons", 0, (struct OPS *)record_elts_low_type__ops);
        add_selector_info("any_", 1, (struct OPS *)expr_ops);
        add_selector_info("apply", 2, (struct OPS *)record_gen_parms_ops);
        add_selector_info("bad", 3, (struct OPS *)null_ops);
        add_selector_info("bool_", 4, (struct OPS *)bool_ops);
        add_selector_info("cand_", 5, (struct OPS *)record_left_right_ops);
        add_selector_info("char_", 6, (struct OPS *)char_ops);
        add_selector_info("cor_", 7, (struct OPS *)record_left_right_ops);
        add_selector_info("down_", 8, (struct OPS *)expr_ops);
        add_selector_info("fetch", 9, (struct OPS *)record_index_object_ops);
        add_selector_info("force_", 10, (struct OPS *)typespec_ops);
        add_selector_info("get", 11, (struct OPS *)record_object_sel_ops);
        add_selector_info("idn", 12, (struct OPS *)idn_ops);
        add_selector_info("infix", 13, (struct OPS *)record_left_neg_op_right_ops);
        add_selector_info("int_", 14, (struct OPS *)int_ops);
        add_selector_info("invoke", 15, (struct OPS *)record_apply_args_ops);
        add_selector_info("minus", 16, (struct OPS *)expr_ops);
        add_selector_info("not", 17, (struct OPS *)expr_ops);
        add_selector_info("null_", 18, (struct OPS *)null_ops);
        add_selector_info("op", 19, (struct OPS *)record_name_parms_type__ops);
        add_selector_info("real_", 20, (struct OPS *)real_ops);
        add_selector_info("ref", 21, (struct OPS *)record_idn_parms_ops);
        add_selector_info("s_cons", 22, (struct OPS *)record_fields_type__ops);
        add_selector_info("str", 23, (struct OPS *)string_ops);
        add_selector_info("type_", 24, (struct OPS *)typespec_ops);
        add_selector_info("type_of_", 25, (struct OPS *)expr_ops);
        add_selector_info("up_", 26, (struct OPS *)expr_ops);
        find_selector_ops("oneof", 27, &(oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops));
        add_selector_info("down_", 0, (struct OPS *)null_ops);
        add_selector_info("force_", 1, (struct OPS *)null_ops);
        add_selector_info("type_of_", 2, (struct OPS *)null_ops);
        add_selector_info("up_", 3, (struct OPS *)null_ops);
        find_selector_ops("oneof", 4, &(oneof_down__force__type_of__up__ops));
        add_selector_info("begin_", 0, (struct OPS *)null_ops);
        add_selector_info("break_", 1, (struct OPS *)null_ops);
        add_selector_info("continue_", 2, (struct OPS *)null_ops);
        add_selector_info("exit_", 3, (struct OPS *)null_ops);
        add_selector_info("for_", 4, (struct OPS *)null_ops);
        add_selector_info("if_", 5, (struct OPS *)null_ops);
        add_selector_info("own_", 6, (struct OPS *)null_ops);
        add_selector_info("return_", 7, (struct OPS *)null_ops);
        add_selector_info("signal_", 8, (struct OPS *)null_ops);
        add_selector_info("tagcase_", 9, (struct OPS *)null_ops);
        add_selector_info("while_", 10, (struct OPS *)null_ops);
        add_selector_info("yield_", 11, (struct OPS *)null_ops);
        find_selector_ops("oneof", 12, &(oneof_begin__break__continue__exit__for__if__own__return__signal__tagcase__while__yield__ops));
        add_selector_info("applytype_", 0, (struct OPS *)du_ops);
        add_selector_info("cluster_", 1, (struct OPS *)du_ops);
        add_selector_info("rep_", 2, (struct OPS *)idn_ops);
        add_selector_info("selector_", 3, (struct OPS *)du_ops);
        find_selector_ops("oneof", 4, &(oneof_applytype__cluster__rep__selector__ops));
        add_selector_info("assn", 0, (struct OPS *)null_ops);
        add_selector_info("colon", 1, (struct OPS *)null_ops);
        add_selector_info("comma", 2, (struct OPS *)null_ops);
        add_selector_info("defnkey", 3, (struct OPS *)oneof_applytype__cluster__iter__proc__selector__ops);
        add_selector_info("do_", 4, (struct OPS *)null_ops);
        add_selector_info("dollar", 5, (struct OPS *)null_ops);
        add_selector_info("else_", 6, (struct OPS *)null_ops);
        add_selector_info("elseif_", 7, (struct OPS *)null_ops);
        add_selector_info("end_", 8, (struct OPS *)null_ops);
        add_selector_info("eof", 9, (struct OPS *)null_ops);
        add_selector_info("equal", 10, (struct OPS *)struct_neg_op_prec_ops);
        add_selector_info("except_", 11, (struct OPS *)null_ops);
        add_selector_info("expr", 12, (struct OPS *)oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops);
        add_selector_info("exprkey", 13, (struct OPS *)oneof_down__force__type_of__up__ops);
        add_selector_info("has_", 14, (struct OPS *)null_ops);
        add_selector_info("idn", 15, (struct OPS *)idn_ops);
        add_selector_info("in_", 16, (struct OPS *)null_ops);
        add_selector_info("is_", 17, (struct OPS *)null_ops);
        add_selector_info("l_bkt", 18, (struct OPS *)null_ops);
        add_selector_info("l_curly", 19, (struct OPS *)null_ops);
        add_selector_info("l_paren", 20, (struct OPS *)null_ops);
        add_selector_info("not", 21, (struct OPS *)null_ops);
        add_selector_info("op", 22, (struct OPS *)struct_neg_op_prec_ops);
        add_selector_info("others_", 23, (struct OPS *)null_ops);
        add_selector_info("period", 24, (struct OPS *)null_ops);
        add_selector_info("r_bkt", 25, (struct OPS *)null_ops);
        add_selector_info("r_curly", 26, (struct OPS *)null_ops);
        add_selector_info("r_paren", 27, (struct OPS *)null_ops);
        add_selector_info("resignal_", 28, (struct OPS *)null_ops);
        add_selector_info("returns_", 29, (struct OPS *)null_ops);
        add_selector_info("semi", 30, (struct OPS *)null_ops);
        add_selector_info("sharp", 31, (struct OPS *)null_ops);
        add_selector_info("signals_", 32, (struct OPS *)null_ops);
        add_selector_info("stmtkey", 33, (struct OPS *)oneof_begin__break__continue__exit__for__if__own__return__signal__tagcase__while__yield__ops);
        add_selector_info("tag_", 34, (struct OPS *)null_ops);
        add_selector_info("then_", 35, (struct OPS *)null_ops);
        add_selector_info("type_", 36, (struct OPS *)typespec_ops);
        add_selector_info("typekey", 37, (struct OPS *)oneof_applytype__cluster__rep__selector__ops);
        add_selector_info("when_", 38, (struct OPS *)null_ops);
        add_selector_info("where_", 39, (struct OPS *)null_ops);
        add_selector_info("yields_", 40, (struct OPS *)null_ops);
        find_selector_ops("oneof", 41, &(oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops));
        add_parm_info_type(0, (const struct OPS *)string_ops, table_of_key_reqs);
        add_parm_info_type(1, (const struct OPS *)oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops, table_of_val_reqs);
        find_type_instance(table_ops, 2, &table_ownreqs, &(table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops));
        stringOPcons("begin", CLU_1, CLUREF_make_num(5), &STR_begin);
        stringOPcons("break", CLU_1, CLUREF_make_num(5), &STR_break);
        stringOPcons("cand", CLU_1, CLUREF_make_num(4), &STR_cand);
        stringOPcons("cluster", CLU_1, CLUREF_make_num(7), &STR_cluster);
        stringOPcons("continue", CLU_1, CLUREF_make_num(8), &STR_continue);
        stringOPcons("cor", CLU_1, CLUREF_make_num(3), &STR_cor);
        stringOPcons("do", CLU_1, CLUREF_make_num(2), &STR_do);
        stringOPcons("down", CLU_1, CLUREF_make_num(4), &STR_down);
        stringOPcons("else", CLU_1, CLUREF_make_num(4), &STR_else);
        stringOPcons("elseif", CLU_1, CLUREF_make_num(6), &STR_elseif);
        stringOPcons("end", CLU_1, CLUREF_make_num(3), &STR_end);
        stringOPcons("except", CLU_1, CLUREF_make_num(6), &STR_except);
        stringOPcons("exit", CLU_1, CLUREF_make_num(4), &STR_exit);
        stringOPcons("false", CLU_1, CLUREF_make_num(5), &STR_false);
        stringOPcons("for", CLU_1, CLUREF_make_num(3), &STR_for);
        stringOPcons("force", CLU_1, CLUREF_make_num(5), &STR_force);
        stringOPcons("has", CLU_1, CLUREF_make_num(3), &STR_has);
        stringOPcons("if", CLU_1, CLUREF_make_num(2), &STR_if);
        stringOPcons("in", CLU_1, CLUREF_make_num(2), &STR_in);
        stringOPcons("is", CLU_1, CLUREF_make_num(2), &STR_is);
        stringOPcons("nil", CLU_1, CLUREF_make_num(3), &STR_nil);
        stringOPcons("others", CLU_1, CLUREF_make_num(6), &STR_others);
        stringOPcons("own", CLU_1, CLUREF_make_num(3), &STR_own);
        stringOPcons("resignal", CLU_1, CLUREF_make_num(8), &STR_resignal);
        stringOPcons("return", CLU_1, CLUREF_make_num(6), &STR_return);
        stringOPcons("returns", CLU_1, CLUREF_make_num(7), &STR_returns);
        stringOPcons("signal", CLU_1, CLUREF_make_num(6), &STR_signal);
        stringOPcons("signals", CLU_1, CLUREF_make_num(7), &STR_signals);
        stringOPcons("tag", CLU_1, CLUREF_make_num(3), &STR_tag);
        stringOPcons("tagcase", CLU_1, CLUREF_make_num(7), &STR_tagcase);
        stringOPcons("then", CLU_1, CLUREF_make_num(4), &STR_then);
        stringOPcons("true", CLU_1, CLUREF_make_num(4), &STR_true);
        stringOPcons("up", CLU_1, CLUREF_make_num(2), &STR_up);
        stringOPcons("when", CLU_1, CLUREF_make_num(4), &STR_when);
        stringOPcons("where", CLU_1, CLUREF_make_num(5), &STR_where);
        stringOPcons("while", CLU_1, CLUREF_make_num(5), &STR_while);
        stringOPcons("yield", CLU_1, CLUREF_make_num(5), &STR_yield);
        stringOPcons("yields", CLU_1, CLUREF_make_num(6), &STR_yields);
        stringOPcons("any", CLU_1, CLUREF_make_num(3), &STR_any);
        stringOPcons("array", CLU_1, CLUREF_make_num(5), &STR_array);
        stringOPcons("bool", CLU_1, CLUREF_make_num(4), &STR_bool);
        stringOPcons("char", CLU_1, CLUREF_make_num(4), &STR_char);
        stringOPcons("cvt", CLU_1, CLUREF_make_num(3), &STR_cvt);
        stringOPcons("int", CLU_1, CLUREF_make_num(3), &STR_int);
        stringOPcons("iter", CLU_1, CLUREF_make_num(4), &STR_iter);
        stringOPcons("itertype", CLU_1, CLUREF_make_num(8), &STR_itertype);
        stringOPcons("null", CLU_1, CLUREF_make_num(4), &STR_null);
        stringOPcons("oneof", CLU_1, CLUREF_make_num(5), &STR_oneof);
        stringOPcons("proc", CLU_1, CLUREF_make_num(4), &STR_proc);
        stringOPcons("proctype", CLU_1, CLUREF_make_num(8), &STR_proctype);
        stringOPcons("real", CLU_1, CLUREF_make_num(4), &STR_real);
        stringOPcons("record", CLU_1, CLUREF_make_num(6), &STR_record);
        stringOPcons("rep", CLU_1, CLUREF_make_num(3), &STR_rep);
        stringOPcons("REP", CLU_1, CLUREF_make_num(3), &STR_REP);
        stringOPcons("sequence", CLU_1, CLUREF_make_num(8), &STR_sequence);
        stringOPcons("string", CLU_1, CLUREF_make_num(6), &STR_string);
        stringOPcons("struct", CLU_1, CLUREF_make_num(6), &STR_struct);
        stringOPcons("type", CLU_1, CLUREF_make_num(4), &STR_type);
        stringOPcons("variant", CLU_1, CLUREF_make_num(7), &STR_variant);
        stringOPcons("applytype", CLU_1, CLUREF_make_num(9), &STR_applytype);
        stringOPcons("selector", CLU_1, CLUREF_make_num(8), &STR_selector);
        stringOPcons("type_of", CLU_1, CLUREF_make_num(7), &STR_type_137of);
        stringOPcons("monitor", CLU_1, CLUREF_make_num(7), &STR_monitor);
        tokentab_own_init = 1;
        signal(ERR_ok);
      ex_0:
        __CLU_EX_HANDLER;
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE create ****/

struct OPS *oneof_applytype__cluster__iter__proc__selector__ops __CLU_COMMON;
struct OPS *struct_neg_op_prec_ops __CLU_COMMON;
struct OPS *sequence_of_expr_ops __CLU_COMMON;
struct OPS *oneof_none_one_ops __CLU_COMMON;
struct OPS *record_elts_low_type__ops __CLU_COMMON;
struct OPS *record_gen_parms_ops __CLU_COMMON;
struct OPS *record_left_right_ops __CLU_COMMON;
struct OPS *record_index_object_ops __CLU_COMMON;
struct OPS *record_object_sel_ops __CLU_COMMON;
struct OPS *record_left_neg_op_right_ops __CLU_COMMON;
struct OPS *record_apply_args_ops __CLU_COMMON;
struct OPS *record_name_parms_type__ops __CLU_COMMON;
struct OPS *record_idn_parms_ops __CLU_COMMON;
struct OPS *sequence_of_string_ops __CLU_COMMON;
struct OPS *record_line_sels_val_ops __CLU_COMMON;
struct OPS *sequence_of_record_line_sels_val_ops __CLU_COMMON;
struct OPS *record_fields_type__ops __CLU_COMMON;
struct OPS *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_down__force__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_begin__break__continue__exit__for__if__own__return__signal__tagcase__while__yield__ops __CLU_COMMON;
struct OPS *oneof_applytype__cluster__rep__selector__ops __CLU_COMMON;
struct OPS *oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
struct OPS *table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
static int tokentabOPcreate_own_init = 0;

errcode
tokentabOPcreate(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF t;
    if (tokentabOPcreate_own_init == 0) {
        if (tokentab_own_init == 0) {
            err = tokentab_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        tokentabOPcreate_own_init = 1;
    }
    enter_proc(26);

  LINE(27);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = 500;
    err = proctypeOPnew(CLU_0, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_2.proc->type_owns = NULL;
    T_1_2.proc->op_owns = NULL;
    T_1_2.proc->proc = hash;
    err = proctypeOPnew(CLU_0, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_3.proc->proc = stringOPequal;
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPcreate;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPcreate(T_1_1, T_1_2, T_1_3, &T_1_4);
    if (err != ERR_ok)
        goto ex_0;
    t.num = T_1_4.num;
    }

  LINE(28);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(1, nil, T_1_1);
    CellAlloc(34, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_begin, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(29);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(2, nil, T_1_1);
    CellAlloc(34, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_break, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(30);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(3, T_1_1);
    T_1_1.vec->data[2] = 2;
    T_1_1.vec->data[1] = STR_cand.num;
    T_1_1.vec->data[0] = false;
    CellAlloc(23, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_cand, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(33);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(2, nil, T_1_1);
    CellAlloc(4, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_cluster, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(34);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(3, nil, T_1_1);
    CellAlloc(34, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_continue, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(35);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(3, T_1_1);
    T_1_1.vec->data[2] = 1;
    T_1_1.vec->data[1] = STR_cor.num;
    T_1_1.vec->data[0] = false;
    CellAlloc(23, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_cor, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(38);
    {
    CLUREF T_1_1;
    CellAlloc(5, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_do, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(39);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(1, nil, T_1_1);
    CellAlloc(14, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_down, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(40);
    {
    CLUREF T_1_1;
    CellAlloc(7, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_else, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(41);
    {
    CLUREF T_1_1;
    CellAlloc(8, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_elseif, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(42);
    {
    CLUREF T_1_1;
    CellAlloc(9, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_end, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(43);
    {
    CLUREF T_1_1;
    CellAlloc(12, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_except, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(44);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(4, nil, T_1_1);
    CellAlloc(34, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_exit, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(45);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(5, false, T_1_1);
    CellAlloc(13, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_false, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(46);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(5, nil, T_1_1);
    CellAlloc(34, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_for, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(47);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(2, nil, T_1_1);
    CellAlloc(14, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_force, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(48);
    {
    CLUREF T_1_1;
    CellAlloc(15, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_has, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(49);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(6, nil, T_1_1);
    CellAlloc(34, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_if, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(50);
    {
    CLUREF T_1_1;
    CellAlloc(17, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_in, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(51);
    {
    CLUREF T_1_1;
    CellAlloc(18, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_is, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(52);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(19, nil, T_1_1);
    CellAlloc(13, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_nil, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(53);
    {
    CLUREF T_1_1;
    CellAlloc(24, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_others, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(54);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(7, nil, T_1_1);
    CellAlloc(34, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_own, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(55);
    {
    CLUREF T_1_1;
    CellAlloc(29, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_resignal, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(56);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(8, nil, T_1_1);
    CellAlloc(34, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_return, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(57);
    {
    CLUREF T_1_1;
    CellAlloc(30, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_returns, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(58);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(9, nil, T_1_1);
    CellAlloc(34, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_signal, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(59);
    {
    CLUREF T_1_1;
    CellAlloc(33, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_signals, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(60);
    {
    CLUREF T_1_1;
    CellAlloc(35, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_tag, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(61);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(10, nil, T_1_1);
    CellAlloc(34, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_tagcase, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(62);
    {
    CLUREF T_1_1;
    CellAlloc(36, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_then, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(63);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(5, true, T_1_1);
    CellAlloc(13, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_true, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(64);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(4, nil, T_1_1);
    CellAlloc(14, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_up, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(65);
    {
    CLUREF T_1_1;
    CellAlloc(39, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_when, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(66);
    {
    CLUREF T_1_1;
    CellAlloc(40, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_where, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(67);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(11, nil, T_1_1);
    CellAlloc(34, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_while, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(68);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(12, nil, T_1_1);
    CellAlloc(34, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_yield, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(69);
    {
    CLUREF T_1_1;
    CellAlloc(41, nil, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_yields, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(70);
    {
    err = tokentabOPreset(t, e);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(71);
    { /* return */
    {
    ret_1->num = t.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE create ****/


/**** BEGIN PROCEDURE reset ****/

struct OPS *oneof_applytype__cluster__iter__proc__selector__ops __CLU_COMMON;
struct OPS *struct_neg_op_prec_ops __CLU_COMMON;
struct OPS *sequence_of_expr_ops __CLU_COMMON;
struct OPS *oneof_none_one_ops __CLU_COMMON;
struct OPS *record_elts_low_type__ops __CLU_COMMON;
struct OPS *record_gen_parms_ops __CLU_COMMON;
struct OPS *record_left_right_ops __CLU_COMMON;
struct OPS *record_index_object_ops __CLU_COMMON;
struct OPS *record_object_sel_ops __CLU_COMMON;
struct OPS *record_left_neg_op_right_ops __CLU_COMMON;
struct OPS *record_apply_args_ops __CLU_COMMON;
struct OPS *record_name_parms_type__ops __CLU_COMMON;
struct OPS *record_idn_parms_ops __CLU_COMMON;
struct OPS *sequence_of_string_ops __CLU_COMMON;
struct OPS *record_line_sels_val_ops __CLU_COMMON;
struct OPS *sequence_of_record_line_sels_val_ops __CLU_COMMON;
struct OPS *record_fields_type__ops __CLU_COMMON;
struct OPS *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_down__force__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_begin__break__continue__exit__for__if__own__return__signal__tagcase__while__yield__ops __CLU_COMMON;
struct OPS *oneof_applytype__cluster__rep__selector__ops __CLU_COMMON;
struct OPS *oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
struct OPS *table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
static int tokentabOPreset_own_init = 0;

errcode
tokentabOPreset(CLUREF t, CLUREF e)
{
    errcode err;
    if (tokentabOPreset_own_init == 0) {
        if (tokentab_own_init == 0) {
            err = tokentab_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        tokentabOPreset_own_init = 1;
    }
    enter_proc(74);

  LINE(75);
    {
    err = tokentabOPunhack(t);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(76);
    {
    CLUREF T_1_1;
    err = proctypeOPnew(CLU_1, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->proc = oneofOPis_16;
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPcond_flush;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPcond_flush(t, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(77);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = ceOPget_any_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(37, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_any, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(78);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = ceOPget_array_(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(2, T_1_1.num, T_1_2);
    CellAlloc(38, T_1_2.num, T_1_3);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_array, T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(79);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = ceOPget_bool_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(37, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_bool, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(80);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = ceOPget_char_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(37, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_char, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(81);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = ceOPget_cvt_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(37, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_cvt, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(82);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = ceOPget_int_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(37, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_int, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(83);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = ceOPget_iter_(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(3, T_1_1.num, T_1_2);
    CellAlloc(4, T_1_2.num, T_1_3);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_iter, T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(84);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = ceOPget_iter_(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(1, T_1_1.num, T_1_2);
    CellAlloc(38, T_1_2.num, T_1_3);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_itertype, T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(85);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = ceOPget_null_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(37, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_null, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(86);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = ceOPget_oneof_(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(4, T_1_1.num, T_1_2);
    CellAlloc(38, T_1_2.num, T_1_3);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_oneof, T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(87);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = ceOPget_proc_(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(4, T_1_1.num, T_1_2);
    CellAlloc(4, T_1_2.num, T_1_3);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_proc, T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(88);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = ceOPget_proc_(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(1, T_1_1.num, T_1_2);
    CellAlloc(38, T_1_2.num, T_1_3);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_proctype, T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(89);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = ceOPget_real_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(37, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_real, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(90);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = ceOPget_record_(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(4, T_1_1.num, T_1_2);
    CellAlloc(38, T_1_2.num, T_1_3);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_record, T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(91);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = tokentabOPident(t, STR_REP, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(3, T_1_1.num, T_1_2);
    CellAlloc(38, T_1_2.num, T_1_3);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_rep, T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(92);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = ceOPget_seq_(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(2, T_1_1.num, T_1_2);
    CellAlloc(38, T_1_2.num, T_1_3);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_sequence, T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(93);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = ceOPget_str_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(37, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_string, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(94);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = ceOPget_struct_(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(4, T_1_1.num, T_1_2);
    CellAlloc(38, T_1_2.num, T_1_3);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_struct, T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(95);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = ceOPget_type_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(37, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_type, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(96);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = ceOPget_variant_(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(4, T_1_1.num, T_1_2);
    CellAlloc(38, T_1_2.num, T_1_3);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_variant, T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE reset ****/


/**** BEGIN PROCEDURE hack ****/

struct OPS *oneof_applytype__cluster__iter__proc__selector__ops __CLU_COMMON;
struct OPS *struct_neg_op_prec_ops __CLU_COMMON;
struct OPS *sequence_of_expr_ops __CLU_COMMON;
struct OPS *oneof_none_one_ops __CLU_COMMON;
struct OPS *record_elts_low_type__ops __CLU_COMMON;
struct OPS *record_gen_parms_ops __CLU_COMMON;
struct OPS *record_left_right_ops __CLU_COMMON;
struct OPS *record_index_object_ops __CLU_COMMON;
struct OPS *record_object_sel_ops __CLU_COMMON;
struct OPS *record_left_neg_op_right_ops __CLU_COMMON;
struct OPS *record_apply_args_ops __CLU_COMMON;
struct OPS *record_name_parms_type__ops __CLU_COMMON;
struct OPS *record_idn_parms_ops __CLU_COMMON;
struct OPS *sequence_of_string_ops __CLU_COMMON;
struct OPS *record_line_sels_val_ops __CLU_COMMON;
struct OPS *sequence_of_record_line_sels_val_ops __CLU_COMMON;
struct OPS *record_fields_type__ops __CLU_COMMON;
struct OPS *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_down__force__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_begin__break__continue__exit__for__if__own__return__signal__tagcase__while__yield__ops __CLU_COMMON;
struct OPS *oneof_applytype__cluster__rep__selector__ops __CLU_COMMON;
struct OPS *oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
struct OPS *table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
static int tokentabOPhack_own_init = 0;

errcode
tokentabOPhack(CLUREF t)
{
    errcode err;
    if (tokentabOPhack_own_init == 0) {
        if (tokentab_own_init == 0) {
            err = tokentab_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        tokentabOPhack_own_init = 1;
    }
    enter_proc(99);

  LINE(100);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(1, nil, T_1_1);
    CellAlloc(4, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_applytype, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(101);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(5, nil, T_1_1);
    CellAlloc(4, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_selector, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(102);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(3, nil, T_1_1);
    CellAlloc(14, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_type_137of, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(103);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(2, nil, T_1_1);
    CellAlloc(4, T_1_1.num, T_1_2);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, STR_monitor, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE hack ****/


/**** BEGIN PROCEDURE unhack ****/

static int tokentabOPunhack_own_init = 0;

errcode
tokentabOPunhack(CLUREF t)
{
    errcode err;
    if (tokentabOPunhack_own_init == 0) {
        if (tokentab_own_init == 0) {
            err = tokentab_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        tokentabOPunhack_own_init = 1;
    }
    enter_proc(106);

  LINE(107);
    {
    CLUREF T_1_1;
    err = tokentabOPident(t, STR_applytype, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(108);
    {
    CLUREF T_1_1;
    err = tokentabOPident(t, STR_selector, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(109);
    {
    CLUREF T_1_1;
    err = tokentabOPident(t, STR_type_137of, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(110);
    {
    CLUREF T_1_1;
    err = tokentabOPident(t, STR_monitor, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE unhack ****/


/**** BEGIN PROCEDURE ident ****/

struct OPS *oneof_applytype__cluster__iter__proc__selector__ops __CLU_COMMON;
struct OPS *struct_neg_op_prec_ops __CLU_COMMON;
struct OPS *sequence_of_expr_ops __CLU_COMMON;
struct OPS *oneof_none_one_ops __CLU_COMMON;
struct OPS *record_elts_low_type__ops __CLU_COMMON;
struct OPS *record_gen_parms_ops __CLU_COMMON;
struct OPS *record_left_right_ops __CLU_COMMON;
struct OPS *record_index_object_ops __CLU_COMMON;
struct OPS *record_object_sel_ops __CLU_COMMON;
struct OPS *record_left_neg_op_right_ops __CLU_COMMON;
struct OPS *record_apply_args_ops __CLU_COMMON;
struct OPS *record_name_parms_type__ops __CLU_COMMON;
struct OPS *record_idn_parms_ops __CLU_COMMON;
struct OPS *sequence_of_string_ops __CLU_COMMON;
struct OPS *record_line_sels_val_ops __CLU_COMMON;
struct OPS *sequence_of_record_line_sels_val_ops __CLU_COMMON;
struct OPS *record_fields_type__ops __CLU_COMMON;
struct OPS *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_down__force__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_begin__break__continue__exit__for__if__own__return__signal__tagcase__while__yield__ops __CLU_COMMON;
struct OPS *oneof_applytype__cluster__rep__selector__ops __CLU_COMMON;
struct OPS *oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
struct OPS *table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
static int tokentabOPident_own_init = 0;

errcode
tokentabOPident(CLUREF t, CLUREF s, CLUREF *ret_1)
{
    errcode err;
    CLUREF id;
    if (tokentabOPident_own_init == 0) {
        if (tokentab_own_init == 0) {
            err = tokentab_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        tokentabOPident_own_init = 1;
    }
    enter_proc(113);

  LINE(114);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(8, nil, T_1_1);
    err = idnOPcreate(s, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    id.num = T_1_2.num;
    }

  LINE(115);
    {
    CLUREF T_1_1;
    CellAlloc(16, id.num, T_1_1);
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, s, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(116);
    { /* return */
    {
    ret_1->num = id.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE ident ****/


/**** BEGIN PROCEDURE get_token ****/

struct OPS *oneof_applytype__cluster__iter__proc__selector__ops __CLU_COMMON;
struct OPS *struct_neg_op_prec_ops __CLU_COMMON;
struct OPS *sequence_of_expr_ops __CLU_COMMON;
struct OPS *oneof_none_one_ops __CLU_COMMON;
struct OPS *record_elts_low_type__ops __CLU_COMMON;
struct OPS *record_gen_parms_ops __CLU_COMMON;
struct OPS *record_left_right_ops __CLU_COMMON;
struct OPS *record_index_object_ops __CLU_COMMON;
struct OPS *record_object_sel_ops __CLU_COMMON;
struct OPS *record_left_neg_op_right_ops __CLU_COMMON;
struct OPS *record_apply_args_ops __CLU_COMMON;
struct OPS *record_name_parms_type__ops __CLU_COMMON;
struct OPS *record_idn_parms_ops __CLU_COMMON;
struct OPS *sequence_of_string_ops __CLU_COMMON;
struct OPS *record_line_sels_val_ops __CLU_COMMON;
struct OPS *sequence_of_record_line_sels_val_ops __CLU_COMMON;
struct OPS *record_fields_type__ops __CLU_COMMON;
struct OPS *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_down__force__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_begin__break__continue__exit__for__if__own__return__signal__tagcase__while__yield__ops __CLU_COMMON;
struct OPS *oneof_applytype__cluster__rep__selector__ops __CLU_COMMON;
struct OPS *oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
struct OPS *table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
static int tokentabOPget_token_own_init = 0;

errcode
tokentabOPget_token(CLUREF t, CLUREF s, CLUREF *ret_1)
{
    errcode err;
    CLUREF k;
    if (tokentabOPget_token_own_init == 0) {
        if (tokentab_own_init == 0) {
            err = tokentab_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        tokentabOPget_token_own_init = 1;
    }
    enter_proc(119);

  LINE(120);
    { /* return */
    {
    CLUREF T_2_1;
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPlookup;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPlookup(t, s, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    ret_1->num = T_2_1.num;
    }
    signal (ERR_ok);
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_found) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(122);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CellAlloc(8, nil, T_1_1);
    err = idnOPcreate(s, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    CellAlloc(16, T_1_2.num, T_1_3);
    k.num = T_1_3.num;
    }

  LINE(123);
    {
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPbind;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPbind(t, s, k);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(124);
    { /* return */
    {
    ret_1->num = k.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_token ****/


/**** BEGIN PROCEDURE add_token ****/

struct OPS *oneof_applytype__cluster__iter__proc__selector__ops __CLU_COMMON;
struct OPS *struct_neg_op_prec_ops __CLU_COMMON;
struct OPS *sequence_of_expr_ops __CLU_COMMON;
struct OPS *oneof_none_one_ops __CLU_COMMON;
struct OPS *record_elts_low_type__ops __CLU_COMMON;
struct OPS *record_gen_parms_ops __CLU_COMMON;
struct OPS *record_left_right_ops __CLU_COMMON;
struct OPS *record_index_object_ops __CLU_COMMON;
struct OPS *record_object_sel_ops __CLU_COMMON;
struct OPS *record_left_neg_op_right_ops __CLU_COMMON;
struct OPS *record_apply_args_ops __CLU_COMMON;
struct OPS *record_name_parms_type__ops __CLU_COMMON;
struct OPS *record_idn_parms_ops __CLU_COMMON;
struct OPS *sequence_of_string_ops __CLU_COMMON;
struct OPS *record_line_sels_val_ops __CLU_COMMON;
struct OPS *sequence_of_record_line_sels_val_ops __CLU_COMMON;
struct OPS *record_fields_type__ops __CLU_COMMON;
struct OPS *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_down__force__type_of__up__ops __CLU_COMMON;
struct OPS *oneof_begin__break__continue__exit__for__if__own__return__signal__tagcase__while__yield__ops __CLU_COMMON;
struct OPS *oneof_applytype__cluster__rep__selector__ops __CLU_COMMON;
struct OPS *oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
struct OPS *table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops __CLU_COMMON;
static int tokentabOPadd_token_own_init = 0;

errcode
tokentabOPadd_token(CLUREF t, CLUREF s, CLUREF k)
{
    errcode err;
    if (tokentabOPadd_token_own_init == 0) {
        if (tokentab_own_init == 0) {
            err = tokentab_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        tokentabOPadd_token_own_init = 1;
    }
    enter_proc(127);

  LINE(128);
    {
    generic_CLU_proc.type_owns = table_of_string_oneof_assn_colon_comma_defnkey_do__dollar_else__elseif__end__eof_equal_except__expr_exprkey_has__idn_in__is__l_bkt_l_curly_l_paren_not_op_others__period_r_bkt_r_curly_r_paren_resignal__returns__semi_sharp_signals__stmtkey_tag__then__type__typekey_when__where__yields__ops->type_owns;
    generic_CLU_proc.proc = tableOPalter;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPalter(t, s, k);
    if (err != ERR_ok)
        goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE add_token ****/

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[6];
} tokentab_OPS;

static CLU_proc tokentab_oe_add_token = { .proc = tokentabOPadd_token };
static CLU_proc tokentab_oe_create = { .proc = tokentabOPcreate };
static CLU_proc tokentab_oe_get_token = { .proc = tokentabOPget_token };
static CLU_proc tokentab_oe_hack = { .proc = tokentabOPhack };
static CLU_proc tokentab_oe_reset = { .proc = tokentabOPreset };
static CLU_proc tokentab_oe_unhack = { .proc = tokentabOPunhack };

static tokentab_OPS tokentab_ops_actual = {6, (OWNPTR)&tokentab_own_init, (OWNPTR)&tokentab_own_init, {
    {&tokentab_oe_add_token, "add_token"},
    {&tokentab_oe_create, "create"},
    {&tokentab_oe_get_token, "get_token"},
    {&tokentab_oe_hack, "hack"},
    {&tokentab_oe_reset, "reset"},
    {&tokentab_oe_unhack, "unhack"}}};

struct OPS *tokentab_ops = (struct OPS *)&tokentab_ops_actual;

/**** END CLUSTER tokentab ****/
