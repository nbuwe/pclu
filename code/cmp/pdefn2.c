
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


extern errcode p_envOPget_peek1();
extern errcode p_envOPnext_token();
extern errcode p_clist();
extern errcode p_restrict();
extern errcode sequenceOPnew();
extern struct REQS *sequence_of_t_reqs;
extern struct OPS *expr_ops;
extern OWN_req sequence_ownreqs;
extern struct OPS *sequence_ops;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
extern struct OPS *string_ops;
extern struct OPS *sequence_of_expr_ops;
extern struct OPS *typespec_ops;
struct OPS  *record_name_parms_type__ops;
extern struct OPS *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
extern struct OPS *int_ops;
extern struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS  *record_line_opers_ops;
extern struct OPS *record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_table;
struct OPS *sequence_of_record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_ops;
OWNPTR sequence_of_record_line_opers_owns;
extern struct OPS *equate_ops;
struct OPS *sequence_of_equate_table;
struct OPS *sequence_of_equate_ops;
struct OPS *sequence_of_equate_ops;
OWNPTR sequence_of_equate_owns;
extern struct OPS *sequence_of_equate_ops;
extern struct OPS *idn_ops;
extern struct OPS *sequence_of_record_line_opers_ops;
struct OPS  *record_equates_idn_ops_ops;
extern struct OPS *record_equates_idn_ops_ops;
struct OPS  *oneof_has__idn_set_ops;
extern struct OPS *oneof_has__idn_set_ops;
struct OPS  *record_idn_kind_line_ops;
extern struct REQS *p_clist_of_t_reqs;
extern struct OPS *record_idn_kind_line_ops;
extern OWN_req p_clist_ownreqs;
struct OPS *p_clist_of_record_idn_kind_line_table;
struct OPS *p_clist_of_record_idn_kind_line_ops;
struct OPS *p_clist_of_record_idn_kind_line_ops;
OWNPTR p_clist_of_record_idn_kind_line_owns;
CLUREF STR_restriction;
static int p_where_own_init = 0;

/**** BEGIN PROCEDURE p_where ****/

errcode p_where(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (p_where_own_init == 0) {
        add_parm_info_type(0, expr_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_expr_ops));
        add_selector_info("name", 0, string_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        add_selector_info("type_", 2, typespec_ops); 
        find_selector_ops("record", 3, &(record_name_parms_type__ops));
        add_parm_info_type(0, record_name_parms_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_name_parms_type__ops));
        add_selector_info("line", 0, int_ops); 
        add_selector_info("opers", 1, sequence_of_record_name_parms_type__ops); 
        find_selector_ops("record", 2, &(record_line_opers_ops));
        add_parm_info_type(0, record_line_opers_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_line_opers_ops));
        add_parm_info_type(0, equate_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_equate_ops));
        add_selector_info("equates", 0, sequence_of_equate_ops); 
        add_selector_info("idn", 1, idn_ops); 
        add_selector_info("ops", 2, sequence_of_record_line_opers_ops); 
        find_selector_ops("record", 3, &(record_equates_idn_ops_ops));
        add_selector_info("has_", 0, sequence_of_record_line_opers_ops); 
        add_selector_info("idn", 1, idn_ops); 
        add_selector_info("set", 2, record_equates_idn_ops_ops); 
        find_selector_ops("oneof", 3, &(oneof_has__idn_set_ops));
        add_selector_info("idn", 0, idn_ops); 
        add_selector_info("kind", 1, oneof_has__idn_set_ops); 
        add_selector_info("line", 2, int_ops); 
        find_selector_ops("record", 3, &(record_idn_kind_line_ops));
        add_parm_info_type(0, record_idn_kind_line_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_record_idn_kind_line_ops));
        stringOPcons("restriction", CLU_1, CLU_11, &STR_restriction);
        p_where_own_init = 1;
    }
    enter_proc(9);

  LINE(10);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 40: 
         {

  LINE(11);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(12);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = proctypeOPnew(CLU_0, &T_2_1.proc);
            if (err!= ERR_ok) goto ex_0;
            T_2_1.proc->type_owns = 0;
            T_2_1.proc->op_owns = 0;
            T_2_1.proc->proc = p_restrict;
            generic_CLU_proc.type_owns = 0;
            generic_CLU_proc.op_owns = (long)p_clist_of_record_idn_kind_line_ops->op_owns;
            generic_CLU_proc.proc = p_clist;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = p_clist(e, T_2_1, STR_restriction, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(14);
        {
        {
        CLUREF T_2_1;
        err = sequenceOPnew(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_where ****/


extern errcode p_idn();
extern errcode p_envOPget_line();
extern errcode oneofOPmake_2();
extern errcode oneofOPmake_3();
extern errcode p_typeset();
extern errcode p_envOPassume();
extern errcode oneofOPmake_1();
extern errcode p_operdecllist();
CLUREF STR_typeset_040after_040IN;
CLUREF STR_IN_040or_040HAS_040restriction_040after_040idn_040in_040WHERE_040clause;
static int p_restrict_own_init = 0;

/**** BEGIN PROCEDURE p_restrict ****/

errcode p_restrict(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF id;
    CLUREF line;
    CLUREF kind;
    CLUREF k;
        if (p_restrict_own_init == 0) {
        stringOPcons("typeset after IN", CLU_1, CLU_16, &STR_typeset_040after_040IN);
        stringOPcons("IN or HAS restriction after idn in WHERE clause", CLU_1, CLU_47, &STR_IN_040or_040HAS_040restriction_040after_040idn_040in_040WHERE_040clause);
        p_restrict_own_init = 1;
    }
    enter_proc(20);

  LINE(21);
    {
        {CLUREF T_2_1;
        err = p_idn(e, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        id.num = T_2_1.num;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_none) {signal(ERR_none);}
        else {
            goto ex_0;}
    end_1:;

  LINE(23);
    {
        {CLUREF T_1_1;
        err = p_envOPget_line(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        line.num = T_1_1.num;
        }
        }

  LINE(25);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 17: 
         {

  LINE(27);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(28);
            {
            CLUREF T_2_1;
            err = p_envOPget_peek1(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_1.cell->tag) {
            case 16: 
                 {CLUREF T_2_2;
                T_2_2.num = T_2_1.cell->value;
                k.num = T_2_2.num;

  LINE(30);
                    {
                    CLUREF T_3_1;
                    err = p_envOPnext_token(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(31);
                    {
                    CLUREF T_3_1;
                    CellAlloc(2, k.num, T_3_1);
                    kind.num = T_3_1.num;
                    }
                    break;
                    }
            case 20: 
                 {

  LINE(33);
                    {
                    CLUREF T_3_1;
                    err = p_envOPnext_token(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(34);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    err = p_typeset(e, &T_4_1);
                    if (err != ERR_ok) goto ex_2;
                    CellAlloc(3, T_4_1.num, T_4_2);
                    kind.num = T_4_2.num;
                    }
                    goto end_2;
                    ex_2:
                        if (err == ERR_bad) {signal(ERR_bad);}
                        else {
                            goto ex_0;}
                    end_2:;
                    break;
                    }
            default: {

  LINE(37);
                {
                err = p_envOPassume(e, STR_typeset_040after_040IN);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(38);
                {
                {signal (ERR_bad);}}
            }
            }
            }
            break;
            }
    case 15: 
         {

  LINE(41);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(42);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = p_operdecllist(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            CellAlloc(1, T_2_1.num, T_2_2);
            kind.num = T_2_2.num;
            }
            break;
            }
    default: {

  LINE(44);
        {
        err = p_envOPassume(e, STR_IN_040or_040HAS_040restriction_040after_040idn_040in_040WHERE_040clause);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(45);
        {
        {signal (ERR_bad);}}
    }
    }
    }

  LINE(47);
    {
    {
    CLUREF T_1_1;
    RecordAlloc(3, T_1_1);
    T_1_1.vec->data[0]  = id.num;
    T_1_1.vec->data[1]  = kind.num;
    T_1_1.vec->data[2]  = line.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_restrict ****/


extern errcode stringOPequal();
extern errcode structOPget_2();
extern errcode boolOPnot();
extern errcode structOPget_1();
extern errcode idnOPget_str();
extern errcode p_slist();
extern errcode p_equate();
extern struct REQS *p_slist_of_t_reqs;
extern OWN_req p_slist_ownreqs;
struct OPS *p_slist_of_equate_table;
struct OPS *p_slist_of_equate_ops;
struct OPS *p_slist_of_equate_ops;
OWNPTR p_slist_of_equate_owns;
CLUREF STR_idn_040after_040_173;
CLUREF STR_or;
CLUREF STR_idn_040after_040_174_040in_040_173idn_040_174_040idn_040_056_056_056_175;
CLUREF STR__174_040idn_040in_040_173idn_040_174_040idn_040_056_056_056_175;
CLUREF STR__174_040idn_040in_040_173idn_040_174_040_056_056_056_175;
CLUREF STR_idns_040do_040not_040match_040in_040_173idn_040_174_040idn_040_056_056_056_175;
CLUREF STR_HAS_040restriction_040in_040typeset;
CLUREF STR__175_040in_040_173idn_040_174_040_056_056_056_175;
static int p_typeset_own_init = 0;

/**** BEGIN PROCEDURE p_typeset ****/

errcode p_typeset(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF id;
    CLUREF id2;
    CLUREF k;
    CLUREF ops;
    CLUREF equates;
    CLUREF set;
        if (p_typeset_own_init == 0) {
        add_parm_info_type(0, equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        stringOPcons("idn after {", CLU_1, CLU_11, &STR_idn_040after_040_173);
        stringOPcons("or", CLU_1, CLU_2, &STR_or);
        stringOPcons("idn after | in {idn | idn ...}", CLU_1, CLU_30, &STR_idn_040after_040_174_040in_040_173idn_040_174_040idn_040_056_056_056_175);
        stringOPcons("| idn in {idn | idn ...}", CLU_1, CLU_24, &STR__174_040idn_040in_040_173idn_040_174_040idn_040_056_056_056_175);
        stringOPcons("| idn in {idn | ...}", CLU_1, CLU_20, &STR__174_040idn_040in_040_173idn_040_174_040_056_056_056_175);
        stringOPcons("idns do not match in {idn | idn ...}", CLU_1, CLU_36, &STR_idns_040do_040not_040match_040in_040_173idn_040_174_040idn_040_056_056_056_175);
        stringOPcons("HAS restriction in typeset", CLU_1, CLU_26, &STR_HAS_040restriction_040in_040typeset);
        stringOPcons("} in {idn | ...}", CLU_1, CLU_16, &STR__175_040in_040_173idn_040_174_040_056_056_056_175);
        p_typeset_own_init = 1;
    }
    enter_proc(54);

  LINE(55);
    {
        {CLUREF T_2_1;
        err = p_idn(e, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        id.num = T_2_1.num;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_none)) {

  LINE(56);
                {
                err = p_envOPassume(e, STR_idn_040after_040_173);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(57);
                {
                {signal (ERR_bad);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(59);
    {
        {id2.num = id.num;
        }
        }

  LINE(60);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 23: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(62);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            T_2_2.num = k.vec->data[1];
            T_2_3.num = ((STR_or.str->size != T_2_2.str->size)? false :
                !(bcmp(STR_or.str->data, T_2_2.str->data, STR_or.str->size)));
            T_2_1.num = T_2_3.num;
            if (T_2_3.num) {
                T_2_4.num = k.vec->data[0];
                T_2_5.num = T_2_4.num ^ 1;
                T_2_1.num = T_2_5.num;
            }
            if (T_2_1.num == true) {

  LINE(63);
                {
                CLUREF T_3_1;
                err = p_envOPnext_token(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(64);
                {
                CLUREF T_4_1;
                err = p_idn(e, &T_4_1);
                if (err != ERR_ok) goto ex_2;
                id2.num = T_4_1.num;
                }
                    goto end_2;
                    ex_2:
                        if ((err == ERR_none)) {

  LINE(65);
                            {
                            err = p_envOPassume(e, STR_idn_040after_040_174_040in_040_173idn_040_174_040idn_040_056_056_056_175);
                            if (err != ERR_ok) goto ex_0;
                            }
                        }
                        else {
                            goto ex_0;
                        }
                    end_2:;
                }
            else {

  LINE(68);
                {
                err = p_envOPassume(e, STR__174_040idn_040in_040_173idn_040_174_040idn_040_056_056_056_175);
                if (err != ERR_ok) goto ex_0;
                }
                }}/* end if */
            break;
            }
    default: {

  LINE(71);
        {
        err = p_envOPassume(e, STR__174_040idn_040in_040_173idn_040_174_040_056_056_056_175);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(73);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    err = idnOPget_str(id, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = idnOPget_str(id2, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_3.num = ((T_1_1.str->size != T_1_2.str->size)? false :
        !(bcmp(T_1_1.str->data, T_1_2.str->data, T_1_1.str->size)));
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {

  LINE(74);
        {
        err = p_envOPassume(e, STR_idns_040do_040not_040match_040in_040_173idn_040_174_040idn_040_056_056_056_175);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(76);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 15: 
         {

  LINE(77);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(78);
            {
            CLUREF T_2_1;
            err = p_operdecllist(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ops.num = T_2_1.num;
            }
            break;
            }
    default: {

  LINE(79);
        {
        err = p_envOPassume(e, STR_HAS_040restriction_040in_040typeset);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(80);
        {
        CLUREF T_2_1;
        err = sequenceOPnew(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        ops.num = T_2_1.num;
        }
    }
    }
    }

  LINE(82);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_equate;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_slist_of_equate_ops->op_owns;
        generic_CLU_proc.proc = p_slist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_slist(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        equates.num = T_1_2.num;
        }
        }

  LINE(83);
    {
        {CLUREF T_1_1;
        RecordAlloc(3, T_1_1);
        T_1_1.vec->data[1]  = id.num;
        T_1_1.vec->data[2]  = ops.num;
        T_1_1.vec->data[0]  = equates.num;
        set.num = T_1_1.num;
        }
        }

  LINE(86);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 27: 
         {

  LINE(87);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(88);
        {
        err = p_envOPassume(e, STR__175_040in_040_173idn_040_174_040_056_056_056_175);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(90);
    {
    {
    ret_1->num = set.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_typeset ****/


extern errcode p_envOPget_peekline();
extern errcode p_opname();
extern errcode p_type1();
extern errcode p_envOPget_unknown_type();
extern errcode sequenceOPelements();
extern errcode recordOPset_3();
extern errcode sequenceOPaddh();
extern errcode p_envOPpeek();
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_name_parms_type__ops;
struct OPS *p_clist_of_record_name_parms_type__table;
struct OPS *p_clist_of_record_name_parms_type__ops;
struct OPS *p_clist_of_record_name_parms_type__ops;
OWNPTR p_clist_of_record_name_parms_type__owns;
CLUREF STR_opname;
CLUREF STR__072_040type_040of_040operation_040declaration_040in_040type_040restriction;
static int p_operdecllist_own_init = 0;

/**** BEGIN PROCEDURE p_operdecllist ****/

errcode p_operdecllist(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF list;
    CLUREF line;
    CLUREF opers;
    CLUREF typ;
    CLUREF op;
        if (p_operdecllist_own_init == 0) {
        add_parm_info_type(0, expr_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_expr_ops));
        add_selector_info("name", 0, string_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        add_selector_info("type_", 2, typespec_ops); 
        find_selector_ops("record", 3, &(record_name_parms_type__ops));
        add_parm_info_type(0, record_name_parms_type__ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_record_name_parms_type__ops));
        stringOPcons("opname", CLU_1, CLU_6, &STR_opname);
        CLU_string_size.num = 51;
        stringOPcons(": type of operation declaration in type restriction", CLU_1, CLU_string_size, &STR__072_040type_040of_040operation_040declaration_040in_040type_040restriction);
        p_operdecllist_own_init = 1;
    }
    enter_proc(96);

  LINE(97);
    {
        {CLUREF T_1_1;
        err = sequenceOPnew(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        list.num = T_1_1.num;
        }
        }

  LINE(98);
    for (;;) {
        if (true != true) { break; }

  LINE(99);
        {
            {CLUREF T_2_1;
            err = p_envOPget_peekline(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            line.num = T_2_1.num;
            }
            }

  LINE(100);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            err = proctypeOPnew(CLU_0, &T_2_1.proc);
            if (err!= ERR_ok) goto ex_0;
            T_2_1.proc->type_owns = 0;
            T_2_1.proc->op_owns = 0;
            T_2_1.proc->proc = p_opname;
            generic_CLU_proc.type_owns = 0;
            generic_CLU_proc.op_owns = (long)p_clist_of_record_name_parms_type__ops->op_owns;
            generic_CLU_proc.proc = p_clist;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = p_clist(e, T_2_1, STR_opname, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            opers.num = T_2_2.num;
            }
            }

  LINE(102);
        {
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 2: 
             {

  LINE(103);
                {
                CLUREF T_3_1;
                err = p_envOPnext_token(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(104);
                {
                CLUREF T_3_1;
                err = p_type1(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                typ.num = T_3_1.num;
                }
                break;
                }
        default: {

  LINE(105);
            {
            err = p_envOPassume(e, STR__072_040type_040of_040operation_040declaration_040in_040type_040restriction);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(107);
            {
            CLUREF T_3_1;
            err = p_envOPget_unknown_type(e, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            typ.num = T_3_1.num;
            }
        }
        }
        }

  LINE(109);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
            T_2_2.num = opers.vec->size; 
            T_2_3 = opers;
            for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                op.num = T_2_3.vec->data[T_2_1.num - 1];

  LINE(110);
                {
                op.vec->data[2]  = typ.num;
                }
            }
        }
        end_inline_for_1:;

  LINE(112);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(2, T_2_1);
        T_2_1.vec->data[1]  = opers.num;
        T_2_1.vec->data[0]  = line.num;
        err = sequenceOPaddh(list, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        list.num = T_2_2.num;
        }

  LINE(114);
        {
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 3: 
             {

  LINE(115);
                {
                CLUREF T_3_1;
                err = p_envOPpeek(e, CLU_3, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                switch (T_3_1.cell->tag) {
                case 15: 
                case 17: 
                     {

  LINE(116);
                        {
                        {
                        ret_1->num = list.num;
                        }
                        {signal (ERR_ok);}}
                        break;
                        }
                default: {

  LINE(117);
                    {
                    CLUREF T_4_1;
                    err = p_envOPnext_token(e, &T_4_1);
                    if (err != ERR_ok) goto ex_0;
                    }
                }
                }
                }
                break;
                }
        default: {

  LINE(119);
            {
            {
            ret_1->num = list.num;
            }
            {signal (ERR_ok);}}
        }
        }
        }
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_operdecllist ****/


extern errcode p_name();
extern errcode p_blist();
extern errcode p_expr();
extern struct REQS *p_blist_of_t_reqs;
extern OWN_req p_blist_ownreqs;
struct OPS *p_blist_of_expr_table;
struct OPS *p_blist_of_expr_ops;
struct OPS *p_blist_of_expr_ops;
OWNPTR p_blist_of_expr_owns;
CLUREF STR_constant;
static int p_opname_own_init = 0;

/**** BEGIN PROCEDURE p_opname ****/

errcode p_opname(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF n;
    CLUREF parms;
        if (p_opname_own_init == 0) {
        add_parm_info_type(0, expr_ops, p_blist_of_t_reqs);
        find_prociter_instance(p_blist, 1, &p_blist_ownreqs, &(p_blist_of_expr_ops));
        stringOPcons("constant", CLU_1, CLU_8, &STR_constant);
        p_opname_own_init = 1;
    }
    enter_proc(128);

  LINE(129);
    {
        {CLUREF T_2_1;
        err = p_name(e, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        n.num = T_2_1.num;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_none) {signal(ERR_none);}
        else {
            goto ex_0;}
    end_1:;

  LINE(131);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_expr;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_blist_of_expr_ops->op_owns;
        generic_CLU_proc.proc = p_blist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_blist(e, T_1_1, CLU_1, STR_constant, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        parms.num = T_1_2.num;
        }
        }

  LINE(132);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(3, T_1_1);
    T_1_1.vec->data[0]  = n.num;
    T_1_1.vec->data[1]  = parms.num;
    err = p_envOPget_unknown_type(e, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[2]  = T_1_2.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_opname ****/


extern errcode oneofOPvalue_24();
extern errcode oneofOPvalue_13();
CLUREF STR_pathname_040in_040idn_040_075_040PATHNAME_040pathname;
static int p_pathname_own_init = 0;

/**** BEGIN PROCEDURE p_pathname ****/

errcode p_pathname(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
        if (p_pathname_own_init == 0) {
        stringOPcons("pathname in idn = PATHNAME pathname", CLU_1, CLU_35, &STR_pathname_040in_040idn_040_075_040PATHNAME_040pathname);
        p_pathname_own_init = 1;
    }
    enter_proc(139);

  LINE(140);
    {

  LINE(141);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = p_envOPget_peek1(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            if (T_3_1.cell->tag != 13) {err = ERR_wrong_tag; goto ex_1;}
            T_3_2.num = T_3_1.cell->value;
            if (T_3_2.cell->tag != 24) {err = ERR_wrong_tag; goto ex_1;}
            T_3_3.num = T_3_2.cell->value;
            s.num = T_3_3.num;
            }
            }

  LINE(142);
        {
        CLUREF T_3_1;
        err = p_envOPnext_token(e, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(143);
        {
        {
        ret_1->num = s.num;
        }
        {signal (ERR_ok);}}
        }
        goto end_1;
        ex_1:
            if ((err == ERR_wrong_tag)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(145);
    {
    err = p_envOPassume(e, STR_pathname_040in_040idn_040_075_040PATHNAME_040pathname);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(146);
    {
    {signal (ERR_bad);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_pathname ****/


extern errcode stringOPconcat();
extern errcode oneofOPvalue_16();
extern errcode p_envOPget_clustr();
extern errcode p_envOPerr();
extern errcode p_semi();
CLUREF STR_END_040and_040trailing_040idn_040of_040module_040;
CLUREF STR_trailing_040idn_040does_040not_040match_040;
CLUREF STR_trailing_040idn_040of_040module_040;
static int p_defn_end_own_init = 0;

/**** BEGIN PROCEDURE p_defn_end ****/

errcode p_defn_end(e, id)
CLUREF e;
CLUREF id;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
        if (p_defn_end_own_init == 0) {
        stringOPcons("END and trailing idn of module ", CLU_1, CLU_31, &STR_END_040and_040trailing_040idn_040of_040module_040);
        stringOPcons("trailing idn does not match ", CLU_1, CLU_28, &STR_trailing_040idn_040does_040not_040match_040);
        stringOPcons("trailing idn of module ", CLU_1, CLU_23, &STR_trailing_040idn_040of_040module_040);
        p_defn_end_own_init = 1;
    }
    enter_proc(151);

  LINE(152);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 9: 
         {
            break;
            }
    default: {

  LINE(154);
        {
        CLUREF T_2_1;
        err = stringOPconcat(STR_END_040and_040trailing_040idn_040of_040module_040, id, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = p_envOPassume(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(155);
        {
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(157);
    {

  LINE(158);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = p_envOPpeek(e, CLU_2, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            if (T_3_1.cell->tag != 16) {err = ERR_wrong_tag; goto ex_1;}
            T_3_2.num = T_3_1.cell->value;
            err = idnOPget_str(T_3_2, &T_3_3);
            if (err != ERR_ok) goto ex_1;
            s.num = T_3_3.num;
            }
            }

  LINE(159);
        {
        CLUREF T_3_1;
        T_3_1.num = ((id.str->size != s.str->size)? false :
            !(bcmp(id.str->data, s.str->data, id.str->size)));
        if (T_3_1.num == true) {

  LINE(160);
            {
            CLUREF T_4_1;
            err = p_envOPnext_token(e, &T_4_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(161);
            {
            CLUREF T_4_1;
            err = p_envOPnext_token(e, &T_4_1);
            if (err != ERR_ok) goto ex_1;
            }
            }
        else {
        CLUREF T_3_2;
        CLUREF T_3_3;
        err = p_envOPget_clustr(e, &T_3_2);
        if (err != ERR_ok) goto ex_1;
        T_3_3.num = ((s.str->size != T_3_2.str->size)? false :
            !(bcmp(s.str->data, T_3_2.str->data, s.str->size)));
        if (T_3_3.num == true) {

  LINE(163);
            {
            CLUREF T_4_1;
            err = stringOPconcat(STR_END_040and_040trailing_040idn_040of_040module_040, id, &T_4_1);
            if (err != ERR_ok) goto ex_1;
            err = p_envOPassume(e, T_4_1);
            if (err != ERR_ok) goto ex_1;
            }
            }
        else {

  LINE(164);
            {
            CLUREF T_4_1;
            err = p_envOPnext_token(e, &T_4_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(165);
            {
            CLUREF T_4_1;
            err = p_envOPpeek(e, CLU_2, &T_4_1);
            if (err != ERR_ok) goto ex_1;
            switch (T_4_1.cell->tag) {
            case 31: 
            case 9: 
            case 16: 
            case 10: 
                 {

  LINE(167);
                    {
                    CLUREF T_5_1;
                    err = p_envOPnext_token(e, &T_5_1);
                    if (err != ERR_ok) goto ex_1;
                    }

  LINE(168);
                    {
                    CLUREF T_5_1;
                    err = stringOPconcat(STR_trailing_040idn_040does_040not_040match_040, id, &T_5_1);
                    if (err != ERR_ok) goto ex_1;
                    err = p_envOPerr(e, T_5_1, CLU_1);
                    if (err != ERR_ok) goto ex_1;
                    }
                    break;
                    }
            default: {

  LINE(170);
                {
                CLUREF T_5_1;
                err = stringOPconcat(STR_trailing_040idn_040of_040module_040, id, &T_5_1);
                if (err != ERR_ok) goto ex_1;
                err = p_envOPassume(e, T_5_1);
                if (err != ERR_ok) goto ex_1;
                }
            }
            }
            }
            }}}/* end if */
        }
        goto end_1;
        ex_1:
            if ((err == ERR_wrong_tag)) {

  LINE(174);
                {
                CLUREF T_2_1;
                err = p_envOPnext_token(e, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(175);
                {
                CLUREF T_2_1;
                err = stringOPconcat(STR_trailing_040idn_040of_040module_040, id, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                err = p_envOPassume(e, T_2_1);
                if (err != ERR_ok) goto ex_0;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(177);
    {
    err = p_semi(e);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE p_defn_end ****/


extern errcode intOPadd();
extern errcode intOPgt();
CLUREF STR_more_040than_040one_040_073_040in_040a_040row;
static int p_semi_own_init = 0;

/**** BEGIN PROCEDURE p_semi ****/

errcode p_semi(e)
CLUREF e;
    {
    errcode err;
    errcode ecode2;
    CLUREF i;
        if (p_semi_own_init == 0) {
        stringOPcons("more than one ; in a row", CLU_1, CLU_24, &STR_more_040than_040one_040_073_040in_040a_040row);
        p_semi_own_init = 1;
    }
    enter_proc(182);

  LINE(183);
    {
        {i.num = 0;
        }
        }

  LINE(184);
    for (;;) {
        if (true != true) { break; }

  LINE(185);
        {
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 31: 
             {

  LINE(187);
                {
                CLUREF T_3_1;
                err = p_envOPnext_token(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(188);
                {
                CLUREF T_3_1;
                T_3_1.num = i.num + 1;
                 if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) || 
                     (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                i.num = T_3_1.num;
                }
                break;
                }
        default: {

  LINE(190);
            {
            CLUREF T_3_1;
            T_3_1.num = (i.num > 1)? true : false;
            if (T_3_1.num == true) {

  LINE(191);
                {
                err = p_envOPerr(e, STR_more_040than_040one_040_073_040in_040a_040row, CLU_1);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */

  LINE(193);
            {
            {signal (ERR_ok);}}
        }
        }
        }
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE p_semi ****/


extern errcode intOPequal();
CLUREF STR_looking_040for_040an_040operation;
CLUREF STR_looking_040for_040a_040module;
CLUREF STR_resuming_040parse_040at_040this_040point;
static int p_find_a_defn_own_init = 0;

/**** BEGIN PROCEDURE p_find_a_defn ****/

errcode p_find_a_defn(e, want_oper, ret_1)
CLUREF e;
CLUREF want_oper;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF flushed;
    CLUREF found;
    CLUREF line;
        if (p_find_a_defn_own_init == 0) {
        stringOPcons("looking for an operation", CLU_1, CLU_24, &STR_looking_040for_040an_040operation);
        stringOPcons("looking for a module", CLU_1, CLU_20, &STR_looking_040for_040a_040module);
        stringOPcons("resuming parse at this point", CLU_1, CLU_28, &STR_resuming_040parse_040at_040this_040point);
        p_find_a_defn_own_init = 1;
    }
    enter_proc(201);

  LINE(202);
    {
        {flushed.tf = false;
        }
        }

  LINE(203);
    {
        {found.tf = false;
        }
        }

  LINE(204);
    for (;;) {
        if (true != true) { break; }

  LINE(205);
        {
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 16: 
             {

  LINE(207);
                {
                CLUREF T_3_1;
                err = p_envOPpeek(e, CLU_2, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                switch (T_3_1.cell->tag) {
                case 11: 
                     {

  LINE(208);
                        {
                        found.tf = true;
                        }

  LINE(209);
                        goto end_while_1;
                        break;
                        }
                default: {
                }
                }
                }
                break;
                }
        case 9: 
             {

  LINE(213);
                {
                if (want_oper.num == true) {
                    goto end_while_1;
                    }
                    }/* end if */
                break;
                }
        case 10: 
             {

  LINE(215);
                goto end_while_1;
                break;
                }
        default: {
        }
        }
        }

  LINE(218);
        {
        CLUREF T_2_1;
        T_2_1.num = flushed.num ^ 1;
        if (T_2_1.num == true) {

  LINE(219);
            {
            if (want_oper.num == true) {

  LINE(220);
                {
                err = p_envOPerr(e, STR_looking_040for_040an_040operation, CLU_2);
                if (err != ERR_ok) goto ex_0;
                }
                }
            else {

  LINE(221);
                {
                err = p_envOPerr(e, STR_looking_040for_040a_040module, CLU_2);
                if (err != ERR_ok) goto ex_0;
                }
                }}/* end if */

  LINE(223);
            {
            flushed.tf = true;
            }
            }
            }/* end if */

  LINE(225);
        {
            {CLUREF T_2_1;
            err = p_envOPget_peekline(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            line.num = T_2_1.num;
            }
            }

  LINE(226);
        for (;;) {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = p_envOPget_peekline(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            T_2_2.num = (T_2_1.num == line.num)? true : false;
            if (T_2_2.num != true) { break; }

  LINE(227);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            }
            }
            end_while_2:;
        }
        end_while_1:;

  LINE(230);
    {
    if (flushed.num == true) {

  LINE(231);
        {
        err = p_envOPerr(e, STR_resuming_040parse_040at_040this_040point, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(232);
    {
    {
    ret_1->num = found.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_find_a_defn ****/

