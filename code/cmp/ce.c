
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER ce ****/

extern errcode ce_IB_1();
extern errcode ce_IB_2();
extern errcode ce_IB_3();
extern errcode ce_IB_4();
extern errcode sequenceOPnew();
extern errcode xlibOPlookup();
extern errcode tableOPcreate();
extern errcode hash();
extern errcode stringOPequal();
extern errcode oneofOPmake_8();
extern errcode hash_typeabs();
extern errcode oneofOPsimilar();
extern errcode hash_du();
extern errcode duOPsimilar();
extern errcode typespecOPcreate();
extern errcode oneofOPmake_9();
extern errcode oneofOPmake_3();
extern errcode oneofOPmake_4();
extern errcode oneofOPmake_1();
extern errcode ceOPfixup();
extern errcode recordOPget_23();
extern errcode recordOPget_11();
extern errcode recordOPget_3();
extern errcode recordOPget_8();
extern errcode recordOPget_14();
extern errcode recordOPget_4();
extern errcode recordOPget_17();
extern errcode recordOPget_19();
extern errcode recordOPget_5();
extern errcode recordOPget_1();
extern errcode ceOPadd_du();
extern errcode recordOPget_2();
extern errcode recordOPget_15();
extern errcode recordOPget_12();
extern errcode recordOPget_16();
extern errcode recordOPget_18();
extern errcode recordOPget_24();
extern errcode recordOPget_13();
extern errcode recordOPget_9();
extern errcode ceOPkeep();
extern errcode tableOPpcond_flush();
extern errcode recordOPget_7();
extern errcode ceOPpflush_id();
extern errcode tableOPflush();
extern errcode intOPequal();
extern errcode recordOPset_1();
extern errcode intOPge();
extern errcode boolOPnot();
extern errcode arrayOPelements();
extern errcode intOPgt();
extern errcode typespecOPget_id();
extern errcode recordOPget_20();
extern errcode typespecOPset_id();
extern errcode tableOPdelete();
extern errcode recordOPget_22();
extern errcode typespecOPget_abs();
extern errcode tableOPcond_flush();
extern errcode ceOPflush_id();
extern errcode ceOPpflush_type();
extern errcode tableOPelements();
extern errcode recordOPget_6();
extern errcode duOPset_mspecs();
extern errcode boolOPcopy();
extern errcode recordOPset_21();
extern errcode intOPadd();
extern errcode tableOPalter();
extern errcode recordOPset_20();
extern errcode intOPsub();
extern errcode recordOPget_21();
extern errcode recordOPget_25();
extern errcode tableOPmbind();
extern errcode recordOPequal();
extern errcode recordOPset_25();
extern errcode recordOPcopy1();
extern errcode recordOPget_10();
extern errcode intOPlt();
extern errcode tableOPbind();
extern errcode idnOPget_str();
extern errcode idnOPget_kind();
extern errcode tableOPget_pair();
extern errcode recordOPset_2();
extern errcode xlibOPget_du();
extern errcode duOPget_unique();
extern struct REQS *sequence_of_t_reqs;
extern struct OPS *expr_ops;
extern OWN_req sequence_ownreqs;
extern struct OPS *sequence_ops;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
extern struct OPS *string_ops;
extern struct OPS *sequence_of_expr_ops;
extern struct OPS *typespec_ops;
struct OPS  *record_name_parms_type__ops;
extern struct OPS *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
extern struct OPS *sequence_of_record_name_parms_type__ops;
extern struct OPS *idn_ops;
struct OPS  *record_opers_parm_ops;
extern struct OPS *du_ops;
extern struct OPS *record_opers_parm_ops;
extern struct OPS *null_ops;
struct OPS  *oneof_expr_gen_opgen_ownvar_tconst_tparm_typeset_unknown_var_vparm_ops;
extern struct OPS *int_ops;
extern struct OPS *oneof_expr_gen_opgen_ownvar_tconst_tparm_typeset_unknown_var_vparm_ops;
struct OPS  *record_code_kind_ops;
extern struct REQS *table_of_key_reqs;
extern struct REQS *table_of_val_reqs;
extern struct OPS *record_code_kind_ops;
extern OWN_req table_ownreqs;
extern struct OPS *table_ops;
struct OPS *table_of_string_table;
struct OPS *table_of_record_code_kind_table;
struct OPS *table_of_string_record_code_kind_ops;
struct OPS *table_of_string_record_code_kind_ops;
OWNPTR table_of_string_record_code_kind_owns;
struct OPS *sequence_of_typespec_table;
struct OPS *sequence_of_typespec_ops;
struct OPS *sequence_of_typespec_ops;
OWNPTR sequence_of_typespec_owns;
extern struct OPS *sequence_of_typespec_ops;
struct OPS  *record_name_types_ops;
extern struct OPS *record_name_types_ops;
struct OPS *sequence_of_record_name_types_table;
struct OPS *sequence_of_record_name_types_ops;
struct OPS *sequence_of_record_name_types_ops;
OWNPTR sequence_of_record_name_types_owns;
extern struct OPS *sequence_of_record_name_types_ops;
struct OPS  *record_args_gen_sigs_vals_ops;
struct OPS  *record_gen_parms_ops;
extern struct OPS *record_gen_parms_ops;
struct OPS  *oneof_du_op_return__ops;
struct OPS  *record_sel_type__ops;
extern struct OPS *record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__table;
struct OPS *sequence_of_record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__ops;
OWNPTR sequence_of_record_sel_type__owns;
extern struct OPS *sequence_of_record_sel_type__ops;
struct OPS  *record_gen_parms_1_ops;
struct OPS  *record_idn_parms_ops;
struct OPS  *record_idn_parms_1_ops;
extern struct OPS *record_args_gen_sigs_vals_ops;
extern struct OPS *oneof_du_op_return__ops;
extern struct OPS *record_gen_parms_1_ops;
extern struct OPS *record_idn_parms_ops;
extern struct OPS *record_idn_parms_1_ops;
struct OPS  *oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops;
extern struct OPS *oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_table;
struct OPS *table_of_typespec_table;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
OWNPTR table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_owns;
extern struct OPS *bool_ops;
struct OPS *table_of_du_table;
struct OPS *table_of_bool_table;
struct OPS *table_of_du_bool_ops;
struct OPS *table_of_du_bool_ops;
OWNPTR table_of_du_bool_owns;
extern struct REQS *table_op_pcond_flush_of_u_reqs;
extern OWN_req table_op_pcond_flush_ownreqs;
struct OPS *table_of_string_table;
struct OPS *table_of_record_code_kind_table;
struct OPS *table_op_pcond_flush_of_bool_table;
struct OPS *table_op_pcond_flush_of_string_record_code_kind_bool_ops;
struct OPS *table_of_string_record_code_kind_ops;
OWNPTR table_op_pcond_flush_of_string_record_code_kind_bool_owns;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_table;
struct OPS *table_of_typespec_table;
struct OPS *table_op_pcond_flush_of_int_table;
struct OPS *table_op_pcond_flush_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_int_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
OWNPTR table_op_pcond_flush_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_int_owns;
CLUREF STR_null;
CLUREF STR_bool;
CLUREF STR_int;
CLUREF STR_real;
CLUREF STR_char;
CLUREF STR_string;
CLUREF STR_type;
CLUREF STR_array;
CLUREF STR_record;
CLUREF STR_oneof;
CLUREF STR_sequence;
CLUREF STR_struct;
CLUREF STR_variant;
CLUREF STR_proctype;
CLUREF STR_itertype;
static int ce_own_init = 0;
OWN_req ce_ownreqs = {0,0};
errcode ce_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (ce_own_init == 0) {
        add_parm_info_type(0, expr_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_expr_ops));
        add_selector_info("name", 0, string_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        add_selector_info("type_", 2, typespec_ops); 
        find_selector_ops("record", 3, &(record_name_parms_type__ops));
        add_parm_info_type(0, record_name_parms_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_name_parms_type__ops));
        add_selector_info("opers", 0, sequence_of_record_name_parms_type__ops); 
        add_selector_info("parm", 1, idn_ops); 
        find_selector_ops("record", 2, &(record_opers_parm_ops));
        add_selector_info("expr", 0, expr_ops); 
        add_selector_info("gen", 1, du_ops); 
        add_selector_info("opgen", 2, string_ops); 
        add_selector_info("ownvar", 3, typespec_ops); 
        add_selector_info("tconst", 4, sequence_of_record_name_parms_type__ops); 
        add_selector_info("tparm", 5, sequence_of_record_name_parms_type__ops); 
        add_selector_info("typeset", 6, record_opers_parm_ops); 
        add_selector_info("unknown", 7, null_ops); 
        add_selector_info("var", 8, typespec_ops); 
        add_selector_info("vparm", 9, typespec_ops); 
        find_selector_ops("oneof", 10, &(oneof_expr_gen_opgen_ownvar_tconst_tparm_typeset_unknown_var_vparm_ops));
        add_selector_info("code", 0, int_ops); 
        add_selector_info("kind", 1, oneof_expr_gen_opgen_ownvar_tconst_tparm_typeset_unknown_var_vparm_ops); 
        find_selector_ops("record", 2, &(record_code_kind_ops));
        add_parm_info_type(0, string_ops, table_of_key_reqs);
        add_parm_info_type(1, record_code_kind_ops, table_of_val_reqs);
        find_type_instance(table_ops, 2, &table_ownreqs, &(table_of_string_record_code_kind_ops));
        add_parm_info_type(0, typespec_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_typespec_ops));
        add_selector_info("name", 0, string_ops); 
        add_selector_info("types", 1, sequence_of_typespec_ops); 
        find_selector_ops("record", 2, &(record_name_types_ops));
        add_parm_info_type(0, record_name_types_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_name_types_ops));
        add_selector_info("args", 0, sequence_of_typespec_ops); 
        add_selector_info("gen", 1, du_ops); 
        add_selector_info("sigs", 2, sequence_of_record_name_types_ops); 
        add_selector_info("vals", 3, sequence_of_typespec_ops); 
        find_selector_ops("record", 4, &(record_args_gen_sigs_vals_ops));
        add_selector_info("gen", 0, du_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        find_selector_ops("record", 2, &(record_gen_parms_ops));
        add_selector_info("du", 0, record_gen_parms_ops); 
        add_selector_info("op", 1, record_name_parms_type__ops); 
        add_selector_info("return_", 2, typespec_ops); 
        find_selector_ops("oneof", 3, &(oneof_du_op_return__ops));
        add_selector_info("sel", 0, string_ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_sel_type__ops));
        add_parm_info_type(0, record_sel_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_sel_type__ops));
        add_selector_info("gen", 0, du_ops); 
        add_selector_info("parms", 1, sequence_of_record_sel_type__ops); 
        find_selector_ops("record", 2, &(record_gen_parms_1_ops));
        add_selector_info("idn", 0, idn_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        find_selector_ops("record", 2, &(record_idn_parms_ops));
        add_selector_info("idn", 0, idn_ops); 
        add_selector_info("parms", 1, sequence_of_record_sel_type__ops); 
        find_selector_ops("record", 2, &(record_idn_parms_1_ops));
        add_selector_info("any_", 0, null_ops); 
        add_selector_info("apply", 1, record_args_gen_sigs_vals_ops); 
        add_selector_info("cluster_", 2, record_gen_parms_ops); 
        add_selector_info("cvt_", 3, null_ops); 
        add_selector_info("idn", 4, idn_ops); 
        add_selector_info("other", 5, oneof_du_op_return__ops); 
        add_selector_info("select", 6, record_gen_parms_1_ops); 
        add_selector_info("type_", 7, record_gen_parms_ops); 
        add_selector_info("unknown", 8, null_ops); 
        add_selector_info("xclu", 9, record_idn_parms_ops); 
        add_selector_info("xsel", 10, record_idn_parms_1_ops); 
        find_selector_ops("oneof", 11, &(oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops));
        add_parm_info_type(0, oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops, table_of_key_reqs);
        add_parm_info_type(1, typespec_ops, table_of_val_reqs);
        find_type_instance(table_ops, 2, &table_ownreqs, &(table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops));
        add_parm_info_type(0, du_ops, table_of_key_reqs);
        add_parm_info_type(1, bool_ops, table_of_val_reqs);
        find_type_instance(table_ops, 2, &table_ownreqs, &(table_of_du_bool_ops));
        add_parm_info_type(0, string_ops, table_of_key_reqs);
        add_parm_info_type(1, record_code_kind_ops, table_of_val_reqs);
        add_parm_info_type(2, bool_ops, table_op_pcond_flush_of_u_reqs);
        find_type_instance(table_ops, 2, &table_ownreqs, &(table_of_string_record_code_kind_ops));
        find_typeop_instance(table_ops, tableOPpcond_flush, 3, 2, &table_op_pcond_flush_ownreqs, &table_ownreqs, &(table_op_pcond_flush_of_string_record_code_kind_bool_ops));
        add_parm_info_type(0, oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops, table_of_key_reqs);
        add_parm_info_type(1, typespec_ops, table_of_val_reqs);
        add_parm_info_type(2, int_ops, table_op_pcond_flush_of_u_reqs);
        find_type_instance(table_ops, 2, &table_ownreqs, &(table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops));
        find_typeop_instance(table_ops, tableOPpcond_flush, 3, 2, &table_op_pcond_flush_ownreqs, &table_ownreqs, &(table_op_pcond_flush_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_int_ops));
        stringOPcons("null", CLU_1, CLU_4, &STR_null);
        stringOPcons("bool", CLU_1, CLU_4, &STR_bool);
        stringOPcons("int", CLU_1, CLU_3, &STR_int);
        stringOPcons("real", CLU_1, CLU_4, &STR_real);
        stringOPcons("char", CLU_1, CLU_4, &STR_char);
        stringOPcons("string", CLU_1, CLU_6, &STR_string);
        stringOPcons("type", CLU_1, CLU_4, &STR_type);
        stringOPcons("array", CLU_1, CLU_5, &STR_array);
        stringOPcons("record", CLU_1, CLU_6, &STR_record);
        stringOPcons("oneof", CLU_1, CLU_5, &STR_oneof);
        stringOPcons("sequence", CLU_1, CLU_8, &STR_sequence);
        stringOPcons("struct", CLU_1, CLU_6, &STR_struct);
        stringOPcons("variant", CLU_1, CLU_7, &STR_variant);
        stringOPcons("proctype", CLU_1, CLU_8, &STR_proctype);
        stringOPcons("itertype", CLU_1, CLU_8, &STR_itertype);
        ce_own_init = 1;
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }

struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_opers_parm_ops;
struct OPS  *oneof_expr_gen_opgen_ownvar_tconst_tparm_typeset_unknown_var_vparm_ops;
struct OPS  *record_code_kind_ops;
struct OPS *table_of_string_table;
struct OPS *table_of_record_code_kind_table;
struct OPS *table_of_string_record_code_kind_ops;
struct OPS *table_of_string_record_code_kind_ops;
OWNPTR table_of_string_record_code_kind_owns;
struct OPS *sequence_of_typespec_table;
struct OPS *sequence_of_typespec_ops;
struct OPS *sequence_of_typespec_ops;
OWNPTR sequence_of_typespec_owns;
struct OPS  *record_name_types_ops;
struct OPS *sequence_of_record_name_types_table;
struct OPS *sequence_of_record_name_types_ops;
struct OPS *sequence_of_record_name_types_ops;
OWNPTR sequence_of_record_name_types_owns;
struct OPS  *record_args_gen_sigs_vals_ops;
struct OPS  *record_gen_parms_ops;
struct OPS  *oneof_du_op_return__ops;
struct OPS  *record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__table;
struct OPS *sequence_of_record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__ops;
OWNPTR sequence_of_record_sel_type__owns;
struct OPS  *record_gen_parms_1_ops;
struct OPS  *record_idn_parms_ops;
struct OPS  *record_idn_parms_1_ops;
struct OPS  *oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_table;
struct OPS *table_of_typespec_table;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
OWNPTR table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_owns;
struct OPS *table_of_du_table;
struct OPS *table_of_bool_table;
struct OPS *table_of_du_bool_ops;
struct OPS *table_of_du_bool_ops;
OWNPTR table_of_du_bool_owns;
static int ceOPcreate_own_init = 0;

/**** BEGIN PROCEDURE create ****/

errcode ceOPcreate(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF parms;
    CLUREF nullt;
    CLUREF boolt;
    CLUREF intt;
    CLUREF realt;
    CLUREF chart;
    CLUREF strt;
    CLUREF typet;
    CLUREF e;
    CLUREF ne;
        if (ceOPcreate_own_init == 0) {
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ceOPcreate_own_init = 1;
    }
    enter_proc(87);

  LINE(88);
    {
        {CLUREF T_1_1;
        err = sequenceOPnew(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        parms.num = T_1_1.num;
        }
        }

  LINE(89);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        RecordAlloc(2, T_1_1);
        err = xlibOPlookup(STR_null, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_2.num;
        T_1_1.vec->data[1]  = parms.num;
        nullt.num = T_1_1.num;
        }
        }

  LINE(91);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        RecordAlloc(2, T_1_1);
        err = xlibOPlookup(STR_bool, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_2.num;
        T_1_1.vec->data[1]  = parms.num;
        boolt.num = T_1_1.num;
        }
        }

  LINE(93);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        RecordAlloc(2, T_1_1);
        err = xlibOPlookup(STR_int, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_2.num;
        T_1_1.vec->data[1]  = parms.num;
        intt.num = T_1_1.num;
        }
        }

  LINE(95);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        RecordAlloc(2, T_1_1);
        err = xlibOPlookup(STR_real, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_2.num;
        T_1_1.vec->data[1]  = parms.num;
        realt.num = T_1_1.num;
        }
        }

  LINE(97);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        RecordAlloc(2, T_1_1);
        err = xlibOPlookup(STR_char, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_2.num;
        T_1_1.vec->data[1]  = parms.num;
        chart.num = T_1_1.num;
        }
        }

  LINE(99);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        RecordAlloc(2, T_1_1);
        err = xlibOPlookup(STR_string, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_2.num;
        T_1_1.vec->data[1]  = parms.num;
        strt.num = T_1_1.num;
        }
        }

  LINE(101);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        RecordAlloc(2, T_1_1);
        err = xlibOPlookup(STR_type, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_2.num;
        T_1_1.vec->data[1]  = parms.num;
        typet.num = T_1_1.num;
        }
        }

  LINE(103);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        CLUREF T_1_6;
        CLUREF T_1_7;
        CLUREF T_1_8;
        CLUREF T_1_9;
        CLUREF T_1_10;
        CLUREF T_1_11;
        CLUREF T_1_12;
        CLUREF T_1_13;
        CLUREF T_1_14;
        CLUREF T_1_15;
        CLUREF T_1_16;
        CLUREF T_1_17;
        CLUREF T_1_18;
        CLUREF T_1_19;
        CLUREF T_1_20;
        CLUREF T_1_21;
        CLUREF T_1_22;
        CLUREF T_1_23;
        CLUREF T_1_24;
        CLUREF T_1_25;
        CLUREF T_1_26;
        CLUREF T_1_27;
        CLUREF T_1_28;
        CLUREF T_1_29;
        CLUREF T_1_30;
        CLUREF T_1_31;
        CLUREF T_1_32;
        CLUREF T_1_33;
        CLUREF T_1_34;
        CLUREF T_1_35;
        CLUREF T_1_36;
        CLUREF T_1_37;
        CLUREF T_1_38;
        CLUREF T_1_39;
        CLUREF T_1_40;
        CLUREF T_1_41;
        CLUREF T_1_42;
        CLUREF T_1_43;
        CLUREF T_1_44;
        CLUREF T_1_45;
        RecordAlloc(25, T_1_1);
        T_1_2.num = 300;
        err = proctypeOPnew(CLU_0, &T_1_3.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_3.proc->type_owns = 0;
        T_1_3.proc->op_owns = 0;
        T_1_3.proc->proc = hash;
        err = proctypeOPnew(CLU_0, &T_1_4.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_4.proc->proc = stringOPequal;
        generic_CLU_proc.type_owns = table_of_string_record_code_kind_ops->type_owns;
        generic_CLU_proc.proc = tableOPcreate;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = tableOPcreate(T_1_2, T_1_3, T_1_4, &T_1_5);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[6]  = T_1_5.num;
        RecordAlloc(2, T_1_6);
        CellAlloc(8, nil, T_1_7);
        T_1_6.vec->data[1]  = T_1_7.num;
        T_1_6.vec->data[0]  = 0;
        T_1_1.vec->data[9]  = T_1_6.num;
        RecordAlloc(2, T_1_8);
        CellAlloc(8, nil, T_1_9);
        T_1_8.vec->data[1]  = T_1_9.num;
        T_1_8.vec->data[0]  = 1;
        T_1_1.vec->data[24]  = T_1_8.num;
        T_1_10.num = 300;
        err = proctypeOPnew(CLU_0, &T_1_11.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_11.proc->type_owns = 0;
        T_1_11.proc->op_owns = 0;
        T_1_11.proc->proc = hash_typeabs;
        err = proctypeOPnew(CLU_1, &T_1_12.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_12.proc->op_owns = oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops->entry[1].fcn->op_owns;
        T_1_12.proc->proc = oneofOPsimilar;
        generic_CLU_proc.type_owns = table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops->type_owns;
        generic_CLU_proc.proc = tableOPcreate;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = tableOPcreate(T_1_10, T_1_11, T_1_12, &T_1_13);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[21]  = T_1_13.num;
        T_1_1.vec->data[20]  = 1;
        T_1_1.vec->data[19]  = 0;
        T_1_14.num = 300;
        err = proctypeOPnew(CLU_0, &T_1_15.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_15.proc->type_owns = 0;
        T_1_15.proc->op_owns = 0;
        T_1_15.proc->proc = hash_du;
        err = proctypeOPnew(CLU_0, &T_1_16.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_16.proc->proc = duOPsimilar;
        generic_CLU_proc.type_owns = table_of_du_bool_ops->type_owns;
        generic_CLU_proc.proc = tableOPcreate;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = tableOPcreate(T_1_14, T_1_15, T_1_16, &T_1_17);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[5]  = T_1_17.num;
        err = xlibOPlookup(STR_array, &T_1_18);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1]  = T_1_18.num;
        err = xlibOPlookup(STR_record, &T_1_19);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[14]  = T_1_19.num;
        err = xlibOPlookup(STR_oneof, &T_1_20);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[11]  = T_1_20.num;
        err = xlibOPlookup(STR_sequence, &T_1_21);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[15]  = T_1_21.num;
        err = xlibOPlookup(STR_struct, &T_1_22);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[17]  = T_1_22.num;
        err = xlibOPlookup(STR_variant, &T_1_23);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[23]  = T_1_23.num;
        err = xlibOPlookup(STR_proctype, &T_1_24);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[12]  = T_1_24.num;
        err = xlibOPlookup(STR_itertype, &T_1_25);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[8]  = T_1_25.num;
        CellAlloc(9, nil, T_1_26);
        err = typespecOPcreate(T_1_26, CLU_0, &T_1_27);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[22]  = T_1_27.num;
        CellAlloc(3, nullt.num, T_1_28);
        err = typespecOPcreate(T_1_28, CLU_0, &T_1_29);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[10]  = T_1_29.num;
        CellAlloc(3, boolt.num, T_1_30);
        err = typespecOPcreate(T_1_30, CLU_0, &T_1_31);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[2]  = T_1_31.num;
        CellAlloc(3, intt.num, T_1_32);
        err = typespecOPcreate(T_1_32, CLU_0, &T_1_33);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[7]  = T_1_33.num;
        CellAlloc(3, realt.num, T_1_34);
        err = typespecOPcreate(T_1_34, CLU_0, &T_1_35);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[13]  = T_1_35.num;
        CellAlloc(3, chart.num, T_1_36);
        err = typespecOPcreate(T_1_36, CLU_0, &T_1_37);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[3]  = T_1_37.num;
        CellAlloc(3, strt.num, T_1_38);
        err = typespecOPcreate(T_1_38, CLU_0, &T_1_39);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[16]  = T_1_39.num;
        CellAlloc(8, typet.num, T_1_40);
        err = typespecOPcreate(T_1_40, CLU_0, &T_1_41);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[18]  = T_1_41.num;
        CellAlloc(4, nil, T_1_42);
        err = typespecOPcreate(T_1_42, CLU_0, &T_1_43);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[4]  = T_1_43.num;
        CellAlloc(1, nil, T_1_44);
        err = typespecOPcreate(T_1_44, CLU_0, &T_1_45);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_45.num;
        e.num = T_1_1.num;
        }
        }

  LINE(130);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[22];
    err = ceOPfixup(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(131);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[10];
    err = ceOPfixup(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(132);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[2];
    err = ceOPfixup(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(133);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[7];
    err = ceOPfixup(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(134);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[13];
    err = ceOPfixup(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(135);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[3];
    err = ceOPfixup(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(136);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[16];
    err = ceOPfixup(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(137);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[18];
    err = ceOPfixup(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(138);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[4];
    err = ceOPfixup(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(139);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[0];
    err = ceOPfixup(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(140);
    {
        {ne.num = e.num;
        }
        }

  LINE(141);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[1];
    err = ceOPadd_du(ne, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(142);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[14];
    err = ceOPadd_du(ne, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(143);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[11];
    err = ceOPadd_du(ne, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(144);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[15];
    err = ceOPadd_du(ne, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(145);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[17];
    err = ceOPadd_du(ne, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(146);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[23];
    err = ceOPadd_du(ne, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(147);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[12];
    err = ceOPadd_du(ne, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(148);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[8];
    err = ceOPadd_du(ne, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(149);
    {
    err = ceOPkeep(ne);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(150);
    {
    {
    ret_1->num = ne.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE create ****/

struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_opers_parm_ops;
struct OPS  *oneof_expr_gen_opgen_ownvar_tconst_tparm_typeset_unknown_var_vparm_ops;
struct OPS  *record_code_kind_ops;
struct OPS *table_of_string_table;
struct OPS *table_of_record_code_kind_table;
struct OPS *table_of_string_record_code_kind_ops;
struct OPS *table_of_string_record_code_kind_ops;
OWNPTR table_of_string_record_code_kind_owns;
struct OPS *table_of_string_table;
struct OPS *table_of_record_code_kind_table;
struct OPS *table_op_pcond_flush_of_bool_table;
struct OPS *table_op_pcond_flush_of_string_record_code_kind_bool_ops;
struct OPS *table_of_string_record_code_kind_ops;
OWNPTR table_op_pcond_flush_of_string_record_code_kind_bool_owns;
static int ceOPreset_entries_own_init = 0;

/**** BEGIN PROCEDURE reset_entries ****/

errcode ceOPreset_entries(e, lasting)
CLUREF e;
CLUREF lasting;
    {
    errcode err;
    errcode ecode2;
        if (ceOPreset_entries_own_init == 0) {
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ceOPreset_entries_own_init = 1;
    }
    enter_proc(153);

  LINE(154);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[6];
    err = proctypeOPnew(CLU_0, &T_1_2.proc);
    if (err!= ERR_ok) goto ex_0;
    T_1_2.proc->proc = ceOPpflush_id;
    generic_CLU_proc.type_owns = table_of_string_record_code_kind_ops->type_owns;
    generic_CLU_proc.op_owns = table_op_pcond_flush_of_string_record_code_kind_bool_ops->op_owns;
    generic_CLU_proc.proc = tableOPpcond_flush;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPpcond_flush(T_1_1, T_1_2, lasting);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE reset_entries ****/

struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_opers_parm_ops;
struct OPS  *oneof_expr_gen_opgen_ownvar_tconst_tparm_typeset_unknown_var_vparm_ops;
struct OPS  *record_code_kind_ops;
struct OPS *table_of_string_table;
struct OPS *table_of_record_code_kind_table;
struct OPS *table_of_string_record_code_kind_ops;
struct OPS *table_of_string_record_code_kind_ops;
OWNPTR table_of_string_record_code_kind_owns;
static int ceOPflush_entries_own_init = 0;

/**** BEGIN PROCEDURE flush_entries ****/

errcode ceOPflush_entries(e)
CLUREF e;
    {
    errcode err;
    errcode ecode2;
        if (ceOPflush_entries_own_init == 0) {
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ceOPflush_entries_own_init = 1;
    }
    enter_proc(157);

  LINE(158);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[6];
    generic_CLU_proc.type_owns = table_of_string_record_code_kind_ops->type_owns;
    generic_CLU_proc.proc = tableOPflush;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPflush(T_1_1);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE flush_entries ****/


/**** BEGIN PROCEDURE pflush_id ****/

errcode ceOPpflush_id(ent, lasting, ret_1)
CLUREF ent;
CLUREF lasting;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF code;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(161);

  LINE(162);
    {
        {CLUREF T_1_1;
        T_1_1.num = ent.vec->data[0];
        code.num = T_1_1.num;
        }
        }

  LINE(163);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = -3;
    T_1_3.num = (code.num == T_1_2.num)? true : false;
    T_1_1.num = T_1_3.num;
    if (T_1_3.num) {
        T_1_1.num = lasting.num;
    }
    if (T_1_1.num == true) {

  LINE(164);
        {
        CLUREF T_2_1;
        T_2_1.num = -2;
        ent.vec->data[0]  = T_2_1.num;
        }
        }
    else {
    CLUREF T_1_4;
    T_1_4.num = (code.num >= 0)? true : false;
    if (T_1_4.num == true) {

  LINE(166);
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }
    else {
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    T_1_5.num = -2;
    T_1_6.num = (code.num == T_1_5.num)? true : false;
    T_1_7.num = T_1_6.num ^ 1;
    if (T_1_7.num == true) {

  LINE(168);
        {
        CLUREF T_2_1;
        T_2_1.num = -4;
        ent.vec->data[0]  = T_2_1.num;
        }
        }
        }}}/* end if */

  LINE(169);
    {
    {
    ret_1->tf = false;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE pflush_id ****/

struct OPS *sequence_of_typespec_table;
struct OPS *sequence_of_typespec_ops;
struct OPS *sequence_of_typespec_ops;
OWNPTR sequence_of_typespec_owns;
struct OPS  *record_name_types_ops;
struct OPS *sequence_of_record_name_types_table;
struct OPS *sequence_of_record_name_types_ops;
struct OPS *sequence_of_record_name_types_ops;
OWNPTR sequence_of_record_name_types_owns;
struct OPS  *record_args_gen_sigs_vals_ops;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_gen_parms_ops;
struct OPS  *record_name_parms_type__ops;
struct OPS  *oneof_du_op_return__ops;
struct OPS  *record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__table;
struct OPS *sequence_of_record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__ops;
OWNPTR sequence_of_record_sel_type__owns;
struct OPS  *record_gen_parms_1_ops;
struct OPS  *record_idn_parms_ops;
struct OPS  *record_idn_parms_1_ops;
struct OPS  *oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_table;
struct OPS *table_of_typespec_table;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
OWNPTR table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_owns;
static int ceOPreset_types_own_init = 0;

/**** BEGIN PROCEDURE reset_types ****/

errcode ceOPreset_types(e, types)
CLUREF e;
CLUREF types;
    {
    errcode err;
    errcode ecode2;
    CLUREF t;
        if (ceOPreset_types_own_init == 0) {
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ceOPreset_types_own_init = 1;
    }
    enter_proc(172);

  LINE(173);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = types.array->ext_high; 
        T_1_3 = types;
        for (T_1_1.num = types.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            t.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(174);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            err = typespecOPget_id(t, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            T_2_2.num = e.vec->data[19];
            T_2_3.num = (T_2_1.num > T_2_2.num)? true : false;
            if (T_2_3.num == true) {

  LINE(175);
                {
                err = typespecOPset_id(t, CLU_0);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(176);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = e.vec->data[21];
                err = typespecOPget_abs(t, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                generic_CLU_proc.type_owns = table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops->type_owns;
                generic_CLU_proc.proc = tableOPdelete;
                CUR_PROC_VAR.proc = &generic_CLU_proc;
                err = tableOPdelete(T_3_1, T_3_2);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE reset_types ****/

extern errcode ceOPreset_IB_1();
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_opers_parm_ops;
struct OPS  *oneof_expr_gen_opgen_ownvar_tconst_tparm_typeset_unknown_var_vparm_ops;
struct OPS  *record_code_kind_ops;
struct OPS *table_of_string_table;
struct OPS *table_of_record_code_kind_table;
struct OPS *table_of_string_record_code_kind_ops;
struct OPS *table_of_string_record_code_kind_ops;
OWNPTR table_of_string_record_code_kind_owns;
struct OPS *sequence_of_typespec_table;
struct OPS *sequence_of_typespec_ops;
struct OPS *sequence_of_typespec_ops;
OWNPTR sequence_of_typespec_owns;
struct OPS  *record_name_types_ops;
struct OPS *sequence_of_record_name_types_table;
struct OPS *sequence_of_record_name_types_ops;
struct OPS *sequence_of_record_name_types_ops;
OWNPTR sequence_of_record_name_types_owns;
struct OPS  *record_args_gen_sigs_vals_ops;
struct OPS  *record_gen_parms_ops;
struct OPS  *oneof_du_op_return__ops;
struct OPS  *record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__table;
struct OPS *sequence_of_record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__ops;
OWNPTR sequence_of_record_sel_type__owns;
struct OPS  *record_gen_parms_1_ops;
struct OPS  *record_idn_parms_ops;
struct OPS  *record_idn_parms_1_ops;
struct OPS  *oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_table;
struct OPS *table_of_typespec_table;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
OWNPTR table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_owns;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_table;
struct OPS *table_of_typespec_table;
struct OPS *table_op_pcond_flush_of_int_table;
struct OPS *table_op_pcond_flush_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_int_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
OWNPTR table_op_pcond_flush_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_int_owns;
struct OPS *table_of_du_table;
struct OPS *table_of_bool_table;
struct OPS *table_of_du_bool_ops;
struct OPS *table_of_du_bool_ops;
OWNPTR table_of_du_bool_owns;
static int ceOPreset_own_init = 0;

/**** BEGIN PROCEDURE reset ****/

errcode ceOPreset(e)
CLUREF e;
    {
    struct {
        errcode err;
        errcode ecode2;
        CLUREF ms;
        CLUREF d;
        CLUREF flush;
        CLUREF e;
        } locals;
    locals.e = e;
        if (ceOPreset_own_init == 0) {
        if (ce_own_init == 0) {
            locals.err = ce_own_init_proc();
            if (locals.err != ERR_ok) goto ex_0;
            }
        ceOPreset_own_init = 1;
    }
    enter_proc(181);

  LINE(182);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.e.vec->data[6];
    locals.err = proctypeOPnew(CLU_0, &T_1_2.proc);
    if (locals.err!= ERR_ok) goto ex_0;
    T_1_2.proc->proc = ceOPflush_id;
    generic_CLU_proc.type_owns = table_of_string_record_code_kind_ops->type_owns;
    generic_CLU_proc.proc = tableOPcond_flush;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    locals.err = tableOPcond_flush(T_1_1, T_1_2);
    if (locals.err != ERR_ok) goto ex_0;
    }

  LINE(183);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = locals.e.vec->data[21];
    locals.err = proctypeOPnew(CLU_0, &T_1_2.proc);
    if (locals.err!= ERR_ok) goto ex_0;
    T_1_2.proc->proc = ceOPpflush_type;
    T_1_3.num = locals.e.vec->data[19];
    generic_CLU_proc.type_owns = table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops->type_owns;
    generic_CLU_proc.op_owns = table_op_pcond_flush_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_int_ops->op_owns;
    generic_CLU_proc.proc = tableOPpcond_flush;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    locals.err = tableOPpcond_flush(T_1_1, T_1_2, T_1_3);
    if (locals.err != ERR_ok) goto ex_0;
    }

  LINE(184);
    {
        {CLUREF T_1_1;
        CellAlloc(1, nil, T_1_1);
        locals.ms.num = T_1_1.num;
        }
        }

  LINE(185);
    {
        CLUREF T_1_1;
        T_1_1.num = locals.e.vec->data[5];
        generic_CLU_proc.type_owns = table_of_du_bool_ops->type_owns;
        generic_CLU_proc.proc = tableOPelements;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        locals.err = tableOPelements(T_1_1, ceOPreset_IB_1, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {
        signal(ERR_ok);}
        if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
        if (locals.err == ERR_break) locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
        if (locals.err != ERR_ok) goto ex_0;
        }

  LINE(188);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.e.vec->data[5];
    locals.err = proctypeOPnew(CLU_0, &T_1_2.proc);
    if (locals.err!= ERR_ok) goto ex_0;
    T_1_2.proc->proc = boolOPcopy;
    generic_CLU_proc.type_owns = table_of_du_bool_ops->type_owns;
    generic_CLU_proc.proc = tableOPcond_flush;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    locals.err = tableOPcond_flush(T_1_1, T_1_2);
    if (locals.err != ERR_ok) goto ex_0;
    }

  LINE(189);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.e.vec->data[19];
    T_1_2.num = T_1_1.num + 1;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && 1 < 0) || 
         (T_1_2.num < 0 && T_1_1.num > 0 && 1 > 0)) {
        locals.err = ERR_overflow;
        goto ex_0;}
    locals.e.vec->data[20]  = T_1_2.num;
    }
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE reset ****/


/**** BEGIN ITERATOR BODIES for reset ****/

errcode ceOPreset_IB_1(iv_1, iv_2, locals, iecode)
errcode *iecode;
CLUREF iv_1;
CLUREF iv_2;
struct {
    errcode err;
    errcode ecode2;
    CLUREF ms;
    CLUREF d;
    CLUREF flush;
    CLUREF e;
    } *locals;
{
    locals->d.num = iv_1.num;
    locals->flush.num = iv_2.num;
    enter_iter_body_proc(186);

  FB_LINE(186);
    {
    locals->err = duOPset_mspecs(locals->d, locals->ms);
    if (locals->err != ERR_ok) goto ex_0;
    }
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end ceOPreset_IB_1 */

/**** END ITERATOR BODIES for reset ****/

extern errcode ceOPreset1_IB_1();
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_opers_parm_ops;
struct OPS  *oneof_expr_gen_opgen_ownvar_tconst_tparm_typeset_unknown_var_vparm_ops;
struct OPS  *record_code_kind_ops;
struct OPS *table_of_string_table;
struct OPS *table_of_record_code_kind_table;
struct OPS *table_of_string_record_code_kind_ops;
struct OPS *table_of_string_record_code_kind_ops;
OWNPTR table_of_string_record_code_kind_owns;
struct OPS *sequence_of_typespec_table;
struct OPS *sequence_of_typespec_ops;
struct OPS *sequence_of_typespec_ops;
OWNPTR sequence_of_typespec_owns;
struct OPS  *record_name_types_ops;
struct OPS *sequence_of_record_name_types_table;
struct OPS *sequence_of_record_name_types_ops;
struct OPS *sequence_of_record_name_types_ops;
OWNPTR sequence_of_record_name_types_owns;
struct OPS  *record_args_gen_sigs_vals_ops;
struct OPS  *record_gen_parms_ops;
struct OPS  *oneof_du_op_return__ops;
struct OPS  *record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__table;
struct OPS *sequence_of_record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__ops;
OWNPTR sequence_of_record_sel_type__owns;
struct OPS  *record_gen_parms_1_ops;
struct OPS  *record_idn_parms_ops;
struct OPS  *record_idn_parms_1_ops;
struct OPS  *oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_table;
struct OPS *table_of_typespec_table;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
OWNPTR table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_owns;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_table;
struct OPS *table_of_typespec_table;
struct OPS *table_op_pcond_flush_of_int_table;
struct OPS *table_op_pcond_flush_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_int_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
OWNPTR table_op_pcond_flush_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_int_owns;
struct OPS *table_of_du_table;
struct OPS *table_of_bool_table;
struct OPS *table_of_du_bool_ops;
struct OPS *table_of_du_bool_ops;
OWNPTR table_of_du_bool_owns;
static int ceOPreset1_own_init = 0;

/**** BEGIN PROCEDURE reset1 ****/

errcode ceOPreset1(e)
CLUREF e;
    {
    struct {
        errcode err;
        errcode ecode2;
        CLUREF ms;
        CLUREF d;
        CLUREF flush;
        CLUREF e;
        } locals;
    locals.e = e;
        if (ceOPreset1_own_init == 0) {
        if (ce_own_init == 0) {
            locals.err = ce_own_init_proc();
            if (locals.err != ERR_ok) goto ex_0;
            }
        ceOPreset1_own_init = 1;
    }
    enter_proc(192);

  LINE(193);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.e.vec->data[6];
    locals.err = proctypeOPnew(CLU_0, &T_1_2.proc);
    if (locals.err!= ERR_ok) goto ex_0;
    T_1_2.proc->proc = ceOPflush_id;
    generic_CLU_proc.type_owns = table_of_string_record_code_kind_ops->type_owns;
    generic_CLU_proc.proc = tableOPcond_flush;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    locals.err = tableOPcond_flush(T_1_1, T_1_2);
    if (locals.err != ERR_ok) goto ex_0;
    }

  LINE(194);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = locals.e.vec->data[21];
    locals.err = proctypeOPnew(CLU_0, &T_1_2.proc);
    if (locals.err!= ERR_ok) goto ex_0;
    T_1_2.proc->proc = ceOPpflush_type;
    T_1_3.num = locals.e.vec->data[19];
    generic_CLU_proc.type_owns = table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops->type_owns;
    generic_CLU_proc.op_owns = table_op_pcond_flush_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_int_ops->op_owns;
    generic_CLU_proc.proc = tableOPpcond_flush;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    locals.err = tableOPpcond_flush(T_1_1, T_1_2, T_1_3);
    if (locals.err != ERR_ok) goto ex_0;
    }

  LINE(195);
    {
        {CLUREF T_1_1;
        CellAlloc(1, nil, T_1_1);
        locals.ms.num = T_1_1.num;
        }
        }

  LINE(196);
    {
        CLUREF T_1_1;
        T_1_1.num = locals.e.vec->data[5];
        generic_CLU_proc.type_owns = table_of_du_bool_ops->type_owns;
        generic_CLU_proc.proc = tableOPelements;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        locals.err = tableOPelements(T_1_1, ceOPreset1_IB_1, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {
        signal(ERR_ok);}
        if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
        if (locals.err == ERR_break) locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
        if (locals.err != ERR_ok) goto ex_0;
        }

  LINE(199);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.e.vec->data[19];
    T_1_2.num = T_1_1.num + 1;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && 1 < 0) || 
         (T_1_2.num < 0 && T_1_1.num > 0 && 1 > 0)) {
        locals.err = ERR_overflow;
        goto ex_0;}
    locals.e.vec->data[20]  = T_1_2.num;
    }
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE reset1 ****/


/**** BEGIN ITERATOR BODIES for reset1 ****/

errcode ceOPreset1_IB_1(iv_1, iv_2, locals, iecode)
errcode *iecode;
CLUREF iv_1;
CLUREF iv_2;
struct {
    errcode err;
    errcode ecode2;
    CLUREF ms;
    CLUREF d;
    CLUREF flush;
    CLUREF e;
    } *locals;
{
    locals->d.num = iv_1.num;
    locals->flush.num = iv_2.num;
    enter_iter_body_proc(197);

  FB_LINE(197);
    {
    locals->err = duOPset_mspecs(locals->d, locals->ms);
    if (locals->err != ERR_ok) goto ex_0;
    }
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end ceOPreset1_IB_1 */

/**** END ITERATOR BODIES for reset1 ****/


/**** BEGIN PROCEDURE flush_id ****/

errcode ceOPflush_id(ent, ret_1)
CLUREF ent;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(202);

  LINE(203);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ent.vec->data[0];
    T_1_2.num = (T_1_1.num >= 0)? true : false;
    if (T_1_2.num == true) {

  LINE(204);
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(205);
        {
        CLUREF T_2_1;
        T_2_1.num = -4;
        ent.vec->data[0]  = T_2_1.num;
        }

  LINE(206);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE flush_id ****/


/**** BEGIN PROCEDURE pflush_type ****/

errcode ceOPpflush_type(t, max, ret_1)
CLUREF t;
CLUREF max;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(210);

  LINE(211);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = typespecOPget_id(t, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = (T_1_1.num > max.num)? true : false;
    if (T_1_2.num == true) {

  LINE(212);
        {
        err = typespecOPset_id(t, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(213);
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(214);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE pflush_type ****/

extern errcode ceOPkeep_IB_1();
struct OPS *table_of_du_table;
struct OPS *table_of_bool_table;
struct OPS *table_of_du_bool_ops;
struct OPS *table_of_du_bool_ops;
OWNPTR table_of_du_bool_owns;
static int ceOPkeep_own_init = 0;

/**** BEGIN PROCEDURE keep ****/

errcode ceOPkeep(e)
CLUREF e;
    {
    struct {
        errcode err;
        errcode ecode2;
        CLUREF tab;
        CLUREF d;
        CLUREF flush;
        CLUREF e;
        } locals;
    locals.e = e;
        if (ceOPkeep_own_init == 0) {
        if (ce_own_init == 0) {
            locals.err = ce_own_init_proc();
            if (locals.err != ERR_ok) goto ex_0;
            }
        ceOPkeep_own_init = 1;
    }
    enter_proc(218);

  LINE(219);
    {
        {CLUREF T_1_1;
        T_1_1.num = locals.e.vec->data[5];
        locals.tab.num = T_1_1.num;
        }
        }

  LINE(220);
    {
        generic_CLU_proc.type_owns = table_of_du_bool_ops->type_owns;
        generic_CLU_proc.proc = tableOPelements;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        locals.err = tableOPelements(locals.tab, ceOPkeep_IB_1, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {
        signal(ERR_ok);}
        if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
        if (locals.err == ERR_break) locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
        if (locals.err != ERR_ok) goto ex_0;
        }

  LINE(224);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.e.vec->data[20];
    T_1_2.num = T_1_1.num - 1;
     if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-1) < 0) || 
         (T_1_2.num <= 0 && T_1_1.num > 0 && (-1) > 0)) {
        locals.err = ERR_overflow;
        goto ex_0;}
    locals.e.vec->data[19]  = T_1_2.num;
    }
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE keep ****/


/**** BEGIN ITERATOR BODIES for keep ****/

errcode ceOPkeep_IB_1(iv_1, iv_2, locals, iecode)
errcode *iecode;
CLUREF iv_1;
CLUREF iv_2;
struct {
    errcode err;
    errcode ecode2;
    CLUREF tab;
    CLUREF d;
    CLUREF flush;
    CLUREF e;
    } *locals;
{
    locals->d.num = iv_1.num;
    locals->flush.num = iv_2.num;
    enter_iter_body_proc(221);

  FB_LINE(221);
    {
    if (locals->flush.num == true) {

  FB_LINE(222);
        {
        generic_CLU_proc.type_owns = table_of_du_bool_ops->type_owns;
        generic_CLU_proc.proc = tableOPalter;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        locals->err = tableOPalter(locals->tab, locals->d, CLU_0);
        if (locals->err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end ceOPkeep_IB_1 */

/**** END ITERATOR BODIES for keep ****/

struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_opers_parm_ops;
struct OPS  *oneof_expr_gen_opgen_ownvar_tconst_tparm_typeset_unknown_var_vparm_ops;
struct OPS  *record_code_kind_ops;
struct OPS *table_of_string_table;
struct OPS *table_of_record_code_kind_table;
struct OPS *table_of_string_record_code_kind_ops;
struct OPS *table_of_string_record_code_kind_ops;
OWNPTR table_of_string_record_code_kind_owns;
static int ceOPlookup_own_init = 0;

/**** BEGIN PROCEDURE lookup ****/

errcode ceOPlookup(e, s, line, ret_1)
CLUREF e;
CLUREF s;
CLUREF line;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF xent;
    CLUREF ent;
    CLUREF code;
        if (ceOPlookup_own_init == 0) {
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ceOPlookup_own_init = 1;
    }
    enter_proc(227);

  LINE(228);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[24];
        xent.num = T_1_1.num;
        }
        }

  LINE(229);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = e.vec->data[6];
        generic_CLU_proc.type_owns = table_of_string_record_code_kind_ops->type_owns;
        generic_CLU_proc.proc = tableOPmbind;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = tableOPmbind(T_1_1, s, xent, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        ent.num = T_1_2.num;
        }
        }

  LINE(230);
    {
    CLUREF T_1_1;
    T_1_1.num = (ent.num == xent.num)? true : false;
    if (T_1_1.num == true) {

  LINE(231);
        {
        CLUREF T_2_1;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.proc = recordOPcopy1;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = recordOPcopy1(xent, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        e.vec->data[24]  = T_2_1.num;
        }

  LINE(232);
        {
        CLUREF T_2_1;
        T_2_1.num = (line.num > 0)? true : false;
        if (T_2_1.num == true) {

  LINE(233);
            {
            xent.vec->data[0]  = line.num;
            }
            }
            }/* end if */
        }
    else {

  LINE(234);
        {
            {CLUREF T_2_1;
            T_2_1.num = ent.vec->data[0];
            code.num = T_2_1.num;
            }
            }

  LINE(235);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_2.num = -1;
        T_2_3.num = (code.num == T_2_2.num)? true : false;
        T_2_1.num = T_2_3.num;
        if (!T_2_3.num) {
            T_2_4.num = (code.num == 0)? true : false;
            T_2_1.num = T_2_4.num;
        }
        if (T_2_1.num == true) {

  LINE(236);
            {
            {signal (ERR_local);}}
            }
        else {
        CLUREF T_2_5;
        CLUREF T_2_6;
        T_2_5.num = -4;
        T_2_6.num = (code.num == T_2_5.num)? true : false;
        if (T_2_6.num == true) {

  LINE(238);
            {
            CLUREF T_3_1;
            T_3_1.num = -3;
            ent.vec->data[0]  = T_3_1.num;
            }
            }
            }}/* end if */
        }}/* end if */

  LINE(240);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = ent.vec->data[1];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE lookup ****/

struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_opers_parm_ops;
struct OPS  *oneof_expr_gen_opgen_ownvar_tconst_tparm_typeset_unknown_var_vparm_ops;
struct OPS  *record_code_kind_ops;
struct OPS *table_of_string_table;
struct OPS *table_of_record_code_kind_table;
struct OPS *table_of_string_record_code_kind_ops;
struct OPS *table_of_string_record_code_kind_ops;
OWNPTR table_of_string_record_code_kind_owns;
static int ceOPlocal_own_init = 0;

/**** BEGIN PROCEDURE local ****/

errcode ceOPlocal(e, s, ret_1)
CLUREF e;
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ent;
    CLUREF code;
        if (ceOPlocal_own_init == 0) {
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ceOPlocal_own_init = 1;
    }
    enter_proc(243);

  LINE(244);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = e.vec->data[6];
        T_1_2.num = e.vec->data[9];
        generic_CLU_proc.type_owns = table_of_string_record_code_kind_ops->type_owns;
        generic_CLU_proc.proc = tableOPmbind;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = tableOPmbind(T_1_1, s, T_1_2, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        ent.num = T_1_3.num;
        }
        }

  LINE(245);
    {
        {CLUREF T_1_1;
        T_1_1.num = ent.vec->data[0];
        code.num = T_1_1.num;
        }
        }

  LINE(246);
    {
    CLUREF T_1_1;
    T_1_1.num = (code.num > 0)? true : false;
    if (T_1_1.num == true) {

  LINE(247);
        {
        {
        ret_1->num = code.num;
        }
        {signal (ERR_ok);}}
        }
    else {
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = -1;
    T_1_3.num = (code.num < T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(249);
        {
        CLUREF T_2_1;
        T_2_1.num = -1;
        ent.vec->data[0]  = T_2_1.num;
        }
        }
        }}/* end if */

  LINE(250);
    {
    {
    ret_1->num = 0;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE local ****/

struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_opers_parm_ops;
struct OPS  *oneof_expr_gen_opgen_ownvar_tconst_tparm_typeset_unknown_var_vparm_ops;
struct OPS  *record_code_kind_ops;
struct OPS *table_of_string_table;
struct OPS *table_of_record_code_kind_table;
struct OPS *table_of_string_record_code_kind_ops;
struct OPS *table_of_string_record_code_kind_ops;
OWNPTR table_of_string_record_code_kind_owns;
static int ceOPadd_entry_own_init = 0;

/**** BEGIN PROCEDURE add_entry ****/

errcode ceOPadd_entry(e, i)
CLUREF e;
CLUREF i;
    {
    errcode err;
    errcode ecode2;
        if (ceOPadd_entry_own_init == 0) {
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ceOPadd_entry_own_init = 1;
    }
    enter_proc(253);

  LINE(254);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    CLUREF T_2_4;
    T_2_1.num = e.vec->data[6];
    err = idnOPget_str(i, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    RecordAlloc(2, T_2_3);
    err = idnOPget_kind(i, &T_2_4);
    if (err != ERR_ok) goto ex_1;
    T_2_3.vec->data[1]  = T_2_4.num;
    T_2_3.vec->data[0]  = -4;
    generic_CLU_proc.type_owns = table_of_string_record_code_kind_ops->type_owns;
    generic_CLU_proc.proc = tableOPbind;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPbind(T_2_1, T_2_2, T_2_3);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_exists) {signal(ERR_exists);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE add_entry ****/


/**** BEGIN PROCEDURE get_unknown_type ****/

errcode ceOPget_unknown_type(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(259);

  LINE(260);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[22];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_unknown_type ****/


/**** BEGIN PROCEDURE get_null_type ****/

errcode ceOPget_null_type(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(263);

  LINE(264);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[10];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_null_type ****/


/**** BEGIN PROCEDURE get_bool_type ****/

errcode ceOPget_bool_type(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(267);

  LINE(268);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[2];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_bool_type ****/


/**** BEGIN PROCEDURE get_int_type ****/

errcode ceOPget_int_type(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(271);

  LINE(272);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[7];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_int_type ****/


/**** BEGIN PROCEDURE get_real_type ****/

errcode ceOPget_real_type(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(275);

  LINE(276);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[13];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_real_type ****/


/**** BEGIN PROCEDURE get_char_type ****/

errcode ceOPget_char_type(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(279);

  LINE(280);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[3];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_char_type ****/


/**** BEGIN PROCEDURE get_str_type ****/

errcode ceOPget_str_type(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(283);

  LINE(284);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[16];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_str_type ****/


/**** BEGIN PROCEDURE get_type_type ****/

errcode ceOPget_type_type(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(287);

  LINE(288);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[18];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_type_type ****/


/**** BEGIN PROCEDURE get_cvt_type ****/

errcode ceOPget_cvt_type(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(291);

  LINE(292);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[4];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_cvt_type ****/


/**** BEGIN PROCEDURE get_any_type ****/

errcode ceOPget_any_type(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(295);

  LINE(296);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[0];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_any_type ****/


/**** BEGIN PROCEDURE get_array_ ****/

errcode ceOPget_array_(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(299);

  LINE(300);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[1];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_array_ ****/


/**** BEGIN PROCEDURE get_record_ ****/

errcode ceOPget_record_(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(303);

  LINE(304);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[14];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_record_ ****/


/**** BEGIN PROCEDURE get_oneof_ ****/

errcode ceOPget_oneof_(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(307);

  LINE(308);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[11];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_oneof_ ****/


/**** BEGIN PROCEDURE get_seq_ ****/

errcode ceOPget_seq_(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(311);

  LINE(312);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[15];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_seq_ ****/


/**** BEGIN PROCEDURE get_struct_ ****/

errcode ceOPget_struct_(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(315);

  LINE(316);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[17];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_struct_ ****/


/**** BEGIN PROCEDURE get_variant_ ****/

errcode ceOPget_variant_(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(319);

  LINE(320);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[23];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_variant_ ****/


/**** BEGIN PROCEDURE get_proc_ ****/

errcode ceOPget_proc_(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(323);

  LINE(324);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[12];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_proc_ ****/


/**** BEGIN PROCEDURE get_iter_ ****/

errcode ceOPget_iter_(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(327);

  LINE(328);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[8];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_iter_ ****/

struct OPS *sequence_of_typespec_table;
struct OPS *sequence_of_typespec_ops;
struct OPS *sequence_of_typespec_ops;
OWNPTR sequence_of_typespec_owns;
struct OPS  *record_name_types_ops;
struct OPS *sequence_of_record_name_types_table;
struct OPS *sequence_of_record_name_types_ops;
struct OPS *sequence_of_record_name_types_ops;
OWNPTR sequence_of_record_name_types_owns;
struct OPS  *record_args_gen_sigs_vals_ops;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_gen_parms_ops;
struct OPS  *record_name_parms_type__ops;
struct OPS  *oneof_du_op_return__ops;
struct OPS  *record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__table;
struct OPS *sequence_of_record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__ops;
OWNPTR sequence_of_record_sel_type__owns;
struct OPS  *record_gen_parms_1_ops;
struct OPS  *record_idn_parms_ops;
struct OPS  *record_idn_parms_1_ops;
struct OPS  *oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_table;
struct OPS *table_of_typespec_table;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
OWNPTR table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_owns;
static int ceOPget_type_own_init = 0;

/**** BEGIN PROCEDURE get_type ****/

errcode ceOPget_type(e, ta, ret_1, ret_2)
CLUREF e;
CLUREF ta;
CLUREF *ret_1;
CLUREF *ret_2;
    {
    errcode err;
    errcode ecode2;
    CLUREF nta;
    CLUREF t;
        if (ceOPget_type_own_init == 0) {
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ceOPget_type_own_init = 1;
    }
    enter_proc(333);

  LINE(334);
    {

  LINE(335);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = e.vec->data[21];
            generic_CLU_proc.type_owns = table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops->type_owns;
            generic_CLU_proc.proc = tableOPget_pair;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = tableOPget_pair(T_3_1, ta, &T_3_2, &T_3_3);
            if (err != ERR_ok) goto ex_1;
            nta.num = T_3_2.num;
            t.num = T_3_3.num;
            }
            }

  LINE(336);
        {
        {
        ret_1->num = t.num;
        }
        {
        ret_2->tf = true;
        }
        {signal (ERR_ok);}}
        }
        goto end_1;
        ex_1:
            if ((err == ERR_not_found)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(338);
    {
        {CLUREF T_1_1;
        err = typespecOPcreate(ta, CLU_0, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        t.num = T_1_1.num;
        }
        }

  LINE(339);
    {
    err = ceOPfixup(e, t);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(340);
    {
    {
    ret_1->num = t.num;
    }
    {
    ret_2->tf = false;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_type ****/

struct OPS *sequence_of_typespec_table;
struct OPS *sequence_of_typespec_ops;
struct OPS *sequence_of_typespec_ops;
OWNPTR sequence_of_typespec_owns;
struct OPS  *record_name_types_ops;
struct OPS *sequence_of_record_name_types_table;
struct OPS *sequence_of_record_name_types_ops;
struct OPS *sequence_of_record_name_types_ops;
OWNPTR sequence_of_record_name_types_owns;
struct OPS  *record_args_gen_sigs_vals_ops;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_gen_parms_ops;
struct OPS  *record_name_parms_type__ops;
struct OPS  *oneof_du_op_return__ops;
struct OPS  *record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__table;
struct OPS *sequence_of_record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__ops;
OWNPTR sequence_of_record_sel_type__owns;
struct OPS  *record_gen_parms_1_ops;
struct OPS  *record_idn_parms_ops;
struct OPS  *record_idn_parms_1_ops;
struct OPS  *oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_table;
struct OPS *table_of_typespec_table;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
struct OPS *table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops;
OWNPTR table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_owns;
static int ceOPfixup_own_init = 0;

/**** BEGIN PROCEDURE fixup ****/

errcode ceOPfixup(e, t)
CLUREF e;
CLUREF t;
    {
    errcode err;
    errcode ecode2;
    CLUREF clut;
    CLUREF selt;
    CLUREF apt;
    CLUREF ot;
        if (ceOPfixup_own_init == 0) {
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ceOPfixup_own_init = 1;
    }
    enter_proc(343);

  LINE(344);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[20];
    err = typespecOPset_id(t, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(345);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[21];
    err = typespecOPget_abs(t, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    generic_CLU_proc.type_owns = table_of_oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_typespec_ops->type_owns;
    generic_CLU_proc.proc = tableOPbind;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPbind(T_1_1, T_1_2, t);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(346);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[20];
    T_1_2.num = T_1_1.num + 1;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && 1 < 0) || 
         (T_1_2.num < 0 && T_1_1.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    e.vec->data[20]  = T_1_2.num;
    }

  LINE(347);
    {
    CLUREF T_1_1;
    err = typespecOPget_abs(t, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 3: 
    case 8: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        clut.num = T_1_2.num;

  LINE(349);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = clut.vec->data[0];
            err = ceOPadd_du(e, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            clut.vec->data[0]  = T_2_2.num;
            }
            break;
            }
    case 7: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        selt.num = T_1_3.num;

  LINE(351);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = selt.vec->data[0];
            err = ceOPadd_du(e, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            selt.vec->data[0]  = T_2_2.num;
            }
            break;
            }
    case 2: 
         {CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        apt.num = T_1_4.num;

  LINE(353);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = apt.vec->data[1];
            err = ceOPadd_du(e, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            apt.vec->data[1]  = T_2_2.num;
            }
            break;
            }
    case 6: 
         {CLUREF T_1_5;
        T_1_5.num = T_1_1.cell->value;
        ot.num = T_1_5.num;

  LINE(355);
            {
            switch (ot.cell->tag) {
            case 1: 
                 {CLUREF T_2_1;
                T_2_1.num = ot.cell->value;
                clut.num = T_2_1.num;

  LINE(357);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    T_3_1.num = clut.vec->data[0];
                    err = ceOPadd_du(e, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    clut.vec->data[0]  = T_3_2.num;
                    }
                    break;
                    }
            default: {
            }
            }
            }
            break;
            }
    default: {
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE fixup ****/

struct OPS *table_of_du_table;
struct OPS *table_of_bool_table;
struct OPS *table_of_du_bool_ops;
struct OPS *table_of_du_bool_ops;
OWNPTR table_of_du_bool_owns;
static int ceOPadd_du_own_init = 0;

/**** BEGIN PROCEDURE add_du ****/

errcode ceOPadd_du(e, mod, ret_1)
CLUREF e;
CLUREF mod;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF d;
    CLUREF flush;
        if (ceOPadd_du_own_init == 0) {
        if (ce_own_init == 0) {
            err = ce_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ceOPadd_du_own_init = 1;
    }
    enter_proc(364);

  LINE(365);
    {

  LINE(366);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = e.vec->data[5];
            generic_CLU_proc.type_owns = table_of_du_bool_ops->type_owns;
            generic_CLU_proc.proc = tableOPget_pair;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = tableOPget_pair(T_3_1, mod, &T_3_2, &T_3_3);
            if (err != ERR_ok) goto ex_1;
            d.num = T_3_2.num;
            flush.num = T_3_3.num;
            }
            }

  LINE(367);
        {
        {
        ret_1->num = d.num;
        }
        {signal (ERR_ok);}}
        }
        goto end_1;
        ex_1:
            if ((err == ERR_not_found)) {

  LINE(370);
                {
                    {CLUREF T_2_1;
                    CLUREF T_2_2;
                    err = duOPget_unique(mod, &T_2_1);
                    if (err != ERR_ok) goto ex_0;
                    err = xlibOPget_du(T_2_1, &T_2_2);
                    if (err != ERR_ok) goto ex_0;
                    d.num = T_2_2.num;
                    }
                    }

  LINE(371);
                {
                CLUREF T_2_1;
                T_2_1.num = e.vec->data[5];
                generic_CLU_proc.type_owns = table_of_du_bool_ops->type_owns;
                generic_CLU_proc.proc = tableOPbind;
                CUR_PROC_VAR.proc = &generic_CLU_proc;
                err = tableOPbind(T_2_1, d, CLU_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(372);
                {
                {
                ret_1->num = d.num;
                }
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE add_du ****/

extern errcode ceOPall_dus_IB_1();
struct OPS *table_of_du_table;
struct OPS *table_of_bool_table;
struct OPS *table_of_du_bool_ops;
struct OPS *table_of_du_bool_ops;
OWNPTR table_of_du_bool_owns;
static int ceOPall_dus_own_init = 0;

/**** BEGIN ITERATOR all_dus ****/

errcode ceOPall_dus(e, proc, user_locals, iecode)
CLUREF e;
errcode (*proc)();
char **user_locals;
errcode *iecode;
    {
    errcode ecode;
    struct {
        char **user_locals;
        errcode (*proc)();
        errcode err;
        errcode ecode2;
        bool body_ctrl_req;
        CLUREF d;
        CLUREF flush;
        CLUREF e;
        } locals;
    locals.e = e;
    locals.proc = proc;
    locals.user_locals = user_locals;
    locals.user_locals = user_locals;
    locals.proc = proc;
        if (ceOPall_dus_own_init == 0) {
        if (ce_own_init == 0) {
            locals.err = ce_own_init_proc();
            if (locals.err != ERR_ok) goto ex_0;
            }
        ceOPall_dus_own_init = 1;
    }
    enter_proc(376);

  LINE(377);
    {
        CLUREF T_1_1;
        T_1_1.num = locals.e.vec->data[5];
        locals.body_ctrl_req = false;
        generic_CLU_proc.type_owns = table_of_du_bool_ops->type_owns;
        generic_CLU_proc.proc = tableOPelements;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        locals.err = tableOPelements(T_1_1, ceOPall_dus_IB_1, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {signal(ERR_iterbodyreturn);}
        if (locals.err == ERR_iterbodysignal) {
            *iecode = locals.ecode2; signal(ERR_iterbodysignal);}
        if (locals.err == ERR_iterbodyexit) {
            *iecode = locals.ecode2; signal(ERR_iterbodyexit);}
        if (locals.body_ctrl_req == true) {
            locals.body_ctrl_req = false;
            if (locals.err == ERR_iteriterbodyreturn) {signal(ERR_ok);}
            if (locals.err == ERR_iteriterbodysignal) {signal(locals.ecode2);}
            if (locals.err == ERR_break) locals.err = ERR_ok;
            if (locals.err == ERR_iteriterbodyexit) locals.err = locals.ecode2;
            }
        else {
            if (locals.err == ERR_iteriterbodyreturn) {signal(ERR_iteriterbodyreturn);}
            if (locals.err == ERR_break) {signal(ERR_break);}
            if (locals.err == ERR_iteriterbodysignal) {
                  *iecode = locals.ecode2; signal(ERR_iteriterbodysignal);}
            if (locals.err == ERR_iteriterbodyexit) {
                  *iecode = locals.ecode2; signal(ERR_iteriterbodyexit);}}
        if (locals.err != ERR_ok) goto ex_0;
        }
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END ITERATOR all_dus ****/


/**** BEGIN ITERATOR BODIES for all_dus ****/

errcode ceOPall_dus_IB_1(iv_1, iv_2, locals, iecode)
errcode *iecode;
CLUREF iv_1;
CLUREF iv_2;
struct {
    char **user_locals;
    errcode (*proc)();
    errcode err;
    errcode ecode2;
    bool body_ctrl_req;
    CLUREF d;
    CLUREF flush;
    CLUREF e;
    } *locals;
{
    locals->d.num = iv_1.num;
    locals->flush.num = iv_2.num;
    enter_iter_body_proc(378);

  FB_LINE(378);
    {
    locals->err = locals->proc(locals->d, locals->user_locals, iecode);
    if ((locals->body_ctrl_req == true) && (locals->err == ERR_iteriterbodyexit)) {
        locals->err = *iecode;
        goto ex_0;}
    if (locals->err != ERR_ok) {
    signal(locals->err);
    }
    }
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            locals->body_ctrl_req = true;
            {signal(ERR_iteriterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end ceOPall_dus_IB_1 */

/**** END ITERATOR BODIES for all_dus ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[31];
} ce_OPS;

CLU_proc ce_oe_add_du = {{0,0,0,0}, ceOPadd_du, 0};
CLU_proc ce_oe_add_entry = {{0,0,0,0}, ceOPadd_entry, 0};
CLU_proc ce_oe_all_dus = {{0,0,0,0}, ceOPall_dus, 0};
CLU_proc ce_oe_create = {{0,0,0,0}, ceOPcreate, 0};
CLU_proc ce_oe_flush_entries = {{0,0,0,0}, ceOPflush_entries, 0};
CLU_proc ce_oe_get_any_type = {{0,0,0,0}, ceOPget_any_type, 0};
CLU_proc ce_oe_get_array_ = {{0,0,0,0}, ceOPget_array_, 0};
CLU_proc ce_oe_get_bool_type = {{0,0,0,0}, ceOPget_bool_type, 0};
CLU_proc ce_oe_get_char_type = {{0,0,0,0}, ceOPget_char_type, 0};
CLU_proc ce_oe_get_cvt_type = {{0,0,0,0}, ceOPget_cvt_type, 0};
CLU_proc ce_oe_get_int_type = {{0,0,0,0}, ceOPget_int_type, 0};
CLU_proc ce_oe_get_iter_ = {{0,0,0,0}, ceOPget_iter_, 0};
CLU_proc ce_oe_get_null_type = {{0,0,0,0}, ceOPget_null_type, 0};
CLU_proc ce_oe_get_oneof_ = {{0,0,0,0}, ceOPget_oneof_, 0};
CLU_proc ce_oe_get_proc_ = {{0,0,0,0}, ceOPget_proc_, 0};
CLU_proc ce_oe_get_real_type = {{0,0,0,0}, ceOPget_real_type, 0};
CLU_proc ce_oe_get_record_ = {{0,0,0,0}, ceOPget_record_, 0};
CLU_proc ce_oe_get_seq_ = {{0,0,0,0}, ceOPget_seq_, 0};
CLU_proc ce_oe_get_str_type = {{0,0,0,0}, ceOPget_str_type, 0};
CLU_proc ce_oe_get_struct_ = {{0,0,0,0}, ceOPget_struct_, 0};
CLU_proc ce_oe_get_type = {{0,0,0,0}, ceOPget_type, 0};
CLU_proc ce_oe_get_type_type = {{0,0,0,0}, ceOPget_type_type, 0};
CLU_proc ce_oe_get_unknown_type = {{0,0,0,0}, ceOPget_unknown_type, 0};
CLU_proc ce_oe_get_variant_ = {{0,0,0,0}, ceOPget_variant_, 0};
CLU_proc ce_oe_keep = {{0,0,0,0}, ceOPkeep, 0};
CLU_proc ce_oe_local = {{0,0,0,0}, ceOPlocal, 0};
CLU_proc ce_oe_lookup = {{0,0,0,0}, ceOPlookup, 0};
CLU_proc ce_oe_reset = {{0,0,0,0}, ceOPreset, 0};
CLU_proc ce_oe_reset1 = {{0,0,0,0}, ceOPreset1, 0};
CLU_proc ce_oe_reset_entries = {{0,0,0,0}, ceOPreset_entries, 0};
CLU_proc ce_oe_reset_types = {{0,0,0,0}, ceOPreset_types, 0};

ce_OPS ce_ops_actual = {31, (OWNPTR)&ce_own_init, (OWNPTR)&ce_own_init, {
    {&ce_oe_add_du, "add_du"},
    {&ce_oe_add_entry, "add_entry"},
    {&ce_oe_all_dus, "all_dus"},
    {&ce_oe_create, "create"},
    {&ce_oe_flush_entries, "flush_entries"},
    {&ce_oe_get_any_type, "get_any_type"},
    {&ce_oe_get_array_, "get_array_"},
    {&ce_oe_get_bool_type, "get_bool_type"},
    {&ce_oe_get_char_type, "get_char_type"},
    {&ce_oe_get_cvt_type, "get_cvt_type"},
    {&ce_oe_get_int_type, "get_int_type"},
    {&ce_oe_get_iter_, "get_iter_"},
    {&ce_oe_get_null_type, "get_null_type"},
    {&ce_oe_get_oneof_, "get_oneof_"},
    {&ce_oe_get_proc_, "get_proc_"},
    {&ce_oe_get_real_type, "get_real_type"},
    {&ce_oe_get_record_, "get_record_"},
    {&ce_oe_get_seq_, "get_seq_"},
    {&ce_oe_get_str_type, "get_str_type"},
    {&ce_oe_get_struct_, "get_struct_"},
    {&ce_oe_get_type, "get_type"},
    {&ce_oe_get_type_type, "get_type_type"},
    {&ce_oe_get_unknown_type, "get_unknown_type"},
    {&ce_oe_get_variant_, "get_variant_"},
    {&ce_oe_keep, "keep"},
    {&ce_oe_local, "local"},
    {&ce_oe_lookup, "lookup"},
    {&ce_oe_reset, "reset"},
    {&ce_oe_reset1, "reset1"},
    {&ce_oe_reset_entries, "reset_entries"},
    {&ce_oe_reset_types, "reset_types"}}};

struct OPS *ce_ops = (struct OPS *)&ce_ops_actual;

/**** END CLUSTER ce ****/

extern errcode sequenceOPelements();
extern errcode exprOPget_abs();
extern errcode intOPmod();

/**** BEGIN PROCEDURE hash_exprs ****/

errcode hash_exprs(exprs, z, ret_1)
CLUREF exprs;
CLUREF z;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF index;
    CLUREF x;
    CLUREF add;
    CLUREF xa;
    enter_proc(384);

  LINE(385);
    {
        {index.num = 0;
        }
        }

  LINE(386);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = exprs.vec->size; 
        T_1_3 = exprs;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            x.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(388);
            {
            CLUREF T_2_1;
            err = exprOPget_abs(x, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_1.cell->tag) {
            case 25: 
                 {CLUREF T_2_2;
                T_2_2.num = T_2_1.cell->value;
                xa.num = T_2_2.num;

  LINE(390);
                    {
                    CLUREF T_3_1;
                    err = typespecOPget_id(xa, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    add.num = T_3_1.num;
                    }
                    break;
                    }
            case 15: 
                 {CLUREF T_2_3;
                T_2_3.num = T_2_1.cell->value;
                xa.num = T_2_3.num;

  LINE(392);
                    {
                    add.num = xa.num;
                    }
                    break;
                    }
            case 24: 
                 {CLUREF T_2_4;
                T_2_4.num = T_2_1.cell->value;
                xa.num = T_2_4.num;

  LINE(394);
                    {
                    CLUREF T_3_1;
                    err = hash(xa, z, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    add.num = T_3_1.num;
                    }
                    break;
                    }
            default: {

  LINE(396);
                continue;
            }
            }
            }

  LINE(398);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = index.num + add.num;
             if ((T_2_1.num > 0 && index.num < 0 && add.num < 0) || 
                 (T_2_1.num < 0 && index.num > 0 && add.num > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            err = intOPmod(T_2_1, z, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            index.num = T_2_2.num;
            }
        }
    }
    end_inline_for_1:;

  LINE(400);
    {
    {
    ret_1->num = index.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE hash_exprs ****/


extern errcode hash_exprs();
extern errcode intOPmul();
extern errcode stringOPsize();
extern errcode sequenceOPindexes();
extern errcode sequenceOPfetch();
CLUREF STR_illegal_137typespec;
static int hash_typeabs_own_init = 0;

/**** BEGIN PROCEDURE hash_typeabs ****/

errcode hash_typeabs(ta, z, ret_1)
CLUREF ta;
CLUREF z;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF x;
    CLUREF index;
    CLUREF fs;
    CLUREF args;
    CLUREF vals;
    CLUREF i;
    CLUREF xx;
        if (hash_typeabs_own_init == 0) {
        stringOPcons("illegal_typespec", CLU_1, CLU_16, &STR_illegal_137typespec);
        hash_typeabs_own_init = 1;
    }
    enter_proc(403);

  LINE(404);
    {
    switch (ta.cell->tag) {
    case 3: 
         {CLUREF T_1_1;
        T_1_1.num = ta.cell->value;
        x.num = T_1_1.num;

  LINE(406);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            CLUREF T_2_6;
            CLUREF T_2_7;
            T_2_1.num = x.vec->data[1];
            err = hash_exprs(T_2_1, z, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            T_2_3.num = x.vec->data[0];
            err = duOPget_unique(T_2_3, &T_2_4);
            if (err != ERR_ok) goto ex_0;
            err = hash(T_2_4, z, &T_2_5);
            if (err != ERR_ok) goto ex_0;
            T_2_6.num = T_2_2.num + T_2_5.num;
             if ((T_2_6.num > 0 && T_2_2.num < 0 && T_2_5.num < 0) || 
                 (T_2_6.num < 0 && T_2_2.num > 0 && T_2_5.num > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            err = intOPmod(T_2_6, z, &T_2_7);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_7.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 7: 
         {CLUREF T_1_2;
        T_1_2.num = ta.cell->value;
        x.num = T_1_2.num;

  LINE(408);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                T_2_1.num = x.vec->data[0];
                err = duOPget_unique(T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                err = hash(T_2_2, z, &T_2_3);
                if (err != ERR_ok) goto ex_0;
                index.num = T_2_3.num;
                }
                }

  LINE(409);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = x.vec->data[1];
                T_2_3.num = T_2_1.vec->size; 
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    fs.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(410);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                    CLUREF T_3_5;
                    CLUREF T_3_6;
                    CLUREF T_3_7;
                    T_3_1.num = fs.vec->data[0];
                    err = stringOPsize(T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    T_3_3.num = fs.vec->data[1];
                    err = typespecOPget_id(T_3_3, &T_3_4);
                    if (err != ERR_ok) goto ex_0;
                    err = intOPmul(T_3_2, T_3_4, &T_3_5);
                    if (err != ERR_ok) goto ex_0;
                    T_3_6.num = index.num + T_3_5.num;
                     if ((T_3_6.num > 0 && index.num < 0 && T_3_5.num < 0) || 
                         (T_3_6.num < 0 && index.num > 0 && T_3_5.num > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    err = intOPmod(T_3_6, z, &T_3_7);
                    if (err != ERR_ok) goto ex_0;
                    index.num = T_3_7.num;
                    }
                }
            }
            end_inline_for_1:;

  LINE(412);
            {
            {
            ret_1->num = index.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 2: 
         {CLUREF T_1_3;
        T_1_3.num = ta.cell->value;
        x.num = T_1_3.num;

  LINE(414);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                T_2_1.num = x.vec->data[1];
                err = duOPget_unique(T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                err = hash(T_2_2, z, &T_2_3);
                if (err != ERR_ok) goto ex_0;
                index.num = T_2_3.num;
                }
                }

  LINE(415);
            {
                {CLUREF T_2_1;
                T_2_1.num = x.vec->data[0];
                args.num = T_2_1.num;
                }
                }

  LINE(416);
            {
                {CLUREF T_2_1;
                T_2_1.num = x.vec->data[3];
                vals.num = T_2_1.num;
                }
                }

  LINE(417);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
                T_2_2.num = args.vec->size; 
                for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                    i.num = T_2_1.num;

  LINE(418);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                    CLUREF T_3_5;
                    CLUREF T_3_6;
                    T_3_1.num = i.num + 1;
                     if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) || 
                         (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    if (i.num < 1 || i.num > args.vec->size ) {
                        err = ERR_bounds;
                        goto ex_0;}
                    T_3_2.num = args.vec->data[i.num - 1];
                    err = typespecOPget_id(T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    err = intOPmul(T_3_1, T_3_3, &T_3_4);
                    if (err != ERR_ok) goto ex_0;
                    T_3_5.num = index.num + T_3_4.num;
                     if ((T_3_5.num > 0 && index.num < 0 && T_3_4.num < 0) || 
                         (T_3_5.num < 0 && index.num > 0 && T_3_4.num > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    err = intOPmod(T_3_5, z, &T_3_6);
                    if (err != ERR_ok) goto ex_0;
                    index.num = T_3_6.num;
                    }
                }
            }
            end_inline_for_2:;

  LINE(420);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
                T_2_2.num = vals.vec->size; 
                for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                    i.num = T_2_1.num;

  LINE(421);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                    CLUREF T_3_5;
                    CLUREF T_3_6;
                    T_3_1.num = i.num + 4;
                     if ((T_3_1.num > 0 && i.num < 0 && 4 < 0) || 
                         (T_3_1.num < 0 && i.num > 0 && 4 > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    if (i.num < 1 || i.num > vals.vec->size ) {
                        err = ERR_bounds;
                        goto ex_0;}
                    T_3_2.num = vals.vec->data[i.num - 1];
                    err = typespecOPget_id(T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    err = intOPmul(T_3_1, T_3_3, &T_3_4);
                    if (err != ERR_ok) goto ex_0;
                    T_3_5.num = index.num + T_3_4.num;
                     if ((T_3_5.num > 0 && index.num < 0 && T_3_4.num < 0) || 
                         (T_3_5.num < 0 && index.num > 0 && T_3_4.num > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    err = intOPmod(T_3_5, z, &T_3_6);
                    if (err != ERR_ok) goto ex_0;
                    index.num = T_3_6.num;
                    }
                }
            }
            end_inline_for_3:;

  LINE(423);
            {
            {
            ret_1->num = index.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 5: 
         {CLUREF T_1_4;
        T_1_4.num = ta.cell->value;
        x.num = T_1_4.num;

  LINE(425);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = idnOPget_str(x, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = hash(T_2_1, z, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 6: 
         {CLUREF T_1_5;
        T_1_5.num = ta.cell->value;
        x.num = T_1_5.num;

  LINE(428);
            {
            switch (x.cell->tag) {
            case 1: 
                 {CLUREF T_2_1;
                T_2_1.num = x.cell->value;
                xx.num = T_2_1.num;

  LINE(430);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                    CLUREF T_3_5;
                    CLUREF T_3_6;
                    CLUREF T_3_7;
                    T_3_1.num = xx.vec->data[0];
                    err = duOPget_unique(T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    err = hash(T_3_2, z, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    T_3_4.num = 1 + T_3_3.num;
                     if ((T_3_4.num > 0 && 1 < 0 && T_3_3.num < 0) || 
                         (T_3_4.num < 0 && 1 > 0 && T_3_3.num > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    T_3_5.num = xx.vec->data[1];
                    err = hash_exprs(T_3_5, z, &T_3_6);
                    if (err != ERR_ok) goto ex_0;
                    T_3_7.num = T_3_4.num + T_3_6.num;
                     if ((T_3_7.num > 0 && T_3_4.num < 0 && T_3_6.num < 0) || 
                         (T_3_7.num < 0 && T_3_4.num > 0 && T_3_6.num > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    index.num = T_3_7.num;
                    }
                    break;
                    }
            case 2: 
                 {CLUREF T_2_2;
                T_2_2.num = x.cell->value;
                xx.num = T_2_2.num;

  LINE(432);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                    CLUREF T_3_5;
                    T_3_1.num = xx.vec->data[2];
                    err = typespecOPget_id(T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    T_3_3.num = xx.vec->data[0];
                    err = hash(T_3_3, z, &T_3_4);
                    if (err != ERR_ok) goto ex_0;
                    T_3_5.num = T_3_2.num + T_3_4.num;
                     if ((T_3_5.num > 0 && T_3_2.num < 0 && T_3_4.num < 0) || 
                         (T_3_5.num < 0 && T_3_2.num > 0 && T_3_4.num > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    index.num = T_3_5.num;
                    }
                    break;
                    }
            case 3: 
                 {CLUREF T_2_3;
                T_2_3.num = x.cell->value;
                xx.num = T_2_3.num;

  LINE(434);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = typespecOPget_id(xx, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    T_3_2.num = 1 + T_3_1.num;
                     if ((T_3_2.num > 0 && 1 < 0 && T_3_1.num < 0) || 
                         (T_3_2.num < 0 && 1 > 0 && T_3_1.num > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    index.num = T_3_2.num;
                    }
                    break;
                    }
            }
            }

  LINE(436);
            {
            {
            CLUREF T_2_1;
            err = intOPmod(index, z, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 9: 
         {

  LINE(438);
            {
            {
            ret_1->num = 0;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 8: 
         {

  LINE(440);
            {
            {
            ret_1->num = 1;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 4: 
         {

  LINE(442);
            {
            {
            ret_1->num = 2;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 1: 
         {

  LINE(444);
            {
            {
            ret_1->num = 3;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(446);
        {
        elist[0] = STR_illegal_137typespec;
        {signal (ERR_failure);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE hash_typeabs ****/



/**** BEGIN PROCEDURE hash_du ****/

errcode hash_du(d, size, ret_1)
CLUREF d;
CLUREF size;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    enter_proc(450);

  LINE(451);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = duOPget_unique(d, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = hash(T_1_1, size, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE hash_du ****/

