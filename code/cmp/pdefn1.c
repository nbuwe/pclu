
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


extern errcode p_envOPset_clustr();
extern errcode p_envOPset_applystr();
extern errcode p_envOPget_peek1();
extern errcode p_envOPnext_token();
extern errcode p_directive();
extern errcode boolOPnot();
extern errcode p_find_a_defn();
extern errcode p_envOPpeek();
extern errcode oneofOPmake_1();
extern errcode p_applydefn();
extern errcode oneofOPmake_3();
extern errcode p_typedefn();
extern errcode oneofOPmake_5();
extern errcode oneofOPmake_2();
extern errcode oneofOPmake_4();
extern errcode p_slist();
extern errcode p_equate();
extern struct REQS *p_slist_of_t_reqs;
extern struct OPS *equate_ops;
extern OWN_req p_slist_ownreqs;
struct OPS *p_slist_of_equate_table;
struct OPS *p_slist_of_equate_ops;
struct OPS *p_slist_of_equate_ops;
OWNPTR p_slist_of_equate_owns;
CLUREF STR_;
static int p_definition_own_init = 0;

/**** BEGIN PROCEDURE p_definition ****/

errcode p_definition(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF def;
    CLUREF k;
        if (p_definition_own_init == 0) {
        add_parm_info_type(0, equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        stringOPcons("", CLU_1, CLU_0, &STR_);
        p_definition_own_init = 1;
    }
    enter_proc(12);

  LINE(14);
    {
    err = p_envOPset_clustr(e, STR_);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(15);
    {
    err = p_envOPset_applystr(e, STR_);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(16);
    for (;;) {
        if (true != true) { break; }

  LINE(17);
        {
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 32: 
             {

  LINE(18);
                {
                CLUREF T_3_1;
                err = p_envOPnext_token(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(19);
                {
                {
                CLUREF T_4_1;
                err = p_directive(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                ret_1->num = T_4_1.num;
                }
                {signal (ERR_ok);}}
                    goto end_1;
                    ex_1:
                        if ((err == ERR_no_directive)) {
                        }
                        else {
                            goto ex_0;
                        }
                    end_1:;
                break;
                }
        default: {

  LINE(21);
            goto end_while_1;
        }
        }
        }
        }
        end_while_1:;

  LINE(24);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = p_find_a_defn(e, CLU_0, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(25);
        {
        {signal (ERR_eof);}}
        }
        }/* end if */

  LINE(27);
    {
    CLUREF T_1_1;
    err = p_envOPpeek(e, CLU_3, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 4: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(29);
            {
            switch (k.cell->tag) {
            case 4: 
                 {

  LINE(30);
                    {
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = p_applydefn(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    CellAlloc(1, T_3_1.num, T_3_2);
                    ret_1->num = T_3_2.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            case 3: 
                 {

  LINE(31);
                    {
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = p_applydefn(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    CellAlloc(1, T_3_1.num, T_3_2);
                    ret_1->num = T_3_2.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            case 2: 
                 {

  LINE(32);
                    {
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = p_typedefn(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    CellAlloc(3, T_3_1.num, T_3_2);
                    ret_1->num = T_3_2.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            case 5: 
                 {

  LINE(33);
                    {
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = p_typedefn(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    CellAlloc(5, T_3_1.num, T_3_2);
                    ret_1->num = T_3_2.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            case 1: 
                 {

  LINE(34);
                    {
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = p_typedefn(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    CellAlloc(2, T_3_1.num, T_3_2);
                    ret_1->num = T_3_2.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            }
            }
            break;
            }
    default: {

  LINE(37);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = proctypeOPnew(CLU_0, &T_2_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_2_1.proc->type_owns = 0;
        T_2_1.proc->op_owns = 0;
        T_2_1.proc->proc = p_equate;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_slist_of_equate_ops->op_owns;
        generic_CLU_proc.proc = p_slist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_slist(e, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        CellAlloc(4, T_2_2.num, T_2_3);
        ret_1->num = T_2_3.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_definition ****/


extern errcode stringOPequal();
extern errcode idnOPget_str();
extern errcode p_include();
extern errcode p_envOPhack();
extern errcode p_envOPunhack();
extern errcode p_envOPerr();
extern errcode oneofOPis_9();
extern errcode recordOPget_7();
extern errcode cmpvarOPstuffs();
extern errcode g_envOPforce_signal();
CLUREF STR_include;
CLUREF STR_extend;
CLUREF STR_normal;
CLUREF STR_unrecognized_040directive;
CLUREF STR_missing_040directive_040after_040_043;
static int p_directive_own_init = 0;

/**** BEGIN PROCEDURE p_directive ****/

errcode p_directive(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF dir;
    CLUREF k;
    CLUREF ge;
        if (p_directive_own_init == 0) {
        stringOPcons("include", CLU_1, CLU_7, &STR_include);
        stringOPcons("extend", CLU_1, CLU_6, &STR_extend);
        stringOPcons("normal", CLU_1, CLU_6, &STR_normal);
        stringOPcons("unrecognized directive", CLU_1, CLU_22, &STR_unrecognized_040directive);
        stringOPcons("missing directive after #", CLU_1, CLU_25, &STR_missing_040directive_040after_040_043);
        p_directive_own_init = 1;
    }
    enter_proc(44);

  LINE(45);
    {
    CLUREF T_2_1;
    err = p_envOPget_peek1(e, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    switch (T_2_1.cell->tag) {
    case 16: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        dir.num = T_2_2.num;

  LINE(47);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = idnOPget_str(dir, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            T_3_2.num = ((T_3_1.str->size != STR_include.str->size)? false :
                !(bcmp(T_3_1.str->data, STR_include.str->data, T_3_1.str->size)));
            if (T_3_2.num == true) {

  LINE(48);
                {
                CLUREF T_4_1;
                err = p_envOPnext_token(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                }

  LINE(49);
                {
                {
                CLUREF T_4_1;
                err = p_include(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                ret_1->num = T_4_1.num;
                }
                {signal (ERR_ok);}}
                }
            else {
            CLUREF T_3_3;
            CLUREF T_3_4;
            err = idnOPget_str(dir, &T_3_3);
            if (err != ERR_ok) goto ex_1;
            T_3_4.num = ((T_3_3.str->size != STR_extend.str->size)? false :
                !(bcmp(T_3_3.str->data, STR_extend.str->data, T_3_3.str->size)));
            if (T_3_4.num == true) {

  LINE(51);
                {
                err = p_envOPhack(e);
                if (err != ERR_ok) goto ex_1;
                }
                }
            else {
            CLUREF T_3_5;
            CLUREF T_3_6;
            err = idnOPget_str(dir, &T_3_5);
            if (err != ERR_ok) goto ex_1;
            T_3_6.num = ((T_3_5.str->size != STR_normal.str->size)? false :
                !(bcmp(T_3_5.str->data, STR_normal.str->data, T_3_5.str->size)));
            if (T_3_6.num == true) {

  LINE(53);
                {
                err = p_envOPunhack(e);
                if (err != ERR_ok) goto ex_1;
                }
                }
            else {

  LINE(54);
                {
                err = p_envOPerr(e, STR_unrecognized_040directive, CLU_2);
                if (err != ERR_ok) goto ex_1;
                }
                }}}}/* end if */

  LINE(55);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(56);
            {
            {signal (ERR_no_directive);}}
            break;
            }
    case 34: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        k.num = T_2_3.num;

  LINE(58);
            {
            CLUREF T_3_1;
            if (k.cell->tag == 9) T_3_1.num = true; else T_3_1.num = false;
            if (T_3_1.num == true) {

  LINE(59);
                {
                CLUREF T_4_1;
                err = p_envOPnext_token(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                }

  LINE(60);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                err = cmpvarOPstuffs(&T_4_1);
                if (err != ERR_ok) goto ex_1;
                T_4_2.num = T_4_1.vec->data[6];
                switch (T_4_2.cell->tag) {
                case 2: 
                     {CLUREF T_4_3;
                    T_4_3.num = T_4_2.cell->value;
                    ge.num = T_4_3.num;

  LINE(61);
                        {
                        err = g_envOPforce_signal(ge);
                        if (err != ERR_ok) goto ex_1;
                        }
                        break;
                        }
                default: {
                }
                }
                }

  LINE(64);
                {
                {signal (ERR_no_directive);}}
                }
                }/* end if */
            break;
            }
    default: {
    }
    }
    }
        goto end_1;
        ex_1:
            if ((err == ERR_include_failed)) {

  LINE(67);
                {
                {signal (ERR_no_directive);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(68);
    {
    err = p_envOPerr(e, STR_missing_040directive_040after_040_043, CLU_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(69);
    {
    {signal (ERR_no_directive);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_directive ****/


extern errcode oneofOPvalue_24();
extern errcode oneofOPvalue_13();
extern errcode recordOPget_8();
extern errcode file_nameOPparse();
extern errcode stringOPempty();
extern errcode file_nameOPget_dir();
extern errcode file_nameOPcreate();
extern errcode streamOPget_name();
extern errcode file_nameOPget_name();
extern errcode file_nameOPget_suffix();
extern errcode file_nameOPget_other();
extern errcode file_name_fill();
extern errcode equate_suffix();
extern errcode streamOPopen();
extern errcode check_file_name();
extern errcode recordOPset_8();
extern errcode p_envOPnew_env();
extern errcode streamOPclose();
extern errcode p_envOPset_err();
extern errcode p_envOPget_err();
extern errcode stringOPconcat();
struct OPS *p_slist_of_equate_table;
struct OPS *p_slist_of_equate_ops;
struct OPS *p_slist_of_equate_ops;
OWNPTR p_slist_of_equate_owns;
CLUREF STR_read;
CLUREF STR_more_040than_040equates_040in_040include_040file;
CLUREF STR_file_040name_040has_040bad_040format;
CLUREF STR_cannot_040open_040include_040file_072_040;
CLUREF STR_missing_040file_040name_040string_040after_040_043_040include;
static int p_include_own_init = 0;

/**** BEGIN PROCEDURE p_include ****/

errcode p_include(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
    CLUREF x;
    CLUREF ost;
    CLUREF fn;
    CLUREF inst;
    CLUREF e1;
    CLUREF def;
    CLUREF xx;
        if (p_include_own_init == 0) {
        add_parm_info_type(0, equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        stringOPcons("read", CLU_1, CLU_4, &STR_read);
        stringOPcons("more than equates in include file", CLU_1, CLU_33, &STR_more_040than_040equates_040in_040include_040file);
        stringOPcons("file name has bad format", CLU_1, CLU_24, &STR_file_040name_040has_040bad_040format);
        stringOPcons("cannot open include file: ", CLU_1, CLU_26, &STR_cannot_040open_040include_040file_072_040);
        stringOPcons("missing file name string after # include", CLU_1, CLU_40, &STR_missing_040file_040name_040string_040after_040_043_040include);
        p_include_own_init = 1;
    }
    enter_proc(72);

  LINE(73);
    {

  LINE(74);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = p_envOPget_peek1(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            if (T_3_1.cell->tag != 13) {err = ERR_wrong_tag; goto ex_1;}
            T_3_2.num = T_3_1.cell->value;
            if (T_3_2.cell->tag != 24) {err = ERR_wrong_tag; goto ex_1;}
            T_3_3.num = T_3_2.cell->value;
            s.num = T_3_3.num;
            }
            }

  LINE(75);
        {
        CLUREF T_3_1;
        err = p_envOPnext_token(e, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(76);
        {
            {CLUREF T_3_1;
            err = cmpvarOPstuffs(&T_3_1);
            if (err != ERR_ok) goto ex_1;
            x.num = T_3_1.num;
            }
            }

  LINE(77);
        {
            {CLUREF T_3_1;
            T_3_1.num = x.vec->data[7];
            ost.num = T_3_1.num;
            }
            }

  LINE(78);
        {
            {CLUREF T_3_1;
            err = file_nameOPparse(s, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            fn.num = T_3_1.num;
            }
            }

  LINE(79);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = file_nameOPget_dir(fn, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        err = stringOPempty(T_3_1, &T_3_2);
        if (err != ERR_ok) goto ex_1;
        if (T_3_2.num == true) {

  LINE(80);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            CLUREF T_4_6;
            err = streamOPget_name(ost, &T_4_1);
            if (err != ERR_ok) goto ex_1;
            err = file_nameOPget_dir(T_4_1, &T_4_2);
            if (err != ERR_ok) goto ex_1;
            err = file_nameOPget_name(fn, &T_4_3);
            if (err != ERR_ok) goto ex_1;
            err = file_nameOPget_suffix(fn, &T_4_4);
            if (err != ERR_ok) goto ex_1;
            err = file_nameOPget_other(fn, &T_4_5);
            if (err != ERR_ok) goto ex_1;
            err = file_nameOPcreate(T_4_2, T_4_3, T_4_4, T_4_5, &T_4_6);
            if (err != ERR_ok) goto ex_1;
            fn.num = T_4_6.num;
            }
            }
            }/* end if */

  LINE(82);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = equate_suffix(&T_3_1);
        if (err != ERR_ok) goto ex_1;
        err = file_name_fill(fn, T_3_1, &T_3_2);
        if (err != ERR_ok) goto ex_1;
        fn.num = T_3_2.num;
        }

  LINE(83);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            err = check_file_name(fn, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            err = streamOPopen(T_3_1, STR_read, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            inst.num = T_3_2.num;
            }
            }

  LINE(84);
        {
        x.vec->data[7]  = inst.num;
        }

  LINE(85);
        {
            {CLUREF T_3_1;
            err = p_envOPnew_env(e, inst, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            e1.num = T_3_1.num;
            }
            }

  LINE(86);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = proctypeOPnew(CLU_0, &T_3_1.proc);
            if (err!= ERR_ok) goto ex_1;
            T_3_1.proc->type_owns = 0;
            T_3_1.proc->op_owns = 0;
            T_3_1.proc->proc = p_equate;
            generic_CLU_proc.type_owns = 0;
            generic_CLU_proc.op_owns = (long)p_slist_of_equate_ops->op_owns;
            generic_CLU_proc.proc = p_slist;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = p_slist(e1, T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            CellAlloc(4, T_3_2.num, T_3_3);
            def.num = T_3_3.num;
            }
            }

  LINE(88);
        {
        CLUREF T_3_1;
        err = p_envOPget_peek1(e1, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        switch (T_3_1.cell->tag) {
        case 10: 
             {
                break;
                }
        default: {

  LINE(90);
            {
            err = p_envOPerr(e1, STR_more_040than_040equates_040in_040include_040file, CLU_1);
            if (err != ERR_ok) goto ex_1;
            }
        }
        }
        }

  LINE(92);
        {
        err = streamOPclose(inst);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(93);
        {
        x.vec->data[7]  = ost.num;
        }

  LINE(94);
        {
        CLUREF T_3_1;
        err = p_envOPget_err(e1, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        err = p_envOPset_err(e, T_3_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(95);
        {
        {
        ret_1->num = def.num;
        }
        {signal (ERR_ok);}}
        }
        goto end_1;
        ex_1:
            if ((err == ERR_bad_format)) {

  LINE(98);
                {
                err = p_envOPerr(e, STR_file_040name_040has_040bad_040format, CLU_2);
                if (err != ERR_ok) goto ex_0;
                }
            }
            else if ((err == ERR_not_possible)) {
            CLUREF xx;
            xx.num = elist[0].num;

  LINE(100);
                {
                CLUREF T_2_1;
                err = stringOPconcat(STR_cannot_040open_040include_040file_072_040, xx, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                err = p_envOPerr(e, T_2_1, CLU_2);
                if (err != ERR_ok) goto ex_0;
                }
            }
            else if ((err == ERR_wrong_tag)) {

  LINE(102);
                {
                err = p_envOPerr(e, STR_missing_040file_040name_040string_040after_040_043_040include, CLU_2);
                if (err != ERR_ok) goto ex_0;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(105);
    {
    {signal (ERR_include_failed);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_include ****/


extern errcode p_idn();
extern errcode p_envOPget_line();
extern errcode oneofOPvalue_4();
extern errcode p_blist();
extern errcode p_decl();
extern errcode p_plist();
extern errcode p_values();
extern errcode p_signals();
extern errcode p_where();
extern errcode p_envOPset_deftype();
extern errcode sequenceOPempty();
extern errcode p_semi();
extern errcode p_envOPbegin_body();
extern errcode p_init();
extern errcode p_stmt();
extern errcode p_envOPend_body();
extern errcode p_defn_end();
extern errcode p_envOPget_unknown_type();
extern errcode arrayOPpredict();
extern struct REQS *sequence_of_t_reqs;
extern struct OPS *idn_ops;
extern OWN_req sequence_ownreqs;
extern struct OPS *sequence_ops;
struct OPS *sequence_of_idn_table;
struct OPS *sequence_of_idn_ops;
struct OPS *sequence_of_idn_ops;
OWNPTR sequence_of_idn_owns;
extern struct OPS *sequence_of_idn_ops;
extern struct OPS *typespec_ops;
struct OPS  *record_idns_type__ops;
extern struct REQS *p_blist_of_t_reqs;
extern struct OPS *record_idns_type__ops;
extern OWN_req p_blist_ownreqs;
struct OPS *p_blist_of_record_idns_type__table;
struct OPS *p_blist_of_record_idns_type__ops;
struct OPS *p_blist_of_record_idns_type__ops;
OWNPTR p_blist_of_record_idns_type__owns;
extern struct REQS *p_plist_of_t_reqs;
extern OWN_req p_plist_ownreqs;
struct OPS *p_plist_of_record_idns_type__table;
struct OPS *p_plist_of_record_idns_type__ops;
struct OPS *p_plist_of_record_idns_type__ops;
OWNPTR p_plist_of_record_idns_type__owns;
struct OPS *p_slist_of_equate_table;
struct OPS *p_slist_of_equate_ops;
struct OPS *p_slist_of_equate_ops;
OWNPTR p_slist_of_equate_owns;
struct OPS *sequence_of_record_idns_type__table;
struct OPS *sequence_of_record_idns_type__ops;
struct OPS *sequence_of_record_idns_type__ops;
OWNPTR sequence_of_record_idns_type__owns;
extern struct OPS *sequence_of_record_idns_type__ops;
extern struct OPS *expr_ops;
struct OPS  *record_anys_decls_expr_ops;
extern struct OPS *record_anys_decls_expr_ops;
struct OPS  *oneof_decl_init_ops;
extern struct OPS *int_ops;
extern struct OPS *oneof_decl_init_ops;
struct OPS  *record_line_stmt_ops;
extern struct OPS *record_line_stmt_ops;
struct OPS *p_slist_of_record_line_stmt_table;
struct OPS *p_slist_of_record_line_stmt_ops;
struct OPS *p_slist_of_record_line_stmt_ops;
OWNPTR p_slist_of_record_line_stmt_owns;
extern struct OPS *stmt_ops;
struct OPS *p_slist_of_stmt_table;
struct OPS *p_slist_of_stmt_ops;
struct OPS *p_slist_of_stmt_ops;
OWNPTR p_slist_of_stmt_owns;
CLUREF STR_parameter;
CLUREF STR_argument;
static int p_applydefn_own_init = 0;

/**** BEGIN PROCEDURE p_applydefn ****/

errcode p_applydefn(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF id;
    CLUREF line;
    CLUREF gen;
    CLUREF procdef;
    CLUREF d;
    CLUREF parms;
    CLUREF args;
    CLUREF vals;
    CLUREF sigs;
    CLUREF wher;
    CLUREF eqs;
    CLUREF inits;
    CLUREF bod;
        if (p_applydefn_own_init == 0) {
        add_parm_info_type(0, idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, sequence_of_idn_ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_parm_info_type(0, record_idns_type__ops, p_blist_of_t_reqs);
        find_prociter_instance(p_blist, 1, &p_blist_ownreqs, &(p_blist_of_record_idns_type__ops));
        add_parm_info_type(0, record_idns_type__ops, p_plist_of_t_reqs);
        find_prociter_instance(p_plist, 1, &p_plist_ownreqs, &(p_plist_of_record_idns_type__ops));
        add_parm_info_type(0, equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        add_parm_info_type(0, record_idns_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_idns_type__ops));
        add_selector_info("anys", 0, sequence_of_record_idns_type__ops); 
        add_selector_info("decls", 1, sequence_of_record_idns_type__ops); 
        add_selector_info("expr", 2, expr_ops); 
        find_selector_ops("record", 3, &(record_anys_decls_expr_ops));
        add_selector_info("decl", 0, record_idns_type__ops); 
        add_selector_info("init", 1, record_anys_decls_expr_ops); 
        find_selector_ops("oneof", 2, &(oneof_decl_init_ops));
        add_selector_info("line", 0, int_ops); 
        add_selector_info("stmt", 1, oneof_decl_init_ops); 
        find_selector_ops("record", 2, &(record_line_stmt_ops));
        add_parm_info_type(0, record_line_stmt_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_record_line_stmt_ops));
        add_parm_info_type(0, stmt_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_stmt_ops));
        stringOPcons("parameter", CLU_1, CLU_9, &STR_parameter);
        stringOPcons("argument", CLU_1, CLU_8, &STR_argument);
        p_applydefn_own_init = 1;
    }
    enter_proc(111);

  LINE(112);
    {
        {CLUREF T_1_1;
        err = p_idn(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        id.num = T_1_1.num;
        }
        }

  LINE(113);
    {
        {CLUREF T_1_1;
        err = p_envOPget_line(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        line.num = T_1_1.num;
        }
        }

  LINE(114);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(117);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.cell->tag != 4) {err = ERR_wrong_tag; goto ex_0;}
    T_1_2.num = T_1_1.cell->value;
    switch (T_1_2.cell->tag) {
    case 4: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_2.cell->value;
        d.num = T_1_3.num;

  LINE(119);
            {
            gen.num = d.num;
            }

  LINE(120);
            {
            procdef.tf = true;
            }
            break;
            }
    case 3: 
         {CLUREF T_1_4;
        T_1_4.num = T_1_2.cell->value;
        d.num = T_1_4.num;

  LINE(122);
            {
            gen.num = d.num;
            }

  LINE(123);
            {
            procdef.tf = false;
            }
            break;
            }
    default: {
    }
    }
    }

  LINE(126);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_decl;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_blist_of_record_idns_type__ops->op_owns;
        generic_CLU_proc.proc = p_blist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_blist(e, T_1_1, CLU_1, STR_parameter, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        parms.num = T_1_2.num;
        }
        }

  LINE(127);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_decl;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_plist_of_record_idns_type__ops->op_owns;
        generic_CLU_proc.proc = p_plist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_plist(e, T_1_1, CLU_0, CLU_1, STR_argument, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        args.num = T_1_2.num;
        }
        }

  LINE(129);
    {
        {CLUREF T_1_1;
        err = p_values(e, procdef, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        vals.num = T_1_1.num;
        }
        }

  LINE(130);
    {
        {CLUREF T_1_1;
        err = p_signals(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        sigs.num = T_1_1.num;
        }
        }

  LINE(131);
    {
        {CLUREF T_1_1;
        err = p_where(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        wher.num = T_1_1.num;
        }
        }

  LINE(132);
    {
    CLUREF T_1_1;
    err = idnOPget_str(id, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = p_envOPset_applystr(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(133);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = sequenceOPempty(vals, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = T_1_1.num ^ 1;
    err = p_envOPset_deftype(e, gen, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(134);
    {
    err = p_semi(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(135);
    {
    err = p_envOPbegin_body(e, CLU_3);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(136);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_equate;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_slist_of_equate_ops->op_owns;
        generic_CLU_proc.proc = p_slist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_slist(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        eqs.num = T_1_2.num;
        }
        }

  LINE(137);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_init;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_slist_of_record_line_stmt_ops->op_owns;
        generic_CLU_proc.proc = p_slist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_slist(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        inits.num = T_1_2.num;
        }
        }

  LINE(138);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_stmt;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_slist_of_stmt_ops->op_owns;
        generic_CLU_proc.proc = p_slist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_slist(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        bod.num = T_1_2.num;
        }
        }

  LINE(139);
    {
    err = p_envOPend_body(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(140);
    {
    CLUREF T_1_1;
    err = idnOPget_str(id, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = p_defn_end(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(141);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(13, T_1_1);
    T_1_1.vec->data[4]  = id.num;
    T_1_1.vec->data[3]  = gen.num;
    err = p_envOPget_unknown_type(e, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[9]  = T_1_2.num;
    T_1_1.vec->data[7]  = parms.num;
    T_1_1.vec->data[0]  = args.num;
    T_1_1.vec->data[10]  = vals.num;
    T_1_1.vec->data[8]  = sigs.num;
    T_1_1.vec->data[12]  = wher.num;
    T_1_1.vec->data[2]  = eqs.num;
    T_1_1.vec->data[5]  = inits.num;
    err = arrayOPpredict(CLU_1, CLU_10, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[11]  = T_1_3.num;
    T_1_1.vec->data[1]  = bod.num;
    T_1_1.vec->data[6]  = line.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_applydefn ****/


extern errcode p_order();
extern errcode p_idn1();
extern errcode p_envOPassume();
extern errcode sequenceOPnew();
extern errcode p_list();
extern errcode p_operdefn();
extern errcode sequenceOPelements();
extern errcode recordOPget_5();
extern errcode recordOPget_11();
extern errcode recordOPget_9();
extern errcode intOPequal();
extern errcode sequenceOPsize();
extern errcode recordOPget_1();
extern errcode sequenceOPfetch();
extern errcode typespecOPget_abs();
extern errcode recordOPget_2();
extern errcode recordOPget_13();
extern errcode streamOPcreate_input();
extern errcode p_envOPpush();
extern errcode p_envOPpop();
extern errcode sequenceOPconcat();
struct OPS *sequence_of_idn_table;
struct OPS *sequence_of_idn_ops;
struct OPS *sequence_of_idn_ops;
OWNPTR sequence_of_idn_owns;
struct OPS  *record_idns_type__ops;
struct OPS *p_blist_of_record_idns_type__table;
struct OPS *p_blist_of_record_idns_type__ops;
struct OPS *p_blist_of_record_idns_type__ops;
OWNPTR p_blist_of_record_idns_type__owns;
extern struct REQS *p_order_of_t_reqs;
extern OWN_req p_order_ownreqs;
struct OPS *p_order_of_idn_table;
struct OPS *p_order_of_idn_ops;
struct OPS *p_order_of_idn_ops;
OWNPTR p_order_of_idn_owns;
struct OPS *p_slist_of_equate_table;
struct OPS *p_slist_of_equate_ops;
struct OPS *p_slist_of_equate_ops;
OWNPTR p_slist_of_equate_owns;
struct OPS *sequence_of_record_idns_type__table;
struct OPS *sequence_of_record_idns_type__ops;
struct OPS *sequence_of_record_idns_type__ops;
OWNPTR sequence_of_record_idns_type__owns;
struct OPS  *record_anys_decls_expr_ops;
struct OPS  *oneof_decl_init_ops;
struct OPS  *record_line_stmt_ops;
struct OPS *p_slist_of_record_line_stmt_table;
struct OPS *p_slist_of_record_line_stmt_ops;
struct OPS *p_slist_of_record_line_stmt_ops;
OWNPTR p_slist_of_record_line_stmt_owns;
struct OPS *sequence_of_stmt_table;
struct OPS *sequence_of_stmt_ops;
struct OPS *sequence_of_stmt_ops;
OWNPTR sequence_of_stmt_owns;
struct OPS *sequence_of_equate_table;
struct OPS *sequence_of_equate_ops;
struct OPS *sequence_of_equate_ops;
OWNPTR sequence_of_equate_owns;
struct OPS *sequence_of_record_line_stmt_table;
struct OPS *sequence_of_record_line_stmt_ops;
struct OPS *sequence_of_record_line_stmt_ops;
OWNPTR sequence_of_record_line_stmt_owns;
struct OPS *sequence_of_typespec_table;
struct OPS *sequence_of_typespec_ops;
struct OPS *sequence_of_typespec_ops;
OWNPTR sequence_of_typespec_owns;
extern struct OPS *string_ops;
extern struct OPS *sequence_of_typespec_ops;
struct OPS  *record_name_types_ops;
extern struct OPS *record_name_types_ops;
struct OPS *sequence_of_record_name_types_table;
struct OPS *sequence_of_record_name_types_ops;
struct OPS *sequence_of_record_name_types_ops;
OWNPTR sequence_of_record_name_types_owns;
extern struct REQS *array_of_t_reqs;
extern OWN_req array_ownreqs;
extern struct OPS *array_ops;
struct OPS *array_of_idn_table;
struct OPS *array_of_idn_ops;
struct OPS *array_of_idn_ops;
OWNPTR array_of_idn_owns;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
extern struct OPS *sequence_of_expr_ops;
struct OPS  *record_name_parms_type__ops;
extern struct OPS *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
extern struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS  *record_line_opers_ops;
extern struct OPS *record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_table;
struct OPS *sequence_of_record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_ops;
OWNPTR sequence_of_record_line_opers_owns;
extern struct OPS *sequence_of_equate_ops;
extern struct OPS *sequence_of_record_line_opers_ops;
struct OPS  *record_equates_idn_ops_ops;
extern struct OPS *record_equates_idn_ops_ops;
struct OPS  *oneof_has__idn_set_ops;
extern struct OPS *oneof_has__idn_set_ops;
struct OPS  *record_idn_kind_line_ops;
extern struct OPS *record_idn_kind_line_ops;
struct OPS *sequence_of_record_idn_kind_line_table;
struct OPS *sequence_of_record_idn_kind_line_ops;
struct OPS *sequence_of_record_idn_kind_line_ops;
OWNPTR sequence_of_record_idn_kind_line_owns;
extern struct OPS *sequence_of_stmt_ops;
extern struct OPS *du_ops;
extern struct OPS *sequence_of_record_line_stmt_ops;
extern struct OPS *sequence_of_record_name_types_ops;
extern struct OPS *array_of_idn_ops;
extern struct OPS *sequence_of_record_idn_kind_line_ops;
struct OPS  *record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops;
extern struct REQS *p_list_of_t_reqs;
extern struct OPS *record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops;
extern OWN_req p_list_ownreqs;
struct OPS *p_list_of_record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__table;
struct OPS *p_list_of_record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops;
struct OPS *p_list_of_record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops;
OWNPTR p_list_of_record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__owns;
CLUREF STR_idn;
CLUREF STR_IS_040idn_137list_040in_040module_040header;
CLUREF STR_operation;
CLUREF STR_print;
CLUREF STR_pstream;
CLUREF STR_where_040;
CLUREF STR__040has_040print_072_040proctype_050;
CLUREF STR__054_040pstream_051_012;
CLUREF STR_debug_137print_040_075_040proc_050_137rep_072_040cvt_054_040ps_072_040pstream_051_012;
CLUREF STR__040print_050up_050_137rep_051_054_040ps_051_012;
CLUREF STR__040end_040debug_137print_012;
CLUREF STR_debug_137print_040_075_040proc_050_137rep_072_040cvt_054_040ps_072_040pstream_051_012_040rep_044debug_137print_050_137rep_054_040ps_051_012_040end_040debug_137print_012;
static int p_typedefn_own_init = 0;

/**** BEGIN PROCEDURE p_typedefn ****/

errcode p_typedefn(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF id;
    CLUREF line;
    CLUREF parms;
    CLUREF ops;
    CLUREF wher;
    CLUREF equates;
    CLUREF inits;
    CLUREF bod;
    CLUREF found;
    CLUREF form;
    CLUREF wh;
    CLUREF each;
    CLUREF arg1;
    CLUREF arg2;
    CLUREF i;
    CLUREF x;
    CLUREF apstr;
    CLUREF wclause;
    CLUREF each_r;
    CLUREF newst;
    CLUREF new;
        if (p_typedefn_own_init == 0) {
        add_parm_info_type(0, idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, sequence_of_idn_ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_parm_info_type(0, record_idns_type__ops, p_blist_of_t_reqs);
        find_prociter_instance(p_blist, 1, &p_blist_ownreqs, &(p_blist_of_record_idns_type__ops));
        add_parm_info_type(0, idn_ops, p_order_of_t_reqs);
        find_prociter_instance(p_order, 1, &p_order_ownreqs, &(p_order_of_idn_ops));
        add_parm_info_type(0, equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        add_parm_info_type(0, record_idns_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_idns_type__ops));
        add_selector_info("anys", 0, sequence_of_record_idns_type__ops); 
        add_selector_info("decls", 1, sequence_of_record_idns_type__ops); 
        add_selector_info("expr", 2, expr_ops); 
        find_selector_ops("record", 3, &(record_anys_decls_expr_ops));
        add_selector_info("decl", 0, record_idns_type__ops); 
        add_selector_info("init", 1, record_anys_decls_expr_ops); 
        find_selector_ops("oneof", 2, &(oneof_decl_init_ops));
        add_selector_info("line", 0, int_ops); 
        add_selector_info("stmt", 1, oneof_decl_init_ops); 
        find_selector_ops("record", 2, &(record_line_stmt_ops));
        add_parm_info_type(0, record_line_stmt_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_record_line_stmt_ops));
        add_parm_info_type(0, stmt_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_stmt_ops));
        add_parm_info_type(0, equate_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_equate_ops));
        add_parm_info_type(0, record_line_stmt_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_line_stmt_ops));
        add_parm_info_type(0, typespec_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_typespec_ops));
        add_selector_info("name", 0, string_ops); 
        add_selector_info("types", 1, sequence_of_typespec_ops); 
        find_selector_ops("record", 2, &(record_name_types_ops));
        add_parm_info_type(0, record_name_types_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_name_types_ops));
        add_parm_info_type(0, idn_ops, array_of_t_reqs);
        find_type_instance(array_ops, 1, &array_ownreqs, &(array_of_idn_ops));
        add_parm_info_type(0, expr_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_expr_ops));
        add_selector_info("name", 0, string_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        add_selector_info("type_", 2, typespec_ops); 
        find_selector_ops("record", 3, &(record_name_parms_type__ops));
        add_parm_info_type(0, record_name_parms_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_name_parms_type__ops));
        add_selector_info("line", 0, int_ops); 
        add_selector_info("opers", 1, sequence_of_record_name_parms_type__ops); 
        find_selector_ops("record", 2, &(record_line_opers_ops));
        add_parm_info_type(0, record_line_opers_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_line_opers_ops));
        add_selector_info("equates", 0, sequence_of_equate_ops); 
        add_selector_info("idn", 1, idn_ops); 
        add_selector_info("ops", 2, sequence_of_record_line_opers_ops); 
        find_selector_ops("record", 3, &(record_equates_idn_ops_ops));
        add_selector_info("has_", 0, sequence_of_record_line_opers_ops); 
        add_selector_info("idn", 1, idn_ops); 
        add_selector_info("set", 2, record_equates_idn_ops_ops); 
        find_selector_ops("oneof", 3, &(oneof_has__idn_set_ops));
        add_selector_info("idn", 0, idn_ops); 
        add_selector_info("kind", 1, oneof_has__idn_set_ops); 
        add_selector_info("line", 2, int_ops); 
        find_selector_ops("record", 3, &(record_idn_kind_line_ops));
        add_parm_info_type(0, record_idn_kind_line_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_idn_kind_line_ops));
        add_selector_info("args", 0, sequence_of_record_idns_type__ops); 
        add_selector_info("body", 1, sequence_of_stmt_ops); 
        add_selector_info("equates", 2, sequence_of_equate_ops); 
        add_selector_info("gen", 3, du_ops); 
        add_selector_info("idn", 4, idn_ops); 
        add_selector_info("init", 5, sequence_of_record_line_stmt_ops); 
        add_selector_info("line", 6, int_ops); 
        add_selector_info("parms", 7, sequence_of_record_idns_type__ops); 
        add_selector_info("sigs", 8, sequence_of_record_name_types_ops); 
        add_selector_info("type_", 9, typespec_ops); 
        add_selector_info("vals", 10, sequence_of_typespec_ops); 
        add_selector_info("vars", 11, array_of_idn_ops); 
        add_selector_info("where_", 12, sequence_of_record_idn_kind_line_ops); 
        find_selector_ops("record", 13, &(record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops));
        add_parm_info_type(0, record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops, p_list_of_t_reqs);
        find_prociter_instance(p_list, 1, &p_list_ownreqs, &(p_list_of_record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops));
        stringOPcons("parameter", CLU_1, CLU_9, &STR_parameter);
        stringOPcons("idn", CLU_1, CLU_3, &STR_idn);
        stringOPcons("IS idn_list in module header", CLU_1, CLU_28, &STR_IS_040idn_137list_040in_040module_040header);
        stringOPcons("operation", CLU_1, CLU_9, &STR_operation);
        stringOPcons("print", CLU_1, CLU_5, &STR_print);
        stringOPcons("pstream", CLU_1, CLU_7, &STR_pstream);
        stringOPcons("", CLU_1, CLU_0, &STR_);
        stringOPcons("where ", CLU_1, CLU_6, &STR_where_040);
        stringOPcons(" has print: proctype(", CLU_1, CLU_21, &STR__040has_040print_072_040proctype_050);
        stringOPcons(", pstream)\n", CLU_1, CLU_11, &STR__054_040pstream_051_012);
        stringOPcons("debug_print = proc(_rep: cvt, ps: pstream)\n", CLU_1, CLU_43, &STR_debug_137print_040_075_040proc_050_137rep_072_040cvt_054_040ps_072_040pstream_051_012);
        stringOPcons(" print(up(_rep), ps)\n", CLU_1, CLU_21, &STR__040print_050up_050_137rep_051_054_040ps_051_012);
        stringOPcons(" end debug_print\n", CLU_1, CLU_17, &STR__040end_040debug_137print_012);
        CLU_string_size.num = 87;
        stringOPcons("debug_print = proc(_rep: cvt, ps: pstream)\n rep$debug_print(_rep, ps)\n end debug_print\n", CLU_1, CLU_string_size, &STR_debug_137print_040_075_040proc_050_137rep_072_040cvt_054_040ps_072_040pstream_051_012_040rep_044debug_137print_050_137rep_054_040ps_051_012_040end_040debug_137print_012);
        p_typedefn_own_init = 1;
    }
    enter_proc(160);

  LINE(162);
    {
        {CLUREF T_1_1;
        err = p_idn(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        id.num = T_1_1.num;
        }
        }

  LINE(163);
    {
        {CLUREF T_1_1;
        err = p_envOPget_line(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        line.num = T_1_1.num;
        }
        }

  LINE(164);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(165);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(166);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_decl;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_blist_of_record_idns_type__ops->op_owns;
        generic_CLU_proc.proc = p_blist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_blist(e, T_1_1, CLU_1, STR_parameter, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        parms.num = T_1_2.num;
        }
        }

  LINE(168);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 18: 
         {

  LINE(169);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(170);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            err = proctypeOPnew(CLU_0, &T_2_1.proc);
            if (err!= ERR_ok) goto ex_0;
            T_2_1.proc->type_owns = 0;
            T_2_1.proc->op_owns = 0;
            T_2_1.proc->proc = p_idn1;
            err = proctypeOPnew(CLU_0, &T_2_2.proc);
            if (err!= ERR_ok) goto ex_0;
            T_2_2.proc->proc = idnOPget_str;
            generic_CLU_proc.type_owns = 0;
            generic_CLU_proc.op_owns = (long)p_order_of_idn_ops->op_owns;
            generic_CLU_proc.proc = p_order;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = p_order(e, T_2_1, T_2_2, STR_idn, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            ops.num = T_2_3.num;
            }
            break;
            }
    default: {

  LINE(171);
        {
        err = p_envOPassume(e, STR_IS_040idn_137list_040in_040module_040header);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(172);
        {
        CLUREF T_2_1;
        err = sequenceOPnew(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        ops.num = T_2_1.num;
        }
    }
    }
    }

  LINE(174);
    {
        {CLUREF T_1_1;
        err = p_where(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        wher.num = T_1_1.num;
        }
        }

  LINE(175);
    {
    err = p_semi(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(176);
    {
    CLUREF T_1_1;
    err = idnOPget_str(id, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = p_envOPset_clustr(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(177);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_equate;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_slist_of_equate_ops->op_owns;
        generic_CLU_proc.proc = p_slist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_slist(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        equates.num = T_1_2.num;
        }
        }

  LINE(178);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_init;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_slist_of_record_line_stmt_ops->op_owns;
        generic_CLU_proc.proc = p_slist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_slist(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        inits.num = T_1_2.num;
        }
        }

  LINE(179);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_operdefn;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_list_of_record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops->op_owns;
        generic_CLU_proc.proc = p_list;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_list(e, T_1_1, CLU_0, STR_operation, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        bod.num = T_1_2.num;
        }
        }

  LINE(184);
    {
        {found.tf = false;
        }
        }

  LINE(186);
    {
        {CLUREF T_1_1;
        err = sequenceOPnew(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        wh.num = T_1_1.num;
        }
        }

  LINE(190);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = bod.vec->size; 
        T_1_3 = bod;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            each.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(191);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            T_2_1.num = each.vec->data[4];
            err = idnOPget_str(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            T_2_3.num = ((T_2_2.str->size != STR_print.str->size)? false :
                !(bcmp(T_2_2.str->data, STR_print.str->data, T_2_2.str->size)));
            if (T_2_3.num == true) {

  LINE(192);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CLUREF T_3_4;
                CLUREF T_3_5;
                CLUREF T_3_6;
                CLUREF T_3_7;
                CLUREF T_3_8;
                CLUREF T_3_9;
                CLUREF T_3_10;
                CLUREF T_3_11;
                CLUREF T_3_12;
                T_3_4.num = each.vec->data[7];
                err = sequenceOPempty(T_3_4, &T_3_5);
                if (err != ERR_ok) goto ex_0;
                T_3_3.num = T_3_5.num;
                if (T_3_5.num) {
                    T_3_6.num = each.vec->data[10];
                    err = sequenceOPempty(T_3_6, &T_3_7);
                    if (err != ERR_ok) goto ex_0;
                    T_3_3.num = T_3_7.num;
                }
                T_3_2.num = T_3_3.num;
                if (T_3_3.num) {
                    T_3_8.num = each.vec->data[8];
                    err = sequenceOPempty(T_3_8, &T_3_9);
                    if (err != ERR_ok) goto ex_0;
                    T_3_2.num = T_3_9.num;
                }
                T_3_1.num = T_3_2.num;
                if (T_3_2.num) {
                    T_3_10.num = each.vec->data[0];
                    T_3_11.num = T_3_10.vec->size;
                    T_3_12.num = (T_3_11.num == 2)? true : false;
                    T_3_1.num = T_3_12.num;
                }
                if (T_3_1.num == true) {

  LINE(196);
                    {
                        {CLUREF T_4_1;
                        CLUREF T_4_2;
                        T_4_1.num = each.vec->data[0];
                        if (1 < 1 || 1 > T_4_1.vec->size ) {
                            err = ERR_bounds;
                            goto ex_0;}
                        T_4_2.num = T_4_1.vec->data[1 - 1];
                        arg1.num = T_4_2.num;
                        }
                        }

  LINE(197);
                    {
                        {CLUREF T_4_1;
                        CLUREF T_4_2;
                        T_4_1.num = each.vec->data[0];
                        if (2 < 1 || 2 > T_4_1.vec->size ) {
                            err = ERR_bounds;
                            goto ex_0;}
                        T_4_2.num = T_4_1.vec->data[2 - 1];
                        arg2.num = T_4_2.num;
                        }
                        }

  LINE(198);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    CLUREF T_4_3;
                    CLUREF T_4_4;
                    CLUREF T_4_5;
                    CLUREF T_4_6;
                    CLUREF T_4_7;
                    T_4_2.num = arg1.vec->data[0];
                    T_4_3.num = T_4_2.vec->size;
                    T_4_4.num = (T_4_3.num == 1)? true : false;
                    T_4_1.num = T_4_4.num;
                    if (T_4_4.num) {
                        T_4_5.num = arg2.vec->data[0];
                        T_4_6.num = T_4_5.vec->size;
                        T_4_7.num = (T_4_6.num == 1)? true : false;
                        T_4_1.num = T_4_7.num;
                    }
                    if (T_4_1.num == true) {

  LINE(200);
                        {
                        CLUREF T_5_1;
                        CLUREF T_5_2;
                        T_5_1.num = arg2.vec->data[1];
                        err = typespecOPget_abs(T_5_1, &T_5_2);
                        if (err != ERR_ok) goto ex_0;
                        switch (T_5_2.cell->tag) {
                        case 5: 
                             {CLUREF T_5_3;
                            T_5_3.num = T_5_2.cell->value;
                            i.num = T_5_3.num;

  LINE(202);
                                {
                                CLUREF T_6_1;
                                CLUREF T_6_2;
                                CLUREF T_6_3;
                                err = idnOPget_str(i, &T_6_1);
                                if (err != ERR_ok) goto ex_0;
                                T_6_2.num = ((T_6_1.str->size != STR_pstream.str->size)? false :
                                    !(bcmp(T_6_1.str->data, STR_pstream.str->data, T_6_1.str->size)));
                                T_6_3.num = T_6_2.num ^ 1;
                                if (T_6_3.num == true) {
                                    goto end_inline_for_1;
                                    }
                                    }/* end if */
                                break;
                                }
                        default: {

  LINE(204);
                            goto end_inline_for_1;
                        }
                        }
                        }

  LINE(206);
                        {
                        CLUREF T_5_1;
                        CLUREF T_5_2;
                        T_5_1.num = arg1.vec->data[1];
                        err = typespecOPget_abs(T_5_1, &T_5_2);
                        if (err != ERR_ok) goto ex_0;
                        switch (T_5_2.cell->tag) {
                        case 5: 
                             {CLUREF T_5_3;
                            T_5_3.num = T_5_2.cell->value;
                            i.num = T_5_3.num;

  LINE(208);
                                {
                                CLUREF T_6_1;
                                CLUREF T_6_2;
                                CLUREF T_6_3;
                                err = idnOPget_str(i, &T_6_1);
                                if (err != ERR_ok) goto ex_0;
                                err = idnOPget_str(id, &T_6_2);
                                if (err != ERR_ok) goto ex_0;
                                T_6_3.num = ((T_6_1.str->size != T_6_2.str->size)? false :
                                    !(bcmp(T_6_1.str->data, T_6_2.str->data, T_6_1.str->size)));
                                if (T_6_3.num == true) {

  LINE(209);
                                    {
                                    CLUREF T_7_1;
                                    CellAlloc(2, nil, T_7_1);
                                    form.num = T_7_1.num;
                                    }
                                    }
                                else {

  LINE(210);
                                    goto end_inline_for_1;
                                    }}/* end if */
                                break;
                                }
                        case 4: 
                             {

  LINE(212);
                                {
                                CLUREF T_6_1;
                                CellAlloc(1, nil, T_6_1);
                                form.num = T_6_1.num;
                                }

  LINE(213);
                                {
                                CLUREF T_6_1;
                                T_6_1.num = each.vec->data[12];
                                wh.num = T_6_1.num;
                                }
                                break;
                                }
                        case 10: 
                             {CLUREF T_5_4;
                            T_5_4.num = T_5_2.cell->value;
                            x.num = T_5_4.num;

  LINE(215);
                                {
                                CLUREF T_6_1;
                                CLUREF T_6_2;
                                CLUREF T_6_3;
                                CLUREF T_6_4;
                                T_6_1.num = x.vec->data[0];
                                err = idnOPget_str(T_6_1, &T_6_2);
                                if (err != ERR_ok) goto ex_0;
                                err = idnOPget_str(id, &T_6_3);
                                if (err != ERR_ok) goto ex_0;
                                T_6_4.num = ((T_6_2.str->size != T_6_3.str->size)? false :
                                    !(bcmp(T_6_2.str->data, T_6_3.str->data, T_6_2.str->size)));
                                if (T_6_4.num == true) {

  LINE(216);
                                    {
                                    CLUREF T_7_1;
                                    CellAlloc(3, nil, T_7_1);
                                    form.num = T_7_1.num;
                                    }

  LINE(217);
                                    {
                                    CLUREF T_7_1;
                                    T_7_1.num = each.vec->data[12];
                                    wh.num = T_7_1.num;
                                    }
                                    }
                                else {

  LINE(218);
                                    goto end_inline_for_1;
                                    }}/* end if */
                                break;
                                }
                        default: {

  LINE(220);
                            goto end_inline_for_1;
                        }
                        }
                        }

  LINE(222);
                        {
                        found.tf = true;
                        }
                        }
                        }/* end if */

  LINE(224);
                    goto end_inline_for_1;
                    }
                    }/* end if */
                }
                }/* end if */
        }
    }
    end_inline_for_1:;

  LINE(232);
    {
    if (found.num == true) {

  LINE(234);
        {
            {wclause = STR_;
            }
            }

  LINE(235);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
            T_2_2.num = wh.vec->size; 
            T_2_3 = wh;
            for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                each_r.num = T_2_3.vec->data[T_2_1.num - 1];

  LINE(236);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CLUREF T_3_4;
                CLUREF T_3_5;
                CLUREF T_3_6;
                CLUREF T_3_7;
                CLUREF T_3_8;
                CLUREF T_3_9;
                err = stringOPconcat(wclause, STR_where_040, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                T_3_2.num = each_r.vec->data[0];
                err = idnOPget_str(T_3_2, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                err = stringOPconcat(T_3_1, T_3_3, &T_3_4);
                if (err != ERR_ok) goto ex_0;
                err = stringOPconcat(T_3_4, STR__040has_040print_072_040proctype_050, &T_3_5);
                if (err != ERR_ok) goto ex_0;
                T_3_6.num = each_r.vec->data[0];
                err = idnOPget_str(T_3_6, &T_3_7);
                if (err != ERR_ok) goto ex_0;
                err = stringOPconcat(T_3_5, T_3_7, &T_3_8);
                if (err != ERR_ok) goto ex_0;
                err = stringOPconcat(T_3_8, STR__054_040pstream_051_012, &T_3_9);
                if (err != ERR_ok) goto ex_0;
                wclause.num = T_3_9.num;
                }
            }
        }
        end_inline_for_2:;

  LINE(240);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = stringOPconcat(STR_debug_137print_040_075_040proc_050_137rep_072_040cvt_054_040ps_072_040pstream_051_012, wclause, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_1, STR__040print_050up_050_137rep_051_054_040ps_051_012, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_2, STR__040end_040debug_137print_012, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        apstr.num = T_2_3.num;
        }
        }
    else {

  LINE(245);
        {
        apstr = STR_debug_137print_040_075_040proc_050_137rep_072_040cvt_054_040ps_072_040pstream_051_012_040rep_044debug_137print_050_137rep_054_040ps_051_012_040end_040debug_137print_012;
        }
        }}/* end if */

  LINE(250);
    {
        {CLUREF T_1_1;
        err = streamOPcreate_input(apstr, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        newst.num = T_1_1.num;
        }
        }

  LINE(252);
    {
    CLUREF T_1_1;
    err = p_envOPpush(e, newst, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    e.num = T_1_1.num;
    }

  LINE(254);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_operdefn;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_list_of_record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops->op_owns;
        generic_CLU_proc.proc = p_list;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_list(e, T_1_1, CLU_0, STR_operation, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        new.num = T_1_2.num;
        }
        }

  LINE(257);
    {
    CLUREF T_1_1;
    err = p_envOPpop(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    e.num = T_1_1.num;
    }

  LINE(259);
    {
    CLUREF T_1_1;
    err = sequenceOPconcat(bod, new, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    bod.num = T_1_1.num;
    }

  LINE(263);
    {
    CLUREF T_1_1;
    err = idnOPget_str(id, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = p_defn_end(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(264);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(10, T_1_1);
    T_1_1.vec->data[3]  = id.num;
    T_1_1.vec->data[7]  = parms.num;
    err = p_envOPget_unknown_type(e, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[8]  = T_1_2.num;
    err = p_envOPget_unknown_type(e, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[1]  = T_1_3.num;
    T_1_1.vec->data[6]  = ops.num;
    T_1_1.vec->data[9]  = wher.num;
    T_1_1.vec->data[2]  = equates.num;
    T_1_1.vec->data[4]  = inits.num;
    T_1_1.vec->data[0]  = bod.num;
    T_1_1.vec->data[5]  = line.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_typedefn ****/


extern errcode p_typeset();
extern errcode p_pathname();
extern errcode p_expr();
extern errcode p_envOPget_bad_expr();
extern errcode equateOPcreate();
CLUREF STR_pathname;
CLUREF STR_right_040side_040of_040equate;
static int p_equate_own_init = 0;

/**** BEGIN PROCEDURE p_equate ****/

errcode p_equate(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF id;
    CLUREF k;
    CLUREF i;
    CLUREF line;
    CLUREF val;
    CLUREF tk;
        if (p_equate_own_init == 0) {
        stringOPcons("pathname", CLU_1, CLU_8, &STR_pathname);
        stringOPcons("right side of equate", CLU_1, CLU_20, &STR_right_040side_040of_040equate);
        p_equate_own_init = 1;
    }
    enter_proc(278);

  LINE(280);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 16: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(282);
            {
            id.num = k.num;
            }
            break;
            }
    case 38: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        k.num = T_1_3.num;

  LINE(284);
            {
            switch (k.cell->tag) {
            case 3: 
                 {CLUREF T_2_1;
                T_2_1.num = k.cell->value;
                i.num = T_2_1.num;

  LINE(286);
                    {
                    id.num = i.num;
                    }
                    break;
                    }
            default: {

  LINE(288);
                {
                {signal (ERR_none);}}
            }
            }
            }
            break;
            }
    default: {

  LINE(291);
        {
        {signal (ERR_none);}}
    }
    }
    }

  LINE(293);
    {
    CLUREF T_1_1;
    err = p_envOPpeek(e, CLU_2, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 11: 
         {
            break;
            }
    default: {

  LINE(295);
        {
        {signal (ERR_none);}}
    }
    }
    }

  LINE(297);
    {
        {CLUREF T_1_1;
        err = p_envOPpeek(e, CLU_3, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        k.num = T_1_1.num;
        }
        }

  LINE(298);
    {
    switch (k.cell->tag) {
    case 4: 
         {

  LINE(299);
            {
            {signal (ERR_none);}}
            break;
            }
    default: {
    }
    }
    }

  LINE(302);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(303);
    {
        {CLUREF T_1_1;
        err = p_envOPget_line(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        line.num = T_1_1.num;
        }
        }

  LINE(304);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(306);
    {
    switch (k.cell->tag) {
    case 20: 
         {

  LINE(308);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(309);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = p_typeset(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            CellAlloc(3, T_3_1.num, T_3_2);
            val.num = T_3_2.num;
            }
            break;
            }
    case 16: 
         {CLUREF T_2_1;
        T_2_1.num = k.cell->value;
        tk.num = T_2_1.num;

  LINE(311);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = idnOPget_str(tk, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            T_3_2.num = ((STR_pathname.str->size != T_3_1.str->size)? false :
                !(bcmp(STR_pathname.str->data, T_3_1.str->data, STR_pathname.str->size)));
            if (T_3_2.num == true) {

  LINE(312);
                {
                CLUREF T_4_1;
                err = p_envOPnext_token(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                }

  LINE(313);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                err = p_pathname(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                CellAlloc(1, T_4_1.num, T_4_2);
                val.num = T_4_2.num;
                }
                }
            else {

  LINE(314);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                err = p_expr(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                CellAlloc(2, T_4_1.num, T_4_2);
                val.num = T_4_2.num;
                }
                }}/* end if */
            break;
            }
    default: {

  LINE(317);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = p_expr(e, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        CellAlloc(2, T_3_1.num, T_3_2);
        val.num = T_3_2.num;
        }
    }
    }
    }
        goto end_1;
        ex_1:
            if ((err == ERR_none)) {

  LINE(319);
                {
                err = p_envOPassume(e, STR_right_040side_040of_040equate);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(320);
                {
                CLUREF T_2_1;
                CLUREF T_2_2;
                err = p_envOPget_bad_expr(e, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                CellAlloc(2, T_2_1.num, T_2_2);
                val.num = T_2_2.num;
                }
            }
            else if ((err == ERR_bad)) {

  LINE(321);
                {
                CLUREF T_2_1;
                CLUREF T_2_2;
                err = p_envOPget_bad_expr(e, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                CellAlloc(2, T_2_1.num, T_2_2);
                val.num = T_2_2.num;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(323);
    {
    {
    CLUREF T_1_1;
    err = equateOPcreate(id, val, line, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_equate ****/


extern errcode p_owninit();

/**** BEGIN PROCEDURE p_init ****/

errcode p_init(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF k;
    CLUREF line;
    CLUREF di;
    enter_proc(328);

  LINE(329);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 34: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(331);
            {
            switch (k.cell->tag) {
            case 7: 
                 {

  LINE(332);
                    {
                    CLUREF T_3_1;
                    err = p_envOPnext_token(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    }
                    break;
                    }
            default: {

  LINE(333);
                {
                {signal (ERR_none);}}
            }
            }
            }
            break;
            }
    default: {

  LINE(336);
        {
        {signal (ERR_none);}}
    }
    }
    }

  LINE(338);
    {
        {CLUREF T_1_1;
        err = p_envOPget_line(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        line.num = T_1_1.num;
        }
        }

  LINE(339);
    {
        {CLUREF T_1_1;
        err = p_owninit(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        di.num = T_1_1.num;
        }
        }

  LINE(340);
    {
    {
    CLUREF T_1_1;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[1]  = di.num;
    T_1_1.vec->data[0]  = line.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_init ****/


struct OPS *p_slist_of_equate_table;
struct OPS *p_slist_of_equate_ops;
struct OPS *p_slist_of_equate_ops;
OWNPTR p_slist_of_equate_owns;
CLUREF STR_equates_040legal_040only_040at_040start_040of_040cluster;
static int p_operdefn_own_init = 0;

/**** BEGIN PROCEDURE p_operdefn ****/

errcode p_operdefn(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF k;
        if (p_operdefn_own_init == 0) {
        add_parm_info_type(0, equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        stringOPcons("equates legal only at start of cluster", CLU_1, CLU_38, &STR_equates_040legal_040only_040at_040start_040of_040cluster);
        p_operdefn_own_init = 1;
    }
    enter_proc(344);

  LINE(346);
    for (;;) {
        CLUREF T_1_1;
        err = p_find_a_defn(e, CLU_1, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        if (T_1_1.num != true) { break; }

  LINE(347);
        {
        CLUREF T_2_1;
        err = p_envOPpeek(e, CLU_3, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 4: 
             {CLUREF T_2_2;
            T_2_2.num = T_2_1.cell->value;
            k.num = T_2_2.num;

  LINE(349);
                {
                switch (k.cell->tag) {
                case 4: 
                     {

  LINE(350);
                        {
                        {
                        CLUREF T_4_1;
                        err = p_applydefn(e, &T_4_1);
                        if (err != ERR_ok) goto ex_0;
                        ret_1->num = T_4_1.num;
                        }
                        {signal (ERR_ok);}}
                        break;
                        }
                case 3: 
                     {

  LINE(351);
                        {
                        {
                        CLUREF T_4_1;
                        err = p_applydefn(e, &T_4_1);
                        if (err != ERR_ok) goto ex_0;
                        ret_1->num = T_4_1.num;
                        }
                        {signal (ERR_ok);}}
                        break;
                        }
                default: {

  LINE(352);
                    {
                    {signal (ERR_none);}}
                }
                }
                }
                break;
                }
        default: {

  LINE(355);
            {
            err = p_envOPerr(e, STR_equates_040legal_040only_040at_040start_040of_040cluster, CLU_2);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(357);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = proctypeOPnew(CLU_0, &T_3_1.proc);
            if (err!= ERR_ok) goto ex_0;
            T_3_1.proc->type_owns = 0;
            T_3_1.proc->op_owns = 0;
            T_3_1.proc->proc = p_equate;
            generic_CLU_proc.type_owns = 0;
            generic_CLU_proc.op_owns = (long)p_slist_of_equate_ops->op_owns;
            generic_CLU_proc.proc = p_slist;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = p_slist(e, T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_0;
            }
        }
        }
        }
        }
        end_while_1:;

  LINE(360);
    {
    {signal (ERR_none);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_operdefn ****/

