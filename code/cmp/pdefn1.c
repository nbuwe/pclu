
/* This file was automatically generated by pclu. */

#include "pclu_err.h"
#include "pclu_sys.h"



/**** BEGIN PROCEDURE p_definition ****/

extern errcode p_envOPset_clustr();
extern errcode p_envOPset_applystr();
extern errcode p_envOPget_peek1();
extern errcode p_envOPnext_token();
extern errcode p_directive();
extern errcode boolOPnot();
extern errcode p_find_a_defn();
extern errcode p_envOPpeek();
extern errcode oneofOPmake_1();
extern errcode p_applydefn();
extern errcode oneofOPmake_3();
extern errcode p_typedefn();
extern errcode oneofOPmake_5();
extern errcode oneofOPmake_2();
extern errcode oneofOPmake_4();
extern errcode p_slist();
extern errcode p_equate();
extern const struct REQS * const p_slist_of_t_reqs;
extern struct OPS *equate_ops;
extern const OWN_req p_slist_ownreqs;
struct OPS *p_slist_of_equate_ops __CLU_COMMON;
static int p_definition_own_init = 0;

errcode
p_definition(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF k;
    if (p_definition_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        p_definition_own_init = 1;
    }
    enter_proc(12);

  LINE(14);
    {
    err = p_envOPset_clustr(e, CLU_empty_string);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(15);
    {
    err = p_envOPset_applystr(e, CLU_empty_string);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(16);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(17);
        { /* qtagcase */
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_1.cell->tag) {
        case 32: /* sharp */ {

  LINE(18);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(19);
            { /* return */
            {
            CLUREF T_4_1;
            err = p_directive(e, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_1.num;
            }
            signal (ERR_ok);
            }
            goto end_1;
          ex_1: /* except */
            __CLU_EX_HANDLER;
            if (err == ERR_no_directive) {
            }
            else { /* not handled */
                goto ex_0;
            }
          end_1:;
            break;
        }
        default: {

  LINE(21);
            goto end_while_1;
            break;
        }
        }
        } /* end qtagcase */
    }
    end_while_1:
    __CLU_END_LABEL;

  LINE(24);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = p_find_a_defn(e, CLU_false, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_2.num = !T_1_1.num;
    if (T_1_2.num == true) { /* if */

  LINE(25);
        { /* signal */
            signal(ERR_eof);
        }
    }
    } /* end if */

  LINE(26);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPpeek(e, CLU_3, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 4: /* defnkey */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(28);
        { /* qtagcase */
        switch (k.cell->tag) {
        case 4: /* proc_ */ {

  LINE(29);
            { /* return */
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = p_applydefn(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            CellAlloc(1, T_3_1.num, T_3_2);
            ret_1->num = T_3_2.num;
            }
            signal (ERR_ok);
            }
            break;
        }
        case 3: /* iter_ */ {

  LINE(30);
            { /* return */
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = p_applydefn(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            CellAlloc(1, T_3_1.num, T_3_2);
            ret_1->num = T_3_2.num;
            }
            signal (ERR_ok);
            }
            break;
        }
        case 2: /* cluster_ */ {

  LINE(31);
            { /* return */
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = p_typedefn(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            CellAlloc(3, T_3_1.num, T_3_2);
            ret_1->num = T_3_2.num;
            }
            signal (ERR_ok);
            }
            break;
        }
        case 5: /* selector_ */ {

  LINE(32);
            { /* return */
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = p_typedefn(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            CellAlloc(5, T_3_1.num, T_3_2);
            ret_1->num = T_3_2.num;
            }
            signal (ERR_ok);
            }
            break;
        }
        case 1: /* applytype_ */ {

  LINE(33);
            { /* return */
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = p_typedefn(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            CellAlloc(2, T_3_1.num, T_3_2);
            ret_1->num = T_3_2.num;
            }
            signal (ERR_ok);
            }
            break;
        }
        }
        } /* end qtagcase */
        break;
    }
    default: {

  LINE(36);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = proctypeOPnew(CLU_0, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.proc->type_owns = NULL;
        T_2_1.proc->op_owns = NULL;
        T_2_1.proc->proc = p_equate;
        generic_CLU_proc.type_owns = NULL;
        generic_CLU_proc.op_owns = p_slist_of_equate_ops->op_owns;
        generic_CLU_proc.proc = p_slist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_slist(e, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        CellAlloc(4, T_2_2.num, T_2_3);
        ret_1->num = T_2_3.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_definition ****/



/**** BEGIN PROCEDURE p_directive ****/

extern errcode stringOPequal();
extern errcode idnOPget_str();
extern errcode p_include();
extern errcode p_envOPhack();
extern errcode p_envOPunhack();
extern errcode p_envOPerr();
extern errcode oneofOPis_9();
extern errcode recordOPget_7();
extern errcode cmpvarOPstuffs();
extern errcode g_envOPforce_signal();
static CLUREF STR_include;
static CLUREF STR_extend;
static CLUREF STR_normal;
static CLUREF STR_unrecognized_040directive;
static CLUREF STR_missing_040directive_040after_040_043;
static int p_directive_own_init = 0;

errcode
p_directive(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF dir;
    CLUREF k;
    CLUREF ge;
    if (p_directive_own_init == 0) {
        stringOPcons("include", CLU_1, CLUREF_make_num(7), &STR_include);
        stringOPcons("extend", CLU_1, CLUREF_make_num(6), &STR_extend);
        stringOPcons("normal", CLU_1, CLUREF_make_num(6), &STR_normal);
        stringOPcons("unrecognized directive", CLU_1, CLUREF_make_num(22), &STR_unrecognized_040directive);
        stringOPcons("missing directive after #", CLU_1, CLUREF_make_num(25), &STR_missing_040directive_040after_040_043);
        p_directive_own_init = 1;
    }
    enter_proc(43);

  LINE(44);
    { /* qtagcase */
    CLUREF T_2_1;
    err = p_envOPget_peek1(e, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    switch (T_2_1.cell->tag) {
    case 16: /* idn */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        dir.num = T_2_2.num;

  LINE(46);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = idnOPget_str(dir, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        T_3_2.num = ((T_3_1.str->size != STR_include.str->size)? false :
            !(memcmp(T_3_1.str->data, STR_include.str->data, T_3_1.str->size)));
        if (T_3_2.num == true) { /* if */

  LINE(47);
            {
            CLUREF T_4_1;
            err = p_envOPnext_token(e, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            }

  LINE(48);
            { /* return */
            {
            CLUREF T_4_1;
            err = p_include(e, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_1.num;
            }
            signal (ERR_ok);
            }
        }
        else {

  LINE(49);
        CLUREF T_3_3;
        CLUREF T_3_4;
        err = idnOPget_str(dir, &T_3_3);
        if (err != ERR_ok)
            goto ex_1;
        T_3_4.num = ((T_3_3.str->size != STR_extend.str->size)? false :
            !(memcmp(T_3_3.str->data, STR_extend.str->data, T_3_3.str->size)));
        if (T_3_4.num == true) { /* elseif */

  LINE(50);
            {
            err = p_envOPhack(e);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        else {

  LINE(51);
        CLUREF T_3_5;
        CLUREF T_3_6;
        err = idnOPget_str(dir, &T_3_5);
        if (err != ERR_ok)
            goto ex_1;
        T_3_6.num = ((T_3_5.str->size != STR_normal.str->size)? false :
            !(memcmp(T_3_5.str->data, STR_normal.str->data, T_3_5.str->size)));
        if (T_3_6.num == true) { /* elseif */

  LINE(52);
            {
            err = p_envOPunhack(e);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        else { /* else */

  LINE(53);
            {
            err = p_envOPerr(e, STR_unrecognized_040directive, CLU_2);
            if (err != ERR_ok)
                goto ex_1;
            }
        }}}} /* end if */

  LINE(54);
        {
        CLUREF T_3_1;
        err = p_envOPnext_token(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(55);
        { /* signal */
            signal(ERR_no_directive);
        }
        break;
    }
    case 34: /* stmtkey */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        k.num = T_2_3.num;

  LINE(57);
        { /* if */
        CLUREF T_3_1;
        if (k.cell->tag == 9) T_3_1.num = true; else T_3_1.num = false;
        if (T_3_1.num == true) { /* if */

  LINE(58);
            {
            CLUREF T_4_1;
            err = p_envOPnext_token(e, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            }

  LINE(59);
            { /* qtagcase */
            CLUREF T_4_1;
            CLUREF T_4_2;
            err = cmpvarOPstuffs(&T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            T_4_2.num = T_4_1.vec->data[6];
            switch (T_4_2.cell->tag) {
            case 2: /* one */ {
                CLUREF T_4_3;
                T_4_3.num = T_4_2.cell->value;
                ge.num = T_4_3.num;

  LINE(60);
                {
                err = g_envOPforce_signal(ge);
                if (err != ERR_ok)
                    goto ex_1;
                }
                break;
            }
            }
            } /* end qtagcase */

  LINE(63);
            { /* signal */
                signal(ERR_no_directive);
            }
        }
        } /* end if */
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_include_failed) {

  LINE(66);
        { /* signal */
            signal(ERR_no_directive);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(67);
    {
    err = p_envOPerr(e, STR_missing_040directive_040after_040_043, CLU_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(68);
    { /* signal */
        signal(ERR_no_directive);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_directive ****/



/**** BEGIN PROCEDURE p_include ****/

extern errcode oneofOPvalue_24();
extern errcode oneofOPvalue_13();
extern errcode recordOPget_8();
extern errcode file_nameOPparse();
extern errcode stringOPempty();
extern errcode file_nameOPget_dir();
extern errcode file_nameOPcreate();
extern errcode streamOPget_name();
extern errcode file_nameOPget_name();
extern errcode file_nameOPget_suffix();
extern errcode file_nameOPget_other();
extern errcode file_name_fill();
extern errcode equate_suffix();
extern errcode streamOPopen();
extern errcode check_file_name();
extern errcode recordOPset_8();
extern errcode p_envOPnew_env();
extern errcode streamOPclose();
extern errcode p_envOPset_err();
extern errcode p_envOPget_err();
extern errcode stringOPconcat();
struct OPS *p_slist_of_equate_ops __CLU_COMMON;
static CLUREF STR_read;
static CLUREF STR_more_040than_040equates_040in_040include_040file;
static CLUREF STR_file_040name_040has_040bad_040format;
static CLUREF STR_cannot_040open_040include_040file_072_040;
static CLUREF STR_missing_040file_040name_040string_040after_040_043_040include;
static int p_include_own_init = 0;

errcode
p_include(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF s;
    CLUREF x;
    CLUREF ost;
    CLUREF fn;
    CLUREF inst;
    CLUREF e1;
    CLUREF def;
    CLUREF xx;
    if (p_include_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        stringOPcons("read", CLU_1, CLUREF_make_num(4), &STR_read);
        stringOPcons("more than equates in include file", CLU_1, CLUREF_make_num(33), &STR_more_040than_040equates_040in_040include_040file);
        stringOPcons("file name has bad format", CLU_1, CLUREF_make_num(24), &STR_file_040name_040has_040bad_040format);
        stringOPcons("cannot open include file: ", CLU_1, CLUREF_make_num(26), &STR_cannot_040open_040include_040file_072_040);
        stringOPcons("missing file name string after # include", CLU_1, CLUREF_make_num(40), &STR_missing_040file_040name_040string_040after_040_043_040include);
        p_include_own_init = 1;
    }
    enter_proc(71);

  LINE(72);
    { /* begin */

  LINE(73);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        err = p_envOPget_peek1(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        if (T_3_1.cell->tag != 13) {
            err = ERR_wrong_tag;
            goto ex_1;
        }
        T_3_2.num = T_3_1.cell->value;
        if (T_3_2.cell->tag != 24) {
            err = ERR_wrong_tag;
            goto ex_1;
        }
        T_3_3.num = T_3_2.cell->value;
        s.num = T_3_3.num;
        }

  LINE(74);
        {
        CLUREF T_3_1;
        err = p_envOPnext_token(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(75);
        {
        CLUREF T_3_1;
        err = cmpvarOPstuffs(&T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        x.num = T_3_1.num;
        }

  LINE(76);
        {
        CLUREF T_3_1;
        T_3_1.num = x.vec->data[7];
        ost.num = T_3_1.num;
        }

  LINE(77);
        {
        CLUREF T_3_1;
        err = file_nameOPparse(s, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        fn.num = T_3_1.num;
        }

  LINE(78);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = file_nameOPget_dir(fn, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        err = stringOPempty(T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        if (T_3_2.num == true) { /* if */

  LINE(79);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            CLUREF T_4_6;
            err = streamOPget_name(ost, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            err = file_nameOPget_dir(T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            err = file_nameOPget_name(fn, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            err = file_nameOPget_suffix(fn, &T_4_4);
            if (err != ERR_ok)
                goto ex_1;
            err = file_nameOPget_other(fn, &T_4_5);
            if (err != ERR_ok)
                goto ex_1;
            err = file_nameOPcreate(T_4_2, T_4_3, T_4_4, T_4_5, &T_4_6);
            if (err != ERR_ok)
                goto ex_1;
            fn.num = T_4_6.num;
            }
        }
        } /* end if */

  LINE(81);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = equate_suffix(&T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        err = file_name_fill(fn, T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        fn.num = T_3_2.num;
        }

  LINE(82);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = check_file_name(fn, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        err = streamOPopen(T_3_1, STR_read, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        inst.num = T_3_2.num;
        }

  LINE(83);
        {
        x.vec->data[7] = inst.num;
        }

  LINE(84);
        {
        CLUREF T_3_1;
        err = p_envOPnew_env(e, inst, s, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        e1.num = T_3_1.num;
        }

  LINE(85);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        err = proctypeOPnew(CLU_0, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        T_3_1.proc->type_owns = NULL;
        T_3_1.proc->op_owns = NULL;
        T_3_1.proc->proc = p_equate;
        generic_CLU_proc.type_owns = NULL;
        generic_CLU_proc.op_owns = p_slist_of_equate_ops->op_owns;
        generic_CLU_proc.proc = p_slist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_slist(e1, T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        CellAlloc(4, T_3_2.num, T_3_3);
        def.num = T_3_3.num;
        }

  LINE(87);
        { /* qtagcase */
        CLUREF T_3_1;
        err = p_envOPget_peek1(e1, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        switch (T_3_1.cell->tag) {
        case 10: /* eof */ {
            break;
        }
        default: {

  LINE(89);
            {
            err = p_envOPerr(e1, STR_more_040than_040equates_040in_040include_040file, CLU_1);
            if (err != ERR_ok)
                goto ex_1;
            }
            break;
        }
        }
        } /* end qtagcase */

  LINE(91);
        {
        err = streamOPclose(inst);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(92);
        {
        x.vec->data[7] = ost.num;
        }

  LINE(93);
        {
        CLUREF T_3_1;
        err = p_envOPget_err(e1, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        err = p_envOPset_err(e, T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(94);
        { /* return */
        {
        ret_1->num = def.num;
        }
        signal (ERR_ok);
        }
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_bad_format) {

  LINE(97);
        {
        err = p_envOPerr(e, STR_file_040name_040has_040bad_040format, CLU_2);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    else if (err == ERR_not_possible) {
        xx.num = elist[0].num;

  LINE(99);
        {
        CLUREF T_2_1;
        err = stringOPconcat(STR_cannot_040open_040include_040file_072_040, xx, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = p_envOPerr(e, T_2_1, CLU_2);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    else if (err == ERR_wrong_tag) {

  LINE(101);
        {
        err = p_envOPerr(e, STR_missing_040file_040name_040string_040after_040_043_040include, CLU_2);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(104);
    { /* signal */
        signal(ERR_include_failed);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_include ****/



/**** BEGIN PROCEDURE p_applydefn ****/

extern errcode p_idn();
extern errcode p_envOPget_line();
extern errcode oneofOPvalue_4();
extern errcode p_blist();
extern errcode p_decl();
extern errcode p_plist();
extern errcode p_values();
extern errcode p_signals();
extern errcode p_where();
extern errcode p_envOPset_deftype();
extern errcode sequenceOPempty();
extern errcode p_semi();
extern errcode p_envOPbegin_body();
extern errcode p_init();
extern errcode p_stmt();
extern errcode p_envOPend_body();
extern errcode p_defn_end();
extern errcode p_envOPget_unknown_type();
extern errcode arrayOPpredict();
extern const struct REQS * const sequence_of_t_reqs;
extern struct OPS *idn_ops;
extern const OWN_req sequence_ownreqs;
extern struct OPS *sequence_ops;
struct OPS *sequence_of_idn_ops __CLU_COMMON;
extern struct OPS *sequence_of_idn_ops;
extern struct OPS *typespec_ops;
struct OPS *record_idns_type__ops __CLU_COMMON;
extern const struct REQS * const p_blist_of_t_reqs;
extern struct OPS *record_idns_type__ops;
extern const OWN_req p_blist_ownreqs;
struct OPS *p_blist_of_record_idns_type__ops __CLU_COMMON;
extern const struct REQS * const p_plist_of_t_reqs;
extern const OWN_req p_plist_ownreqs;
struct OPS *p_plist_of_record_idns_type__ops __CLU_COMMON;
struct OPS *p_slist_of_equate_ops __CLU_COMMON;
struct OPS *sequence_of_record_idns_type__ops __CLU_COMMON;
extern struct OPS *sequence_of_record_idns_type__ops;
extern struct OPS *expr_ops;
struct OPS *record_anys_decls_expr_ops __CLU_COMMON;
extern struct OPS *record_anys_decls_expr_ops;
struct OPS *oneof_decl_init_ops __CLU_COMMON;
extern struct OPS *int_ops;
extern struct OPS *oneof_decl_init_ops;
struct OPS *record_line_stmt_ops __CLU_COMMON;
extern struct OPS *record_line_stmt_ops;
struct OPS *p_slist_of_record_line_stmt_ops __CLU_COMMON;
extern struct OPS *stmt_ops;
struct OPS *p_slist_of_stmt_ops __CLU_COMMON;
static CLUREF STR_parameter;
static CLUREF STR_argument;
static int p_applydefn_own_init = 0;

errcode
p_applydefn(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF id;
    CLUREF line;
    CLUREF gen;
    CLUREF procdef;
    CLUREF d;
    CLUREF parms;
    CLUREF args;
    CLUREF vals;
    CLUREF sigs;
    CLUREF wher;
    CLUREF eqs;
    CLUREF inits;
    CLUREF bod;
    if (p_applydefn_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, (struct OPS *)sequence_of_idn_ops);
        add_selector_info("type_", 1, (struct OPS *)typespec_ops);
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_parm_info_type(0, (const struct OPS *)record_idns_type__ops, p_blist_of_t_reqs);
        find_prociter_instance(p_blist, 1, &p_blist_ownreqs, &(p_blist_of_record_idns_type__ops));
        add_parm_info_type(0, (const struct OPS *)record_idns_type__ops, p_plist_of_t_reqs);
        find_prociter_instance(p_plist, 1, &p_plist_ownreqs, &(p_plist_of_record_idns_type__ops));
        add_parm_info_type(0, (const struct OPS *)equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        add_parm_info_type(0, (const struct OPS *)record_idns_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_idns_type__ops));
        add_selector_info("anys", 0, (struct OPS *)sequence_of_record_idns_type__ops);
        add_selector_info("decls", 1, (struct OPS *)sequence_of_record_idns_type__ops);
        add_selector_info("expr", 2, (struct OPS *)expr_ops);
        find_selector_ops("record", 3, &(record_anys_decls_expr_ops));
        add_selector_info("decl", 0, (struct OPS *)record_idns_type__ops);
        add_selector_info("init", 1, (struct OPS *)record_anys_decls_expr_ops);
        find_selector_ops("oneof", 2, &(oneof_decl_init_ops));
        add_selector_info("line", 0, (struct OPS *)int_ops);
        add_selector_info("stmt", 1, (struct OPS *)oneof_decl_init_ops);
        find_selector_ops("record", 2, &(record_line_stmt_ops));
        add_parm_info_type(0, (const struct OPS *)record_line_stmt_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_record_line_stmt_ops));
        add_parm_info_type(0, (const struct OPS *)stmt_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_stmt_ops));
        stringOPcons("parameter", CLU_1, CLUREF_make_num(9), &STR_parameter);
        stringOPcons("argument", CLU_1, CLUREF_make_num(8), &STR_argument);
        p_applydefn_own_init = 1;
    }
    enter_proc(110);

  LINE(111);
    {
    CLUREF T_1_1;
    err = p_idn(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    id.num = T_1_1.num;
    }

  LINE(112);
    {
    CLUREF T_1_1;
    err = p_envOPget_line(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    line.num = T_1_1.num;
    }

  LINE(113);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(116);
    { /* qtagcase */
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_1.cell->tag != 4) {
        err = ERR_wrong_tag;
        goto ex_0;
    }
    T_1_2.num = T_1_1.cell->value;
    switch (T_1_2.cell->tag) {
    case 4: /* proc_ */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_2.cell->value;
        d.num = T_1_3.num;

  LINE(118);
        {
        gen.num = d.num;
        }

  LINE(119);
        {
        procdef.tf = true;
        }
        break;
    }
    case 3: /* iter_ */ {
        CLUREF T_1_4;
        T_1_4.num = T_1_2.cell->value;
        d.num = T_1_4.num;

  LINE(121);
        {
        gen.num = d.num;
        }

  LINE(122);
        {
        procdef.tf = false;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(125);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_decl;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_blist_of_record_idns_type__ops->op_owns;
    generic_CLU_proc.proc = p_blist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_blist(e, T_1_1, CLU_true, STR_parameter, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    parms.num = T_1_2.num;
    }

  LINE(126);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_decl;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_plist_of_record_idns_type__ops->op_owns;
    generic_CLU_proc.proc = p_plist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_plist(e, T_1_1, CLU_false, CLU_true, STR_argument, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    args.num = T_1_2.num;
    }

  LINE(128);
    {
    CLUREF T_1_1;
    err = p_values(e, procdef, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    vals.num = T_1_1.num;
    }

  LINE(129);
    {
    CLUREF T_1_1;
    err = p_signals(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    sigs.num = T_1_1.num;
    }

  LINE(130);
    {
    CLUREF T_1_1;
    err = p_where(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    wher.num = T_1_1.num;
    }

  LINE(131);
    {
    CLUREF T_1_1;
    err = idnOPget_str(id, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = p_envOPset_applystr(e, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(132);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = sequenceOPempty(vals, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_2.num = !T_1_1.num;
    err = p_envOPset_deftype(e, gen, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(133);
    {
    err = p_semi(e);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(134);
    {
    err = p_envOPbegin_body(e, CLU_3);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(135);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_equate;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_slist_of_equate_ops->op_owns;
    generic_CLU_proc.proc = p_slist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_slist(e, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    eqs.num = T_1_2.num;
    }

  LINE(136);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_init;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_slist_of_record_line_stmt_ops->op_owns;
    generic_CLU_proc.proc = p_slist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_slist(e, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    inits.num = T_1_2.num;
    }

  LINE(137);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_stmt;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_slist_of_stmt_ops->op_owns;
    generic_CLU_proc.proc = p_slist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_slist(e, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    bod.num = T_1_2.num;
    }

  LINE(138);
    {
    err = p_envOPend_body(e);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(139);
    {
    CLUREF T_1_1;
    err = idnOPget_str(id, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = p_defn_end(e, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(140);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(13, T_1_1);
    T_1_1.vec->data[4] = id.num;
    T_1_1.vec->data[3] = gen.num;
    err = p_envOPget_unknown_type(e, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[9] = T_1_2.num;
    T_1_1.vec->data[7] = parms.num;
    T_1_1.vec->data[0] = args.num;
    T_1_1.vec->data[10] = vals.num;
    T_1_1.vec->data[8] = sigs.num;
    T_1_1.vec->data[12] = wher.num;
    T_1_1.vec->data[2] = eqs.num;
    T_1_1.vec->data[5] = inits.num;
    err = arrayOPpredict(CLU_1, CLU_10, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[11] = T_1_3.num;
    T_1_1.vec->data[1] = bod.num;
    T_1_1.vec->data[6] = line.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_applydefn ****/



/**** BEGIN PROCEDURE p_typedefn ****/

extern errcode p_order();
extern errcode p_idn1();
extern errcode p_envOPassume();
extern errcode sequenceOPnew();
extern errcode p_list();
extern errcode p_operdefn();
extern errcode sequenceOPelements();
extern errcode recordOPget_5();
extern errcode recordOPget_11();
extern errcode recordOPget_9();
extern errcode intOPequal();
extern errcode sequenceOPsize();
extern errcode recordOPget_1();
extern errcode sequenceOPfetch();
extern errcode typespecOPget_abs();
extern errcode recordOPget_2();
extern errcode recordOPget_13();
extern errcode streamOPcreate_input();
extern errcode p_envOPpush();
extern errcode p_envOPpop();
extern errcode sequenceOPconcat();
struct OPS *sequence_of_idn_ops __CLU_COMMON;
struct OPS *record_idns_type__ops __CLU_COMMON;
struct OPS *p_blist_of_record_idns_type__ops __CLU_COMMON;
extern const struct REQS * const p_order_of_t_reqs;
extern const OWN_req p_order_ownreqs;
struct OPS *p_order_of_idn_ops __CLU_COMMON;
struct OPS *p_slist_of_equate_ops __CLU_COMMON;
struct OPS *sequence_of_record_idns_type__ops __CLU_COMMON;
struct OPS *record_anys_decls_expr_ops __CLU_COMMON;
struct OPS *oneof_decl_init_ops __CLU_COMMON;
struct OPS *record_line_stmt_ops __CLU_COMMON;
struct OPS *p_slist_of_record_line_stmt_ops __CLU_COMMON;
struct OPS *sequence_of_stmt_ops __CLU_COMMON;
struct OPS *sequence_of_equate_ops __CLU_COMMON;
struct OPS *sequence_of_record_line_stmt_ops __CLU_COMMON;
struct OPS *sequence_of_typespec_ops __CLU_COMMON;
extern struct OPS *string_ops;
extern struct OPS *sequence_of_typespec_ops;
struct OPS *record_name_types_ops __CLU_COMMON;
extern struct OPS *record_name_types_ops;
struct OPS *sequence_of_record_name_types_ops __CLU_COMMON;
extern const struct REQS * const array_of_t_reqs;
extern const OWN_req array_ownreqs;
extern struct OPS *array_ops;
struct OPS *array_of_idn_ops __CLU_COMMON;
struct OPS *sequence_of_expr_ops __CLU_COMMON;
extern struct OPS *sequence_of_expr_ops;
struct OPS *record_name_parms_type__ops __CLU_COMMON;
extern struct OPS *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops __CLU_COMMON;
extern struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *record_line_opers_ops __CLU_COMMON;
extern struct OPS *record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_ops __CLU_COMMON;
extern struct OPS *sequence_of_equate_ops;
extern struct OPS *sequence_of_record_line_opers_ops;
struct OPS *record_equates_idn_ops_ops __CLU_COMMON;
extern struct OPS *record_equates_idn_ops_ops;
struct OPS *oneof_has__idn_set_ops __CLU_COMMON;
extern struct OPS *oneof_has__idn_set_ops;
struct OPS *record_idn_kind_line_ops __CLU_COMMON;
extern struct OPS *record_idn_kind_line_ops;
struct OPS *sequence_of_record_idn_kind_line_ops __CLU_COMMON;
extern struct OPS *sequence_of_stmt_ops;
extern struct OPS *du_ops;
extern struct OPS *sequence_of_record_line_stmt_ops;
extern struct OPS *sequence_of_record_name_types_ops;
extern struct OPS *array_of_idn_ops;
extern struct OPS *sequence_of_record_idn_kind_line_ops;
struct OPS *record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops __CLU_COMMON;
extern const struct REQS * const p_list_of_t_reqs;
extern struct OPS *record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops;
extern const OWN_req p_list_ownreqs;
struct OPS *p_list_of_record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops __CLU_COMMON;
static CLUREF STR_idn;
static CLUREF STR_IS_040idn_137list_040in_040module_040header;
static CLUREF STR_operation;
static CLUREF STR_print;
static CLUREF STR_pstream;
static CLUREF STR_where_040;
static CLUREF STR__040has_040print_072_040proctype_050;
static CLUREF STR__054_040pstream_051_012;
static CLUREF STR_debug_137print_040_075_040proc_050_137rep_072_040cvt_054_040ps_072_040pstream_051_012;
static CLUREF STR__040print_050up_050_137rep_051_054_040ps_051_012;
static CLUREF STR__040end_040debug_137print_012;
static CLUREF STR_debug_137print_040_075_040proc_050_137rep_072_040cvt_054_040ps_072_040pstream_051_012_040rep_044debug_137print_050_137rep_054_040ps_051_012_040end_040debug_137print_012;
static int p_typedefn_own_init = 0;

errcode
p_typedefn(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF id;
    CLUREF line;
    CLUREF parms;
    CLUREF ops;
    CLUREF wher;
    CLUREF equates;
    CLUREF inits;
    CLUREF bod;
    CLUREF found;
    CLUREF form;
    CLUREF wh;
    CLUREF each;
    CLUREF arg1;
    CLUREF arg2;
    CLUREF i;
    CLUREF x;
    CLUREF apstr;
    CLUREF wclause;
    CLUREF each_r;
    CLUREF newst;
    CLUREF new;
    if (p_typedefn_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, (struct OPS *)sequence_of_idn_ops);
        add_selector_info("type_", 1, (struct OPS *)typespec_ops);
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_parm_info_type(0, (const struct OPS *)record_idns_type__ops, p_blist_of_t_reqs);
        find_prociter_instance(p_blist, 1, &p_blist_ownreqs, &(p_blist_of_record_idns_type__ops));
        add_parm_info_type(0, (const struct OPS *)idn_ops, p_order_of_t_reqs);
        find_prociter_instance(p_order, 1, &p_order_ownreqs, &(p_order_of_idn_ops));
        add_parm_info_type(0, (const struct OPS *)equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        add_parm_info_type(0, (const struct OPS *)record_idns_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_idns_type__ops));
        add_selector_info("anys", 0, (struct OPS *)sequence_of_record_idns_type__ops);
        add_selector_info("decls", 1, (struct OPS *)sequence_of_record_idns_type__ops);
        add_selector_info("expr", 2, (struct OPS *)expr_ops);
        find_selector_ops("record", 3, &(record_anys_decls_expr_ops));
        add_selector_info("decl", 0, (struct OPS *)record_idns_type__ops);
        add_selector_info("init", 1, (struct OPS *)record_anys_decls_expr_ops);
        find_selector_ops("oneof", 2, &(oneof_decl_init_ops));
        add_selector_info("line", 0, (struct OPS *)int_ops);
        add_selector_info("stmt", 1, (struct OPS *)oneof_decl_init_ops);
        find_selector_ops("record", 2, &(record_line_stmt_ops));
        add_parm_info_type(0, (const struct OPS *)record_line_stmt_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_record_line_stmt_ops));
        add_parm_info_type(0, (const struct OPS *)stmt_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_stmt_ops));
        add_parm_info_type(0, (const struct OPS *)equate_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_equate_ops));
        add_parm_info_type(0, (const struct OPS *)record_line_stmt_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_line_stmt_ops));
        add_parm_info_type(0, (const struct OPS *)typespec_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_typespec_ops));
        add_selector_info("name", 0, (struct OPS *)string_ops);
        add_selector_info("types", 1, (struct OPS *)sequence_of_typespec_ops);
        find_selector_ops("record", 2, &(record_name_types_ops));
        add_parm_info_type(0, (const struct OPS *)record_name_types_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_name_types_ops));
        add_parm_info_type(0, (const struct OPS *)idn_ops, array_of_t_reqs);
        find_type_instance(array_ops, 1, &array_ownreqs, &(array_of_idn_ops));
        add_parm_info_type(0, (const struct OPS *)expr_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_expr_ops));
        add_selector_info("name", 0, (struct OPS *)string_ops);
        add_selector_info("parms", 1, (struct OPS *)sequence_of_expr_ops);
        add_selector_info("type_", 2, (struct OPS *)typespec_ops);
        find_selector_ops("record", 3, &(record_name_parms_type__ops));
        add_parm_info_type(0, (const struct OPS *)record_name_parms_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_name_parms_type__ops));
        add_selector_info("line", 0, (struct OPS *)int_ops);
        add_selector_info("opers", 1, (struct OPS *)sequence_of_record_name_parms_type__ops);
        find_selector_ops("record", 2, &(record_line_opers_ops));
        add_parm_info_type(0, (const struct OPS *)record_line_opers_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_line_opers_ops));
        add_selector_info("equates", 0, (struct OPS *)sequence_of_equate_ops);
        add_selector_info("idn", 1, (struct OPS *)idn_ops);
        add_selector_info("ops", 2, (struct OPS *)sequence_of_record_line_opers_ops);
        find_selector_ops("record", 3, &(record_equates_idn_ops_ops));
        add_selector_info("has_", 0, (struct OPS *)sequence_of_record_line_opers_ops);
        add_selector_info("idn", 1, (struct OPS *)idn_ops);
        add_selector_info("set", 2, (struct OPS *)record_equates_idn_ops_ops);
        find_selector_ops("oneof", 3, &(oneof_has__idn_set_ops));
        add_selector_info("idn", 0, (struct OPS *)idn_ops);
        add_selector_info("kind", 1, (struct OPS *)oneof_has__idn_set_ops);
        add_selector_info("line", 2, (struct OPS *)int_ops);
        find_selector_ops("record", 3, &(record_idn_kind_line_ops));
        add_parm_info_type(0, (const struct OPS *)record_idn_kind_line_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_idn_kind_line_ops));
        add_selector_info("args", 0, (struct OPS *)sequence_of_record_idns_type__ops);
        add_selector_info("body", 1, (struct OPS *)sequence_of_stmt_ops);
        add_selector_info("equates", 2, (struct OPS *)sequence_of_equate_ops);
        add_selector_info("gen", 3, (struct OPS *)du_ops);
        add_selector_info("idn", 4, (struct OPS *)idn_ops);
        add_selector_info("init", 5, (struct OPS *)sequence_of_record_line_stmt_ops);
        add_selector_info("line", 6, (struct OPS *)int_ops);
        add_selector_info("parms", 7, (struct OPS *)sequence_of_record_idns_type__ops);
        add_selector_info("sigs", 8, (struct OPS *)sequence_of_record_name_types_ops);
        add_selector_info("type_", 9, (struct OPS *)typespec_ops);
        add_selector_info("vals", 10, (struct OPS *)sequence_of_typespec_ops);
        add_selector_info("vars", 11, (struct OPS *)array_of_idn_ops);
        add_selector_info("where_", 12, (struct OPS *)sequence_of_record_idn_kind_line_ops);
        find_selector_ops("record", 13, &(record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops));
        add_parm_info_type(0, (const struct OPS *)record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops, p_list_of_t_reqs);
        find_prociter_instance(p_list, 1, &p_list_ownreqs, &(p_list_of_record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops));
        stringOPcons("parameter", CLU_1, CLUREF_make_num(9), &STR_parameter);
        stringOPcons("idn", CLU_1, CLUREF_make_num(3), &STR_idn);
        stringOPcons("IS idn_list in module header", CLU_1, CLUREF_make_num(28), &STR_IS_040idn_137list_040in_040module_040header);
        stringOPcons("operation", CLU_1, CLUREF_make_num(9), &STR_operation);
        stringOPcons("print", CLU_1, CLUREF_make_num(5), &STR_print);
        stringOPcons("pstream", CLU_1, CLUREF_make_num(7), &STR_pstream);
        stringOPcons("where ", CLU_1, CLUREF_make_num(6), &STR_where_040);
        stringOPcons(" has print: proctype(", CLU_1, CLUREF_make_num(21), &STR__040has_040print_072_040proctype_050);
        stringOPcons(", pstream)\n", CLU_1, CLUREF_make_num(11), &STR__054_040pstream_051_012);
        stringOPcons("debug_print = proc(_rep: cvt, ps: pstream)\n", CLU_1, CLUREF_make_num(43), &STR_debug_137print_040_075_040proc_050_137rep_072_040cvt_054_040ps_072_040pstream_051_012);
        stringOPcons(" print(up(_rep), ps)\n", CLU_1, CLUREF_make_num(21), &STR__040print_050up_050_137rep_051_054_040ps_051_012);
        stringOPcons(" end debug_print\n", CLU_1, CLUREF_make_num(17), &STR__040end_040debug_137print_012);
        stringOPcons("debug_print = proc(_rep: cvt, ps: pstream)\n rep$debug_print(_rep, ps)\n end debug_print\n", CLU_1, CLUREF_make_num(87), &STR_debug_137print_040_075_040proc_050_137rep_072_040cvt_054_040ps_072_040pstream_051_012_040rep_044debug_137print_050_137rep_054_040ps_051_012_040end_040debug_137print_012);
        p_typedefn_own_init = 1;
    }
    enter_proc(159);

  LINE(161);
    {
    CLUREF T_1_1;
    err = p_idn(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    id.num = T_1_1.num;
    }

  LINE(162);
    {
    CLUREF T_1_1;
    err = p_envOPget_line(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    line.num = T_1_1.num;
    }

  LINE(163);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(164);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(165);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_decl;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_blist_of_record_idns_type__ops->op_owns;
    generic_CLU_proc.proc = p_blist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_blist(e, T_1_1, CLU_true, STR_parameter, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    parms.num = T_1_2.num;
    }

  LINE(167);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 18: /* is_ */ {

  LINE(168);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(169);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = proctypeOPnew(CLU_0, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.proc->type_owns = NULL;
        T_2_1.proc->op_owns = NULL;
        T_2_1.proc->proc = p_idn1;
        err = proctypeOPnew(CLU_0, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_2.proc->proc = idnOPget_str;
        generic_CLU_proc.type_owns = NULL;
        generic_CLU_proc.op_owns = p_order_of_idn_ops->op_owns;
        generic_CLU_proc.proc = p_order;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_order(e, T_2_1, T_2_2, STR_idn, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        ops.num = T_2_3.num;
        }
        break;
    }
    default: {

  LINE(170);
        {
        err = p_envOPassume(e, STR_IS_040idn_137list_040in_040module_040header);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(171);
        {
        CLUREF T_2_1;
        err = sequenceOPnew(&T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ops.num = T_2_1.num;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(173);
    {
    CLUREF T_1_1;
    err = p_where(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    wher.num = T_1_1.num;
    }

  LINE(174);
    {
    err = p_semi(e);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(175);
    {
    CLUREF T_1_1;
    err = idnOPget_str(id, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = p_envOPset_clustr(e, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(176);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_equate;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_slist_of_equate_ops->op_owns;
    generic_CLU_proc.proc = p_slist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_slist(e, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    equates.num = T_1_2.num;
    }

  LINE(177);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_init;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_slist_of_record_line_stmt_ops->op_owns;
    generic_CLU_proc.proc = p_slist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_slist(e, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    inits.num = T_1_2.num;
    }

  LINE(178);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_operdefn;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_list_of_record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops->op_owns;
    generic_CLU_proc.proc = p_list;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_list(e, T_1_1, CLU_false, STR_operation, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    bod.num = T_1_2.num;
    }

  LINE(183);
    {
    found.tf = false;
    }

  LINE(185);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    wh.num = T_1_1.num;
    }

  LINE(189);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = bod.vec->size;
    T_1_3 = bod;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        each.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(190);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = each.vec->data[4];
        err = idnOPget_str(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_3.num = ((T_2_2.str->size != STR_print.str->size)? false :
            !(memcmp(T_2_2.str->data, STR_print.str->data, T_2_2.str->size)));
        if (T_2_3.num == true) { /* if */

  LINE(191);
            { /* if */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            CLUREF T_3_6;
            CLUREF T_3_7;
            CLUREF T_3_8;
            CLUREF T_3_9;
            CLUREF T_3_10;
            CLUREF T_3_11;
            CLUREF T_3_12;
            T_3_4.num = each.vec->data[7];
            err = sequenceOPempty(T_3_4, &T_3_5);
            if (err != ERR_ok)
                goto ex_0;
            T_3_3.num = T_3_5.num;
            if (T_3_5.num) {
                T_3_6.num = each.vec->data[10];
                err = sequenceOPempty(T_3_6, &T_3_7);
                if (err != ERR_ok)
                    goto ex_0;
                T_3_3.num = T_3_7.num;
            }
            T_3_2.num = T_3_3.num;
            if (T_3_3.num) {
                T_3_8.num = each.vec->data[8];
                err = sequenceOPempty(T_3_8, &T_3_9);
                if (err != ERR_ok)
                    goto ex_0;
                T_3_2.num = T_3_9.num;
            }
            T_3_1.num = T_3_2.num;
            if (T_3_2.num) {
                T_3_10.num = each.vec->data[0];
                T_3_11.num = T_3_10.vec->size;
                T_3_12.num = (T_3_11.num == 2);
                T_3_1.num = T_3_12.num;
            }
            if (T_3_1.num == true) { /* if */

  LINE(195);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = each.vec->data[0];
                if (1 < 1 || 1 > T_4_1.vec->size) {
                    err = ERR_bounds;
                    goto ex_0;
                }
                T_4_2.num = T_4_1.vec->data[1 - 1];
                arg1.num = T_4_2.num;
                }

  LINE(196);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = each.vec->data[0];
                if (2 < 1 || 2 > T_4_1.vec->size) {
                    err = ERR_bounds;
                    goto ex_0;
                }
                T_4_2.num = T_4_1.vec->data[2 - 1];
                arg2.num = T_4_2.num;
                }

  LINE(197);
                { /* if */
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                CLUREF T_4_4;
                CLUREF T_4_5;
                CLUREF T_4_6;
                CLUREF T_4_7;
                T_4_2.num = arg1.vec->data[0];
                T_4_3.num = T_4_2.vec->size;
                T_4_4.num = (T_4_3.num == 1);
                T_4_1.num = T_4_4.num;
                if (T_4_4.num) {
                    T_4_5.num = arg2.vec->data[0];
                    T_4_6.num = T_4_5.vec->size;
                    T_4_7.num = (T_4_6.num == 1);
                    T_4_1.num = T_4_7.num;
                }
                if (T_4_1.num == true) { /* if */

  LINE(199);
                    { /* qtagcase */
                    CLUREF T_5_1;
                    CLUREF T_5_2;
                    T_5_1.num = arg2.vec->data[1];
                    err = typespecOPget_abs(T_5_1, &T_5_2);
                    if (err != ERR_ok)
                        goto ex_0;
                    switch (T_5_2.cell->tag) {
                    case 5: /* idn */ {
                        CLUREF T_5_3;
                        T_5_3.num = T_5_2.cell->value;
                        i.num = T_5_3.num;

  LINE(201);
                        { /* if */
                        CLUREF T_6_1;
                        CLUREF T_6_2;
                        CLUREF T_6_3;
                        err = idnOPget_str(i, &T_6_1);
                        if (err != ERR_ok)
                            goto ex_0;
                        T_6_2.num = ((T_6_1.str->size != STR_pstream.str->size)? false :
                            !(memcmp(T_6_1.str->data, STR_pstream.str->data, T_6_1.str->size)));
                        T_6_3.num = !T_6_2.num;
                        if (T_6_3.num == true) { /* if */
                            goto end_inline_for_1;
                        }
                        } /* end if */
                        break;
                    }
                    default: {

  LINE(203);
                        goto end_inline_for_1;
                        break;
                    }
                    }
                    } /* end qtagcase */

  LINE(205);
                    { /* qtagcase */
                    CLUREF T_5_1;
                    CLUREF T_5_2;
                    T_5_1.num = arg1.vec->data[1];
                    err = typespecOPget_abs(T_5_1, &T_5_2);
                    if (err != ERR_ok)
                        goto ex_0;
                    switch (T_5_2.cell->tag) {
                    case 5: /* idn */ {
                        CLUREF T_5_3;
                        T_5_3.num = T_5_2.cell->value;
                        i.num = T_5_3.num;

  LINE(207);
                        { /* if */
                        CLUREF T_6_1;
                        CLUREF T_6_2;
                        CLUREF T_6_3;
                        err = idnOPget_str(i, &T_6_1);
                        if (err != ERR_ok)
                            goto ex_0;
                        err = idnOPget_str(id, &T_6_2);
                        if (err != ERR_ok)
                            goto ex_0;
                        T_6_3.num = ((T_6_1.str->size != T_6_2.str->size)? false :
                            !(memcmp(T_6_1.str->data, T_6_2.str->data, T_6_1.str->size)));
                        if (T_6_3.num == true) { /* if */

  LINE(208);
                            {
                            CLUREF T_7_1;
                            CellAlloc(2, nil, T_7_1);
                            form.num = T_7_1.num;
                            }
                        }
                        else { /* else */

  LINE(209);
                            goto end_inline_for_1;
                        }} /* end if */
                        break;
                    }
                    case 4: /* cvt_ */ {

  LINE(211);
                        {
                        CLUREF T_6_1;
                        CellAlloc(1, nil, T_6_1);
                        form.num = T_6_1.num;
                        }

  LINE(212);
                        {
                        CLUREF T_6_1;
                        T_6_1.num = each.vec->data[12];
                        wh.num = T_6_1.num;
                        }
                        break;
                    }
                    case 10: /* xclu */ {
                        CLUREF T_5_4;
                        T_5_4.num = T_5_2.cell->value;
                        x.num = T_5_4.num;

  LINE(214);
                        { /* if */
                        CLUREF T_6_1;
                        CLUREF T_6_2;
                        CLUREF T_6_3;
                        CLUREF T_6_4;
                        T_6_1.num = x.vec->data[0];
                        err = idnOPget_str(T_6_1, &T_6_2);
                        if (err != ERR_ok)
                            goto ex_0;
                        err = idnOPget_str(id, &T_6_3);
                        if (err != ERR_ok)
                            goto ex_0;
                        T_6_4.num = ((T_6_2.str->size != T_6_3.str->size)? false :
                            !(memcmp(T_6_2.str->data, T_6_3.str->data, T_6_2.str->size)));
                        if (T_6_4.num == true) { /* if */

  LINE(215);
                            {
                            CLUREF T_7_1;
                            CellAlloc(3, nil, T_7_1);
                            form.num = T_7_1.num;
                            }

  LINE(216);
                            {
                            CLUREF T_7_1;
                            T_7_1.num = each.vec->data[12];
                            wh.num = T_7_1.num;
                            }
                        }
                        else { /* else */

  LINE(217);
                            goto end_inline_for_1;
                        }} /* end if */
                        break;
                    }
                    default: {

  LINE(219);
                        goto end_inline_for_1;
                        break;
                    }
                    }
                    } /* end qtagcase */

  LINE(221);
                    {
                    found.tf = true;
                    }
                }
                } /* end if */

  LINE(223);
                goto end_inline_for_1;
            }
            } /* end if */
        }
        } /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(231);
    { /* if */
    if (found.num == true) { /* if */

  LINE(233);
        {
        wclause = CLU_empty_string;
        }

  LINE(234);
        { /* for sequence$elements */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_2.num = wh.vec->size;
        T_2_3 = wh;
        for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
            each_r.num = T_2_3.vec->data[T_2_1.num - 1];

  LINE(235);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            CLUREF T_3_6;
            CLUREF T_3_7;
            CLUREF T_3_8;
            CLUREF T_3_9;
            err = stringOPconcat(wclause, STR_where_040, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            T_3_2.num = each_r.vec->data[0];
            err = idnOPget_str(T_3_2, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_1, T_3_3, &T_3_4);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_4, STR__040has_040print_072_040proctype_050, &T_3_5);
            if (err != ERR_ok)
                goto ex_0;
            T_3_6.num = each_r.vec->data[0];
            err = idnOPget_str(T_3_6, &T_3_7);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_5, T_3_7, &T_3_8);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_8, STR__054_040pstream_051_012, &T_3_9);
            if (err != ERR_ok)
                goto ex_0;
            wclause.num = T_3_9.num;
            }
        }
        }
        end_inline_for_2:
        __CLU_END_LABEL;

  LINE(239);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = stringOPconcat(STR_debug_137print_040_075_040proc_050_137rep_072_040cvt_054_040ps_072_040pstream_051_012, wclause, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_1, STR__040print_050up_050_137rep_051_054_040ps_051_012, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_2, STR__040end_040debug_137print_012, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        apstr.num = T_2_3.num;
        }
    }
    else { /* else */

  LINE(244);
        {
        apstr = STR_debug_137print_040_075_040proc_050_137rep_072_040cvt_054_040ps_072_040pstream_051_012_040rep_044debug_137print_050_137rep_054_040ps_051_012_040end_040debug_137print_012;
        }
    }} /* end if */

  LINE(249);
    {
    CLUREF T_1_1;
    err = streamOPcreate_input(apstr, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    newst.num = T_1_1.num;
    }

  LINE(251);
    {
    CLUREF T_1_1;
    err = p_envOPpush(e, newst, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    e.num = T_1_1.num;
    }

  LINE(253);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_operdefn;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_list_of_record_args_body_equates_gen_idn_init_line_parms_sigs_type__vals_vars_where__ops->op_owns;
    generic_CLU_proc.proc = p_list;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_list(e, T_1_1, CLU_false, STR_operation, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    new.num = T_1_2.num;
    }

  LINE(256);
    {
    CLUREF T_1_1;
    err = p_envOPpop(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    e.num = T_1_1.num;
    }

  LINE(258);
    {
    CLUREF T_1_1;
    err = sequenceOPconcat(bod, new, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    bod.num = T_1_1.num;
    }

  LINE(262);
    {
    CLUREF T_1_1;
    err = idnOPget_str(id, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = p_defn_end(e, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(263);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(10, T_1_1);
    T_1_1.vec->data[3] = id.num;
    T_1_1.vec->data[7] = parms.num;
    err = p_envOPget_unknown_type(e, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[8] = T_1_2.num;
    err = p_envOPget_unknown_type(e, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[1] = T_1_3.num;
    T_1_1.vec->data[6] = ops.num;
    T_1_1.vec->data[9] = wher.num;
    T_1_1.vec->data[2] = equates.num;
    T_1_1.vec->data[4] = inits.num;
    T_1_1.vec->data[0] = bod.num;
    T_1_1.vec->data[5] = line.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_typedefn ****/



/**** BEGIN PROCEDURE p_equate ****/

extern errcode p_typeset();
extern errcode p_pathname();
extern errcode p_expr();
extern errcode p_envOPget_bad_expr();
extern errcode equateOPcreate();
static CLUREF STR_pathname;
static CLUREF STR_right_040side_040of_040equate;
static int p_equate_own_init = 0;

errcode
p_equate(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF id;
    CLUREF k;
    CLUREF i;
    CLUREF line;
    CLUREF val;
    CLUREF tk;
    if (p_equate_own_init == 0) {
        stringOPcons("pathname", CLU_1, CLUREF_make_num(8), &STR_pathname);
        stringOPcons("right side of equate", CLU_1, CLUREF_make_num(20), &STR_right_040side_040of_040equate);
        p_equate_own_init = 1;
    }
    enter_proc(277);

  LINE(279);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 16: /* idn */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(281);
        {
        id.num = k.num;
        }
        break;
    }
    case 38: /* typekey */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        k.num = T_1_3.num;

  LINE(283);
        { /* qtagcase */
        switch (k.cell->tag) {
        case 3: /* rep_ */ {
            CLUREF T_2_1;
            T_2_1.num = k.cell->value;
            i.num = T_2_1.num;

  LINE(285);
            {
            id.num = i.num;
            }
            break;
        }
        default: {

  LINE(287);
            { /* signal */
                signal(ERR_none);
            }
            break;
        }
        }
        } /* end qtagcase */
        break;
    }
    default: {

  LINE(290);
        { /* signal */
            signal(ERR_none);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(292);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPpeek(e, CLU_2, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 11: /* equal */ {
        break;
    }
    default: {

  LINE(294);
        { /* signal */
            signal(ERR_none);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(296);
    {
    CLUREF T_1_1;
    err = p_envOPpeek(e, CLU_3, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    k.num = T_1_1.num;
    }

  LINE(297);
    { /* qtagcase */
    switch (k.cell->tag) {
    case 4: /* defnkey */ {

  LINE(298);
        { /* signal */
            signal(ERR_none);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(301);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(302);
    {
    CLUREF T_1_1;
    err = p_envOPget_line(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    line.num = T_1_1.num;
    }

  LINE(303);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(305);
    { /* qtagcase */
    switch (k.cell->tag) {
    case 20: /* l_curly */ {

  LINE(307);
        {
        CLUREF T_3_1;
        err = p_envOPnext_token(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(308);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = p_typeset(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        CellAlloc(3, T_3_1.num, T_3_2);
        val.num = T_3_2.num;
        }
        break;
    }
    case 16: /* idn */ {
        CLUREF T_2_1;
        T_2_1.num = k.cell->value;
        tk.num = T_2_1.num;

  LINE(310);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = idnOPget_str(tk, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        T_3_2.num = ((STR_pathname.str->size != T_3_1.str->size)? false :
            !(memcmp(STR_pathname.str->data, T_3_1.str->data, STR_pathname.str->size)));
        if (T_3_2.num == true) { /* if */

  LINE(311);
            {
            CLUREF T_4_1;
            err = p_envOPnext_token(e, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            }

  LINE(312);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            err = p_pathname(e, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            CellAlloc(1, T_4_1.num, T_4_2);
            val.num = T_4_2.num;
            }
        }
        else { /* else */

  LINE(313);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            err = p_expr(e, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            CellAlloc(2, T_4_1.num, T_4_2);
            val.num = T_4_2.num;
            }
        }} /* end if */
        break;
    }
    default: {

  LINE(316);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = p_expr(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        CellAlloc(2, T_3_1.num, T_3_2);
        val.num = T_3_2.num;
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_none) {

  LINE(318);
        {
        err = p_envOPassume(e, STR_right_040side_040of_040equate);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(319);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = p_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        CellAlloc(2, T_2_1.num, T_2_2);
        val.num = T_2_2.num;
        }
    }
    else if (err == ERR_bad) {

  LINE(320);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = p_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        CellAlloc(2, T_2_1.num, T_2_2);
        val.num = T_2_2.num;
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(322);
    { /* return */
    {
    CLUREF T_1_1;
    err = equateOPcreate(id, val, line, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_equate ****/



/**** BEGIN PROCEDURE p_init ****/

extern errcode p_owninit();

errcode
p_init(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF k;
    CLUREF line;
    CLUREF di;
    enter_proc(327);

  LINE(328);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 34: /* stmtkey */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(330);
        { /* qtagcase */
        switch (k.cell->tag) {
        case 7: /* own_ */ {

  LINE(331);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        default: {

  LINE(332);
            { /* signal */
                signal(ERR_none);
            }
            break;
        }
        }
        } /* end qtagcase */
        break;
    }
    default: {

  LINE(335);
        { /* signal */
            signal(ERR_none);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(337);
    {
    CLUREF T_1_1;
    err = p_envOPget_line(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    line.num = T_1_1.num;
    }

  LINE(338);
    {
    CLUREF T_1_1;
    err = p_owninit(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    di.num = T_1_1.num;
    }

  LINE(339);
    { /* return */
    {
    CLUREF T_1_1;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[1] = di.num;
    T_1_1.vec->data[0] = line.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_init ****/



/**** BEGIN PROCEDURE p_operdefn ****/

struct OPS *p_slist_of_equate_ops __CLU_COMMON;
static CLUREF STR_equates_040legal_040only_040at_040start_040of_040cluster;
static int p_operdefn_own_init = 0;

errcode
p_operdefn(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF k;
    if (p_operdefn_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        stringOPcons("equates legal only at start of cluster", CLU_1, CLUREF_make_num(38), &STR_equates_040legal_040only_040at_040start_040of_040cluster);
        p_operdefn_own_init = 1;
    }
    enter_proc(343);

  LINE(345);
    for (;;) { /* while */
        CLUREF T_1_1;
        err = p_find_a_defn(e, CLU_true, &T_1_1);
        if (err != ERR_ok)
            goto ex_0;
        if (T_1_1.num != true)
            break;

  LINE(346);
        { /* qtagcase */
        CLUREF T_2_1;
        err = p_envOPpeek(e, CLU_3, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_1.cell->tag) {
        case 4: /* defnkey */ {
            CLUREF T_2_2;
            T_2_2.num = T_2_1.cell->value;
            k.num = T_2_2.num;

  LINE(348);
            { /* qtagcase */
            switch (k.cell->tag) {
            case 4: /* proc_ */ {

  LINE(349);
                { /* return */
                {
                CLUREF T_4_1;
                err = p_applydefn(e, &T_4_1);
                if (err != ERR_ok)
                    goto ex_0;
                ret_1->num = T_4_1.num;
                }
                signal (ERR_ok);
                }
                break;
            }
            case 3: /* iter_ */ {

  LINE(350);
                { /* return */
                {
                CLUREF T_4_1;
                err = p_applydefn(e, &T_4_1);
                if (err != ERR_ok)
                    goto ex_0;
                ret_1->num = T_4_1.num;
                }
                signal (ERR_ok);
                }
                break;
            }
            default: {

  LINE(351);
                { /* signal */
                    signal(ERR_none);
                }
                break;
            }
            }
            } /* end qtagcase */
            break;
        }
        default: {

  LINE(354);
            {
            err = p_envOPerr(e, STR_equates_040legal_040only_040at_040start_040of_040cluster, CLU_2);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(356);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = proctypeOPnew(CLU_0, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            T_3_1.proc->type_owns = NULL;
            T_3_1.proc->op_owns = NULL;
            T_3_1.proc->proc = p_equate;
            generic_CLU_proc.type_owns = NULL;
            generic_CLU_proc.op_owns = p_slist_of_equate_ops->op_owns;
            generic_CLU_proc.proc = p_slist;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = p_slist(e, T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        }
        } /* end qtagcase */
    }
    end_while_1:
    __CLU_END_LABEL;

  LINE(359);
    { /* signal */
        signal(ERR_none);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_operdefn ****/

