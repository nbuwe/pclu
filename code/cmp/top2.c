
/* This file was automatically generated by pclu. */

#include "pclu_err.h"
#include "pclu_sys.h"



/**** BEGIN PROCEDURE compile ****/

extern errcode setup_stuff();
extern errcode all_input_names();
extern errcode compile1();
extern errcode boolOPnot();
extern errcode recordOPget_13();
extern errcode arrayOPnew();
extern errcode recordOPget_10();
extern errcode xrefOPkeys();
extern errcode arrayOPelements();
extern errcode stringOPequal();
extern errcode arrayOPaddh();
extern errcode recordOPget_5();
extern errcode xrefOPadd_refs();
extern errcode xrefOPrem_refs();
extern errcode xrefOPoutput();
extern errcode cmpvarOPexternals();
static errcode compile_IB_1();
static errcode compile_IB_2();
static CLUREF STR_Undefined;
static CLUREF STR_Referencing_040Modules;
static CLUREF STR_External;
static int compile_own_init = 0;
typedef struct {
    errcode ecode2;
    errcode err;
    CLUREF e;
    CLUREF suffix;
    CLUREF allok;
    CLUREF fn;
    CLUREF allok1;
    CLUREF undefs;
    CLUREF new_exts;
    CLUREF names;
    CLUREF id;
    CLUREF oid;
    CLUREF exts;
    CLUREF mode;
    CLUREF args;
    CLUREF outst;
} compile_LOCALS_t;

errcode
compile(CLUREF mode, CLUREF args, CLUREF outst, CLUREF *ret_1)
{
    compile_LOCALS_t locals;
    locals.mode = mode;
    locals.args = args;
    locals.outst = outst;
    if (compile_own_init == 0) {
        stringOPcons("Undefined", CLU_1, CLUREF_make_num(9), &STR_Undefined);
        stringOPcons("Referencing Modules", CLU_1, CLUREF_make_num(19), &STR_Referencing_040Modules);
        stringOPcons("External", CLU_1, CLUREF_make_num(8), &STR_External);
        compile_own_init = 1;
    }
    enter_proc(7);

  LINE(8);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    locals.err = setup_stuff(locals.mode, locals.outst, &T_1_1, &T_1_2);
    if (locals.err != ERR_ok)
        goto ex_0;
    locals.e.num = T_1_1.num;
    locals.suffix.num = T_1_2.num;
    }

  LINE(9);
    {
    locals.allok.tf = true;
    }

  LINE(10);
    { /* for */
        locals.err = all_input_names(locals.args, locals.suffix, locals.outst, compile_IB_1, &locals, &locals.ecode2);

        if (locals.err == ERR_iterbodyreturn) {
            ret_1->num = elist[0].num;
            signal(ERR_ok);
        }
        if (locals.err == ERR_iterbodysignal)
            signal(locals.ecode2);
        if (locals.err == ERR_break)
            locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit)
            locals.err = locals.ecode2;
        if (locals.err != ERR_ok)
            goto ex_0;
    }

  LINE(16);
    {
    CLUREF T_1_1;
    T_1_1.num = locals.e.vec->data[12];
    locals.undefs.num = T_1_1.num;
    }

  LINE(17);
    {
    CLUREF T_1_1;
    locals.err = arrayOPnew(&T_1_1);
    if (locals.err != ERR_ok)
        goto ex_0;
    locals.new_exts.num = T_1_1.num;
    }

  LINE(18);
    {
    CLUREF T_1_1;
    T_1_1.num = locals.e.vec->data[9];
    locals.names.num = T_1_1.num;
    }

  LINE(19);
    { /* for */
        locals.err = xrefOPkeys(locals.undefs, compile_IB_2, &locals, &locals.ecode2);

        if (locals.err == ERR_iterbodyreturn) {
            ret_1->num = elist[0].num;
            signal(ERR_ok);
        }
        if (locals.err == ERR_iterbodysignal)
            signal(locals.ecode2);
        if (locals.err == ERR_break)
            locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit)
            locals.err = locals.ecode2;
        if (locals.err != ERR_ok)
            goto ex_0;
    }

  LINE(27);
    {
    CLUREF T_1_1;
    T_1_1.num = locals.e.vec->data[4];
    locals.exts.num = T_1_1.num;
    }

  LINE(28);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = locals.new_exts.array->ext_high;
    T_1_3 = locals.new_exts;
    for (T_1_1.num = locals.new_exts.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            locals.err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        locals.id.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(29);
        {
        CLUREF T_2_1;
        locals.err = xrefOPrem_refs(locals.undefs, locals.id, &T_2_1);
        if (locals.err != ERR_ok)
            goto ex_0;
        locals.err = xrefOPadd_refs(locals.exts, locals.id, T_2_1);
        if (locals.err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(31);
    { /* begin */

  LINE(33);
        {
        locals.err = xrefOPoutput(locals.undefs, STR_Undefined, STR_Referencing_040Modules, locals.outst);
        if (locals.err != ERR_ok)
            goto ex_1;
        }

  LINE(34);
        { /* if */
        CLUREF T_3_1;
        locals.err = cmpvarOPexternals(&T_3_1);
        if (locals.err != ERR_ok)
            goto ex_1;
        if (T_3_1.num == true) { /* if */

  LINE(36);
            {
            locals.err = xrefOPoutput(locals.exts, STR_External, STR_Referencing_040Modules, locals.outst);
            if (locals.err != ERR_ok)
                goto ex_1;
            }
        }
        } /* end if */
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (locals.err == ERR_not_possible) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(39);
    { /* return */
    {
    ret_1->num = locals.allok.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (locals.err != ERR_failure)
        elist[0] = _pclu_erstr(locals.err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE compile ****/


/**** BEGIN ITERATOR BODIES for compile ****/

static errcode
compile_IB_1(CLUREF iv_1, compile_LOCALS_t *locals, errcode *iecode)
{
    locals->fn.num = iv_1.num;
    enter_iter_body_proc(11);

  FB_LINE(11);
    {
    CLUREF T_1_1;
    locals->err = compile1(locals->e, locals->fn, &T_1_1);
    if (locals->err != ERR_ok)
        goto ex_0;
    locals->allok1.num = T_1_1.num;
    }

  FB_LINE(12);
    { /* if */
    CLUREF T_2_1;
    T_2_1.num = !locals->allok1.num;
    if (T_2_1.num == true) { /* if */
        {
        locals->allok.tf = false;
        }
    }
    } /* end if */
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (locals->err == ERR_not_possible) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

    signal(ERR_ok);
  ex_0:
    __CLU_EX_HANDLER;
    *iecode = locals->err;
    signal(ERR_iterbodyexit);
  end_0:
    __CLU_END_LABEL;
    signal(ERR_ok);
}

static errcode
compile_IB_2(CLUREF iv_1, compile_LOCALS_t *locals, errcode *iecode)
{
    locals->id.num = iv_1.num;
    enter_iter_body_proc(20);

  FB_LINE(20);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = locals->names.array->ext_high;
    T_1_3 = locals->names;
    for (T_1_1.num = locals->names.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            locals->err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        locals->oid.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  FB_LINE(21);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = ((locals->oid.str->size != locals->id.str->size)? false :
            !(memcmp(locals->oid.str->data, locals->id.str->data, locals->oid.str->size)));
        if (T_2_1.num == true) { /* if */

  FB_LINE(22);
            {
            {
            if ((locals->new_exts.array->int_low + locals->new_exts.array->ext_size + 1) < locals->new_exts.array->int_size) {
                locals->new_exts.array->store->data[locals->new_exts.array->int_low + locals->new_exts.array->ext_size] = locals->id.num;
                locals->new_exts.array->ext_size++;
                locals->new_exts.array->ext_high++;
            }
            else {
                locals->err = arrayOPaddh(locals->new_exts, locals->id);
                if (locals->err != ERR_ok)
                    goto ex_0;
            }
            }
            }

  FB_LINE(23);
            goto end_inline_for_2;
        }
        } /* end if */
    }
    }
    end_inline_for_2:
    __CLU_END_LABEL;

    signal(ERR_ok);
  ex_0:
    __CLU_EX_HANDLER;
    *iecode = locals->err;
    signal(ERR_iterbodyexit);
  end_0:
    __CLU_END_LABEL;
    signal(ERR_ok);
}

/**** END ITERATOR BODIES for compile ****/



/**** BEGIN PROCEDURE setup_stuff ****/

extern errcode cmpvarOPstuffs();
extern errcode intOPequal();
extern errcode ceOPflush_entries();
extern errcode recordOPget_1();
extern errcode ceOPreset();
extern errcode recordOPget_3();
extern errcode recordOPset_3();
extern errcode recordOPset_9();
extern errcode recordOPset_11();
extern errcode arrayOPtrim();
extern errcode xrefOPflush();
static CLUREF STR_spc;
static CLUREF STR_equ;
static CLUREF STR_clu;
static int setup_stuff_own_init = 0;

errcode
setup_stuff(CLUREF mode, CLUREF outst, CLUREF *ret_1, CLUREF *ret_2)
{
    errcode err;
    CLUREF e;
    if (setup_stuff_own_init == 0) {
        stringOPcons("spc", CLU_1, CLUREF_make_num(3), &STR_spc);
        stringOPcons("equ", CLU_1, CLUREF_make_num(3), &STR_equ);
        stringOPcons("clu", CLU_1, CLUREF_make_num(3), &STR_clu);
        setup_stuff_own_init = 1;
    }
    enter_proc(42);

  LINE(43);
    {
    CLUREF T_1_1;
    err = cmpvarOPstuffs(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    e.num = T_1_1.num;
    }

  LINE(44);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (mode.num == 5);
    if (T_1_1.num == true) { /* if */

  LINE(45);
        {
        CLUREF T_2_1;
        T_2_1.num = e.vec->data[0];
        err = ceOPflush_entries(T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(46);
        {
        CLUREF T_2_1;
        T_2_1.num = e.vec->data[0];
        err = ceOPreset(T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    else {

  LINE(47);
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = e.vec->data[2];
    T_1_3.num = !T_1_2.num;
    if (T_1_3.num == true) { /* elseif */

  LINE(48);
        {
        CLUREF T_2_1;
        T_2_1.num = e.vec->data[0];
        err = ceOPreset(T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }} /* end if */

  LINE(49);
    {
    e.vec->data[2] = false;
    }

  LINE(50);
    {
    e.vec->data[8] = mode.num;
    }

  LINE(51);
    {
    e.vec->data[10] = outst.num;
    }

  LINE(52);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[9];
    err = arrayOPtrim(T_1_1, CLU_1, CLU_0);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(53);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[4];
    err = xrefOPflush(T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(54);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[12];
    err = xrefOPflush(T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(55);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (mode.num == 4);
    if (T_1_1.num == true) { /* if */

  LINE(56);
        { /* return */
        {
        ret_1->num = e.num;
        }
        {
        ret_2->str = STR_spc.str;
        }
        signal (ERR_ok);
        }
    }
    else {

  LINE(57);
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_3.num = (mode.num == 5);
    T_1_2.num = T_1_3.num;
    if (!T_1_3.num) {
        T_1_4.num = (mode.num == 6);
        T_1_2.num = T_1_4.num;
    }
    if (T_1_2.num == true) { /* elseif */

  LINE(58);
        { /* return */
        {
        ret_1->num = e.num;
        }
        {
        ret_2->str = STR_equ.str;
        }
        signal (ERR_ok);
        }
    }
    else { /* else */

  LINE(59);
        { /* return */
        {
        ret_1->num = e.num;
        }
        {
        ret_2->str = STR_clu.str;
        }
        signal (ERR_ok);
        }
    }}} /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE setup_stuff ****/



/**** BEGIN PROCEDURE compile1 ****/

extern errcode run_time();
extern errcode reset_stuff();
extern errcode recordOPget_9();
extern errcode recordOPget_11();
extern errcode do_parse();
extern errcode do_check();
extern errcode do_specs();
extern errcode do_ce();
extern errcode do_compile();
extern errcode streamOPputs();
extern errcode streamOPputl();
extern errcode streamOPget_name();
extern errcode recordOPget_8();
extern errcode streamOPclose();
extern errcode _dir_ent_size();
extern errcode cmpvarOPdir();
extern errcode stringOPempty();
extern errcode file_nameOPget_dir();
extern errcode delete_file();
extern errcode file_nameOPcreate();
extern errcode stringOPsubstr();
extern errcode file_nameOPget_name();
extern errcode intOPsub();
extern errcode timeOPformat();
extern errcode timeOPsub();
static CLUREF STR_failure_072_040;
static CLUREF STR__137b_137;
static CLUREF STR_time_040_075_040;
static int compile1_own_init = 0;

errcode
compile1(CLUREF e, CLUREF fn, CLUREF *ret_1)
{
    errcode err;
    CLUREF time1;
    CLUREF allok;
    CLUREF mode;
    CLUREF outst;
    CLUREF s;
    CLUREF dez;
    CLUREF dname;
    CLUREF elapsed;
    if (compile1_own_init == 0) {
        stringOPcons("failure: ", CLU_1, CLUREF_make_num(9), &STR_failure_072_040);
        stringOPcons("_b_", CLU_1, CLUREF_make_num(3), &STR__137b_137);
        stringOPcons("time = ", CLU_1, CLUREF_make_num(7), &STR_time_040_075_040);
        compile1_own_init = 1;
    }
    enter_proc(62);

  LINE(63);
    {
    CLUREF T_1_1;
    err = run_time(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    time1.num = T_1_1.num;
    }

  LINE(64);
    {
    err = reset_stuff(e, fn);
    if (err != ERR_ok)
        goto ex_1;
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_open_failed) {

  LINE(65);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(67);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[8];
    mode.num = T_1_1.num;
    }

  LINE(68);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[10];
    outst.num = T_1_1.num;
    }

  LINE(69);
    { /* if */
    CLUREF T_2_1;
    T_2_1.num = (mode.num == 0);
    if (T_2_1.num == true) { /* if */

  LINE(70);
        {
        CLUREF T_3_1;
        err = do_parse(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        allok.num = T_3_1.num;
        }
    }
    else {

  LINE(71);
    CLUREF T_2_2;
    T_2_2.num = (mode.num == 1);
    if (T_2_2.num == true) { /* elseif */

  LINE(72);
        {
        CLUREF T_3_1;
        err = do_check(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        allok.num = T_3_1.num;
        }
    }
    else {

  LINE(73);
    CLUREF T_2_3;
    T_2_3.num = (mode.num == 4);
    if (T_2_3.num == true) { /* elseif */

  LINE(74);
        {
        CLUREF T_3_1;
        err = do_specs(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        allok.num = T_3_1.num;
        }
    }
    else {

  LINE(75);
    CLUREF T_2_4;
    CLUREF T_2_5;
    CLUREF T_2_6;
    T_2_5.num = (mode.num == 5);
    T_2_4.num = T_2_5.num;
    if (!T_2_5.num) {
        T_2_6.num = (mode.num == 6);
        T_2_4.num = T_2_6.num;
    }
    if (T_2_4.num == true) { /* elseif */

  LINE(76);
        {
        CLUREF T_3_1;
        err = do_ce(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        allok.num = T_3_1.num;
        }
    }
    else { /* else */

  LINE(77);
        {
        CLUREF T_3_1;
        err = do_compile(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        allok.num = T_3_1.num;
        }
    }}}}} /* end if */
    goto end_2;
  ex_2: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_failure) {
        s.num = elist[0].num;

  LINE(79);
        {
        allok.tf = false;
        }

  LINE(80);
        { /* begin */

  LINE(81);
            {
            err = streamOPputs(outst, STR_failure_072_040);
            if (err != ERR_ok)
                goto ex_3;
            }

  LINE(82);
            {
            err = streamOPputl(outst, s);
            if (err != ERR_ok)
                goto ex_3;
            }
        }
        goto end_3;
      ex_3: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_not_possible) {
        }
        else { /* not handled */
            goto ex_0;
        }
      end_3:;
    }
    else { /* not handled */
        goto ex_0;
    }
  end_2:;

  LINE(85);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[7];
    err = streamOPget_name(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    fn.num = T_1_2.num;
    }

  LINE(86);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[7];
    err = streamOPclose(T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(87);
    {
    CLUREF T_1_1;
    err = _dir_ent_size(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    dez.num = T_1_1.num;
    }

  LINE(88);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = allok.num;
    if (allok.num) {
        T_1_2.num = (mode.num == 3);
        T_1_1.num = T_1_2.num;
    }
    if (T_1_1.num == true) { /* if */
    }
    else {

  LINE(113);
    CLUREF T_1_3;
    T_1_3.num = (mode.num == 3);
    if (T_1_3.num == true) { /* elseif */

  LINE(114);
        {
        CLUREF T_2_1;
        err = cmpvarOPdir(&T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        dname.num = T_2_1.num;
        }

  LINE(115);
        { /* if */
        CLUREF T_2_1;
        err = stringOPempty(dname, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        if (T_2_1.num == true) { /* if */

  LINE(116);
            {
            CLUREF T_3_1;
            err = file_nameOPget_dir(fn, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            dname.num = T_3_1.num;
            }
        }
        } /* end if */

  LINE(117);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        err = file_nameOPget_name(fn, &T_3_1);
        if (err != ERR_ok)
            goto ex_4;
        T_3_2.num = dez.num - 4;
        if ((T_3_2.num >= 0 && dez.num < 0 && (-4) < 0) ||
            (T_3_2.num <= 0 && dez.num > 0 && (-4) > 0)) {
            err = ERR_overflow;
            goto ex_4;
        }
        err = stringOPsubstr(T_3_1, CLU_1, T_3_2, &T_3_3);
        if (err != ERR_ok)
            goto ex_4;
        err = file_nameOPcreate(dname, T_3_3, STR__137b_137, CLU_empty_string, &T_3_4);
        if (err != ERR_ok)
            goto ex_4;
        err = delete_file(T_3_4);
        if (err != ERR_ok)
            goto ex_4;
        }
        goto end_4;
      ex_4: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_not_possible) {
        }
        else { /* not handled */
            goto ex_0;
        }
      end_4:;
    }
    }} /* end if */

  LINE(123);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = run_time(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = timeOPsub(T_1_1, time1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    err = timeOPformat(T_1_2, CLU_3, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    elapsed.num = T_1_3.num;
    }

  LINE(124);
    { /* begin */

  LINE(126);
        {
        err = streamOPputs(outst, STR_time_040_075_040);
        if (err != ERR_ok)
            goto ex_5;
        }

  LINE(127);
        {
        err = streamOPputl(outst, elapsed);
        if (err != ERR_ok)
            goto ex_5;
        }
    }
    goto end_5;
  ex_5: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_5:;

  LINE(129);
    { /* return */
    {
    ret_1->num = allok.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE compile1 ****/



/**** BEGIN PROCEDURE reset_stuff ****/

extern errcode open_stream();
extern errcode oneofOPvalue_2();
extern errcode recordOPget_7();
extern errcode g_envOPget_space();
extern errcode g_envOPget_time();
extern errcode streamOPputc();
extern errcode file_nameOPunparse();
extern errcode file_nameOPparse();
extern errcode nul_dev();
extern errcode p_envOPreset();
extern errcode recordOPget_12();
extern errcode c_envOPreset();
extern errcode recordOPget_4();
extern errcode g_envOPreset();
extern errcode recordOPset_8();
static CLUREF STR_read;
static CLUREF STR_Parsing;
static CLUREF STR_Checking;
static CLUREF STR_Optimizing;
static CLUREF STR_Compiling;
static CLUREF STR_Creating_040DU_040specs_040from;
static CLUREF STR_Adding_040to_040CE_040from;
static int reset_stuff_own_init = 0;

errcode
reset_stuff(CLUREF e, CLUREF infn)
{
    errcode err;
    CLUREF outst;
    CLUREF mode;
    CLUREF inst;
    CLUREF ge;
    CLUREF outfn;
    CLUREF dname;
    CLUREF comp;
    CLUREF src;
    if (reset_stuff_own_init == 0) {
        stringOPcons("read", CLU_1, CLUREF_make_num(4), &STR_read);
        stringOPcons("Parsing", CLU_1, CLUREF_make_num(7), &STR_Parsing);
        stringOPcons("Checking", CLU_1, CLUREF_make_num(8), &STR_Checking);
        stringOPcons("Optimizing", CLU_1, CLUREF_make_num(10), &STR_Optimizing);
        stringOPcons("Compiling", CLU_1, CLUREF_make_num(9), &STR_Compiling);
        stringOPcons("Creating DU specs from", CLU_1, CLUREF_make_num(22), &STR_Creating_040DU_040specs_040from);
        stringOPcons("Adding to CE from", CLU_1, CLUREF_make_num(17), &STR_Adding_040to_040CE_040from);
        stringOPcons("_b_", CLU_1, CLUREF_make_num(3), &STR__137b_137);
        reset_stuff_own_init = 1;
    }
    enter_proc(132);

  LINE(133);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[10];
    outst.num = T_1_1.num;
    }

  LINE(134);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[8];
    mode.num = T_1_1.num;
    }

  LINE(135);
    {
    CLUREF T_2_1;
    err = open_stream(infn, STR_read, outst, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    inst.num = T_2_1.num;
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_open_failed) {

  LINE(136);
        { /* signal */
            signal(ERR_open_failed);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(137);
    { /* begin */

  LINE(139);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = (mode.num == 0);
        if (T_3_1.num == true) { /* if */

  LINE(140);
            {
            err = streamOPputs(outst, STR_Parsing);
            if (err != ERR_ok)
                goto ex_2;
            }
        }
        else {

  LINE(141);
        CLUREF T_3_2;
        T_3_2.num = (mode.num == 1);
        if (T_3_2.num == true) { /* elseif */

  LINE(142);
            {
            err = streamOPputs(outst, STR_Checking);
            if (err != ERR_ok)
                goto ex_2;
            }
        }
        else {

  LINE(143);
        CLUREF T_3_3;
        T_3_3.num = (mode.num == 3);
        if (T_3_3.num == true) { /* elseif */

  LINE(144);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = e.vec->data[6];
            if (T_4_1.cell->tag != 2) {
                err = ERR_wrong_tag;
                goto ex_2;
            }
            T_4_2.num = T_4_1.cell->value;
            ge.num = T_4_2.num;
            }

  LINE(145);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            err = g_envOPget_space(ge, &T_4_2);
            if (err != ERR_ok)
                goto ex_2;
            T_4_1.num = T_4_2.num;
            if (!T_4_2.num) {
                err = g_envOPget_time(ge, &T_4_3);
                if (err != ERR_ok)
                    goto ex_2;
                T_4_1.num = T_4_3.num;
            }
            if (T_4_1.num == true) { /* if */

  LINE(146);
                {
                err = streamOPputs(outst, STR_Optimizing);
                if (err != ERR_ok)
                    goto ex_2;
                }
            }
            else { /* else */

  LINE(147);
                {
                err = streamOPputs(outst, STR_Compiling);
                if (err != ERR_ok)
                    goto ex_2;
                }
            }} /* end if */
        }
        else {

  LINE(149);
        CLUREF T_3_4;
        T_3_4.num = (mode.num == 4);
        if (T_3_4.num == true) { /* elseif */

  LINE(150);
            {
            err = streamOPputs(outst, STR_Creating_040DU_040specs_040from);
            if (err != ERR_ok)
                goto ex_2;
            }
        }
        else { /* else */

  LINE(151);
            {
            err = streamOPputs(outst, STR_Adding_040to_040CE_040from);
            if (err != ERR_ok)
                goto ex_2;
            }
        }}}}} /* end if */

  LINE(153);
        {
        CLUREF T_3_1;
        T_3_1.ch = ' ';
        err = streamOPputc(outst, T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        }

  LINE(154);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = streamOPget_name(inst, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        err = file_nameOPunparse(T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_2;
        err = streamOPputl(outst, T_3_2);
        if (err != ERR_ok)
            goto ex_2;
        }
    }
    goto end_2;
  ex_2: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_2:;

  LINE(159);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (mode.num == 3);
    if (T_1_1.num == true) { /* if */

  LINE(160);
        {
        CLUREF T_2_1;
        err = cmpvarOPdir(&T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        dname.num = T_2_1.num;
        }

  LINE(161);
        { /* if */
        CLUREF T_2_1;
        err = stringOPempty(dname, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        if (T_2_1.num == true) { /* if */

  LINE(162);
            {
            CLUREF T_3_1;
            err = file_nameOPget_dir(infn, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            dname.num = T_3_1.num;
            }
        }
        } /* end if */

  LINE(163);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        err = file_nameOPget_name(infn, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = _dir_ent_size(&T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_3.num = T_2_2.num - 4;
        if ((T_2_3.num >= 0 && T_2_2.num < 0 && (-4) < 0) ||
            (T_2_3.num <= 0 && T_2_2.num > 0 && (-4) > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        err = stringOPsubstr(T_2_1, CLU_1, T_2_3, &T_2_4);
        if (err != ERR_ok)
            goto ex_0;
        err = file_nameOPcreate(dname, T_2_4, STR__137b_137, CLU_empty_string, &T_2_5);
        if (err != ERR_ok)
            goto ex_0;
        outfn.num = T_2_5.num;
        }
    }
    else { /* else */

  LINE(167);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = nul_dev(&T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = file_nameOPparse(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        outfn.num = T_2_2.num;
        }
    }} /* end if */

  LINE(169);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[0];
    comp.num = T_1_1.num;
    }

  LINE(170);
    {
    CLUREF T_1_1;
    err = file_nameOPunparse(infn, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    src.num = T_1_1.num;
    }

  LINE(171);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[11];
    err = p_envOPreset(T_1_1, comp, outst, inst, src);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(172);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[3];
    err = c_envOPreset(T_1_1, comp, outst, src);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(173);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[6];
    switch (T_1_1.cell->tag) {
    case 2: /* one */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        ge.num = T_1_2.num;

  LINE(175);
        {
        err = g_envOPreset(ge, comp, outst, outfn, infn);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(178);
    {
    e.vec->data[7] = inst.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE reset_stuff ****/



/**** BEGIN PROCEDURE do_parse ****/

extern errcode parse_one();
extern errcode intOPgt();

errcode
do_parse(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF allok;
    CLUREF def;
    CLUREF ok;
    enter_proc(181);

  LINE(182);
    {
    allok.tf = true;
    }

  LINE(183);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(184);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = parse_one(e, &T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        def.num = T_3_1.num;
        ok.num = T_3_2.num;
        }
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_eof) {

  LINE(185);
            { /* return */
            {
            ret_1->num = allok.num;
            }
            signal (ERR_ok);
            }
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;

  LINE(186);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = (ok.num > 0);
        if (T_2_1.num == true) { /* if */

  LINE(187);
            {
            allok.tf = false;
            }
        }
        } /* end if */
    }
    end_while_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE do_parse ****/



/**** BEGIN PROCEDURE do_check ****/

extern errcode intOPlt();
extern errcode check_one();

errcode
do_check(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF allok;
    CLUREF def;
    CLUREF ok;
    enter_proc(191);

  LINE(192);
    {
    allok.tf = true;
    }

  LINE(193);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(194);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = parse_one(e, &T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        def.num = T_3_1.num;
        ok.num = T_3_2.num;
        }
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_eof) {

  LINE(195);
            { /* return */
            {
            ret_1->num = allok.num;
            }
            signal (ERR_ok);
            }
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;

  LINE(196);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_2.num = (ok.num < 2);
        T_2_1.num = T_2_2.num;
        if (T_2_2.num) {
            T_2_3.num = (ok.num == 0);
            err = check_one(e, def, T_2_3, &T_2_4);
            if (err != ERR_ok)
                goto ex_0;
            T_2_1.num = T_2_4.num;
        }
        T_2_5.num = !T_2_1.num;
        if (T_2_5.num == true) { /* if */

  LINE(197);
            {
            allok.tf = false;
            }
        }
        } /* end if */
    }
    end_while_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE do_check ****/



/**** BEGIN PROCEDURE do_compile ****/

extern errcode cmpvarOPmodules();
extern errcode cmpvarOPallow();
extern errcode idnOPget_str();
extern errcode stringOPindexs();
extern errcode stringOPconcat();
extern errcode generate_one();
extern errcode g_envOPend_all();
extern errcode g_envOPget_err();
extern errcode cc_one();
extern errcode g_envOPreset_err();
static CLUREF STR__012;
static CLUREF STR__040already_040defined_012;
static int do_compile_own_init = 0;

errcode
do_compile(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF lst;
    CLUREF allok;
    CLUREF onedef_found;
    CLUREF allow;
    CLUREF def;
    CLUREF ok;
    CLUREF mod;
    CLUREF apd;
    CLUREF td;
    CLUREF ge;
    if (do_compile_own_init == 0) {
        stringOPcons("\n", CLU_1, CLUREF_make_num(1), &STR__012);
        stringOPcons(" already defined\n", CLU_1, CLUREF_make_num(17), &STR__040already_040defined_012);
        do_compile_own_init = 1;
    }
    enter_proc(201);

  LINE(202);
    {
    CLUREF T_1_1;
    err = cmpvarOPmodules(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    lst.num = T_1_1.num;
    }

  LINE(203);
    {
    allok.tf = true;
    }

  LINE(204);
    {
    onedef_found.tf = false;
    }

  LINE(205);
    {
    CLUREF T_1_1;
    err = cmpvarOPallow(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    allow.num = T_1_1.num;
    }

  LINE(206);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(207);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = parse_one(e, &T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        def.num = T_3_1.num;
        ok.num = T_3_2.num;
        }

  LINE(208);
        {
        onedef_found.tf = true;
        }

  LINE(209);
        {
        mod = CLU_empty_string;
        }

  LINE(210);
        { /* qtagcase */
        switch (def.cell->tag) {
        case 1: /* apply */ {
            CLUREF T_3_1;
            T_3_1.num = def.cell->value;
            apd.num = T_3_1.num;

  LINE(212);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = apd.vec->data[4];
            err = idnOPget_str(T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            mod.num = T_4_2.num;
            }
            break;
        }
        case 3: /* cluster_ */ {
            CLUREF T_3_2;
            T_3_2.num = def.cell->value;
            td.num = T_3_2.num;

  LINE(214);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = td.vec->data[3];
            err = idnOPget_str(T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            mod.num = T_4_2.num;
            }
            break;
        }
        }
        } /* end qtagcase */

  LINE(217);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        CLUREF T_4_4;
        CLUREF T_4_5;
        CLUREF T_4_6;
        CLUREF T_4_7;
        CLUREF T_4_8;
        CLUREF T_4_9;
        CLUREF T_4_10;
        err = stringOPempty(mod, &T_4_3);
        if (err != ERR_ok)
            goto ex_2;
        T_4_4.num = !T_4_3.num;
        T_4_2.num = T_4_4.num;
        if (T_4_4.num) {
            err = stringOPempty(lst, &T_4_5);
            if (err != ERR_ok)
                goto ex_2;
            T_4_6.num = !T_4_5.num;
            T_4_2.num = T_4_6.num;
        }
        T_4_1.num = T_4_2.num;
        if (T_4_2.num) {
            err = stringOPconcat(STR__012, mod, &T_4_7);
            if (err != ERR_ok)
                goto ex_2;
            err = stringOPconcat(T_4_7, STR__012, &T_4_8);
            if (err != ERR_ok)
                goto ex_2;
            err = stringOPindexs(T_4_8, lst, &T_4_9);
            if (err != ERR_ok)
                goto ex_2;
            T_4_10.num = (T_4_9.num > 0);
            T_4_1.num = T_4_10.num;
        }
        if (T_4_1.num == true) { /* if */

  LINE(219);
            {
            CLUREF T_5_1;
            T_5_1.num = e.vec->data[10];
            err = streamOPputs(T_5_1, mod);
            if (err != ERR_ok)
                goto ex_2;
            }

  LINE(220);
            {
            CLUREF T_5_1;
            T_5_1.num = e.vec->data[10];
            err = streamOPputl(T_5_1, STR__040already_040defined_012);
            if (err != ERR_ok)
                goto ex_2;
            }
        }
        } /* end if */
        goto end_2;
      ex_2: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_not_possible) {
        }
        else { /* not handled */
            goto ex_1;
        }
      end_2:;

  LINE(222);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        T_3_2.num = (ok.num < 2);
        T_3_1.num = T_3_2.num;
        if (T_3_2.num) {
            T_3_4.num = (ok.num == 0);
            err = check_one(e, def, T_3_4, &T_3_5);
            if (err != ERR_ok)
                goto ex_1;
            T_3_3.num = T_3_5.num;
            if (!T_3_5.num) {
                T_3_3.num = allow.num;
            }
            T_3_1.num = T_3_3.num;
        }
        if (T_3_1.num == true) { /* if */

  LINE(224);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            T_4_2.num = allok.num;
            if (allok.num) {
                err = generate_one(e, def, &T_4_3);
                if (err != ERR_ok)
                    goto ex_1;
                T_4_2.num = T_4_3.num;
            }
            T_4_1.num = T_4_2.num;
            if (T_4_2.num) {
                T_4_4.num = (ok.num == 0);
                T_4_1.num = T_4_4.num;
            }
            allok.num = T_4_1.num;
            }
        }
        else { /* else */

  LINE(227);
            {
            allok.tf = false;
            }
        }} /* end if */
    }
    end_while_1:
    __CLU_END_LABEL;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_eof) {

  LINE(230);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = !onedef_found.num;
        if (T_2_1.num == true) { /* if */
            {
            allok.tf = false;
            }
        }
        } /* end if */
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(232);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[6];
    if (T_1_1.cell->tag != 2) {
        err = ERR_wrong_tag;
        goto ex_0;
    }
    T_1_2.num = T_1_1.cell->value;
    ge.num = T_1_2.num;
    }

  LINE(233);
    {
    err = g_envOPend_all(ge);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(234);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = allok.num;
    if (allok.num) {
        err = g_envOPget_err(ge, &T_1_2);
        if (err != ERR_ok)
            goto ex_0;
        T_1_3.num = (T_1_2.num == 0);
        T_1_1.num = T_1_3.num;
    }
    allok.num = T_1_1.num;
    }

  LINE(235);
    { /* if */
    if (allok.num == true) { /* if */
        {
        err = cc_one(ge);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(236);
    {
    err = g_envOPreset_err(ge);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(237);
    { /* return */
    {
    ret_1->num = allok.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE do_compile ****/



/**** BEGIN PROCEDURE do_specs ****/

extern errcode arrayOPcreate();
extern errcode xrefOPcreate();
extern errcode recordOPset_5();
extern errcode recordOPset_6();
extern errcode sequenceOPnew();
extern errcode recordOPset_2();
extern errcode sequenceOPelements();
extern errcode specs_one();
extern errcode install_specs();
extern errcode xrefOPmerge();
extern errcode arrayOPsize();
extern errcode setup_specs_pass2();
extern errcode p_envOPhack();
extern errcode p_envOPunhack();
extern errcode boolOPand();

errcode
do_specs(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF allok1;
    CLUREF allok2;
    CLUREF mdefs;
    CLUREF def;
    CLUREF ok;
    CLUREF md;
    CLUREF exts;
    CLUREF xtemp;
    CLUREF d;
    CLUREF dd;
    enter_proc(240);

  LINE(241);
    {
    allok1.tf = true;
    }

  LINE(242);
    {
    allok2.tf = true;
    }

  LINE(243);
    {
    CLUREF T_1_1;
    err = arrayOPcreate(CLU_1, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    mdefs.num = T_1_1.num;
    }

  LINE(247);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[4];
    exts.num = T_1_1.num;
    }

  LINE(248);
    {
    CLUREF T_1_1;
    err = xrefOPcreate(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    xtemp.num = T_1_1.num;
    }

  LINE(249);
    {
    e.vec->data[4] = xtemp.num;
    }

  LINE(250);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(251);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = parse_one(e, &T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        def.num = T_3_1.num;
        ok.num = T_3_2.num;
        }

  LINE(252);
        { /* qtagcase */
        switch (def.cell->tag) {
        case 1: /* apply */ {
            CLUREF T_3_1;
            T_3_1.num = def.cell->value;
            d.num = T_3_1.num;

  LINE(254);
            {
            CLUREF T_4_1;
            err = sequenceOPnew(&T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            d.vec->data[5] = T_4_1.num;
            }

  LINE(255);
            {
            CLUREF T_4_1;
            err = sequenceOPnew(&T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            d.vec->data[1] = T_4_1.num;
            }
            break;
        }
        case 3: /* cluster_ */ /* FALLTHROUGH */
        case 5: /* selector_ */ /* FALLTHROUGH */
        case 2: /* atype */ {
            CLUREF T_3_2;
            T_3_2.num = def.cell->value;
            d.num = T_3_2.num;

  LINE(257);
            {
            CLUREF T_4_1;
            err = sequenceOPnew(&T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            d.vec->data[4] = T_4_1.num;
            }

  LINE(258);
            { /* for sequence$elements */
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            T_4_1.num = d.vec->data[0];
            T_4_3.num = T_4_1.vec->size;
            T_4_4 = T_4_1;
            for (T_4_2.num = 1; T_4_2.num <= T_4_3.num; T_4_2.num++) {
                dd.num = T_4_4.vec->data[T_4_2.num - 1];

  LINE(259);
                {
                CLUREF T_5_1;
                err = sequenceOPnew(&T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                dd.vec->data[5] = T_5_1.num;
                }

  LINE(260);
                {
                CLUREF T_5_1;
                err = sequenceOPnew(&T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                dd.vec->data[1] = T_5_1.num;
                }
            }
            }
            end_inline_for_1:
            __CLU_END_LABEL;
            break;
        }
        }
        } /* end qtagcase */

  LINE(264);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = (ok.num == 0);
        if (T_3_1.num == true) { /* if */

  LINE(265);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            err = specs_one(e, def, &T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            ok.num = T_4_1.num;
            md.num = T_4_2.num;
            }

  LINE(266);
            { /* if */
            CLUREF T_4_1;
            T_4_1.num = (ok.num == 0);
            if (T_4_1.num == true) { /* if */

  LINE(267);
                {
                allok1.tf = false;
                }
            }
            else {

  LINE(268);
            CLUREF T_4_2;
            T_4_2.num = (ok.num == 2);
            if (T_4_2.num == true) { /* elseif */

  LINE(269);
                {
                {
                if ((mdefs.array->int_low + mdefs.array->ext_size + 1) < mdefs.array->int_size) {
                    mdefs.array->store->data[mdefs.array->int_low + mdefs.array->ext_size] = md.num;
                    mdefs.array->ext_size++;
                    mdefs.array->ext_high++;
                }
                else {
                    err = arrayOPaddh(mdefs, md);
                    if (err != ERR_ok)
                        goto ex_1;
                }
                }
                }

  LINE(270);
                {
                err = xrefOPflush(xtemp);
                if (err != ERR_ok)
                    goto ex_1;
                }
            }
            else {

  LINE(271);
            CLUREF T_4_3;
            T_4_3.num = (ok.num == 3);
            if (T_4_3.num == true) { /* elseif */

  LINE(272);
                {
                err = install_specs(md);
                if (err != ERR_ok)
                    goto ex_1;
                }
            }
            }}} /* end if */
        }
        else { /* else */

  LINE(273);
            {
            allok1.tf = false;
            }

  LINE(274);
            { /* if */
            CLUREF T_4_1;
            T_4_1.num = (ok.num == 1);
            if (T_4_1.num == true) { /* if */

  LINE(275);
                {
                CLUREF T_5_1;
                err = check_one(e, def, CLU_false, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                }
            }
            } /* end if */
        }} /* end if */

  LINE(277);
        {
        err = xrefOPmerge(exts, xtemp);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(278);
        {
        err = xrefOPflush(xtemp);
        if (err != ERR_ok)
            goto ex_1;
        }
    }
    end_while_1:
    __CLU_END_LABEL;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_eof) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(280);
    {
    e.vec->data[4] = exts.num;
    }

  LINE(281);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = mdefs.array->ext_size;
    T_1_2.num = (T_1_1.num == 0);
    if (T_1_2.num == true) { /* if */

  LINE(282);
        { /* return */
        {
        ret_1->num = allok1.num;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(283);
    {
    err = setup_specs_pass2(e, mdefs);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(284);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = mdefs.array->ext_high;
    T_1_3 = mdefs;
    for (T_1_1.num = mdefs.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        md.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(285);
        {
        CLUREF T_2_1;
        T_2_1.num = md.vec->data[0];
        def.num = T_2_1.num;
        }

  LINE(286);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = md.vec->data[2];
        if (T_2_1.num == true) { /* if */

  LINE(287);
            {
            CLUREF T_3_1;
            T_3_1.num = e.vec->data[11];
            err = p_envOPhack(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        else { /* else */

  LINE(288);
            {
            CLUREF T_3_1;
            T_3_1.num = e.vec->data[11];
            err = p_envOPunhack(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
        }} /* end if */

  LINE(290);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = specs_one(e, def, &T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        ok.num = T_2_1.num;
        md.num = T_2_2.num;
        }

  LINE(291);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = (ok.num == 0);
        if (T_2_1.num == true) { /* if */

  LINE(292);
            {
            allok2.tf = false;
            }
        }
        else { /* else */

  LINE(293);
            {
            err = install_specs(md);
            if (err != ERR_ok)
                goto ex_0;
            }
        }} /* end if */
    }
    }
    end_inline_for_2:
    __CLU_END_LABEL;

  LINE(296);
    { /* return */
    {
    CLUREF T_1_1;
    err = boolOPand(allok1, allok2, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE do_specs ****/



/**** BEGIN PROCEDURE setup_specs_pass2 ****/

extern errcode ceOPreset1();
extern errcode oneofOPmake_8();
extern errcode idnOPset_kind();
extern errcode equateOPget_idn();
extern errcode f_duspecs();
extern errcode duOPset_mspecs();
extern errcode recordOPget_2();

errcode
setup_specs_pass2(CLUREF e, CLUREF mdefs)
{
    errcode err;
    CLUREF uk;
    CLUREF md;
    CLUREF eqs;
    CLUREF eq;
    CLUREF ms;
    enter_proc(299);

  LINE(300);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[0];
    err = ceOPreset1(T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(301);
    {
    CLUREF T_1_1;
    CellAlloc(8, nil, T_1_1);
    uk.num = T_1_1.num;
    }

  LINE(302);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = mdefs.array->ext_high;
    T_1_3 = mdefs;
    for (T_1_1.num = mdefs.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        md.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(303);
        { /* qtagcase */
        CLUREF T_2_1;
        T_2_1.num = md.vec->data[0];
        switch (T_2_1.cell->tag) {
        case 4: /* equates */ {
            CLUREF T_2_2;
            T_2_2.num = T_2_1.cell->value;
            eqs.num = T_2_2.num;

  LINE(305);
            { /* for sequence$elements */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_2.num = eqs.vec->size;
            T_3_3 = eqs;
            for (T_3_1.num = 1; T_3_1.num <= T_3_2.num; T_3_1.num++) {
                eq.num = T_3_3.vec->data[T_3_1.num - 1];

  LINE(306);
                {
                CLUREF T_4_1;
                err = equateOPget_idn(eq, &T_4_1);
                if (err != ERR_ok)
                    goto ex_0;
                err = idnOPset_kind(T_4_1, uk);
                if (err != ERR_ok)
                    goto ex_0;
                }
            }
            }
            end_inline_for_2:
            __CLU_END_LABEL;
            break;
        }
        default: {

  LINE(309);
            { /* qtagcase */
            CLUREF T_3_1;
            T_3_1.num = md.vec->data[3];
            switch (T_3_1.cell->tag) {
            case 2: /* specs */ {
                CLUREF T_3_2;
                T_3_2.num = T_3_1.cell->value;
                ms.num = T_3_2.num;

  LINE(311);
                {
                CLUREF T_4_1;
                T_4_1.num = e.vec->data[3];
                err = f_duspecs(T_4_1, ms, CLU_false);
                if (err != ERR_ok)
                    goto ex_0;
                }
                break;
            }
            }
            } /* end qtagcase */

  LINE(314);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = md.vec->data[1];
            T_3_2.num = md.vec->data[3];
            err = duOPset_mspecs(T_3_1, T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        }
        } /* end qtagcase */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE setup_specs_pass2 ****/



/**** BEGIN PROCEDURE install_specs ****/

extern errcode duOPadd_specs();

errcode
install_specs(CLUREF md)
{
    errcode err;
    CLUREF gen;
    CLUREF specs;
    CLUREF ds;
    enter_proc(319);

  LINE(320);
    {
    CLUREF T_1_1;
    T_1_1.num = md.vec->data[1];
    gen.num = T_1_1.num;
    }

  LINE(321);
    {
    CLUREF T_1_1;
    T_1_1.num = md.vec->data[3];
    specs.num = T_1_1.num;
    }

  LINE(322);
    {
    err = duOPset_mspecs(gen, specs);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(323);
    { /* qtagcase */
    switch (specs.cell->tag) {
    case 2: /* specs */ {
        CLUREF T_1_1;
        T_1_1.num = specs.cell->value;
        ds.num = T_1_1.num;

  LINE(325);
        {
        err = duOPadd_specs(gen, ds);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE install_specs ****/



/**** BEGIN PROCEDURE specs_one ****/

extern errcode check_one1();
extern errcode c_envOPget_proc_();
extern errcode c_module_idn();
extern errcode duOPget_mspecs();
extern errcode oneofOPmake_1();
extern errcode c_envOPis_hacked();

errcode
specs_one(CLUREF e, CLUREF def, CLUREF *ret_1, CLUREF *ret_2)
{
    errcode err;
    CLUREF undefs;
    CLUREF ok;
    CLUREF res;
    CLUREF gen;
    CLUREF d;
    CLUREF specs;
    CLUREF hack;
    CLUREF md;
    enter_proc(330);

  LINE(331);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = check_one1(e, def, &T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    undefs.num = T_1_1.num;
    ok.num = T_1_2.num;
    }

  LINE(332);
    {
    res.num = 3;
    }

  LINE(334);
    { /* qtagcase */
    switch (def.cell->tag) {
    case 4: /* equates */ {

  LINE(336);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = e.vec->data[3];
        err = c_envOPget_proc_(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        gen.num = T_2_2.num;
        }

  LINE(337);
        {
        res.num = 1;
        }
        break;
    }
    case 1: /* apply */ {
        CLUREF T_1_1;
        T_1_1.num = def.cell->value;
        d.num = T_1_1.num;

  LINE(339);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = d.vec->data[4];
        err = c_module_idn(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        gen.num = T_2_2.num;
        }

  LINE(340);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = d.vec->data[4];
        CellAlloc(8, nil, T_2_2);
        err = idnOPset_kind(T_2_1, T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    case 3: /* cluster_ */ /* FALLTHROUGH */
    case 5: /* selector_ */ /* FALLTHROUGH */
    case 2: /* atype */ {
        CLUREF T_1_2;
        T_1_2.num = def.cell->value;
        d.num = T_1_2.num;

  LINE(342);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = d.vec->data[3];
        err = c_module_idn(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        gen.num = T_2_2.num;
        }

  LINE(343);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = d.vec->data[3];
        CellAlloc(8, nil, T_2_2);
        err = idnOPset_kind(T_2_1, T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(345);
    {
    CLUREF T_1_1;
    err = duOPget_mspecs(gen, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    specs.num = T_1_1.num;
    }

  LINE(346);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (res.num == 3);
    if (T_1_1.num == true) { /* if */

  LINE(347);
        {
        CLUREF T_2_1;
        CellAlloc(1, nil, T_2_1);
        err = duOPset_mspecs(gen, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(348);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[3];
    err = c_envOPis_hacked(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    hack.num = T_1_2.num;
    }

  LINE(349);
    {
    CLUREF T_1_1;
    RecordAlloc(4, T_1_1);
    T_1_1.vec->data[0] = def.num;
    T_1_1.vec->data[2] = hack.num;
    T_1_1.vec->data[1] = gen.num;
    T_1_1.vec->data[3] = specs.num;
    md.num = T_1_1.num;
    }

  LINE(353);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = !ok.num;
    if (T_1_1.num == true) { /* if */

  LINE(354);
        {
        res.num = 0;
        }
    }
    else {

  LINE(356);
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = undefs.array->ext_size;
    T_1_3.num = (T_1_2.num > 0);
    if (T_1_3.num == true) { /* elseif */

  LINE(357);
        {
        res.num = 2;
        }
    }
    }} /* end if */

  LINE(358);
    { /* return */
    {
    ret_1->num = res.num;
    }
    {
    ret_2->num = md.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE specs_one ****/



/**** BEGIN PROCEDURE do_ce ****/

extern errcode add_ce_entries();
static CLUREF STR_file_040has_040more_040than_040just_040equates_041;
static int do_ce_own_init = 0;

errcode
do_ce(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF allok;
    CLUREF def;
    CLUREF ok;
    CLUREF eqs;
    if (do_ce_own_init == 0) {
        stringOPcons("file has more than just equates!", CLU_1, CLUREF_make_num(32), &STR_file_040has_040more_040than_040just_040equates_041);
        do_ce_own_init = 1;
    }
    enter_proc(361);

  LINE(362);
    {
    allok.tf = true;
    }

  LINE(363);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(364);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = parse_one(e, &T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        def.num = T_3_1.num;
        ok.num = T_3_2.num;
        }

  LINE(365);
        { /* qtagcase */
        switch (def.cell->tag) {
        case 4: /* equates */ {
            CLUREF T_3_1;
            T_3_1.num = def.cell->value;
            eqs.num = T_3_1.num;

  LINE(367);
            { /* if */
            CLUREF T_4_1;
            T_4_1.num = (ok.num < 2);
            if (T_4_1.num == true) { /* if */

  LINE(368);
                { /* if */
                CLUREF T_5_1;
                CLUREF T_5_2;
                T_5_1.num = (ok.num == 0);
                err = check_one(e, def, T_5_1, &T_5_2);
                if (err != ERR_ok)
                    goto ex_1;
                if (T_5_2.num == true) { /* if */

  LINE(369);
                    {
                    CLUREF T_6_1;
                    CLUREF T_6_2;
                    err = add_ce_entries(e, eqs, &T_6_1);
                    if (err != ERR_ok)
                        goto ex_1;
                    err = boolOPand(allok, T_6_1, &T_6_2);
                    if (err != ERR_ok)
                        goto ex_1;
                    allok.num = T_6_2.num;
                    }
                }
                else { /* else */

  LINE(370);
                    {
                    allok.tf = false;
                    }
                }} /* end if */
            }
            else { /* else */

  LINE(372);
                {
                allok.tf = false;
                }
            }} /* end if */
            break;
        }
        default: {

  LINE(375);
            {
            CLUREF T_5_1;
            T_5_1.num = e.vec->data[10];
            err = streamOPputl(T_5_1, STR_file_040has_040more_040than_040just_040equates_041);
            if (err != ERR_ok)
                goto ex_2;
            }
            goto end_2;
          ex_2: /* except */
            __CLU_EX_HANDLER;
            if (err == ERR_not_possible) {
            }
            else { /* not handled */
                goto ex_1;
            }
          end_2:;

  LINE(377);
            {
            allok.tf = false;
            }
            break;
        }
        }
        } /* end qtagcase */
    }
    end_while_1:
    __CLU_END_LABEL;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_eof) {

  LINE(380);
        { /* return */
        {
        ret_1->num = allok.num;
        }
        signal (ERR_ok);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE do_ce ****/



/**** BEGIN PROCEDURE add_ce_entries ****/

extern errcode ceOPreset_entries();
extern errcode ceOPadd_entry();
extern errcode ceOPkeep();
static CLUREF STR_value_040for_040_047;
static CLUREF STR__047_040already_040exists;
static int add_ce_entries_own_init = 0;

errcode
add_ce_entries(CLUREF e, CLUREF equates, CLUREF *ret_1)
{
    errcode err;
    CLUREF comp;
    CLUREF outst;
    CLUREF ok;
    CLUREF eq;
    CLUREF i;
    if (add_ce_entries_own_init == 0) {
        stringOPcons("value for \'", CLU_1, CLUREF_make_num(11), &STR_value_040for_040_047);
        stringOPcons("\' already exists", CLU_1, CLUREF_make_num(16), &STR__047_040already_040exists);
        add_ce_entries_own_init = 1;
    }
    enter_proc(383);

  LINE(384);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[0];
    comp.num = T_1_1.num;
    }

  LINE(385);
    {
    e.vec->data[1] = false;
    }

  LINE(386);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[10];
    outst.num = T_1_1.num;
    }

  LINE(387);
    {
    err = ceOPreset_entries(comp, CLU_true);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(388);
    {
    ok.tf = true;
    }

  LINE(389);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = equates.vec->size;
    T_1_3 = equates;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        eq.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(390);
        {
        CLUREF T_2_1;
        err = equateOPget_idn(eq, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        i.num = T_2_1.num;
        }

  LINE(391);
        {
        err = ceOPadd_entry(comp, i);
        if (err != ERR_ok)
            goto ex_1;
        }
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_exists) {

  LINE(393);
            {
            ok.tf = false;
            }

  LINE(394);
            { /* begin */

  LINE(395);
                {
                err = streamOPputs(outst, STR_value_040for_040_047);
                if (err != ERR_ok)
                    goto ex_2;
                }

  LINE(396);
                {
                CLUREF T_5_1;
                err = idnOPget_str(i, &T_5_1);
                if (err != ERR_ok)
                    goto ex_2;
                err = streamOPputs(outst, T_5_1);
                if (err != ERR_ok)
                    goto ex_2;
                }

  LINE(397);
                {
                err = streamOPputl(outst, STR__047_040already_040exists);
                if (err != ERR_ok)
                    goto ex_2;
                }
            }
            goto end_2;
          ex_2: /* except */
            __CLU_EX_HANDLER;
            if (err == ERR_not_possible) {
            }
            else { /* not handled */
                goto ex_0;
            }
          end_2:;
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(401);
    {
    err = ceOPkeep(comp);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(402);
    { /* return */
    {
    ret_1->num = ok.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE add_ce_entries ****/



/**** BEGIN PROCEDURE parse_one ****/

extern errcode p_definition();
extern errcode p_envOPget_err();
extern errcode p_envOPreset_err();

errcode
parse_one(CLUREF e, CLUREF *ret_1, CLUREF *ret_2)
{
    errcode err;
    CLUREF ep;
    CLUREF def;
    CLUREF err_UNIQ;
    enter_proc(405);

  LINE(406);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[11];
    ep.num = T_1_1.num;
    }

  LINE(407);
    {
    CLUREF T_2_1;
    err = p_definition(ep, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    def.num = T_2_1.num;
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_eof) {

  LINE(408);
        { /* signal */
            signal(ERR_eof);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(409);
    {
    CLUREF T_1_1;
    err = p_envOPget_err(ep, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err_UNIQ.num = T_1_1.num;
    }

  LINE(410);
    {
    err = p_envOPreset_err(ep);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(411);
    { /* return */
    {
    ret_1->num = def.num;
    }
    {
    ret_2->num = err_UNIQ.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE parse_one ****/



/**** BEGIN PROCEDURE check_one ****/

extern errcode cmpvarOPexpunge();

errcode
check_one(CLUREF e, CLUREF def, CLUREF go, CLUREF *ret_1)
{
    errcode err;
    CLUREF undefs;
    CLUREF ok;
    CLUREF mod;
    CLUREF exp;
    CLUREF d;
    CLUREF gen;
    CLUREF specs;
    CLUREF ds;
    enter_proc(414);

  LINE(415);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = check_one1(e, def, &T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    undefs.num = T_1_1.num;
    ok.num = T_1_2.num;
    }

  LINE(417);
    {
    CLUREF T_1_1;
    err = cmpvarOPexpunge(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    exp.num = T_1_1.num;
    }

  LINE(418);
    { /* qtagcase */
    switch (def.cell->tag) {
    case 4: /* equates */ {

  LINE(420);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = ok.num;
        if (ok.num) {
            T_2_1.num = go.num;
        }
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 1: /* apply */ {
        CLUREF T_1_1;
        T_1_1.num = def.cell->value;
        d.num = T_1_1.num;

  LINE(422);
        {
        CLUREF T_2_1;
        T_2_1.num = d.vec->data[4];
        mod.num = T_2_1.num;
        }
        break;
    }
    case 3: /* cluster_ */ /* FALLTHROUGH */
    case 5: /* selector_ */ /* FALLTHROUGH */
    case 2: /* atype */ {
        CLUREF T_1_2;
        T_1_2.num = def.cell->value;
        d.num = T_1_2.num;

  LINE(424);
        {
        CLUREF T_2_1;
        T_2_1.num = d.vec->data[3];
        mod.num = T_2_1.num;
        }

  LINE(425);
        {
        exp.tf = false;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(427);
    {
    CLUREF T_1_1;
    err = c_module_idn(mod, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    gen.num = T_1_1.num;
    }

  LINE(428);
    {
    CLUREF T_1_1;
    CellAlloc(8, nil, T_1_1);
    err = idnOPset_kind(mod, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(429);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ok.num;
    if (ok.num) {
        T_1_1.num = go.num;
    }
    T_1_2.num = !T_1_1.num;
    if (T_1_2.num == true) { /* if */

  LINE(430);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(431);
    { /* if */
    if (exp.num == true) { /* if */

  LINE(432);
        { /* return */
        {
        ret_1->num = ok.num;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(433);
    {
    CLUREF T_1_1;
    err = duOPget_mspecs(gen, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    specs.num = T_1_1.num;
    }

  LINE(434);
    { /* qtagcase */
    switch (specs.cell->tag) {
    case 2: /* specs */ {
        CLUREF T_1_1;
        T_1_1.num = specs.cell->value;
        ds.num = T_1_1.num;

  LINE(436);
        {
        err = duOPadd_specs(gen, ds);
        if (err != ERR_ok)
            goto ex_1;
        }
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_specs_exist) {
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;
        break;
    }
    }
    } /* end qtagcase */

  LINE(440);
    { /* return */
    {
    ret_1->num = ok.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE check_one ****/



/**** BEGIN PROCEDURE check_one1 ****/

extern errcode p_envOPis_hacked();
extern errcode c_envOPhack();
extern errcode c_envOPunhack();
extern errcode c_definition();
extern errcode c_envOPget_err();
extern errcode c_envOPend_reset();
extern errcode oneofOPis_4();
extern errcode get_user();
extern errcode c_envOPpop_externals();
extern errcode c_envOPpop_undefined();
extern errcode xrefOPadd_ref();
extern errcode is_internal();
extern errcode duOPget_common();
extern errcode duOPget_unique();
extern errcode remove_externals();

errcode
check_one1(CLUREF e, CLUREF def, CLUREF *ret_1, CLUREF *ret_2)
{
    errcode err;
    CLUREF ec;
    CLUREF outst;
    CLUREF err_UNIQ;
    CLUREF user;
    CLUREF exts;
    CLUREF undefs;
    CLUREF tab;
    CLUREF i;
    CLUREF d;
    enter_proc(443);

  LINE(444);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[3];
    ec.num = T_1_1.num;
    }

  LINE(445);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[11];
    err = p_envOPis_hacked(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_2.num == true) { /* if */

  LINE(446);
        {
        err = c_envOPhack(ec);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    else { /* else */

  LINE(447);
        {
        err = c_envOPunhack(ec);
        if (err != ERR_ok)
            goto ex_0;
        }
    }} /* end if */

  LINE(449);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[10];
    outst.num = T_1_1.num;
    }

  LINE(450);
    {
    err = c_definition(ec, def);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(451);
    {
    CLUREF T_1_1;
    err = c_envOPget_err(ec, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err_UNIQ.num = T_1_1.num;
    }

  LINE(452);
    {
    CLUREF T_1_1;
    if (def.cell->tag == 4) T_1_1.num = true; else T_1_1.num = false;
    err = c_envOPend_reset(ec, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(453);
    {
    CLUREF T_1_1;
    err = get_user(e, def, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    user.num = T_1_1.num;
    }

  LINE(454);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[9];
    {
    if ((T_1_1.array->int_low + T_1_1.array->ext_size + 1) < T_1_1.array->int_size) {
        T_1_1.array->store->data[T_1_1.array->int_low + T_1_1.array->ext_size] = user.num;
        T_1_1.array->ext_size++;
        T_1_1.array->ext_high++;
    }
    else {
        err = arrayOPaddh(T_1_1, user);
        if (err != ERR_ok)
            goto ex_0;
    }
    }
    }

  LINE(455);
    {
    CLUREF T_1_1;
    err = c_envOPpop_externals(ec, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    exts.num = T_1_1.num;
    }

  LINE(456);
    {
    CLUREF T_1_1;
    err = c_envOPpop_undefined(ec, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    undefs.num = T_1_1.num;
    }

  LINE(457);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[4];
    tab.num = T_1_1.num;
    }

  LINE(458);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = exts.array->ext_high;
    T_1_3 = exts;
    for (T_1_1.num = exts.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        i.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(459);
        {
        CLUREF T_2_1;
        err = idnOPget_str(i, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = xrefOPadd_ref(tab, T_2_1, user);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(461);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[12];
    tab.num = T_1_1.num;
    }

  LINE(462);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = undefs.array->ext_high;
    T_1_3 = undefs;
    for (T_1_1.num = undefs.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        d.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(463);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = duOPget_common(d, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = is_internal(T_2_1, exts, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        if (T_2_2.num == true) { /* if */

  LINE(464);
            {
            CLUREF T_3_1;
            err = duOPget_unique(d, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            err = xrefOPadd_ref(tab, T_3_1, user);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(465);
            {
            CLUREF T_3_1;
            CellAlloc(1, nil, T_3_1);
            err = duOPset_mspecs(d, T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        } /* end if */
    }
    }
    end_inline_for_2:
    __CLU_END_LABEL;

  LINE(468);
    {
    err = remove_externals(def, exts);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(469);
    { /* return */
    {
    ret_1->num = undefs.num;
    }
    {
    CLUREF T_1_1;
    T_1_1.num = (err_UNIQ.num < 2);
    ret_2->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE check_one1 ****/



/**** BEGIN PROCEDURE get_user ****/

static CLUREF STR_equates_050;
static CLUREF STR__051;
static int get_user_own_init = 0;

errcode
get_user(CLUREF e, CLUREF def, CLUREF *ret_1)
{
    errcode err;
    CLUREF d;
    if (get_user_own_init == 0) {
        stringOPcons("equates(", CLU_1, CLUREF_make_num(8), &STR_equates_050);
        stringOPcons(")", CLU_1, CLUREF_make_num(1), &STR__051);
        get_user_own_init = 1;
    }
    enter_proc(472);

  LINE(473);
    { /* qtagcase */
    switch (def.cell->tag) {
    case 4: /* equates */ {

  LINE(475);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_1.num = e.vec->data[7];
        err = streamOPget_name(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        err = file_nameOPunparse(T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(STR_equates_050, T_2_3, &T_2_4);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_4, STR__051, &T_2_5);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_5.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 1: /* apply */ {
        CLUREF T_1_1;
        T_1_1.num = def.cell->value;
        d.num = T_1_1.num;

  LINE(477);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = d.vec->data[4];
        err = idnOPget_str(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 3: /* cluster_ */ /* FALLTHROUGH */
    case 5: /* selector_ */ /* FALLTHROUGH */
    case 2: /* atype */ {
        CLUREF T_1_2;
        T_1_2.num = def.cell->value;
        d.num = T_1_2.num;

  LINE(479);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = d.vec->data[3];
        err = idnOPget_str(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_user ****/



/**** BEGIN PROCEDURE is_internal ****/


errcode
is_internal(CLUREF n, CLUREF exts, CLUREF *ret_1)
{
    errcode err;
    CLUREF i;
    enter_proc(483);

  LINE(484);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = exts.array->ext_high;
    T_1_3 = exts;
    for (T_1_1.num = exts.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        i.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(485);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = idnOPget_str(i, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        T_2_2.num = ((n.str->size != T_2_1.str->size)? false :
            !(memcmp(n.str->data, T_2_1.str->data, n.str->size)));
        if (T_2_2.num == true) { /* if */
            { /* return */
            {
            ret_1->tf = false;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(487);
    { /* return */
    {
    ret_1->tf = true;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE is_internal ****/



/**** BEGIN PROCEDURE remove_externals ****/

extern errcode idnOPget_kind();

errcode
remove_externals(CLUREF def, CLUREF exts)
{
    errcode err;
    CLUREF uk;
    CLUREF k;
    CLUREF d;
    CLUREF i;
    enter_proc(490);

  LINE(491);
    {
    CLUREF T_1_1;
    CellAlloc(8, nil, T_1_1);
    uk.num = T_1_1.num;
    }

  LINE(493);
    { /* qtagcase */
    switch (def.cell->tag) {
    case 1: /* apply */ {
        CLUREF T_1_1;
        T_1_1.num = def.cell->value;
        d.num = T_1_1.num;

  LINE(495);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = d.vec->data[4];
        err = idnOPget_kind(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        k.num = T_2_2.num;
        }
        break;
    }
    case 3: /* cluster_ */ /* FALLTHROUGH */
    case 5: /* selector_ */ /* FALLTHROUGH */
    case 2: /* atype */ {
        CLUREF T_1_2;
        T_1_2.num = def.cell->value;
        d.num = T_1_2.num;

  LINE(497);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = d.vec->data[3];
        err = idnOPget_kind(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        k.num = T_2_2.num;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(500);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = exts.array->ext_high;
    T_1_3 = exts;
    for (T_1_1.num = exts.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        i.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(501);
        {
        err = idnOPset_kind(i, uk);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(503);
    { /* qtagcase */
    switch (def.cell->tag) {
    case 1: /* apply */ {
        CLUREF T_1_1;
        T_1_1.num = def.cell->value;
        d.num = T_1_1.num;

  LINE(505);
        {
        CLUREF T_2_1;
        T_2_1.num = d.vec->data[4];
        err = idnOPset_kind(T_2_1, k);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    case 3: /* cluster_ */ /* FALLTHROUGH */
    case 5: /* selector_ */ /* FALLTHROUGH */
    case 2: /* atype */ {
        CLUREF T_1_2;
        T_1_2.num = def.cell->value;
        d.num = T_1_2.num;

  LINE(507);
        {
        CLUREF T_2_1;
        T_2_1.num = d.vec->data[3];
        err = idnOPset_kind(T_2_1, k);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE remove_externals ****/



/**** BEGIN PROCEDURE generate_one ****/

extern errcode g_definition();

errcode
generate_one(CLUREF e, CLUREF def, CLUREF *ret_1)
{
    errcode err;
    CLUREF eg;
    CLUREF err_UNIQ;
    enter_proc(512);

  LINE(513);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[6];
    if (T_1_1.cell->tag != 2) {
        err = ERR_wrong_tag;
        goto ex_0;
    }
    T_1_2.num = T_1_1.cell->value;
    eg.num = T_1_2.num;
    }

  LINE(514);
    {
    err = g_definition(eg, def);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(515);
    {
    CLUREF T_1_1;
    err = g_envOPget_err(eg, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err_UNIQ.num = T_1_1.num;
    }

  LINE(516);
    {
    err = g_envOPreset_err(eg);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(517);
    { /* return */
    {
    CLUREF T_1_1;
    T_1_1.num = (err_UNIQ.num == 0);
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE generate_one ****/



/**** BEGIN PROCEDURE cc_one ****/

extern errcode g_envOPget_file_name();
extern errcode new_suffix();
extern errcode cmpvarOPsuffix();
extern errcode rename_file();
extern errcode cmpvarOPcc_opt_cmd();
extern errcode cmpvarOPcc_dbg_cmd();
extern errcode stringOPsize();
extern errcode unix_cmd();
extern errcode cmpvarOPsave_c();
extern errcode g_xrefOPflush();
static CLUREF STR_o;
static CLUREF STR__040_055o_040;
static CLUREF STR__040;
static int cc_one_own_init = 0;

errcode
cc_one(CLUREF e)
{
    errcode err;
    CLUREF fn;
    CLUREF dname;
    CLUREF exists_dname;
    CLUREF bfn;
    CLUREF cfn;
    CLUREF cmd;
    CLUREF ofile;
    CLUREF ofn;
    if (cc_one_own_init == 0) {
        stringOPcons("_b_", CLU_1, CLUREF_make_num(3), &STR__137b_137);
        stringOPcons("o", CLU_1, CLUREF_make_num(1), &STR_o);
        stringOPcons(" -o ", CLU_1, CLUREF_make_num(4), &STR__040_055o_040);
        stringOPcons(" ", CLU_1, CLUREF_make_num(1), &STR__040);
        cc_one_own_init = 1;
    }
    enter_proc(520);

  LINE(523);
    {
    CLUREF T_1_1;
    err = g_envOPget_file_name(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    fn.num = T_1_1.num;
    }

  LINE(526);
    {
    CLUREF T_1_1;
    err = cmpvarOPdir(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    dname.num = T_1_1.num;
    }

  LINE(527);
    {
    exists_dname.tf = true;
    }

  LINE(528);
    { /* if */
    CLUREF T_1_1;
    err = stringOPempty(dname, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_1.num == true) { /* if */

  LINE(529);
        {
        CLUREF T_2_1;
        err = file_nameOPget_dir(fn, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        dname.num = T_2_1.num;
        }
        {
        exists_dname.tf = false;
        }
    }
    } /* end if */

  LINE(530);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    err = file_nameOPget_name(fn, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = _dir_ent_size(&T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_3.num = T_1_2.num - 4;
    if ((T_1_3.num >= 0 && T_1_2.num < 0 && (-4) < 0) ||
        (T_1_3.num <= 0 && T_1_2.num > 0 && (-4) > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    err = stringOPsubstr(T_1_1, CLU_1, T_1_3, &T_1_4);
    if (err != ERR_ok)
        goto ex_0;
    err = file_nameOPcreate(dname, T_1_4, STR__137b_137, CLU_empty_string, &T_1_5);
    if (err != ERR_ok)
        goto ex_0;
    bfn.num = T_1_5.num;
    }

  LINE(534);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = cmpvarOPsuffix(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = new_suffix(bfn, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    cfn.num = T_1_2.num;
    }

  LINE(535);
    {
    err = rename_file(bfn, cfn);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(539);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = g_envOPget_time(e, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.num = T_1_2.num;
    if (!T_1_2.num) {
        err = g_envOPget_space(e, &T_1_3);
        if (err != ERR_ok)
            goto ex_0;
        T_1_1.num = T_1_3.num;
    }
    if (T_1_1.num == true) { /* if */
        {
        CLUREF T_2_1;
        err = cmpvarOPcc_opt_cmd(&T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        cmd.num = T_2_1.num;
        }
    }
    else { /* else */

  LINE(540);
        {
        CLUREF T_2_1;
        err = cmpvarOPcc_dbg_cmd(&T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        cmd.num = T_2_1.num;
        }
    }} /* end if */

  LINE(542);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = stringOPsize(cmd, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_2.num = (T_1_1.num < 4);
    if (T_1_2.num == true) { /* if */
        { /* return */
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(546);
    {
    ofile = CLU_empty_string;
    }

  LINE(547);
    { /* if */
    if (exists_dname.num == true) { /* if */

  LINE(548);
        {
        CLUREF T_2_1;
        err = new_suffix(cfn, STR_o, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ofn.num = T_2_1.num;
        }

  LINE(549);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = file_nameOPunparse(ofn, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(STR__040_055o_040, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        ofile.num = T_2_2.num;
        }
    }
    } /* end if */

  LINE(554);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    err = stringOPconcat(cmd, ofile, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = stringOPconcat(T_1_1, STR__040, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    err = file_nameOPunparse(cfn, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    err = stringOPconcat(T_1_2, T_1_3, &T_1_4);
    if (err != ERR_ok)
        goto ex_0;
    cmd.num = T_1_4.num;
    }

  LINE(555);
    {
    err = unix_cmd(cmd);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(556);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = cmpvarOPsave_c(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_2.num = !T_1_1.num;
    if (T_1_2.num == true) { /* if */
        {
        err = delete_file(cfn);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(559);
    {
    err = g_xrefOPflush();
    if (err != ERR_ok)
        goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE cc_one ****/



/**** BEGIN PROCEDURE new_suffix ****/

static CLUREF STR__052;
static int new_suffix_own_init = 0;

errcode
new_suffix(CLUREF fn, CLUREF suf, CLUREF *ret_1)
{
    errcode err;
    CLUREF dez;
    CLUREF dname;
    CLUREF nfn;
    if (new_suffix_own_init == 0) {
        stringOPcons("*", CLU_1, CLUREF_make_num(1), &STR__052);
        new_suffix_own_init = 1;
    }
    enter_proc(564);

  LINE(566);
    { /* begin */

  LINE(567);
        {
        CLUREF T_3_1;
        err = _dir_ent_size(&T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        dez.num = T_3_1.num;
        }

  LINE(568);
        {
        CLUREF T_3_1;
        err = cmpvarOPdir(&T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        dname.num = T_3_1.num;
        }

  LINE(569);
        { /* if */
        CLUREF T_3_1;
        err = stringOPempty(dname, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        if (T_3_1.num == true) { /* if */

  LINE(570);
            {
            CLUREF T_4_1;
            err = file_nameOPget_dir(fn, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            dname.num = T_4_1.num;
            }
        }
        } /* end if */

  LINE(571);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = ((suf.str->size != STR__052.str->size)? false :
            !(memcmp(suf.str->data, STR__052.str->data, suf.str->size)));
        if (T_3_1.num == true) { /* if */
            {
            suf = CLU_empty_string;
            }
        }
        } /* end if */

  LINE(572);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        err = file_nameOPget_name(fn, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        T_3_2.num = dez.num - 1;
        if ((T_3_2.num >= 0 && dez.num < 0 && (-1) < 0) ||
            (T_3_2.num <= 0 && dez.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        err = stringOPsize(suf, &T_3_3);
        if (err != ERR_ok)
            goto ex_1;
        T_3_4.num = T_3_2.num - T_3_3.num;
        if ((T_3_4.num >= 0 && T_3_2.num < 0 && (-T_3_3.num) < 0) ||
            (T_3_4.num <= 0 && T_3_2.num > 0 && (-T_3_3.num) > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        err = stringOPsubstr(T_3_1, CLU_1, T_3_4, &T_3_5);
        if (err != ERR_ok)
            goto ex_1;
        err = file_nameOPcreate(dname, T_3_5, suf, CLU_empty_string, &T_3_6);
        if (err != ERR_ok)
            goto ex_1;
        nfn.num = T_3_6.num;
        }

  LINE(577);
        { /* return */
        {
        ret_1->num = nfn.num;
        }
        signal (ERR_ok);
        }
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE new_suffix ****/

