
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"

extern errcode compile_IB_1();
extern errcode compile_IB_2();
extern errcode setup_stuff();
extern errcode all_input_names();
extern errcode compile1();
extern errcode boolOPnot();
extern errcode recordOPget_13();
extern errcode arrayOPnew();
extern errcode recordOPget_10();
extern errcode xrefOPkeys();
extern errcode arrayOPelements();
extern errcode stringOPequal();
extern errcode arrayOPaddh();
extern errcode recordOPget_5();
extern errcode xrefOPadd_refs();
extern errcode xrefOPrem_refs();
extern errcode xrefOPoutput();
extern errcode cmpvarOPexternals();
CLUREF STR_Undefined;
CLUREF STR_Referencing_040Modules;
CLUREF STR_External;
static int compile_own_init = 0;

/**** BEGIN PROCEDURE compile ****/

errcode compile(mode, args, outst, ret_1)
CLUREF mode;
CLUREF args;
CLUREF outst;
CLUREF *ret_1;
    {
    struct {
        errcode err;
        errcode ecode2;
        CLUREF e;
        CLUREF suffix;
        CLUREF allok;
        CLUREF fn;
        CLUREF allok1;
        CLUREF undefs;
        CLUREF new_exts;
        CLUREF names;
        CLUREF id;
        CLUREF oid;
        CLUREF exts;
        CLUREF mode;
        CLUREF args;
        CLUREF outst;
        } locals;
    locals.mode = mode;
    locals.args = args;
    locals.outst = outst;
        if (compile_own_init == 0) {
        stringOPcons("Undefined", CLU_1, CLU_9, &STR_Undefined);
        stringOPcons("Referencing Modules", CLU_1, CLU_19, &STR_Referencing_040Modules);
        stringOPcons("External", CLU_1, CLU_8, &STR_External);
        compile_own_init = 1;
    }
    enter_proc(7);

  LINE(8);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        locals.err = setup_stuff(locals.mode, locals.outst, &T_1_1, &T_1_2);
        if (locals.err != ERR_ok) goto ex_0;
        locals.e.num = T_1_1.num;
        locals.suffix.num = T_1_2.num;
        }
        }

  LINE(9);
    {
        {locals.allok.tf = true;
        }
        }

  LINE(10);
    {
        locals.err = all_input_names(locals.args, locals.suffix, locals.outst, compile_IB_1, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {
        ret_1->num = elist[0].num;
        signal(ERR_ok);}
        if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
        if (locals.err == ERR_break) locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
        if (locals.err != ERR_ok) goto ex_0;
        }

  LINE(16);
    {
        {CLUREF T_1_1;
        T_1_1.num = locals.e.vec->data[12];
        locals.undefs.num = T_1_1.num;
        }
        }

  LINE(17);
    {
        {CLUREF T_1_1;
        locals.err = arrayOPnew(&T_1_1);
        if (locals.err != ERR_ok) goto ex_0;
        locals.new_exts.num = T_1_1.num;
        }
        }

  LINE(18);
    {
        {CLUREF T_1_1;
        T_1_1.num = locals.e.vec->data[9];
        locals.names.num = T_1_1.num;
        }
        }

  LINE(19);
    {
        locals.err = xrefOPkeys(locals.undefs, compile_IB_2, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {
        ret_1->num = elist[0].num;
        signal(ERR_ok);}
        if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
        if (locals.err == ERR_break) locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
        if (locals.err != ERR_ok) goto ex_0;
        }

  LINE(27);
    {
        {CLUREF T_1_1;
        T_1_1.num = locals.e.vec->data[4];
        locals.exts.num = T_1_1.num;
        }
        }

  LINE(28);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = locals.new_exts.array->ext_high; 
        T_1_3 = locals.new_exts;
        for (T_1_1.num = locals.new_exts.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                locals.err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            locals.id.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(29);
            {
            CLUREF T_2_1;
            locals.err = xrefOPrem_refs(locals.undefs, locals.id, &T_2_1);
            if (locals.err != ERR_ok) goto ex_0;
            locals.err = xrefOPadd_refs(locals.exts, locals.id, T_2_1);
            if (locals.err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(31);
    {

  LINE(33);
        {
        locals.err = xrefOPoutput(locals.undefs, STR_Undefined, STR_Referencing_040Modules, locals.outst);
        if (locals.err != ERR_ok) goto ex_1;
        }

  LINE(34);
        {
        CLUREF T_3_1;
        locals.err = cmpvarOPexternals(&T_3_1);
        if (locals.err != ERR_ok) goto ex_1;
        if (T_3_1.num == true) {

  LINE(36);
            {
            locals.err = xrefOPoutput(locals.exts, STR_External, STR_Referencing_040Modules, locals.outst);
            if (locals.err != ERR_ok) goto ex_1;
            }
            }
            }/* end if */
        }
        goto end_1;
        ex_1:
            if ((locals.err == ERR_not_possible)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(39);
    {
    {
    ret_1->num = locals.allok.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE compile ****/


/**** BEGIN ITERATOR BODIES for compile ****/

errcode compile_IB_1(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    errcode err;
    errcode ecode2;
    CLUREF e;
    CLUREF suffix;
    CLUREF allok;
    CLUREF fn;
    CLUREF allok1;
    CLUREF undefs;
    CLUREF new_exts;
    CLUREF names;
    CLUREF id;
    CLUREF oid;
    CLUREF exts;
    CLUREF mode;
    CLUREF args;
    CLUREF outst;
    } *locals;
{
    locals->fn.num = iv_1.num;
    enter_iter_body_proc(11);

  FB_LINE(11);
    {
        {CLUREF T_1_1;
        locals->err = compile1(locals->e, locals->fn, &T_1_1);
        if (locals->err != ERR_ok) goto ex_0;
        locals->allok1.num = T_1_1.num;
        }
        }

  FB_LINE(12);
    {
    CLUREF T_2_1;
    T_2_1.num = locals->allok1.num ^ 1;
    if (T_2_1.num == true) {
        {
        locals->allok.tf = false;
        }
        }
        }/* end if */
        goto end_1;
        ex_1:
            if ((locals->err == ERR_not_possible)) {
            }
            else {
                goto ex_0;
            }
        end_1:;
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end compile_IB_1 */
errcode compile_IB_2(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    errcode err;
    errcode ecode2;
    CLUREF e;
    CLUREF suffix;
    CLUREF allok;
    CLUREF fn;
    CLUREF allok1;
    CLUREF undefs;
    CLUREF new_exts;
    CLUREF names;
    CLUREF id;
    CLUREF oid;
    CLUREF exts;
    CLUREF mode;
    CLUREF args;
    CLUREF outst;
    } *locals;
{
    locals->id.num = iv_1.num;
    enter_iter_body_proc(20);

  FB_LINE(20);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = locals->names.array->ext_high; 
        T_1_3 = locals->names;
        for (T_1_1.num = locals->names.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                locals->err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            locals->oid.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  FB_LINE(21);
            {
            CLUREF T_2_1;
            T_2_1.num = ((locals->oid.str->size != locals->id.str->size)? false :
                !(bcmp(locals->oid.str->data, locals->id.str->data, locals->oid.str->size)));
            if (T_2_1.num == true) {

  FB_LINE(22);
                {
                {
                if ((locals->new_exts.array->int_low + locals->new_exts.array->ext_size + 1) < locals->new_exts.array->int_size) {
                    locals->new_exts.array->store->data[locals->new_exts.array->int_low + locals->new_exts.array->ext_size] = locals->id.num;
                    locals->new_exts.array->ext_size++; locals->new_exts.array->ext_high++;}
                else {
                    locals->err = arrayOPaddh(locals->new_exts, locals->id);
                    if (locals->err != ERR_ok) goto ex_0;}
                }
                }

  FB_LINE(23);
                goto end_inline_for_2;
                }
                }/* end if */
        }
    }
    end_inline_for_2:;
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end compile_IB_2 */

/**** END ITERATOR BODIES for compile ****/


extern errcode cmpvarOPstuffs();
extern errcode intOPequal();
extern errcode ceOPflush_entries();
extern errcode recordOPget_1();
extern errcode ceOPreset();
extern errcode recordOPget_3();
extern errcode recordOPset_3();
extern errcode recordOPset_9();
extern errcode recordOPset_11();
extern errcode arrayOPtrim();
extern errcode xrefOPflush();
CLUREF STR_spc;
CLUREF STR_equ;
CLUREF STR_clu;
static int setup_stuff_own_init = 0;

/**** BEGIN PROCEDURE setup_stuff ****/

errcode setup_stuff(mode, outst, ret_1, ret_2)
CLUREF mode;
CLUREF outst;
CLUREF *ret_1;
CLUREF *ret_2;
    {
    errcode err;
    errcode ecode2;
    CLUREF e;
        if (setup_stuff_own_init == 0) {
        stringOPcons("spc", CLU_1, CLU_3, &STR_spc);
        stringOPcons("equ", CLU_1, CLU_3, &STR_equ);
        stringOPcons("clu", CLU_1, CLU_3, &STR_clu);
        setup_stuff_own_init = 1;
    }
    enter_proc(42);

  LINE(43);
    {
        {CLUREF T_1_1;
        err = cmpvarOPstuffs(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        e.num = T_1_1.num;
        }
        }

  LINE(44);
    {
    CLUREF T_1_1;
    T_1_1.num = (mode.num == 5)? true : false;
    if (T_1_1.num == true) {

  LINE(45);
        {
        CLUREF T_2_1;
        T_2_1.num = e.vec->data[0];
        err = ceOPflush_entries(T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(46);
        {
        CLUREF T_2_1;
        T_2_1.num = e.vec->data[0];
        err = ceOPreset(T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = e.vec->data[2];
    T_1_3.num = T_1_2.num ^ 1;
    if (T_1_3.num == true) {

  LINE(48);
        {
        CLUREF T_2_1;
        T_2_1.num = e.vec->data[0];
        err = ceOPreset(T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }}/* end if */

  LINE(49);
    {
    e.vec->data[2]  = false;
    }

  LINE(50);
    {
    e.vec->data[8]  = mode.num;
    }

  LINE(51);
    {
    e.vec->data[10]  = outst.num;
    }

  LINE(52);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[9];
    err = arrayOPtrim(T_1_1, CLU_1, CLU_0);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(53);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[4];
    err = xrefOPflush(T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(54);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[12];
    err = xrefOPflush(T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(55);
    {
    CLUREF T_1_1;
    T_1_1.num = (mode.num == 4)? true : false;
    if (T_1_1.num == true) {

  LINE(56);
        {
        {
        ret_1->num = e.num;
        }
        {
        ret_2->str = STR_spc.str;
        }
        {signal (ERR_ok);}}
        }
    else {
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_3.num = (mode.num == 5)? true : false;
    T_1_2.num = T_1_3.num;
    if (!T_1_3.num) {
        T_1_4.num = (mode.num == 6)? true : false;
        T_1_2.num = T_1_4.num;
    }
    if (T_1_2.num == true) {

  LINE(58);
        {
        {
        ret_1->num = e.num;
        }
        {
        ret_2->str = STR_equ.str;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(59);
        {
        {
        ret_1->num = e.num;
        }
        {
        ret_2->str = STR_clu.str;
        }
        {signal (ERR_ok);}}
        }}}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE setup_stuff ****/


extern errcode run_time();
extern errcode reset_stuff();
extern errcode recordOPget_9();
extern errcode recordOPget_11();
extern errcode do_parse();
extern errcode do_check();
extern errcode do_specs();
extern errcode do_ce();
extern errcode do_compile();
extern errcode streamOPputs();
extern errcode streamOPputl();
extern errcode streamOPget_name();
extern errcode recordOPget_8();
extern errcode streamOPclose();
extern errcode _dir_ent_size();
extern errcode cmpvarOPdir();
extern errcode stringOPempty();
extern errcode file_nameOPget_dir();
extern errcode delete_file();
extern errcode file_nameOPcreate();
extern errcode stringOPsubstr();
extern errcode file_nameOPget_name();
extern errcode intOPsub();
extern errcode timeOPformat();
extern errcode timeOPsub();
CLUREF STR_failure_072_040;
CLUREF STR__137b_137;
CLUREF STR_;
CLUREF STR_time_040_075_040;
static int compile1_own_init = 0;

/**** BEGIN PROCEDURE compile1 ****/

errcode compile1(e, fn, ret_1)
CLUREF e;
CLUREF fn;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF time1;
    CLUREF allok;
    CLUREF mode;
    CLUREF outst;
    CLUREF s;
    CLUREF dez;
    CLUREF dname;
    CLUREF elapsed;
        if (compile1_own_init == 0) {
        stringOPcons("failure: ", CLU_1, CLU_9, &STR_failure_072_040);
        stringOPcons("_b_", CLU_1, CLU_3, &STR__137b_137);
        stringOPcons("", CLU_1, CLU_0, &STR_);
        stringOPcons("time = ", CLU_1, CLU_7, &STR_time_040_075_040);
        compile1_own_init = 1;
    }
    enter_proc(62);

  LINE(63);
    {
        {CLUREF T_1_1;
        err = run_time(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        time1.num = T_1_1.num;
        }
        }

  LINE(64);
    {
    err = reset_stuff(e, fn);
    if (err != ERR_ok) goto ex_1;
    }
        goto end_1;
        ex_1:
            if ((err == ERR_open_failed)) {

  LINE(65);
                {
                {
                ret_1->tf = false;
                }
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(67);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[8];
        mode.num = T_1_1.num;
        }
        }

  LINE(68);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[10];
        outst.num = T_1_1.num;
        }
        }

  LINE(69);
    {
    CLUREF T_2_1;
    T_2_1.num = (mode.num == 0)? true : false;
    if (T_2_1.num == true) {

  LINE(70);
        {
        CLUREF T_3_1;
        err = do_parse(e, &T_3_1);
        if (err != ERR_ok) goto ex_2;
        allok.num = T_3_1.num;
        }
        }
    else {
    CLUREF T_2_2;
    T_2_2.num = (mode.num == 1)? true : false;
    if (T_2_2.num == true) {

  LINE(72);
        {
        CLUREF T_3_1;
        err = do_check(e, &T_3_1);
        if (err != ERR_ok) goto ex_2;
        allok.num = T_3_1.num;
        }
        }
    else {
    CLUREF T_2_3;
    T_2_3.num = (mode.num == 4)? true : false;
    if (T_2_3.num == true) {

  LINE(74);
        {
        CLUREF T_3_1;
        err = do_specs(e, &T_3_1);
        if (err != ERR_ok) goto ex_2;
        allok.num = T_3_1.num;
        }
        }
    else {
    CLUREF T_2_4;
    CLUREF T_2_5;
    CLUREF T_2_6;
    T_2_5.num = (mode.num == 5)? true : false;
    T_2_4.num = T_2_5.num;
    if (!T_2_5.num) {
        T_2_6.num = (mode.num == 6)? true : false;
        T_2_4.num = T_2_6.num;
    }
    if (T_2_4.num == true) {

  LINE(76);
        {
        CLUREF T_3_1;
        err = do_ce(e, &T_3_1);
        if (err != ERR_ok) goto ex_2;
        allok.num = T_3_1.num;
        }
        }
    else {

  LINE(77);
        {
        CLUREF T_3_1;
        err = do_compile(e, &T_3_1);
        if (err != ERR_ok) goto ex_2;
        allok.num = T_3_1.num;
        }
        }}}}}/* end if */
        goto end_2;
        ex_2:
            if ((err == ERR_failure)) {
            CLUREF s;
            s.num = elist[0].num;

  LINE(79);
                {
                allok.tf = false;
                }

  LINE(80);
                {

  LINE(81);
                    {
                    err = streamOPputs(outst, STR_failure_072_040);
                    if (err != ERR_ok) goto ex_3;
                    }

  LINE(82);
                    {
                    err = streamOPputl(outst, s);
                    if (err != ERR_ok) goto ex_3;
                    }
                    }
                    goto end_3;
                    ex_3:
                        if ((err == ERR_not_possible)) {
                        }
                        else {
                            goto ex_0;
                        }
                    end_3:;
            }
            else {
                goto ex_0;
            }
        end_2:;

  LINE(85);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[7];
    err = streamOPget_name(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    fn.num = T_1_2.num;
    }

  LINE(86);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[7];
    err = streamOPclose(T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(87);
    {
        {CLUREF T_1_1;
        err = _dir_ent_size(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        dez.num = T_1_1.num;
        }
        }

  LINE(88);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = allok.num;
    if (allok.num) {
        T_1_2.num = (mode.num == 3)? true : false;
        T_1_1.num = T_1_2.num;
    }
    if (T_1_1.num == true) {
        }
    else {
    CLUREF T_1_3;
    T_1_3.num = (mode.num == 3)? true : false;
    if (T_1_3.num == true) {

  LINE(114);
        {
            {CLUREF T_2_1;
            err = cmpvarOPdir(&T_2_1);
            if (err != ERR_ok) goto ex_0;
            dname.num = T_2_1.num;
            }
            }

  LINE(115);
        {
        CLUREF T_2_1;
        err = stringOPempty(dname, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        if (T_2_1.num == true) {

  LINE(116);
            {
            CLUREF T_3_1;
            err = file_nameOPget_dir(fn, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            dname.num = T_3_1.num;
            }
            }
            }/* end if */

  LINE(117);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        err = file_nameOPget_name(fn, &T_3_1);
        if (err != ERR_ok) goto ex_4;
        T_3_2.num = dez.num - 4;
         if ((T_3_2.num >= 0 && dez.num < 0 && (-4) < 0) || 
             (T_3_2.num <= 0 && dez.num > 0 && (-4) > 0)) {
            err = ERR_overflow;
            goto ex_4;}
        err = stringOPsubstr(T_3_1, CLU_1, T_3_2, &T_3_3);
        if (err != ERR_ok) goto ex_4;
        err = file_nameOPcreate(dname, T_3_3, STR__137b_137, STR_, &T_3_4);
        if (err != ERR_ok) goto ex_4;
        err = delete_file(T_3_4);
        if (err != ERR_ok) goto ex_4;
        }
            goto end_4;
            ex_4:
                if ((err == ERR_not_possible)) {
                }
                else {
                    goto ex_0;
                }
            end_4:;
        }
        }}/* end if */

  LINE(123);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        err = run_time(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        err = timeOPsub(T_1_1, time1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        err = timeOPformat(T_1_2, CLU_3, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        elapsed.num = T_1_3.num;
        }
        }

  LINE(124);
    {

  LINE(126);
        {
        err = streamOPputs(outst, STR_time_040_075_040);
        if (err != ERR_ok) goto ex_5;
        }

  LINE(127);
        {
        err = streamOPputl(outst, elapsed);
        if (err != ERR_ok) goto ex_5;
        }
        }
        goto end_5;
        ex_5:
            if ((err == ERR_not_possible)) {
            }
            else {
                goto ex_0;
            }
        end_5:;

  LINE(129);
    {
    {
    ret_1->num = allok.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE compile1 ****/


extern errcode open_stream();
extern errcode oneofOPvalue_2();
extern errcode recordOPget_7();
extern errcode g_envOPget_space();
extern errcode g_envOPget_time();
extern errcode streamOPputc();
extern errcode file_nameOPunparse();
extern errcode file_nameOPparse();
extern errcode nul_dev();
extern errcode p_envOPreset();
extern errcode recordOPget_12();
extern errcode c_envOPreset();
extern errcode recordOPget_4();
extern errcode g_envOPreset();
extern errcode g_envOPset_file_name();
extern errcode recordOPset_8();
CLUREF STR_read;
CLUREF STR_Parsing;
CLUREF STR_Checking;
CLUREF STR_Optimizing;
CLUREF STR_Compiling;
CLUREF STR_Creating_040DU_040specs_040from;
CLUREF STR_Adding_040to_040CE_040from;
static int reset_stuff_own_init = 0;

/**** BEGIN PROCEDURE reset_stuff ****/

errcode reset_stuff(e, fn)
CLUREF e;
CLUREF fn;
    {
    errcode err;
    errcode ecode2;
    CLUREF outst;
    CLUREF mode;
    CLUREF inst;
    CLUREF ge;
    CLUREF srcfn;
    CLUREF dname;
    CLUREF comp;
        if (reset_stuff_own_init == 0) {
        stringOPcons("read", CLU_1, CLU_4, &STR_read);
        stringOPcons("Parsing", CLU_1, CLU_7, &STR_Parsing);
        stringOPcons("Checking", CLU_1, CLU_8, &STR_Checking);
        stringOPcons("Optimizing", CLU_1, CLU_10, &STR_Optimizing);
        stringOPcons("Compiling", CLU_1, CLU_9, &STR_Compiling);
        stringOPcons("Creating DU specs from", CLU_1, CLU_22, &STR_Creating_040DU_040specs_040from);
        stringOPcons("Adding to CE from", CLU_1, CLU_17, &STR_Adding_040to_040CE_040from);
        stringOPcons("_b_", CLU_1, CLU_3, &STR__137b_137);
        stringOPcons("", CLU_1, CLU_0, &STR_);
        reset_stuff_own_init = 1;
    }
    enter_proc(132);

  LINE(133);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[10];
        outst.num = T_1_1.num;
        }
        }

  LINE(134);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[8];
        mode.num = T_1_1.num;
        }
        }

  LINE(135);
    {
        {CLUREF T_2_1;
        err = open_stream(fn, STR_read, outst, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        inst.num = T_2_1.num;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_open_failed)) {

  LINE(136);
                {
                {signal (ERR_open_failed);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(137);
    {
    CLUREF T_1_1;
    err = streamOPget_name(inst, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    fn.num = T_1_1.num;
    }

  LINE(138);
    {

  LINE(140);
        {
        CLUREF T_3_1;
        T_3_1.num = (mode.num == 0)? true : false;
        if (T_3_1.num == true) {

  LINE(141);
            {
            err = streamOPputs(outst, STR_Parsing);
            if (err != ERR_ok) goto ex_2;
            }
            }
        else {
        CLUREF T_3_2;
        T_3_2.num = (mode.num == 1)? true : false;
        if (T_3_2.num == true) {

  LINE(143);
            {
            err = streamOPputs(outst, STR_Checking);
            if (err != ERR_ok) goto ex_2;
            }
            }
        else {
        CLUREF T_3_3;
        T_3_3.num = (mode.num == 3)? true : false;
        if (T_3_3.num == true) {

  LINE(145);
            {
                {CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = e.vec->data[6];
                if (T_4_1.cell->tag != 2) {err = ERR_wrong_tag; goto ex_2;}
                T_4_2.num = T_4_1.cell->value;
                ge.num = T_4_2.num;
                }
                }

  LINE(146);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            err = g_envOPget_space(ge, &T_4_2);
            if (err != ERR_ok) goto ex_2;
            T_4_1.num = T_4_2.num;
            if (!T_4_2.num) {
                err = g_envOPget_time(ge, &T_4_3);
                if (err != ERR_ok) goto ex_2;
                T_4_1.num = T_4_3.num;
            }
            if (T_4_1.num == true) {

  LINE(147);
                {
                err = streamOPputs(outst, STR_Optimizing);
                if (err != ERR_ok) goto ex_2;
                }
                }
            else {

  LINE(148);
                {
                err = streamOPputs(outst, STR_Compiling);
                if (err != ERR_ok) goto ex_2;
                }
                }}/* end if */
            }
        else {
        CLUREF T_3_4;
        T_3_4.num = (mode.num == 4)? true : false;
        if (T_3_4.num == true) {

  LINE(151);
            {
            err = streamOPputs(outst, STR_Creating_040DU_040specs_040from);
            if (err != ERR_ok) goto ex_2;
            }
            }
        else {

  LINE(152);
            {
            err = streamOPputs(outst, STR_Adding_040to_040CE_040from);
            if (err != ERR_ok) goto ex_2;
            }
            }}}}}/* end if */

  LINE(153);
        {
        CLUREF T_3_1;
        T_3_1.ch = ' ';
        err = streamOPputc(outst, T_3_1);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(154);
        {
        CLUREF T_3_1;
        err = file_nameOPunparse(fn, &T_3_1);
        if (err != ERR_ok) goto ex_2;
        err = streamOPputl(outst, T_3_1);
        if (err != ERR_ok) goto ex_2;
        }
        }
        goto end_2;
        ex_2:
            if ((err == ERR_not_possible)) {
            }
            else {
                goto ex_0;
            }
        end_2:;

  LINE(157);
    {
        {srcfn.num = fn.num;
        }
        }

  LINE(158);
    {
    CLUREF T_1_1;
    T_1_1.num = (mode.num == 3)? true : false;
    if (T_1_1.num == true) {

  LINE(159);
        {
            {CLUREF T_2_1;
            err = cmpvarOPdir(&T_2_1);
            if (err != ERR_ok) goto ex_0;
            dname.num = T_2_1.num;
            }
            }

  LINE(160);
        {
        CLUREF T_2_1;
        err = stringOPempty(dname, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        if (T_2_1.num == true) {

  LINE(161);
            {
            CLUREF T_3_1;
            err = file_nameOPget_dir(fn, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            dname.num = T_3_1.num;
            }
            }
            }/* end if */

  LINE(162);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        err = file_nameOPget_name(fn, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = _dir_ent_size(&T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_3.num = T_2_2.num - 4;
         if ((T_2_3.num >= 0 && T_2_2.num < 0 && (-4) < 0) || 
             (T_2_3.num <= 0 && T_2_2.num > 0 && (-4) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = stringOPsubstr(T_2_1, CLU_1, T_2_3, &T_2_4);
        if (err != ERR_ok) goto ex_0;
        err = file_nameOPcreate(dname, T_2_4, STR__137b_137, STR_, &T_2_5);
        if (err != ERR_ok) goto ex_0;
        fn.num = T_2_5.num;
        }
        }
    else {

  LINE(166);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = nul_dev(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = file_nameOPparse(T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        fn.num = T_2_2.num;
        }
        }}/* end if */

  LINE(168);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[0];
        comp.num = T_1_1.num;
        }
        }

  LINE(169);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[11];
    err = p_envOPreset(T_1_1, comp, inst, outst);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(170);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[3];
    err = c_envOPreset(T_1_1, comp, outst);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(171);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[6];
    switch (T_1_1.cell->tag) {
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        ge.num = T_1_2.num;

  LINE(173);
            {
            err = g_envOPreset(ge, comp, outst, fn);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(174);
            {
            err = g_envOPset_file_name(ge, srcfn);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {
    }
    }
    }

  LINE(177);
    {
    e.vec->data[7]  = inst.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE reset_stuff ****/


extern errcode parse_one();
extern errcode intOPgt();

/**** BEGIN PROCEDURE do_parse ****/

errcode do_parse(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF allok;
    CLUREF def;
    CLUREF ok;
    enter_proc(180);

  LINE(181);
    {
        {allok.tf = true;
        }
        }

  LINE(182);
    for (;;) {
        if (true != true) { break; }

  LINE(183);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            err = parse_one(e, &T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            def.num = T_3_1.num;
            ok.num = T_3_2.num;
            }
            }
            goto end_1;
            ex_1:
                if ((err == ERR_eof)) {

  LINE(184);
                    {
                    {
                    ret_1->num = allok.num;
                    }
                    {signal (ERR_ok);}}
                }
                else {
                    goto ex_0;
                }
            end_1:;

  LINE(185);
        {
        CLUREF T_2_1;
        T_2_1.num = (ok.num > 0)? true : false;
        if (T_2_1.num == true) {

  LINE(186);
            {
            allok.tf = false;
            }
            }
            }/* end if */
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE do_parse ****/


extern errcode intOPlt();
extern errcode check_one();

/**** BEGIN PROCEDURE do_check ****/

errcode do_check(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF allok;
    CLUREF def;
    CLUREF ok;
    enter_proc(190);

  LINE(191);
    {
        {allok.tf = true;
        }
        }

  LINE(192);
    for (;;) {
        if (true != true) { break; }

  LINE(193);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            err = parse_one(e, &T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            def.num = T_3_1.num;
            ok.num = T_3_2.num;
            }
            }
            goto end_1;
            ex_1:
                if ((err == ERR_eof)) {

  LINE(194);
                    {
                    {
                    ret_1->num = allok.num;
                    }
                    {signal (ERR_ok);}}
                }
                else {
                    goto ex_0;
                }
            end_1:;

  LINE(195);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_2.num = (ok.num < 2)? true : false;
        T_2_1.num = T_2_2.num;
        if (T_2_2.num) {
            T_2_3.num = (ok.num == 0)? true : false;
            err = check_one(e, def, T_2_3, &T_2_4);
            if (err != ERR_ok) goto ex_0;
            T_2_1.num = T_2_4.num;
        }
        T_2_5.num = T_2_1.num ^ 1;
        if (T_2_5.num == true) {

  LINE(196);
            {
            allok.tf = false;
            }
            }
            }/* end if */
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE do_check ****/


extern errcode cmpvarOPmodules();
extern errcode cmpvarOPallow();
extern errcode idnOPget_str();
extern errcode stringOPindexs();
extern errcode stringOPconcat();
extern errcode generate_one();
extern errcode g_envOPend_all();
extern errcode g_envOPget_err();
extern errcode cc_one();
extern errcode g_envOPreset_err();
CLUREF STR__012;
CLUREF STR__040already_040defined_012;
static int do_compile_own_init = 0;

/**** BEGIN PROCEDURE do_compile ****/

errcode do_compile(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF lst;
    CLUREF allok;
    CLUREF onedef_found;
    CLUREF allow;
    CLUREF def;
    CLUREF ok;
    CLUREF mod;
    CLUREF apd;
    CLUREF td;
    CLUREF ge;
        if (do_compile_own_init == 0) {
        stringOPcons("", CLU_1, CLU_0, &STR_);
        stringOPcons("\n", CLU_1, CLU_1, &STR__012);
        stringOPcons(" already defined\n", CLU_1, CLU_17, &STR__040already_040defined_012);
        do_compile_own_init = 1;
    }
    enter_proc(200);

  LINE(201);
    {
        {CLUREF T_1_1;
        err = cmpvarOPmodules(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        lst.num = T_1_1.num;
        }
        }

  LINE(202);
    {
        {allok.tf = true;
        }
        }

  LINE(203);
    {
        {onedef_found.tf = false;
        }
        }

  LINE(204);
    {
        {CLUREF T_1_1;
        err = cmpvarOPallow(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        allow.num = T_1_1.num;
        }
        }

  LINE(205);
    for (;;) {
        if (true != true) { break; }

  LINE(206);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            err = parse_one(e, &T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            def.num = T_3_1.num;
            ok.num = T_3_2.num;
            }
            }

  LINE(207);
        {
        onedef_found.tf = true;
        }

  LINE(208);
        {
            {mod = STR_;
            }
            }

  LINE(209);
        {
        switch (def.cell->tag) {
        case 1: 
             {CLUREF T_3_1;
            T_3_1.num = def.cell->value;
            apd.num = T_3_1.num;

  LINE(211);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = apd.vec->data[4];
                err = idnOPget_str(T_4_1, &T_4_2);
                if (err != ERR_ok) goto ex_1;
                mod.num = T_4_2.num;
                }
                break;
                }
        case 3: 
             {CLUREF T_3_2;
            T_3_2.num = def.cell->value;
            td.num = T_3_2.num;

  LINE(213);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = td.vec->data[3];
                err = idnOPget_str(T_4_1, &T_4_2);
                if (err != ERR_ok) goto ex_1;
                mod.num = T_4_2.num;
                }
                break;
                }
        default: {
        }
        }
        }

  LINE(216);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        CLUREF T_4_4;
        CLUREF T_4_5;
        CLUREF T_4_6;
        CLUREF T_4_7;
        CLUREF T_4_8;
        CLUREF T_4_9;
        CLUREF T_4_10;
        err = stringOPempty(mod, &T_4_3);
        if (err != ERR_ok) goto ex_2;
        T_4_4.num = T_4_3.num ^ 1;
        T_4_2.num = T_4_4.num;
        if (T_4_4.num) {
            err = stringOPempty(lst, &T_4_5);
            if (err != ERR_ok) goto ex_2;
            T_4_6.num = T_4_5.num ^ 1;
            T_4_2.num = T_4_6.num;
        }
        T_4_1.num = T_4_2.num;
        if (T_4_2.num) {
            err = stringOPconcat(STR__012, mod, &T_4_7);
            if (err != ERR_ok) goto ex_2;
            err = stringOPconcat(T_4_7, STR__012, &T_4_8);
            if (err != ERR_ok) goto ex_2;
            err = stringOPindexs(T_4_8, lst, &T_4_9);
            if (err != ERR_ok) goto ex_2;
            T_4_10.num = (T_4_9.num > 0)? true : false;
            T_4_1.num = T_4_10.num;
        }
        if (T_4_1.num == true) {

  LINE(218);
            {
            CLUREF T_5_1;
            T_5_1.num = e.vec->data[10];
            err = streamOPputs(T_5_1, mod);
            if (err != ERR_ok) goto ex_2;
            }

  LINE(219);
            {
            CLUREF T_5_1;
            T_5_1.num = e.vec->data[10];
            err = streamOPputl(T_5_1, STR__040already_040defined_012);
            if (err != ERR_ok) goto ex_2;
            }
            }
            }/* end if */
            goto end_2;
            ex_2:
                if ((err == ERR_not_possible)) {
                }
                else {
                    goto ex_1;
                }
            end_2:;

  LINE(221);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        T_3_2.num = (ok.num < 2)? true : false;
        T_3_1.num = T_3_2.num;
        if (T_3_2.num) {
            T_3_4.num = (ok.num == 0)? true : false;
            err = check_one(e, def, T_3_4, &T_3_5);
            if (err != ERR_ok) goto ex_1;
            T_3_3.num = T_3_5.num;
            if (!T_3_5.num) {
                T_3_3.num = allow.num;
            }
            T_3_1.num = T_3_3.num;
        }
        if (T_3_1.num == true) {

  LINE(223);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            T_4_2.num = allok.num;
            if (allok.num) {
                err = generate_one(e, def, &T_4_3);
                if (err != ERR_ok) goto ex_1;
                T_4_2.num = T_4_3.num;
            }
            T_4_1.num = T_4_2.num;
            if (T_4_2.num) {
                T_4_4.num = (ok.num == 0)? true : false;
                T_4_1.num = T_4_4.num;
            }
            allok.num = T_4_1.num;
            }
            }
        else {

  LINE(226);
            {
            allok.tf = false;
            }
            }}/* end if */
        }
        end_while_1:;
        goto end_1;
        ex_1:
            if ((err == ERR_eof)) {

  LINE(229);
                {
                CLUREF T_2_1;
                T_2_1.num = onedef_found.num ^ 1;
                if (T_2_1.num == true) {
                    {
                    allok.tf = false;
                    }
                    }
                    }/* end if */
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(231);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = e.vec->data[6];
        if (T_1_1.cell->tag != 2) {err = ERR_wrong_tag; goto ex_0;}
        T_1_2.num = T_1_1.cell->value;
        ge.num = T_1_2.num;
        }
        }

  LINE(232);
    {
    err = g_envOPend_all(ge);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(233);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = allok.num;
    if (allok.num) {
        err = g_envOPget_err(ge, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = (T_1_2.num == 0)? true : false;
        T_1_1.num = T_1_3.num;
    }
    allok.num = T_1_1.num;
    }

  LINE(234);
    {
    if (allok.num == true) {
        {
        err = cc_one(ge);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(235);
    {
    err = g_envOPreset_err(ge);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(236);
    {
    {
    ret_1->num = allok.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE do_compile ****/


extern errcode arrayOPcreate();
extern errcode xrefOPcreate();
extern errcode recordOPset_5();
extern errcode recordOPset_6();
extern errcode sequenceOPnew();
extern errcode recordOPset_2();
extern errcode sequenceOPelements();
extern errcode specs_one();
extern errcode install_specs();
extern errcode xrefOPmerge();
extern errcode arrayOPsize();
extern errcode setup_specs_pass2();
extern errcode p_envOPhack();
extern errcode p_envOPunhack();
extern errcode boolOPand();

/**** BEGIN PROCEDURE do_specs ****/

errcode do_specs(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF allok1;
    CLUREF allok2;
    CLUREF mdefs;
    CLUREF def;
    CLUREF ok;
    CLUREF md;
    CLUREF exts;
    CLUREF xtemp;
    CLUREF d;
    CLUREF dd;
    enter_proc(239);

  LINE(240);
    {
        {allok1.tf = true;
        }
        }

  LINE(241);
    {
        {allok2.tf = true;
        }
        }

  LINE(242);
    {
        {CLUREF T_1_1;
        err = arrayOPcreate(CLU_1, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        mdefs.num = T_1_1.num;
        }
        }

  LINE(246);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[4];
        exts.num = T_1_1.num;
        }
        }

  LINE(247);
    {
        {CLUREF T_1_1;
        err = xrefOPcreate(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        xtemp.num = T_1_1.num;
        }
        }

  LINE(248);
    {
    e.vec->data[4]  = xtemp.num;
    }

  LINE(249);
    for (;;) {
        if (true != true) { break; }

  LINE(250);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = parse_one(e, &T_3_1, &T_3_2);
        if (err != ERR_ok) goto ex_1;
        def.num = T_3_1.num;
        ok.num = T_3_2.num;
        }

  LINE(251);
        {
        switch (def.cell->tag) {
        case 1: 
             {CLUREF T_3_1;
            T_3_1.num = def.cell->value;
            d.num = T_3_1.num;

  LINE(253);
                {
                CLUREF T_4_1;
                err = sequenceOPnew(&T_4_1);
                if (err != ERR_ok) goto ex_1;
                d.vec->data[5]  = T_4_1.num;
                }

  LINE(254);
                {
                CLUREF T_4_1;
                err = sequenceOPnew(&T_4_1);
                if (err != ERR_ok) goto ex_1;
                d.vec->data[1]  = T_4_1.num;
                }
                break;
                }
        case 3: 
        case 5: 
        case 2: 
             {CLUREF T_3_2;
            T_3_2.num = def.cell->value;
            d.num = T_3_2.num;

  LINE(256);
                {
                CLUREF T_4_1;
                err = sequenceOPnew(&T_4_1);
                if (err != ERR_ok) goto ex_1;
                d.vec->data[4]  = T_4_1.num;
                }

  LINE(257);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                CLUREF T_4_4;
                    T_4_1.num = d.vec->data[0];
                    T_4_3.num = T_4_1.vec->size; 
                    T_4_4 = T_4_1;
                    for (T_4_2.num = 1; T_4_2.num <= T_4_3.num; T_4_2.num++) {
                        dd.num = T_4_4.vec->data[T_4_2.num - 1];

  LINE(258);
                        {
                        CLUREF T_5_1;
                        err = sequenceOPnew(&T_5_1);
                        if (err != ERR_ok) goto ex_1;
                        dd.vec->data[5]  = T_5_1.num;
                        }

  LINE(259);
                        {
                        CLUREF T_5_1;
                        err = sequenceOPnew(&T_5_1);
                        if (err != ERR_ok) goto ex_1;
                        dd.vec->data[1]  = T_5_1.num;
                        }
                    }
                }
                end_inline_for_1:;
                break;
                }
        default: {
        }
        }
        }

  LINE(263);
        {
        CLUREF T_3_1;
        T_3_1.num = (ok.num == 0)? true : false;
        if (T_3_1.num == true) {

  LINE(264);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            err = specs_one(e, def, &T_4_1, &T_4_2);
            if (err != ERR_ok) goto ex_1;
            ok.num = T_4_1.num;
            md.num = T_4_2.num;
            }

  LINE(265);
            {
            CLUREF T_4_1;
            T_4_1.num = (ok.num == 0)? true : false;
            if (T_4_1.num == true) {

  LINE(266);
                {
                allok1.tf = false;
                }
                }
            else {
            CLUREF T_4_2;
            T_4_2.num = (ok.num == 2)? true : false;
            if (T_4_2.num == true) {

  LINE(268);
                {
                {
                if ((mdefs.array->int_low + mdefs.array->ext_size + 1) < mdefs.array->int_size) {
                    mdefs.array->store->data[mdefs.array->int_low + mdefs.array->ext_size] = md.num;
                    mdefs.array->ext_size++; mdefs.array->ext_high++;}
                else {
                    err = arrayOPaddh(mdefs, md);
                    if (err != ERR_ok) goto ex_1;}
                }
                }

  LINE(269);
                {
                err = xrefOPflush(xtemp);
                if (err != ERR_ok) goto ex_1;
                }
                }
            else {
            CLUREF T_4_3;
            T_4_3.num = (ok.num == 3)? true : false;
            if (T_4_3.num == true) {

  LINE(271);
                {
                err = install_specs(md);
                if (err != ERR_ok) goto ex_1;
                }
                }
                }}}/* end if */
            }
        else {

  LINE(272);
            {
            allok1.tf = false;
            }

  LINE(273);
            {
            CLUREF T_4_1;
            T_4_1.num = (ok.num == 1)? true : false;
            if (T_4_1.num == true) {

  LINE(274);
                {
                CLUREF T_5_1;
                err = check_one(e, def, CLU_0, &T_5_1);
                if (err != ERR_ok) goto ex_1;
                }
                }
                }/* end if */
            }}/* end if */

  LINE(276);
        {
        err = xrefOPmerge(exts, xtemp);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(277);
        {
        err = xrefOPflush(xtemp);
        if (err != ERR_ok) goto ex_1;
        }
        }
        end_while_1:;
        goto end_1;
        ex_1:
            if ((err == ERR_eof)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(279);
    {
    e.vec->data[4]  = exts.num;
    }

  LINE(280);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = mdefs.array->ext_size;
    T_1_2.num = (T_1_1.num == 0)? true : false;
    if (T_1_2.num == true) {

  LINE(281);
        {
        {
        ret_1->num = allok1.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(282);
    {
    err = setup_specs_pass2(e, mdefs);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(283);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = mdefs.array->ext_high; 
        T_1_3 = mdefs;
        for (T_1_1.num = mdefs.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            md.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(284);
            {
            CLUREF T_2_1;
            T_2_1.num = md.vec->data[0];
            def.num = T_2_1.num;
            }

  LINE(285);
            {
            CLUREF T_2_1;
            T_2_1.num = md.vec->data[2];
            if (T_2_1.num == true) {

  LINE(286);
                {
                CLUREF T_3_1;
                T_3_1.num = e.vec->data[11];
                err = p_envOPhack(T_3_1);
                if (err != ERR_ok) goto ex_0;
                }
                }
            else {

  LINE(287);
                {
                CLUREF T_3_1;
                T_3_1.num = e.vec->data[11];
                err = p_envOPunhack(T_3_1);
                if (err != ERR_ok) goto ex_0;
                }
                }}/* end if */

  LINE(289);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = specs_one(e, def, &T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            ok.num = T_2_1.num;
            md.num = T_2_2.num;
            }

  LINE(290);
            {
            CLUREF T_2_1;
            T_2_1.num = (ok.num == 0)? true : false;
            if (T_2_1.num == true) {

  LINE(291);
                {
                allok2.tf = false;
                }
                }
            else {

  LINE(292);
                {
                err = install_specs(md);
                if (err != ERR_ok) goto ex_0;
                }
                }}/* end if */
        }
    }
    end_inline_for_2:;

  LINE(295);
    {
    {
    CLUREF T_1_1;
    err = boolOPand(allok1, allok2, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE do_specs ****/


extern errcode ceOPreset1();
extern errcode oneofOPmake_8();
extern errcode idnOPset_kind();
extern errcode equateOPget_idn();
extern errcode f_duspecs();
extern errcode duOPset_mspecs();
extern errcode recordOPget_2();

/**** BEGIN PROCEDURE setup_specs_pass2 ****/

errcode setup_specs_pass2(e, mdefs)
CLUREF e;
CLUREF mdefs;
    {
    errcode err;
    errcode ecode2;
    CLUREF uk;
    CLUREF md;
    CLUREF eqs;
    CLUREF eq;
    CLUREF ms;
    enter_proc(298);

  LINE(299);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[0];
    err = ceOPreset1(T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(300);
    {
        {CLUREF T_1_1;
        CellAlloc(8, nil, T_1_1);
        uk.num = T_1_1.num;
        }
        }

  LINE(301);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = mdefs.array->ext_high; 
        T_1_3 = mdefs;
        for (T_1_1.num = mdefs.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            md.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(302);
            {
            CLUREF T_2_1;
            T_2_1.num = md.vec->data[0];
            switch (T_2_1.cell->tag) {
            case 4: 
                 {CLUREF T_2_2;
                T_2_2.num = T_2_1.cell->value;
                eqs.num = T_2_2.num;

  LINE(304);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                        T_3_2.num = eqs.vec->size; 
                        T_3_3 = eqs;
                        for (T_3_1.num = 1; T_3_1.num <= T_3_2.num; T_3_1.num++) {
                            eq.num = T_3_3.vec->data[T_3_1.num - 1];

  LINE(305);
                            {
                            CLUREF T_4_1;
                            err = equateOPget_idn(eq, &T_4_1);
                            if (err != ERR_ok) goto ex_0;
                            err = idnOPset_kind(T_4_1, uk);
                            if (err != ERR_ok) goto ex_0;
                            }
                        }
                    }
                    end_inline_for_2:;
                    break;
                    }
            default: {

  LINE(308);
                {
                CLUREF T_3_1;
                T_3_1.num = md.vec->data[3];
                switch (T_3_1.cell->tag) {
                case 2: 
                     {CLUREF T_3_2;
                    T_3_2.num = T_3_1.cell->value;
                    ms.num = T_3_2.num;

  LINE(310);
                        {
                        CLUREF T_4_1;
                        T_4_1.num = e.vec->data[3];
                        err = f_duspecs(T_4_1, ms, CLU_0);
                        if (err != ERR_ok) goto ex_0;
                        }
                        break;
                        }
                default: {
                }
                }
                }

  LINE(313);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = md.vec->data[1];
                T_3_2.num = md.vec->data[3];
                err = duOPset_mspecs(T_3_1, T_3_2);
                if (err != ERR_ok) goto ex_0;
                }
            }
            }
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE setup_specs_pass2 ****/


extern errcode duOPadd_specs();

/**** BEGIN PROCEDURE install_specs ****/

errcode install_specs(md)
CLUREF md;
    {
    errcode err;
    errcode ecode2;
    CLUREF gen;
    CLUREF specs;
    CLUREF ds;
    enter_proc(318);

  LINE(319);
    {
        {CLUREF T_1_1;
        T_1_1.num = md.vec->data[1];
        gen.num = T_1_1.num;
        }
        }

  LINE(320);
    {
        {CLUREF T_1_1;
        T_1_1.num = md.vec->data[3];
        specs.num = T_1_1.num;
        }
        }

  LINE(321);
    {
    err = duOPset_mspecs(gen, specs);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(322);
    {
    switch (specs.cell->tag) {
    case 2: 
         {CLUREF T_1_1;
        T_1_1.num = specs.cell->value;
        ds.num = T_1_1.num;

  LINE(324);
            {
            err = duOPadd_specs(gen, ds);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE install_specs ****/


extern errcode check_one1();
extern errcode c_envOPget_proc_();
extern errcode c_module_idn();
extern errcode duOPget_mspecs();
extern errcode oneofOPmake_1();
extern errcode c_envOPis_hacked();

/**** BEGIN PROCEDURE specs_one ****/

errcode specs_one(e, def, ret_1, ret_2)
CLUREF e;
CLUREF def;
CLUREF *ret_1;
CLUREF *ret_2;
    {
    errcode err;
    errcode ecode2;
    CLUREF undefs;
    CLUREF ok;
    CLUREF res;
    CLUREF gen;
    CLUREF d;
    CLUREF specs;
    CLUREF hack;
    CLUREF md;
    enter_proc(329);

  LINE(330);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = check_one1(e, def, &T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        undefs.num = T_1_1.num;
        ok.num = T_1_2.num;
        }
        }

  LINE(331);
    {
        {res.num = 3;
        }
        }

  LINE(333);
    {
    switch (def.cell->tag) {
    case 4: 
         {

  LINE(335);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = e.vec->data[3];
            err = c_envOPget_proc_(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            gen.num = T_2_2.num;
            }

  LINE(336);
            {
            res.num = 1;
            }
            break;
            }
    case 1: 
         {CLUREF T_1_1;
        T_1_1.num = def.cell->value;
        d.num = T_1_1.num;

  LINE(338);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = d.vec->data[4];
            err = c_module_idn(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            gen.num = T_2_2.num;
            }

  LINE(339);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = d.vec->data[4];
            CellAlloc(8, nil, T_2_2);
            err = idnOPset_kind(T_2_1, T_2_2);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 3: 
    case 5: 
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = def.cell->value;
        d.num = T_1_2.num;

  LINE(341);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = d.vec->data[3];
            err = c_module_idn(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            gen.num = T_2_2.num;
            }

  LINE(342);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = d.vec->data[3];
            CellAlloc(8, nil, T_2_2);
            err = idnOPset_kind(T_2_1, T_2_2);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    }
    }

  LINE(344);
    {
        {CLUREF T_1_1;
        err = duOPget_mspecs(gen, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        specs.num = T_1_1.num;
        }
        }

  LINE(345);
    {
    CLUREF T_1_1;
    T_1_1.num = (res.num == 3)? true : false;
    if (T_1_1.num == true) {

  LINE(346);
        {
        CLUREF T_2_1;
        CellAlloc(1, nil, T_2_1);
        err = duOPset_mspecs(gen, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(347);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = e.vec->data[3];
        err = c_envOPis_hacked(T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        hack.num = T_1_2.num;
        }
        }

  LINE(348);
    {
        {CLUREF T_1_1;
        RecordAlloc(4, T_1_1);
        T_1_1.vec->data[0]  = def.num;
        T_1_1.vec->data[2]  = hack.num;
        T_1_1.vec->data[1]  = gen.num;
        T_1_1.vec->data[3]  = specs.num;
        md.num = T_1_1.num;
        }
        }

  LINE(352);
    {
    CLUREF T_1_1;
    T_1_1.num = ok.num ^ 1;
    if (T_1_1.num == true) {

  LINE(353);
        {
        res.num = 0;
        }
        }
    else {
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = undefs.array->ext_size;
    T_1_3.num = (T_1_2.num > 0)? true : false;
    if (T_1_3.num == true) {

  LINE(356);
        {
        res.num = 2;
        }
        }
        }}/* end if */

  LINE(357);
    {
    {
    ret_1->num = res.num;
    }
    {
    ret_2->num = md.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE specs_one ****/


extern errcode add_ce_entries();
CLUREF STR_file_040has_040more_040than_040just_040equates_041;
static int do_ce_own_init = 0;

/**** BEGIN PROCEDURE do_ce ****/

errcode do_ce(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF allok;
    CLUREF def;
    CLUREF ok;
    CLUREF eqs;
        if (do_ce_own_init == 0) {
        stringOPcons("file has more than just equates!", CLU_1, CLU_32, &STR_file_040has_040more_040than_040just_040equates_041);
        do_ce_own_init = 1;
    }
    enter_proc(360);

  LINE(361);
    {
        {allok.tf = true;
        }
        }

  LINE(362);
    for (;;) {
        if (true != true) { break; }

  LINE(363);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            err = parse_one(e, &T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            def.num = T_3_1.num;
            ok.num = T_3_2.num;
            }
            }

  LINE(364);
        {
        switch (def.cell->tag) {
        case 4: 
             {CLUREF T_3_1;
            T_3_1.num = def.cell->value;
            eqs.num = T_3_1.num;

  LINE(366);
                {
                CLUREF T_4_1;
                T_4_1.num = (ok.num < 2)? true : false;
                if (T_4_1.num == true) {

  LINE(367);
                    {
                    CLUREF T_5_1;
                    CLUREF T_5_2;
                    T_5_1.num = (ok.num == 0)? true : false;
                    err = check_one(e, def, T_5_1, &T_5_2);
                    if (err != ERR_ok) goto ex_1;
                    if (T_5_2.num == true) {

  LINE(368);
                        {
                        CLUREF T_6_1;
                        CLUREF T_6_2;
                        err = add_ce_entries(e, eqs, &T_6_1);
                        if (err != ERR_ok) goto ex_1;
                        err = boolOPand(allok, T_6_1, &T_6_2);
                        if (err != ERR_ok) goto ex_1;
                        allok.num = T_6_2.num;
                        }
                        }
                    else {

  LINE(369);
                        {
                        allok.tf = false;
                        }
                        }}/* end if */
                    }
                else {

  LINE(371);
                    {
                    allok.tf = false;
                    }
                    }}/* end if */
                break;
                }
        default: {

  LINE(374);
            {
            CLUREF T_5_1;
            T_5_1.num = e.vec->data[10];
            err = streamOPputl(T_5_1, STR_file_040has_040more_040than_040just_040equates_041);
            if (err != ERR_ok) goto ex_2;
            }
                goto end_2;
                ex_2:
                    if ((err == ERR_not_possible)) {
                    }
                    else {
                        goto ex_1;
                    }
                end_2:;

  LINE(376);
            {
            allok.tf = false;
            }
        }
        }
        }
        }
        end_while_1:;
        goto end_1;
        ex_1:
            if ((err == ERR_eof)) {

  LINE(379);
                {
                {
                ret_1->num = allok.num;
                }
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE do_ce ****/


extern errcode ceOPreset_entries();
extern errcode ceOPadd_entry();
extern errcode ceOPkeep();
CLUREF STR_value_040for_040_047;
CLUREF STR__047_040already_040exists;
static int add_ce_entries_own_init = 0;

/**** BEGIN PROCEDURE add_ce_entries ****/

errcode add_ce_entries(e, equates, ret_1)
CLUREF e;
CLUREF equates;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF comp;
    CLUREF outst;
    CLUREF ok;
    CLUREF eq;
    CLUREF i;
        if (add_ce_entries_own_init == 0) {
        stringOPcons("value for \'", CLU_1, CLU_11, &STR_value_040for_040_047);
        stringOPcons("\' already exists", CLU_1, CLU_16, &STR__047_040already_040exists);
        add_ce_entries_own_init = 1;
    }
    enter_proc(382);

  LINE(383);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[0];
        comp.num = T_1_1.num;
        }
        }

  LINE(384);
    {
    e.vec->data[1]  = false;
    }

  LINE(385);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[10];
        outst.num = T_1_1.num;
        }
        }

  LINE(386);
    {
    err = ceOPreset_entries(comp, CLU_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(387);
    {
        {ok.tf = true;
        }
        }

  LINE(388);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = equates.vec->size; 
        T_1_3 = equates;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            eq.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(389);
            {
                {CLUREF T_2_1;
                err = equateOPget_idn(eq, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                i.num = T_2_1.num;
                }
                }

  LINE(390);
            {
            err = ceOPadd_entry(comp, i);
            if (err != ERR_ok) goto ex_1;
            }
                goto end_1;
                ex_1:
                    if ((err == ERR_exists)) {

  LINE(392);
                        {
                        ok.tf = false;
                        }

  LINE(393);
                        {

  LINE(394);
                            {
                            err = streamOPputs(outst, STR_value_040for_040_047);
                            if (err != ERR_ok) goto ex_2;
                            }

  LINE(395);
                            {
                            CLUREF T_5_1;
                            err = idnOPget_str(i, &T_5_1);
                            if (err != ERR_ok) goto ex_2;
                            err = streamOPputs(outst, T_5_1);
                            if (err != ERR_ok) goto ex_2;
                            }

  LINE(396);
                            {
                            err = streamOPputl(outst, STR__047_040already_040exists);
                            if (err != ERR_ok) goto ex_2;
                            }
                            }
                            goto end_2;
                            ex_2:
                                if ((err == ERR_not_possible)) {
                                }
                                else {
                                    goto ex_0;
                                }
                            end_2:;
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;
        }
    }
    end_inline_for_1:;

  LINE(400);
    {
    err = ceOPkeep(comp);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(401);
    {
    {
    ret_1->num = ok.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE add_ce_entries ****/


extern errcode p_definition();
extern errcode p_envOPget_err();
extern errcode p_envOPreset_err();

/**** BEGIN PROCEDURE parse_one ****/

errcode parse_one(e, ret_1, ret_2)
CLUREF e;
CLUREF *ret_1;
CLUREF *ret_2;
    {
    errcode err;
    errcode ecode2;
    CLUREF ep;
    CLUREF def;
    CLUREF err_UNIQ;
    enter_proc(404);

  LINE(405);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[11];
        ep.num = T_1_1.num;
        }
        }

  LINE(406);
    {
        {CLUREF T_2_1;
        err = p_definition(ep, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        def.num = T_2_1.num;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_eof)) {

  LINE(407);
                {
                {signal (ERR_eof);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(408);
    {
        {CLUREF T_1_1;
        err = p_envOPget_err(ep, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        err_UNIQ.num = T_1_1.num;
        }
        }

  LINE(409);
    {
    err = p_envOPreset_err(ep);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(410);
    {
    {
    ret_1->num = def.num;
    }
    {
    ret_2->num = err_UNIQ.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE parse_one ****/


extern errcode cmpvarOPexpunge();

/**** BEGIN PROCEDURE check_one ****/

errcode check_one(e, def, go, ret_1)
CLUREF e;
CLUREF def;
CLUREF go;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF undefs;
    CLUREF ok;
    CLUREF mod;
    CLUREF exp;
    CLUREF d;
    CLUREF gen;
    CLUREF specs;
    CLUREF ds;
    enter_proc(413);

  LINE(414);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = check_one1(e, def, &T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        undefs.num = T_1_1.num;
        ok.num = T_1_2.num;
        }
        }

  LINE(416);
    {
        {CLUREF T_1_1;
        err = cmpvarOPexpunge(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        exp.num = T_1_1.num;
        }
        }

  LINE(417);
    {
    switch (def.cell->tag) {
    case 4: 
         {

  LINE(419);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = ok.num;
            if (ok.num) {
                T_2_1.num = go.num;
            }
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 1: 
         {CLUREF T_1_1;
        T_1_1.num = def.cell->value;
        d.num = T_1_1.num;

  LINE(421);
            {
            CLUREF T_2_1;
            T_2_1.num = d.vec->data[4];
            mod.num = T_2_1.num;
            }
            break;
            }
    case 3: 
    case 5: 
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = def.cell->value;
        d.num = T_1_2.num;

  LINE(423);
            {
            CLUREF T_2_1;
            T_2_1.num = d.vec->data[3];
            mod.num = T_2_1.num;
            }

  LINE(424);
            {
            exp.tf = false;
            }
            break;
            }
    }
    }

  LINE(426);
    {
        {CLUREF T_1_1;
        err = c_module_idn(mod, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        gen.num = T_1_1.num;
        }
        }

  LINE(427);
    {
    CLUREF T_1_1;
    CellAlloc(8, nil, T_1_1);
    err = idnOPset_kind(mod, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(428);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ok.num;
    if (ok.num) {
        T_1_1.num = go.num;
    }
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(429);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(430);
    {
    if (exp.num == true) {

  LINE(431);
        {
        {
        ret_1->num = ok.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(432);
    {
        {CLUREF T_1_1;
        err = duOPget_mspecs(gen, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        specs.num = T_1_1.num;
        }
        }

  LINE(433);
    {
    switch (specs.cell->tag) {
    case 2: 
         {CLUREF T_1_1;
        T_1_1.num = specs.cell->value;
        ds.num = T_1_1.num;

  LINE(435);
            {
            err = duOPadd_specs(gen, ds);
            if (err != ERR_ok) goto ex_1;
            }
                goto end_1;
                ex_1:
                    if ((err == ERR_specs_exist)) {
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;
            break;
            }
    default: {
    }
    }
    }

  LINE(439);
    {
    {
    ret_1->num = ok.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE check_one ****/


extern errcode p_envOPis_hacked();
extern errcode c_envOPhack();
extern errcode c_envOPunhack();
extern errcode c_definition();
extern errcode c_envOPget_err();
extern errcode c_envOPend_reset();
extern errcode oneofOPis_4();
extern errcode get_user();
extern errcode c_envOPpop_externals();
extern errcode c_envOPpop_undefined();
extern errcode xrefOPadd_ref();
extern errcode is_internal();
extern errcode duOPget_common();
extern errcode duOPget_unique();
extern errcode remove_externals();

/**** BEGIN PROCEDURE check_one1 ****/

errcode check_one1(e, def, ret_1, ret_2)
CLUREF e;
CLUREF def;
CLUREF *ret_1;
CLUREF *ret_2;
    {
    errcode err;
    errcode ecode2;
    CLUREF ec;
    CLUREF outst;
    CLUREF err_UNIQ;
    CLUREF user;
    CLUREF exts;
    CLUREF undefs;
    CLUREF tab;
    CLUREF i;
    CLUREF d;
    enter_proc(442);

  LINE(443);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[3];
        ec.num = T_1_1.num;
        }
        }

  LINE(444);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = e.vec->data[11];
    err = p_envOPis_hacked(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    if (T_1_2.num == true) {

  LINE(445);
        {
        err = c_envOPhack(ec);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(446);
        {
        err = c_envOPunhack(ec);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(448);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[10];
        outst.num = T_1_1.num;
        }
        }

  LINE(449);
    {
    err = c_definition(ec, def);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(450);
    {
        {CLUREF T_1_1;
        err = c_envOPget_err(ec, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        err_UNIQ.num = T_1_1.num;
        }
        }

  LINE(451);
    {
    CLUREF T_1_1;
    if (def.cell->tag == 4) T_1_1.num = true; else T_1_1.num = false;
    err = c_envOPend_reset(ec, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(452);
    {
        {CLUREF T_1_1;
        err = get_user(e, def, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        user.num = T_1_1.num;
        }
        }

  LINE(453);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[9];
    {
    if ((T_1_1.array->int_low + T_1_1.array->ext_size + 1) < T_1_1.array->int_size) {
        T_1_1.array->store->data[T_1_1.array->int_low + T_1_1.array->ext_size] = user.num;
        T_1_1.array->ext_size++; T_1_1.array->ext_high++;}
    else {
        err = arrayOPaddh(T_1_1, user);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(454);
    {
        {CLUREF T_1_1;
        err = c_envOPpop_externals(ec, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        exts.num = T_1_1.num;
        }
        }

  LINE(455);
    {
        {CLUREF T_1_1;
        err = c_envOPpop_undefined(ec, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        undefs.num = T_1_1.num;
        }
        }

  LINE(456);
    {
        {CLUREF T_1_1;
        T_1_1.num = e.vec->data[4];
        tab.num = T_1_1.num;
        }
        }

  LINE(457);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = exts.array->ext_high; 
        T_1_3 = exts;
        for (T_1_1.num = exts.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            i.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(458);
            {
            CLUREF T_2_1;
            err = idnOPget_str(i, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = xrefOPadd_ref(tab, T_2_1, user);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(460);
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[12];
    tab.num = T_1_1.num;
    }

  LINE(461);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = undefs.array->ext_high; 
        T_1_3 = undefs;
        for (T_1_1.num = undefs.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            d.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(462);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = duOPget_common(d, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = is_internal(T_2_1, exts, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            if (T_2_2.num == true) {

  LINE(463);
                {
                CLUREF T_3_1;
                err = duOPget_unique(d, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                err = xrefOPadd_ref(tab, T_3_1, user);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(464);
                {
                CLUREF T_3_1;
                CellAlloc(1, nil, T_3_1);
                err = duOPset_mspecs(d, T_3_1);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */
        }
    }
    end_inline_for_2:;

  LINE(467);
    {
    err = remove_externals(def, exts);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(468);
    {
    {
    ret_1->num = undefs.num;
    }
    {
    CLUREF T_1_1;
    T_1_1.num = (err_UNIQ.num < 2)? true : false;
    ret_2->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE check_one1 ****/


CLUREF STR_equates_050;
CLUREF STR__051;
static int get_user_own_init = 0;

/**** BEGIN PROCEDURE get_user ****/

errcode get_user(e, def, ret_1)
CLUREF e;
CLUREF def;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF d;
        if (get_user_own_init == 0) {
        stringOPcons("equates(", CLU_1, CLU_8, &STR_equates_050);
        stringOPcons(")", CLU_1, CLU_1, &STR__051);
        get_user_own_init = 1;
    }
    enter_proc(471);

  LINE(472);
    {
    switch (def.cell->tag) {
    case 4: 
         {

  LINE(474);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            T_2_1.num = e.vec->data[7];
            err = streamOPget_name(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            err = file_nameOPunparse(T_2_2, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(STR_equates_050, T_2_3, &T_2_4);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_4, STR__051, &T_2_5);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_5.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 1: 
         {CLUREF T_1_1;
        T_1_1.num = def.cell->value;
        d.num = T_1_1.num;

  LINE(476);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = d.vec->data[4];
            err = idnOPget_str(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 3: 
    case 5: 
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = def.cell->value;
        d.num = T_1_2.num;

  LINE(478);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = d.vec->data[3];
            err = idnOPget_str(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_user ****/



/**** BEGIN PROCEDURE is_internal ****/

errcode is_internal(n, exts, ret_1)
CLUREF n;
CLUREF exts;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF i;
    enter_proc(482);

  LINE(483);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = exts.array->ext_high; 
        T_1_3 = exts;
        for (T_1_1.num = exts.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            i.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(484);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = idnOPget_str(i, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            T_2_2.num = ((n.str->size != T_2_1.str->size)? false :
                !(bcmp(n.str->data, T_2_1.str->data, n.str->size)));
            if (T_2_2.num == true) {
                {
                {
                ret_1->tf = false;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */
        }
    }
    end_inline_for_1:;

  LINE(486);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE is_internal ****/


extern errcode idnOPget_kind();

/**** BEGIN PROCEDURE remove_externals ****/

errcode remove_externals(def, exts)
CLUREF def;
CLUREF exts;
    {
    errcode err;
    errcode ecode2;
    CLUREF uk;
    CLUREF k;
    CLUREF d;
    CLUREF i;
    enter_proc(489);

  LINE(490);
    {
        {CLUREF T_1_1;
        CellAlloc(8, nil, T_1_1);
        uk.num = T_1_1.num;
        }
        }

  LINE(492);
    {
    switch (def.cell->tag) {
    case 1: 
         {CLUREF T_1_1;
        T_1_1.num = def.cell->value;
        d.num = T_1_1.num;

  LINE(494);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = d.vec->data[4];
            err = idnOPget_kind(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            k.num = T_2_2.num;
            }
            break;
            }
    case 3: 
    case 5: 
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = def.cell->value;
        d.num = T_1_2.num;

  LINE(496);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = d.vec->data[3];
            err = idnOPget_kind(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            k.num = T_2_2.num;
            }
            break;
            }
    default: {
    }
    }
    }

  LINE(499);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = exts.array->ext_high; 
        T_1_3 = exts;
        for (T_1_1.num = exts.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            i.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(500);
            {
            err = idnOPset_kind(i, uk);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(502);
    {
    switch (def.cell->tag) {
    case 1: 
         {CLUREF T_1_1;
        T_1_1.num = def.cell->value;
        d.num = T_1_1.num;

  LINE(504);
            {
            CLUREF T_2_1;
            T_2_1.num = d.vec->data[4];
            err = idnOPset_kind(T_2_1, k);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 3: 
    case 5: 
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = def.cell->value;
        d.num = T_1_2.num;

  LINE(506);
            {
            CLUREF T_2_1;
            T_2_1.num = d.vec->data[3];
            err = idnOPset_kind(T_2_1, k);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE remove_externals ****/


extern errcode g_definition();

/**** BEGIN PROCEDURE generate_one ****/

errcode generate_one(e, def, ret_1)
CLUREF e;
CLUREF def;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF eg;
    CLUREF err_UNIQ;
    enter_proc(511);

  LINE(512);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = e.vec->data[6];
        if (T_1_1.cell->tag != 2) {err = ERR_wrong_tag; goto ex_0;}
        T_1_2.num = T_1_1.cell->value;
        eg.num = T_1_2.num;
        }
        }

  LINE(513);
    {
    err = g_definition(eg, def);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(514);
    {
        {CLUREF T_1_1;
        err = g_envOPget_err(eg, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        err_UNIQ.num = T_1_1.num;
        }
        }

  LINE(515);
    {
    err = g_envOPreset_err(eg);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(516);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = (err_UNIQ.num == 0)? true : false;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE generate_one ****/


extern errcode g_envOPget_file_name();
extern errcode new_suffix();
extern errcode cmpvarOPsuffix();
extern errcode rename_file();
extern errcode cmpvarOPcc_opt_cmd();
extern errcode cmpvarOPcc_dbg_cmd();
extern errcode stringOPsize();
extern errcode unix_cmd();
extern errcode cmpvarOPsave_c();
extern errcode g_xrefOPflush();
CLUREF STR_o;
CLUREF STR__040_055o_040;
CLUREF STR__040;
static int cc_one_own_init = 0;

/**** BEGIN PROCEDURE cc_one ****/

errcode cc_one(e)
CLUREF e;
    {
    errcode err;
    errcode ecode2;
    CLUREF fn;
    CLUREF dname;
    CLUREF exists_dname;
    CLUREF bfn;
    CLUREF cfn;
    CLUREF cmd;
    CLUREF ofile;
    CLUREF ofn;
        if (cc_one_own_init == 0) {
        stringOPcons("_b_", CLU_1, CLU_3, &STR__137b_137);
        stringOPcons("", CLU_1, CLU_0, &STR_);
        stringOPcons("o", CLU_1, CLU_1, &STR_o);
        stringOPcons(" -o ", CLU_1, CLU_4, &STR__040_055o_040);
        stringOPcons(" ", CLU_1, CLU_1, &STR__040);
        cc_one_own_init = 1;
    }
    enter_proc(519);

  LINE(522);
    {
        {CLUREF T_1_1;
        err = g_envOPget_file_name(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        fn.num = T_1_1.num;
        }
        }

  LINE(525);
    {
        {CLUREF T_1_1;
        err = cmpvarOPdir(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        dname.num = T_1_1.num;
        }
        }

  LINE(526);
    {
        {exists_dname.tf = true;
        }
        }

  LINE(527);
    {
    CLUREF T_1_1;
    err = stringOPempty(dname, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(528);
        {
        CLUREF T_2_1;
        err = file_nameOPget_dir(fn, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        dname.num = T_2_1.num;
        }
        {
        exists_dname.tf = false;
        }
        }
        }/* end if */

  LINE(529);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        err = file_nameOPget_name(fn, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        err = _dir_ent_size(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = T_1_2.num - 4;
         if ((T_1_3.num >= 0 && T_1_2.num < 0 && (-4) < 0) || 
             (T_1_3.num <= 0 && T_1_2.num > 0 && (-4) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = stringOPsubstr(T_1_1, CLU_1, T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        err = file_nameOPcreate(dname, T_1_4, STR__137b_137, STR_, &T_1_5);
        if (err != ERR_ok) goto ex_0;
        bfn.num = T_1_5.num;
        }
        }

  LINE(533);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = cmpvarOPsuffix(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        err = new_suffix(bfn, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        cfn.num = T_1_2.num;
        }
        }

  LINE(534);
    {
    err = rename_file(bfn, cfn);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(538);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = g_envOPget_time(e, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.num = T_1_2.num;
    if (!T_1_2.num) {
        err = g_envOPget_space(e, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_1.num = T_1_3.num;
    }
    if (T_1_1.num == true) {
        {
        CLUREF T_2_1;
        err = cmpvarOPcc_opt_cmd(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        cmd.num = T_2_1.num;
        }
        }
    else {

  LINE(539);
        {
        CLUREF T_2_1;
        err = cmpvarOPcc_dbg_cmd(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        cmd.num = T_2_1.num;
        }
        }}/* end if */

  LINE(541);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = stringOPsize(cmd, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = (T_1_1.num < 4)? true : false;
    if (T_1_2.num == true) {
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(545);
    {
        {ofile = STR_;
        }
        }

  LINE(546);
    {
    if (exists_dname.num == true) {

  LINE(547);
        {
            {CLUREF T_2_1;
            err = new_suffix(cfn, STR_o, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ofn.num = T_2_1.num;
            }
            }

  LINE(548);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = file_nameOPunparse(ofn, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(STR__040_055o_040, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        ofile.num = T_2_2.num;
        }
        }
        }/* end if */

  LINE(553);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    err = stringOPconcat(cmd, ofile, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_1, STR__040, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = file_nameOPunparse(cfn, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_2, T_1_3, &T_1_4);
    if (err != ERR_ok) goto ex_0;
    cmd.num = T_1_4.num;
    }

  LINE(554);
    {
    err = unix_cmd(cmd);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(555);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = cmpvarOPsave_c(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {
        {
        err = delete_file(cfn);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(558);
    {
    err = g_xrefOPflush();
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE cc_one ****/


CLUREF STR__052;
static int new_suffix_own_init = 0;

/**** BEGIN PROCEDURE new_suffix ****/

errcode new_suffix(fn, suf, ret_1)
CLUREF fn;
CLUREF suf;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF dez;
    CLUREF dname;
    CLUREF nfn;
        if (new_suffix_own_init == 0) {
        stringOPcons("*", CLU_1, CLU_1, &STR__052);
        stringOPcons("", CLU_1, CLU_0, &STR_);
        new_suffix_own_init = 1;
    }
    enter_proc(563);

  LINE(565);
    {

  LINE(566);
        {
            {CLUREF T_3_1;
            err = _dir_ent_size(&T_3_1);
            if (err != ERR_ok) goto ex_1;
            dez.num = T_3_1.num;
            }
            }

  LINE(567);
        {
            {CLUREF T_3_1;
            err = cmpvarOPdir(&T_3_1);
            if (err != ERR_ok) goto ex_1;
            dname.num = T_3_1.num;
            }
            }

  LINE(568);
        {
        CLUREF T_3_1;
        err = stringOPempty(dname, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        if (T_3_1.num == true) {

  LINE(569);
            {
            CLUREF T_4_1;
            err = file_nameOPget_dir(fn, &T_4_1);
            if (err != ERR_ok) goto ex_1;
            dname.num = T_4_1.num;
            }
            }
            }/* end if */

  LINE(570);
        {
        CLUREF T_3_1;
        T_3_1.num = ((suf.str->size != STR__052.str->size)? false :
            !(bcmp(suf.str->data, STR__052.str->data, suf.str->size)));
        if (T_3_1.num == true) {
            {
            suf = STR_;
            }
            }
            }/* end if */

  LINE(571);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            CLUREF T_3_6;
            err = file_nameOPget_name(fn, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            T_3_2.num = dez.num - 1;
             if ((T_3_2.num >= 0 && dez.num < 0 && (-1) < 0) || 
                 (T_3_2.num <= 0 && dez.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            err = stringOPsize(suf, &T_3_3);
            if (err != ERR_ok) goto ex_1;
            T_3_4.num = T_3_2.num - T_3_3.num;
             if ((T_3_4.num >= 0 && T_3_2.num < 0 && (-T_3_3.num) < 0) || 
                 (T_3_4.num <= 0 && T_3_2.num > 0 && (-T_3_3.num) > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            err = stringOPsubstr(T_3_1, CLU_1, T_3_4, &T_3_5);
            if (err != ERR_ok) goto ex_1;
            err = file_nameOPcreate(dname, T_3_5, suf, STR_, &T_3_6);
            if (err != ERR_ok) goto ex_1;
            nfn.num = T_3_6.num;
            }
            }

  LINE(576);
        {
        {
        ret_1->num = nfn.num;
        }
        {signal (ERR_ok);}}
        }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE new_suffix ****/

