
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


extern errcode c_expr();
extern errcode recordOPget_2();
extern errcode c_oneof_specs();
extern errcode c_tag_sugar();
extern errcode c_tagarms();
extern errcode recordOPget_1();
extern errcode arrayOPelements();
extern errcode boolOPnot();
extern errcode recordOPget_3();
extern errcode sequenceOPempty();
extern errcode c_envOPerr1();
extern errcode c_body();
CLUREF STR_others_040arm_040not_040allowed_040_055_040all_040selectors_040present;
CLUREF STR_others_040arm_040required_040_055_040selectors_040missing;
static int c_tagcase_own_init = 0;

/**** BEGIN PROCEDURE c_tagcase ****/

errcode c_tagcase(e, ts)
CLUREF e;
CLUREF ts;
    {
    errcode err;
    errcode ecode2;
    CLUREF at;
    CLUREF specs;
    CLUREF used;
    CLUREF all_used;
    CLUREF mb;
        if (c_tagcase_own_init == 0) {
        stringOPcons("others arm not allowed - all selectors present", CLU_1, CLU_46, &STR_others_040arm_040not_040allowed_040_055_040all_040selectors_040present);
        stringOPcons("others arm required - selectors missing", CLU_1, CLU_39, &STR_others_040arm_040required_040_055_040selectors_040missing);
        c_tagcase_own_init = 1;
    }
    enter_proc(6);

  LINE(7);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = ts.vec->data[1];
        err = c_expr(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        at.num = T_1_2.num;
        }
        }

  LINE(8);
    {
        {CLUREF T_2_1;
        err = c_oneof_specs(e, at, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        specs.num = T_2_1.num;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_abstract)) {

  LINE(9);
                {
                err = c_tag_sugar(e, at, ts);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(10);
                {
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(12);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = ts.vec->data[0];
        err = c_tagarms(e, T_1_1, specs, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        used.num = T_1_2.num;
        }
        }

  LINE(13);
    {
        {all_used.tf = true;
        }
        }

  LINE(14);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = used.array->ext_high; 
        T_1_3 = used;
        for (T_1_1.num = used.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            all_used.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(15);
            {
            CLUREF T_2_1;
            T_2_1.num = all_used.num ^ 1;
            if (T_2_1.num == true) {
                goto end_inline_for_1;
                }
                }/* end if */
        }
    }
    end_inline_for_1:;

  LINE(17);
    {
    CLUREF T_1_1;
    T_1_1.num = ts.vec->data[2];
    switch (T_1_1.cell->tag) {
    case 1: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        mb.num = T_1_2.num;

  LINE(19);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            T_2_1.num = all_used.num;
            if (all_used.num) {
                err = sequenceOPempty(specs, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                T_2_3.num = T_2_2.num ^ 1;
                T_2_1.num = T_2_3.num;
            }
            if (T_2_1.num == true) {

  LINE(20);
                {
                err = c_envOPerr1(e, STR_others_040arm_040not_040allowed_040_055_040all_040selectors_040present);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */

  LINE(22);
            {
            err = c_body(e, mb);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 2: 
         {

  LINE(24);
            {
            CLUREF T_2_1;
            T_2_1.num = all_used.num ^ 1;
            if (T_2_1.num == true) {

  LINE(25);
                {
                err = c_envOPerr1(e, STR_others_040arm_040required_040_055_040selectors_040missing);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */
            break;
            }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_tagcase ****/


extern errcode typespecOPget_abs();
extern errcode duOPequal();
extern errcode c_envOPget_oneof_();
extern errcode c_envOPget_variant_();
extern errcode c_envOPget_record_();
extern errcode c_envOPget_struct_();
extern errcode sequenceOPnew();
extern errcode c_envOPis_hacked();
extern errcode c_envOPerr();
extern errcode get_type_print();
CLUREF STR_tagcase_040expression_040not_040a_040oneof_057variant_072_040;
static int c_oneof_specs_own_init = 0;

/**** BEGIN PROCEDURE c_oneof_specs ****/

errcode c_oneof_specs(e, t, ret_1)
CLUREF e;
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ta;
        if (c_oneof_specs_own_init == 0) {
        stringOPcons("tagcase expression not a oneof/variant: ", CLU_1, CLU_40, &STR_tagcase_040expression_040not_040a_040oneof_057variant_072_040);
        c_oneof_specs_own_init = 1;
    }
    enter_proc(30);

  LINE(32);
    {
    CLUREF T_1_1;
    err = typespecOPget_abs(t, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 7: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        ta.num = T_1_2.num;

  LINE(34);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            CLUREF T_2_6;
            CLUREF T_2_7;
            T_2_2.num = ta.vec->data[0];
            err = c_envOPget_oneof_(e, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            err = duOPequal(T_2_2, T_2_3, &T_2_4);
            if (err != ERR_ok) goto ex_0;
            T_2_1.num = T_2_4.num;
            if (!T_2_4.num) {
                T_2_5.num = ta.vec->data[0];
                err = c_envOPget_variant_(e, &T_2_6);
                if (err != ERR_ok) goto ex_0;
                err = duOPequal(T_2_5, T_2_6, &T_2_7);
                if (err != ERR_ok) goto ex_0;
                T_2_1.num = T_2_7.num;
            }
            if (T_2_1.num == true) {

  LINE(35);
                {
                {
                CLUREF T_3_1;
                T_3_1.num = ta.vec->data[1];
                ret_1->num = T_3_1.num;
                }
                {signal (ERR_ok);}}
                }
            else {
            CLUREF T_2_8;
            CLUREF T_2_9;
            CLUREF T_2_10;
            CLUREF T_2_11;
            CLUREF T_2_12;
            CLUREF T_2_13;
            CLUREF T_2_14;
            CLUREF T_2_15;
            CLUREF T_2_16;
            T_2_9.num = ta.vec->data[0];
            err = c_envOPget_record_(e, &T_2_10);
            if (err != ERR_ok) goto ex_0;
            err = duOPequal(T_2_9, T_2_10, &T_2_11);
            if (err != ERR_ok) goto ex_0;
            T_2_12.num = T_2_11.num ^ 1;
            T_2_8.num = T_2_12.num;
            if (T_2_12.num) {
                T_2_13.num = ta.vec->data[0];
                err = c_envOPget_struct_(e, &T_2_14);
                if (err != ERR_ok) goto ex_0;
                err = duOPequal(T_2_13, T_2_14, &T_2_15);
                if (err != ERR_ok) goto ex_0;
                T_2_16.num = T_2_15.num ^ 1;
                T_2_8.num = T_2_16.num;
            }
            if (T_2_8.num == true) {

  LINE(37);
                {
                {signal (ERR_abstract);}}
                }
                }}/* end if */
            break;
            }
    case 6: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        ta.num = T_1_3.num;

  LINE(39);
            {
            switch (ta.cell->tag) {
            case 3: 
                 {

  LINE(40);
                    {
                    {signal (ERR_abstract);}}
                    break;
                    }
            default: {
            }
            }
            }
            break;
            }
    case 9: 
         {

  LINE(44);
            {
            {
            CLUREF T_2_1;
            err = sequenceOPnew(&T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(46);
        {
        CLUREF T_2_1;
        err = c_envOPis_hacked(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        if (T_2_1.num == true) {

  LINE(47);
            {
            {signal (ERR_abstract);}}
            }
            }/* end if */
    }
    }
    }

  LINE(49);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    sequenceOPnew2(CLU_2, &T_1_1);
    T_1_1.vec->data[0] = STR_tagcase_040expression_040not_040a_040oneof_057variant_072_040.num;
    err = get_type_print(t, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    err = c_envOPerr(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(51);
    {
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_oneof_specs ****/


extern errcode arrayOPfill();
extern errcode sequenceOPsize();
extern errcode sequenceOPelements();
extern errcode c_envOPbegin_scope();
extern errcode c_envOPset_line();
extern errcode c_mdecl();
extern errcode recordOPget_4();
extern errcode c_sel();
extern errcode typespecOPmismatch2();
extern errcode c_envOPerrt();
extern errcode c_envOPend_scope();
CLUREF STR_value_040for_040tag_040_047;
CLUREF STR__047;
static int c_tagarms_own_init = 0;

/**** BEGIN PROCEDURE c_tagarms ****/

errcode c_tagarms(e, arms, specs, ret_1)
CLUREF e;
CLUREF arms;
CLUREF specs;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF used;
    CLUREF arm;
    CLUREF t;
    CLUREF n;
    CLUREF nt;
        if (c_tagarms_own_init == 0) {
        stringOPcons("value for tag \'", CLU_1, CLU_15, &STR_value_040for_040tag_040_047);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        c_tagarms_own_init = 1;
    }
    enter_proc(54);

  LINE(55);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = specs.vec->size;
        err = arrayOPfill(CLU_1, T_1_1, CLU_0, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        used.num = T_1_2.num;
        }
        }

  LINE(56);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = arms.vec->size; 
        T_1_3 = arms;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            arm.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(57);
            {
            err = c_envOPbegin_scope(e);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(58);
            {
            CLUREF T_2_1;
            T_2_1.num = arm.vec->data[1];
            err = c_envOPset_line(e, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(59);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                T_2_1.num = arm.vec->data[3];
                err = c_mdecl(e, T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                t.num = T_2_2.num;
                }
                }

  LINE(60);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = arm.vec->data[2];
                T_2_3.num = T_2_1.vec->size; 
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    n.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(61);
                    {
                        {CLUREF T_3_1;
                        err = c_sel(e, specs, used, n, &T_3_1);
                        if (err != ERR_ok) goto ex_0;
                        nt.num = T_3_1.num;
                        }
                        }

  LINE(62);
                    {
                    CLUREF T_3_1;
                    err = typespecOPmismatch2(t, nt, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    if (T_3_1.num == true) {

  LINE(63);
                        {
                        CLUREF T_4_1;
                        sequenceOPnew2(CLU_3, &T_4_1);
                        T_4_1.vec->data[0] = STR_value_040for_040tag_040_047.num;
                        T_4_1.vec->data[1] = n.num;
                        T_4_1.vec->data[2] = STR__047.num;
                        err = c_envOPerrt(e, T_4_1, t, nt);
                        if (err != ERR_ok) goto ex_0;
                        }
                        }
                        }/* end if */
                }
            }
            end_inline_for_2:;

  LINE(67);
            {
            CLUREF T_2_1;
            T_2_1.num = arm.vec->data[0];
            err = c_body(e, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(68);
            {
            err = c_envOPend_scope(e);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(70);
    {
    {
    ret_1->num = used.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_tagarms ****/


extern errcode arrayOPnew();
extern errcode c_tag_name();

/**** BEGIN PROCEDURE c_tag_sugar ****/

errcode c_tag_sugar(e, at, ts)
CLUREF e;
CLUREF at;
CLUREF ts;
    {
    errcode err;
    errcode ecode2;
    CLUREF names;
    CLUREF arm;
    CLUREF vt;
    CLUREF n;
    CLUREF mb;
    enter_proc(73);

  LINE(75);
    {
        {CLUREF T_1_1;
        err = arrayOPnew(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        names.num = T_1_1.num;
        }
        }

  LINE(76);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = ts.vec->data[0];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            arm.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(77);
            {
            err = c_envOPbegin_scope(e);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(78);
            {
            CLUREF T_2_1;
            T_2_1.num = arm.vec->data[1];
            err = c_envOPset_line(e, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(79);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                T_2_1.num = arm.vec->data[3];
                err = c_mdecl(e, T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                vt.num = T_2_2.num;
                }
                }

  LINE(80);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = arm.vec->data[2];
                T_2_3.num = T_2_1.vec->size; 
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    n.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(81);
                    {
                    err = c_tag_name(e, n, at, vt, names);
                    if (err != ERR_ok) goto ex_0;
                    }
                }
            }
            end_inline_for_2:;

  LINE(83);
            {
            CLUREF T_2_1;
            T_2_1.num = arm.vec->data[0];
            err = c_body(e, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(84);
            {
            err = c_envOPend_scope(e);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(86);
    {
    CLUREF T_1_1;
    T_1_1.num = ts.vec->data[2];
    switch (T_1_1.cell->tag) {
    case 1: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        mb.num = T_1_2.num;

  LINE(88);
            {
            err = c_body(e, mb);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 2: 
         {
            break;
            }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_tag_sugar ****/


extern errcode stringOPequal();
extern errcode stringOPconcat();
extern errcode arrayOPaddh();
extern errcode c_tag_op();
extern errcode c_envOPget_bool_type();
extern errcode oneofOPis_9();
extern errcode recordOPset_1();
CLUREF STR_duplicate_040selector_040_047;
CLUREF STR_is_137;
CLUREF STR_value_137;
static int c_tag_name_own_init = 0;

/**** BEGIN PROCEDURE c_tag_name ****/

errcode c_tag_name(e, n, at, vt, names)
CLUREF e;
CLUREF n;
CLUREF at;
CLUREF vt;
CLUREF names;
    {
    errcode err;
    errcode ecode2;
    CLUREF on;
    CLUREF cop;
        if (c_tag_name_own_init == 0) {
        stringOPcons("duplicate selector \'", CLU_1, CLU_20, &STR_duplicate_040selector_040_047);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        stringOPcons("is_", CLU_1, CLU_3, &STR_is_137);
        stringOPcons("value_", CLU_1, CLU_6, &STR_value_137);
        c_tag_name_own_init = 1;
    }
    enter_proc(93);

  LINE(95);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = names.array->ext_high; 
        T_1_3 = names;
        for (T_1_1.num = names.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            on.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(96);
            {
            CLUREF T_2_1;
            T_2_1.num = ((n.str->size != on.str->size)? false :
                !(bcmp(n.str->data, on.str->data, n.str->size)));
            if (T_2_1.num == true) {

  LINE(97);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                sequenceOPnew2(CLU_1, &T_3_1);
                err = stringOPconcat(STR_duplicate_040selector_040_047, n, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                err = stringOPconcat(T_3_2, STR__047, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                T_3_1.vec->data[0] = T_3_3.num;
                err = c_envOPerr(e, T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(98);
                goto end_inline_for_1;
                }
                }/* end if */
        }
    }
    end_inline_for_1:;

  LINE(101);
    {
    {
    if ((names.array->int_low + names.array->ext_size + 1) < names.array->int_size) {
        names.array->store->data[names.array->int_low + names.array->ext_size] = n.num;
        names.array->ext_size++; names.array->ext_high++;}
    else {
        err = arrayOPaddh(names, n);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(102);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        RecordAlloc(3, T_1_1);
        T_1_1.vec->data[2]  = at.num;
        err = stringOPconcat(STR_is_137, n, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_2.num;
        err = sequenceOPnew(&T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1]  = T_1_3.num;
        cop.num = T_1_1.num;
        }
        }

  LINE(105);
    {
    CLUREF T_1_1;
    err = c_envOPget_bool_type(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = c_tag_op(e, cop, at, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(106);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = typespecOPget_abs(vt, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.cell->tag == 9) T_1_2.num = true; else T_1_2.num = false;
    if (T_1_2.num == true) {

  LINE(107);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(108);
    {
    CLUREF T_1_1;
    err = stringOPconcat(STR_value_137, n, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    cop.vec->data[0]  = T_1_1.num;
    }

  LINE(109);
    {
    err = c_tag_op(e, cop, at, vt);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_tag_name ****/


extern errcode c_clusterop1();
extern errcode c_envOPget_proc_();
extern errcode get_clusterop_print();
extern errcode intOPequal();
extern errcode intOPunparse();
extern errcode typespecOPmismatch();
extern errcode sequenceOPfetch();
extern errcode c_envOPadd_cond();
CLUREF STR_invocation_040of_040non_055procedure_072_040;
CLUREF STR__040arguments_040to_040_047;
CLUREF STR__047_054_0401_040expected;
CLUREF STR_argument_0401_040to_040_047;
CLUREF STR__040results_040from_040_047;
CLUREF STR_result_0401_040from_040_047;
static int c_tag_op_own_init = 0;

/**** BEGIN PROCEDURE c_tag_op ****/

errcode c_tag_op(e, cop, at, vt)
CLUREF e;
CLUREF cop;
CLUREF at;
CLUREF vt;
    {
    errcode err;
    errcode ecode2;
    CLUREF pt;
    CLUREF pta;
    CLUREF xpta;
    CLUREF sig;
        if (c_tag_op_own_init == 0) {
        stringOPcons("invocation of non-procedure: ", CLU_1, CLU_29, &STR_invocation_040of_040non_055procedure_072_040);
        stringOPcons(" arguments to \'", CLU_1, CLU_15, &STR__040arguments_040to_040_047);
        stringOPcons("\', 1 expected", CLU_1, CLU_13, &STR__047_054_0401_040expected);
        stringOPcons("argument 1 to \'", CLU_1, CLU_15, &STR_argument_0401_040to_040_047);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        stringOPcons(" results from \'", CLU_1, CLU_15, &STR__040results_040from_040_047);
        stringOPcons("result 1 from \'", CLU_1, CLU_15, &STR_result_0401_040from_040_047);
        c_tag_op_own_init = 1;
    }
    enter_proc(112);

  LINE(113);
    {
        {CLUREF T_1_1;
        err = c_clusterop1(e, cop, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        pt.num = T_1_1.num;
        }
        }

  LINE(115);
    {
    CLUREF T_1_1;
    err = typespecOPget_abs(pt, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        xpta.num = T_1_2.num;

  LINE(117);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            T_2_1.num = xpta.vec->data[1];
            err = c_envOPget_proc_(e, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            err = duOPequal(T_2_1, T_2_2, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            T_2_4.num = T_2_3.num ^ 1;
            if (T_2_4.num == true) {

  LINE(118);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                sequenceOPnew2(CLU_2, &T_3_1);
                T_3_1.vec->data[0] = STR_invocation_040of_040non_055procedure_072_040.num;
                err = get_clusterop_print(cop, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_1.vec->data[1] = T_3_2.num;
                err = c_envOPerr(e, T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(120);
                {
                {signal (ERR_ok);}}
                }
                }/* end if */

  LINE(122);
            {
            pta.num = xpta.num;
            }
            break;
            }
    case 9: 
         {

  LINE(124);
            {
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(126);
        {
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(128);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = pta.vec->data[0];
    T_1_2.num = T_1_1.vec->size;
    T_1_3.num = (T_1_2.num == 1)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {

  LINE(129);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        sequenceOPnew2(CLU_4, &T_2_1);
        T_2_2.num = pta.vec->data[0];
        T_2_3.num = T_2_2.vec->size;
        err = intOPunparse(T_2_3, &T_2_4);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[0] = T_2_4.num;
        T_2_1.vec->data[1] = STR__040arguments_040to_040_047.num;
        err = get_clusterop_print(cop, &T_2_5);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[2] = T_2_5.num;
        T_2_1.vec->data[3] = STR__047_054_0401_040expected.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    T_1_5.num = pta.vec->data[0];
    if (1 < 1 || 1 > T_1_5.vec->size ) {
        err = ERR_bounds;
        goto ex_0;}
    T_1_6.num = T_1_5.vec->data[1 - 1];
    err = typespecOPmismatch(T_1_6, at, &T_1_7);
    if (err != ERR_ok) goto ex_0;
    if (T_1_7.num == true) {

  LINE(133);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        sequenceOPnew2(CLU_3, &T_2_1);
        T_2_1.vec->data[0] = STR_argument_0401_040to_040_047.num;
        err = get_clusterop_print(cop, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        T_2_1.vec->data[2] = STR__047.num;
        T_2_3.num = pta.vec->data[0];
        if (1 < 1 || 1 > T_2_3.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_2_4.num = T_2_3.vec->data[1 - 1];
        err = c_envOPerrt(e, T_2_1, T_2_4, at);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }}/* end if */

  LINE(137);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = pta.vec->data[3];
    T_1_2.num = T_1_1.vec->size;
    T_1_3.num = (T_1_2.num == 1)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {

  LINE(138);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        sequenceOPnew2(CLU_4, &T_2_1);
        T_2_2.num = pta.vec->data[3];
        T_2_3.num = T_2_2.vec->size;
        err = intOPunparse(T_2_3, &T_2_4);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[0] = T_2_4.num;
        T_2_1.vec->data[1] = STR__040results_040from_040_047.num;
        err = get_clusterop_print(cop, &T_2_5);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[2] = T_2_5.num;
        T_2_1.vec->data[3] = STR__047_054_0401_040expected.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    T_1_5.num = pta.vec->data[3];
    if (1 < 1 || 1 > T_1_5.vec->size ) {
        err = ERR_bounds;
        goto ex_0;}
    T_1_6.num = T_1_5.vec->data[1 - 1];
    err = typespecOPmismatch(T_1_6, vt, &T_1_7);
    if (err != ERR_ok) goto ex_0;
    if (T_1_7.num == true) {

  LINE(142);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        sequenceOPnew2(CLU_3, &T_2_1);
        T_2_1.vec->data[0] = STR_result_0401_040from_040_047.num;
        err = get_clusterop_print(cop, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        T_2_1.vec->data[2] = STR__047.num;
        T_2_3.num = pta.vec->data[3];
        if (1 < 1 || 1 > T_2_3.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_2_4.num = T_2_3.vec->data[1 - 1];
        err = c_envOPerrt(e, T_2_1, T_2_4, vt);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }}/* end if */

  LINE(146);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = pta.vec->data[2];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            sig.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(147);
            {
            err = c_envOPadd_cond(e, sig, CLU_0);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_tag_op ****/


extern errcode c_decl();
extern errcode c_envOPget_unknown_type();

/**** BEGIN PROCEDURE c_mdecl ****/

errcode c_mdecl(e, md, ret_1)
CLUREF e;
CLUREF md;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF d;
    enter_proc(151);

  LINE(152);
    {
    switch (md.cell->tag) {
    case 1: 
         {CLUREF T_1_1;
        T_1_1.num = md.cell->value;
        d.num = T_1_1.num;

  LINE(154);
            {
            err = c_decl(e, d);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(155);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = d.vec->data[1];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 2: 
         {

  LINE(157);
            {
            {
            CLUREF T_2_1;
            err = c_envOPget_unknown_type(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_mdecl ****/


extern errcode c_envOPin_proc();
extern errcode c_values();
extern errcode c_envOPget_values();
CLUREF STR_return;
CLUREF STR_iterator_040cannot_040return_040values;
static int c_return_own_init = 0;

/**** BEGIN PROCEDURE c_return ****/

errcode c_return(e, exprs, ret_1)
CLUREF e;
CLUREF exprs;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF x;
        if (c_return_own_init == 0) {
        stringOPcons("return", CLU_1, CLU_6, &STR_return);
        stringOPcons("iterator cannot return values", CLU_1, CLU_29, &STR_iterator_040cannot_040return_040values);
        c_return_own_init = 1;
    }
    enter_proc(161);

  LINE(162);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = exprs.vec->size; 
        T_1_3 = exprs;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            x.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(163);
            {
            CLUREF T_2_1;
            err = c_expr(e, x, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(165);
    {
    CLUREF T_1_1;
    err = c_envOPin_proc(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(166);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = c_envOPget_values(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = c_values(e, T_2_1, exprs, STR_return, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        exprs.num = T_2_2.num;
        }
        }
    else {
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = sequenceOPempty(exprs, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_3.num = T_1_2.num ^ 1;
    if (T_1_3.num == true) {

  LINE(168);
        {
        err = c_envOPerr1(e, STR_iterator_040cannot_040return_040values);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }}/* end if */

  LINE(169);
    {
    {
    ret_1->num = exprs.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_return ****/


CLUREF STR_yield_040statement_040within_040procedure;
CLUREF STR_yield;
static int c_yield_own_init = 0;

/**** BEGIN PROCEDURE c_yield ****/

errcode c_yield(e, exprs, ret_1)
CLUREF e;
CLUREF exprs;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF x;
        if (c_yield_own_init == 0) {
        stringOPcons("yield statement within procedure", CLU_1, CLU_32, &STR_yield_040statement_040within_040procedure);
        stringOPcons("yield", CLU_1, CLU_5, &STR_yield);
        c_yield_own_init = 1;
    }
    enter_proc(172);

  LINE(173);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = exprs.vec->size; 
        T_1_3 = exprs;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            x.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(174);
            {
            CLUREF T_2_1;
            err = c_expr(e, x, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(176);
    {
    CLUREF T_1_1;
    err = c_envOPin_proc(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(177);
        {
        err = c_envOPerr1(e, STR_yield_040statement_040within_040procedure);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(178);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = c_envOPget_values(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = c_values(e, T_2_1, exprs, STR_yield, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        exprs.num = T_2_2.num;
        }
        }}/* end if */

  LINE(180);
    {
    {
    ret_1->num = exprs.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_yield ****/


extern errcode c_envOPget_xsignals();
extern errcode c_envOPget_str_type();
extern errcode sequenceOPe2s();
CLUREF STR_signal;
CLUREF STR_failure;
CLUREF STR_signal_040_047;
CLUREF STR__047_040not_040listed_040in_040header;
static int c_signal_own_init = 0;

/**** BEGIN PROCEDURE c_signal ****/

errcode c_signal(e, sig)
CLUREF e;
CLUREF sig;
    {
    errcode err;
    errcode ecode2;
    CLUREF x;
    CLUREF n;
    CLUREF xsig;
    CLUREF t;
        if (c_signal_own_init == 0) {
        stringOPcons("signal", CLU_1, CLU_6, &STR_signal);
        stringOPcons("failure", CLU_1, CLU_7, &STR_failure);
        stringOPcons("signal \'", CLU_1, CLU_8, &STR_signal_040_047);
        stringOPcons("\' not listed in header", CLU_1, CLU_22, &STR__047_040not_040listed_040in_040header);
        c_signal_own_init = 1;
    }
    enter_proc(183);

  LINE(184);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = sig.vec->data[0];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            x.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(185);
            {
            CLUREF T_2_1;
            err = c_expr(e, x, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(187);
    {
        {CLUREF T_1_1;
        T_1_1.num = sig.vec->data[1];
        n.num = T_1_1.num;
        }
        }

  LINE(188);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        err = c_envOPget_xsignals(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            xsig.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(189);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = xsig.vec->data[0];
            T_2_2.num = ((n.str->size != T_2_1.str->size)? false :
                !(bcmp(n.str->data, T_2_1.str->data, n.str->size)));
            if (T_2_2.num == true) {

  LINE(190);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                T_3_1.num = xsig.vec->data[1];
                T_3_2.num = sig.vec->data[0];
                err = c_values(e, T_3_1, T_3_2, STR_signal, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                sig.vec->data[0]  = T_3_3.num;
                }

  LINE(191);
                {
                {signal (ERR_ok);}}
                }
                }/* end if */
        }
    }
    end_inline_for_2:;

  LINE(194);
    {
    CLUREF T_1_1;
    T_1_1.num = ((n.str->size != STR_failure.str->size)? false :
        !(bcmp(n.str->data, STR_failure.str->data, n.str->size)));
    if (T_1_1.num == true) {

  LINE(195);
        {
            {CLUREF T_2_1;
            err = c_envOPget_str_type(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            t.num = T_2_1.num;
            }
            }

  LINE(196);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = sequenceOPe2s(t, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        T_2_2.num = sig.vec->data[0];
        err = c_values(e, T_2_1, T_2_2, STR_signal, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        sig.vec->data[0]  = T_2_3.num;
        }

  LINE(197);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(199);
    {
    CLUREF T_1_1;
    sequenceOPnew2(CLU_3, &T_1_1);
    T_1_1.vec->data[0] = STR_signal_040_047.num;
    T_1_1.vec->data[1] = n.num;
    T_1_1.vec->data[2] = STR__047_040not_040listed_040in_040header.num;
    err = c_envOPerr(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_signal ****/


extern errcode c_envOPget_cvt_type();
extern errcode sequenceOPindexes();
extern errcode typespecOPequal();
extern errcode c_envOPget_down_type();
extern errcode exprOPget_typespec();
extern errcode exprOPcreate();
extern errcode oneofOPmake_2();
extern errcode c_envOPget_any_type();
extern errcode sequenceOPreplace();
extern errcode oneofOPmake_27();
extern errcode c_envOPget_up_type();
CLUREF STR__040expressions_040in_040;
CLUREF STR__040statement_054_040;
CLUREF STR__040expected;
CLUREF STR_expression_040;
CLUREF STR__040of_040;
CLUREF STR__040statement;
static int c_values_own_init = 0;

/**** BEGIN PROCEDURE c_values ****/

errcode c_values(e, types, exprs, st, ret_1)
CLUREF e;
CLUREF types;
CLUREF exprs;
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF cvt_;
    CLUREF i;
    CLUREF t;
    CLUREF x;
    CLUREF is_cvt_;
        if (c_values_own_init == 0) {
        stringOPcons(" expressions in ", CLU_1, CLU_16, &STR__040expressions_040in_040);
        stringOPcons(" statement, ", CLU_1, CLU_12, &STR__040statement_054_040);
        stringOPcons(" expected", CLU_1, CLU_9, &STR__040expected);
        stringOPcons("expression ", CLU_1, CLU_11, &STR_expression_040);
        stringOPcons(" of ", CLU_1, CLU_4, &STR__040of_040);
        stringOPcons(" statement", CLU_1, CLU_10, &STR__040statement);
        c_values_own_init = 1;
    }
    enter_proc(202);

  LINE(204);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = exprs.vec->size;
    T_1_2.num = types.vec->size;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {

  LINE(205);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        sequenceOPnew2(CLU_6, &T_2_1);
        T_2_2.num = exprs.vec->size;
        err = intOPunparse(T_2_2, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[0] = T_2_3.num;
        T_2_1.vec->data[1] = STR__040expressions_040in_040.num;
        T_2_1.vec->data[2] = st.num;
        T_2_1.vec->data[3] = STR__040statement_054_040.num;
        T_2_4.num = types.vec->size;
        err = intOPunparse(T_2_4, &T_2_5);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[4] = T_2_5.num;
        T_2_1.vec->data[5] = STR__040expected.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(209);
        {
        {
        ret_1->num = exprs.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(211);
    {
        {CLUREF T_1_1;
        err = c_envOPget_cvt_type(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        cvt_.num = T_1_1.num;
        }
        }

  LINE(212);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = exprs.vec->size; 
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(213);
            {
                {CLUREF T_2_1;
                if (i.num < 1 || i.num > types.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = types.vec->data[i.num - 1];
                t.num = T_2_1.num;
                }
                }

  LINE(214);
            {
                {CLUREF T_2_1;
                if (i.num < 1 || i.num > exprs.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = exprs.vec->data[i.num - 1];
                x.num = T_2_1.num;
                }
                }

  LINE(216);
            {
            CLUREF T_2_1;
            err = typespecOPequal(t, cvt_, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            if (T_2_1.num == true) {

  LINE(217);
                {
                CLUREF T_3_1;
                err = c_envOPget_down_type(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                t.num = T_3_1.num;
                }

  LINE(218);
                {
                is_cvt_.tf = true;
                }
                }
            else {

  LINE(219);
                {
                is_cvt_.tf = false;
                }
                }}/* end if */

  LINE(221);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = exprOPget_typespec(x, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            err = typespecOPmismatch(t, T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            if (T_3_2.num == true) {

  LINE(222);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                sequenceOPnew2(CLU_5, &T_4_1);
                T_4_1.vec->data[0] = STR_expression_040.num;
                err = intOPunparse(i, &T_4_2);
                if (err != ERR_ok) goto ex_1;
                T_4_1.vec->data[1] = T_4_2.num;
                T_4_1.vec->data[2] = STR__040of_040.num;
                T_4_1.vec->data[3] = st.num;
                T_4_1.vec->data[4] = STR__040statement.num;
                err = exprOPget_typespec(x, &T_4_3);
                if (err != ERR_ok) goto ex_1;
                err = c_envOPerrt(e, T_4_1, t, T_4_3);
                if (err != ERR_ok) goto ex_1;
                }
                }
                }/* end if */
                goto end_1;
                ex_1:
                    if ((err == ERR_anyize)) {

  LINE(226);
                        {
                        CLUREF T_3_1;
                        CLUREF T_3_2;
                        CLUREF T_3_3;
                        CellAlloc(2, x.num, T_3_1);
                        err = c_envOPget_any_type(e, &T_3_2);
                        if (err != ERR_ok) goto ex_0;
                        err = exprOPcreate(T_3_1, T_3_2, &T_3_3);
                        if (err != ERR_ok) goto ex_0;
                        x.num = T_3_3.num;
                        }

  LINE(228);
                        {
                        CLUREF T_3_1;
                        err = sequenceOPreplace(exprs, i, x, &T_3_1);
                        if (err != ERR_ok) goto ex_0;
                        exprs.num = T_3_1.num;
                        }
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;

  LINE(230);
            {
            if (is_cvt_.num == true) {

  LINE(231);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CellAlloc(27, x.num, T_3_1);
                err = c_envOPget_up_type(e, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                err = exprOPcreate(T_3_1, T_3_2, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                x.num = T_3_3.num;
                }

  LINE(232);
                {
                CLUREF T_3_1;
                err = sequenceOPreplace(exprs, i, x, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                exprs.num = T_3_1.num;
                }
                }
                }/* end if */
        }
    }
    end_inline_for_1:;

  LINE(235);
    {
    {
    ret_1->num = exprs.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_values ****/


extern errcode c_exprlist();

/**** BEGIN PROCEDURE c_exit ****/

errcode c_exit(e, cond)
CLUREF e;
CLUREF cond;
    {
    errcode err;
    errcode ecode2;
    CLUREF types;
    CLUREF ex;
    enter_proc(238);

  LINE(239);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = cond.vec->data[0];
        err = c_exprlist(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        types.num = T_1_2.num;
        }
        }

  LINE(240);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        RecordAlloc(2, T_1_1);
        T_1_2.num = cond.vec->data[1];
        T_1_1.vec->data[0]  = T_1_2.num;
        T_1_1.vec->data[1]  = types.num;
        ex.num = T_1_1.num;
        }
        }

  LINE(242);
    {
    err = c_envOPadd_cond(e, ex, CLU_1);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_exit ****/


extern errcode c_when_decls();
extern errcode c_envOPpush_handlers();
extern errcode c_stmt();
extern errcode c_envOPpop_handlers();
extern errcode c_whenarms();
CLUREF STR_others_040arms_040variable;
static int c_except_own_init = 0;

/**** BEGIN PROCEDURE c_except ****/

errcode c_except(e, xs)
CLUREF e;
CLUREF xs;
    {
    errcode err;
    errcode ecode2;
    CLUREF marm;
    CLUREF nt;
        if (c_except_own_init == 0) {
        stringOPcons("others arms variable", CLU_1, CLU_20, &STR_others_040arms_040variable);
        c_except_own_init = 1;
    }
    enter_proc(245);

  LINE(246);
    {
    err = c_when_decls(e, xs);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(247);
    {
    err = c_envOPpush_handlers(e, xs);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(248);
    {
    CLUREF T_1_1;
    T_1_1.num = xs.vec->data[2];
    err = c_stmt(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(249);
    {
    err = c_envOPpop_handlers(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(250);
    {
    CLUREF T_1_1;
    T_1_1.num = xs.vec->data[0];
    err = c_whenarms(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(251);
    {
    CLUREF T_1_1;
    T_1_1.num = xs.vec->data[1];
    switch (T_1_1.cell->tag) {
    case 1: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        marm.num = T_1_2.num;

  LINE(253);
            {
            CLUREF T_2_1;
            T_2_1.num = marm.vec->data[2];
            err = c_envOPset_line(e, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(254);
            {
            err = c_envOPbegin_scope(e);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(255);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                T_2_1.num = marm.vec->data[1];
                err = c_mdecl(e, T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                nt.num = T_2_2.num;
                }
                }

  LINE(256);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = c_envOPget_str_type(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = typespecOPmismatch(T_2_1, nt, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            if (T_2_2.num == true) {

  LINE(257);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                sequenceOPnew2(CLU_1, &T_3_1);
                T_3_1.vec->data[0] = STR_others_040arms_040variable.num;
                err = c_envOPget_str_type(e, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                err = c_envOPerrt(e, T_3_1, T_3_2, nt);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */

  LINE(260);
            {
            CLUREF T_2_1;
            T_2_1.num = marm.vec->data[0];
            err = c_body(e, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(261);
            {
            err = c_envOPend_scope(e);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_except ****/


extern errcode recordOPset_2();
extern errcode c_type();

/**** BEGIN PROCEDURE c_when_decls ****/

errcode c_when_decls(e, xs)
CLUREF e;
CLUREF xs;
    {
    errcode err;
    errcode ecode2;
    CLUREF arms;
    CLUREF arm;
    CLUREF decls;
    CLUREF d;
    enter_proc(266);

  LINE(267);
    {
        {CLUREF T_1_1;
        T_1_1.num = xs.vec->data[0];
        arms.num = T_1_1.num;
        }
        }

  LINE(268);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = arms.vec->size; 
        T_1_3 = arms;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            arm.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(269);
            {
            CLUREF T_2_1;
            T_2_1.num = arm.vec->data[1];
            err = c_envOPset_line(e, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(270);
            {
            CLUREF T_2_1;
            T_2_1.num = arm.vec->data[3];
            switch (T_2_1.cell->tag) {
            case 1: 
                 {CLUREF T_2_2;
                T_2_2.num = T_2_1.cell->value;
                decls.num = T_2_2.num;

  LINE(272);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                        T_3_2.num = decls.vec->size; 
                        T_3_3 = decls;
                        for (T_3_1.num = 1; T_3_1.num <= T_3_2.num; T_3_1.num++) {
                            d.num = T_3_3.vec->data[T_3_1.num - 1];

  LINE(273);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            T_4_1.num = d.vec->data[1];
                            err = c_type(e, T_4_1, &T_4_2);
                            if (err != ERR_ok) goto ex_0;
                            d.vec->data[1]  = T_4_2.num;
                            }
                        }
                    }
                    end_inline_for_2:;
                    break;
                    }
            default: {
            }
            }
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_when_decls ****/


extern errcode intOPfrom_to();
extern errcode intOPadd();
extern errcode c_decllist();
CLUREF STR_condition_040_047;
CLUREF STR__047_040listed_040twice;
CLUREF STR_multiple_040handlers_040for_040condition_040_047;
static int c_whenarms_own_init = 0;

/**** BEGIN PROCEDURE c_whenarms ****/

errcode c_whenarms(e, arms)
CLUREF e;
CLUREF arms;
    {
    errcode err;
    errcode ecode2;
    CLUREF ah;
    CLUREF i;
    CLUREF arm;
    CLUREF names;
    CLUREF nh;
    CLUREF j;
    CLUREF n;
    CLUREF k;
    CLUREF n1;
    CLUREF decls;
        if (c_whenarms_own_init == 0) {
        stringOPcons("condition \'", CLU_1, CLU_11, &STR_condition_040_047);
        stringOPcons("\' listed twice", CLU_1, CLU_14, &STR__047_040listed_040twice);
        stringOPcons("multiple handlers for condition \'", CLU_1, CLU_33, &STR_multiple_040handlers_040for_040condition_040_047);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        c_whenarms_own_init = 1;
    }
    enter_proc(280);

  LINE(281);
    {
        {CLUREF T_1_1;
        T_1_1.num = arms.vec->size;
        ah.num = T_1_1.num;
        }
        }

  LINE(282);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = arms.vec->size; 
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(283);
            {
                {CLUREF T_2_1;
                if (i.num < 1 || i.num > arms.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = arms.vec->data[i.num - 1];
                arm.num = T_2_1.num;
                }
                }

  LINE(284);
            {
            CLUREF T_2_1;
            T_2_1.num = arm.vec->data[1];
            err = c_envOPset_line(e, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(285);
            {
                {CLUREF T_2_1;
                T_2_1.num = arm.vec->data[2];
                names.num = T_2_1.num;
                }
                }

  LINE(286);
            {
                {CLUREF T_2_1;
                T_2_1.num = names.vec->size;
                nh.num = T_2_1.num;
                }
                }

  LINE(287);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
                T_2_1.num = arm.vec->data[2];
                T_2_3.num = T_2_1.vec->size; 
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    j.num = T_2_2.num;

  LINE(288);
                    {
                        {CLUREF T_3_1;
                        if (j.num < 1 || j.num > names.vec->size ) {
                            err = ERR_bounds;
                            goto ex_0;}
                        T_3_1.num = names.vec->data[j.num - 1];
                        n.num = T_3_1.num;
                        }
                        }

  LINE(289);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                        T_3_1.num = j.num + 1;
                         if ((T_3_1.num > 0 && j.num < 0 && 1 < 0) || 
                             (T_3_1.num < 0 && j.num > 0 && 1 > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        T_3_3.num = nh.num;
                        for (T_3_2.num = T_3_1.num; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            k.num = T_3_2.num;

  LINE(290);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            if (k.num < 1 || k.num > names.vec->size ) {
                                err = ERR_bounds;
                                goto ex_0;}
                            T_4_1.num = names.vec->data[k.num - 1];
                            T_4_2.num = ((n.str->size != T_4_1.str->size)? false :
                                !(bcmp(n.str->data, T_4_1.str->data, n.str->size)));
                            if (T_4_2.num == true) {

  LINE(291);
                                {
                                CLUREF T_5_1;
                                sequenceOPnew2(CLU_3, &T_5_1);
                                T_5_1.vec->data[0] = STR_condition_040_047.num;
                                T_5_1.vec->data[1] = n.num;
                                T_5_1.vec->data[2] = STR__047_040listed_040twice.num;
                                err = c_envOPerr(e, T_5_1);
                                if (err != ERR_ok) goto ex_0;
                                }
                                }
                                }/* end if */
                        }
                    }
                    end_inline_for_3:;

  LINE(295);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                        T_3_1.num = i.num + 1;
                         if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) || 
                             (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        T_3_3.num = ah.num;
                        for (T_3_2.num = T_3_1.num; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            k.num = T_3_2.num;

  LINE(296);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            CLUREF T_4_4;
                            CLUREF T_4_5;
                                if (k.num < 1 || k.num > arms.vec->size ) {
                                    err = ERR_bounds;
                                    goto ex_0;}
                                T_4_1.num = arms.vec->data[k.num - 1];
                                T_4_2.num = T_4_1.vec->data[2];
                                T_4_4.num = T_4_2.vec->size; 
                                T_4_5 = T_4_2;
                                for (T_4_3.num = 1; T_4_3.num <= T_4_4.num; T_4_3.num++) {
                                    n1.num = T_4_5.vec->data[T_4_3.num - 1];

  LINE(297);
                                    {
                                    CLUREF T_5_1;
                                    T_5_1.num = ((n.str->size != n1.str->size)? false :
                                        !(bcmp(n.str->data, n1.str->data, n.str->size)));
                                    if (T_5_1.num == true) {

  LINE(298);
                                        {
                                        CLUREF T_6_1;
                                        sequenceOPnew2(CLU_3, &T_6_1);
                                        T_6_1.vec->data[0] = STR_multiple_040handlers_040for_040condition_040_047.num;
                                        T_6_1.vec->data[1] = n.num;
                                        T_6_1.vec->data[2] = STR__047.num;
                                        err = c_envOPerr(e, T_6_1);
                                        if (err != ERR_ok) goto ex_0;
                                        }
                                        }
                                        }/* end if */
                                }
                            }
                            end_inline_for_5:;
                        }
                    }
                    end_inline_for_4:;
                }
            }
            end_inline_for_2:;

  LINE(305);
            {
            err = c_envOPbegin_scope(e);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(306);
            {
            CLUREF T_2_1;
            T_2_1.num = arm.vec->data[3];
            switch (T_2_1.cell->tag) {
            case 1: 
                 {CLUREF T_2_2;
                T_2_2.num = T_2_1.cell->value;
                decls.num = T_2_2.num;

  LINE(308);
                    {
                    err = c_decllist(e, decls);
                    if (err != ERR_ok) goto ex_0;
                    }
                    break;
                    }
            default: {
            }
            }
            }

  LINE(311);
            {
            CLUREF T_2_1;
            T_2_1.num = arm.vec->data[0];
            err = c_body(e, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(312);
            {
            err = c_envOPend_scope(e);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_whenarms ****/


extern errcode intOPgt();
extern errcode idnOPget_str();
extern errcode intOPle();
CLUREF STR_exception;
CLUREF STR_exit;
CLUREF STR_exit_040_047;
CLUREF STR__047_040caught_040by_040handler_040with_040_050_052_051_040declaration;
CLUREF STR__040values_040accompany_040;
CLUREF STR__040_047;
CLUREF STR__047_054_0400_040expected;
CLUREF STR_not_040enough_040values_040_050;
CLUREF STR__051_040accompany_040;
CLUREF STR_value_040assigned_040to_040_047;
CLUREF STR__047_040by_040;
CLUREF STR_too_040many_040values_040_050;
static int c_when_assn_own_init = 0;

/**** BEGIN PROCEDURE c_when_assn ****/

errcode c_when_assn(e, vars, cond, is_exit)
CLUREF e;
CLUREF vars;
CLUREF cond;
CLUREF is_exit;
    {
    errcode err;
    errcode ecode2;
    CLUREF which;
    CLUREF types;
    CLUREF decls;
    CLUREF dl;
    CLUREF j;
    CLUREF h;
    CLUREF d;
    CLUREF t;
    CLUREF i;
        if (c_when_assn_own_init == 0) {
        stringOPcons("exception", CLU_1, CLU_9, &STR_exception);
        stringOPcons("exit", CLU_1, CLU_4, &STR_exit);
        stringOPcons("exit \'", CLU_1, CLU_6, &STR_exit_040_047);
        stringOPcons("\' caught by handler with (*) declaration", CLU_1, CLU_40, &STR__047_040caught_040by_040handler_040with_040_050_052_051_040declaration);
        stringOPcons(" values accompany ", CLU_1, CLU_18, &STR__040values_040accompany_040);
        stringOPcons(" \'", CLU_1, CLU_2, &STR__040_047);
        stringOPcons("\', 0 expected", CLU_1, CLU_13, &STR__047_054_0400_040expected);
        stringOPcons("not enough values (", CLU_1, CLU_19, &STR_not_040enough_040values_040_050);
        stringOPcons(") accompany ", CLU_1, CLU_12, &STR__051_040accompany_040);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        stringOPcons("value assigned to \'", CLU_1, CLU_19, &STR_value_040assigned_040to_040_047);
        stringOPcons("\' by ", CLU_1, CLU_5, &STR__047_040by_040);
        stringOPcons("too many values (", CLU_1, CLU_17, &STR_too_040many_040values_040_050);
        c_when_assn_own_init = 1;
    }
    enter_proc(316);

  LINE(317);
    {
        {which = STR_exception;
        }
        }

  LINE(318);
    {
    if (is_exit.num == true) {

  LINE(319);
        {
        which = STR_exit;
        }
        }
        }/* end if */

  LINE(320);
    {
        {CLUREF T_1_1;
        T_1_1.num = cond.vec->data[1];
        types.num = T_1_1.num;
        }
        }

  LINE(322);
    {
    switch (vars.cell->tag) {
    case 3: 
         {

  LINE(324);
            {
            if (is_exit.num == true) {

  LINE(325);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                sequenceOPnew2(CLU_3, &T_3_1);
                T_3_1.vec->data[0] = STR_exit_040_047.num;
                T_3_2.num = cond.vec->data[0];
                T_3_1.vec->data[1] = T_3_2.num;
                T_3_1.vec->data[2] = STR__047_040caught_040by_040handler_040with_040_050_052_051_040declaration.num;
                err = c_envOPerr(e, T_3_1);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */

  LINE(328);
            {
            {signal (ERR_ok);}}
            break;
            }
    case 2: 
         {

  LINE(330);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = sequenceOPempty(types, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            T_2_2.num = T_2_1.num ^ 1;
            if (T_2_2.num == true) {

  LINE(331);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CLUREF T_3_4;
                sequenceOPnew2(CLU_6, &T_3_1);
                T_3_2.num = types.vec->size;
                err = intOPunparse(T_3_2, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                T_3_1.vec->data[0] = T_3_3.num;
                T_3_1.vec->data[1] = STR__040values_040accompany_040.num;
                T_3_1.vec->data[2] = which.num;
                T_3_1.vec->data[3] = STR__040_047.num;
                T_3_4.num = cond.vec->data[0];
                T_3_1.vec->data[4] = T_3_4.num;
                T_3_1.vec->data[5] = STR__047_054_0400_040expected.num;
                err = c_envOPerr(e, T_3_1);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */

  LINE(335);
            {
            {signal (ERR_ok);}}
            break;
            }
    case 1: 
         {CLUREF T_1_1;
        T_1_1.num = vars.cell->value;
        dl.num = T_1_1.num;

  LINE(337);
            {
            decls.num = dl.num;
            }
            break;
            }
    }
    }

  LINE(339);
    {
        {j.num = 1;
        }
        }

  LINE(340);
    {
        {CLUREF T_1_1;
        T_1_1.num = types.vec->size;
        h.num = T_1_1.num;
        }
        }

  LINE(341);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = decls.vec->size; 
        T_1_3 = decls;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            d.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(342);
            {
                {CLUREF T_2_1;
                T_2_1.num = d.vec->data[1];
                t.num = T_2_1.num;
                }
                }

  LINE(343);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = d.vec->data[0];
                T_2_3.num = T_2_1.vec->size; 
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    i.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(344);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = (j.num > h.num)? true : false;
                    if (T_3_1.num == true) {

  LINE(345);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        CLUREF T_4_3;
                        sequenceOPnew2(CLU_7, &T_4_1);
                        T_4_1.vec->data[0] = STR_not_040enough_040values_040_050.num;
                        err = intOPunparse(h, &T_4_2);
                        if (err != ERR_ok) goto ex_0;
                        T_4_1.vec->data[1] = T_4_2.num;
                        T_4_1.vec->data[2] = STR__051_040accompany_040.num;
                        T_4_1.vec->data[3] = which.num;
                        T_4_1.vec->data[4] = STR__040_047.num;
                        T_4_3.num = cond.vec->data[0];
                        T_4_1.vec->data[5] = T_4_3.num;
                        T_4_1.vec->data[6] = STR__047.num;
                        err = c_envOPerr(e, T_4_1);
                        if (err != ERR_ok) goto ex_0;
                        }

  LINE(348);
                        {
                        {signal (ERR_ok);}}
                        }
                        }/* end if */

  LINE(350);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    if (j.num < 1 || j.num > types.vec->size ) {
                        err = ERR_bounds;
                        goto ex_0;}
                    T_3_1.num = types.vec->data[j.num - 1];
                    err = typespecOPmismatch2(t, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    if (T_3_2.num == true) {

  LINE(351);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        CLUREF T_4_3;
                        CLUREF T_4_4;
                        sequenceOPnew2(CLU_7, &T_4_1);
                        T_4_1.vec->data[0] = STR_value_040assigned_040to_040_047.num;
                        err = idnOPget_str(i, &T_4_2);
                        if (err != ERR_ok) goto ex_0;
                        T_4_1.vec->data[1] = T_4_2.num;
                        T_4_1.vec->data[2] = STR__047_040by_040.num;
                        T_4_1.vec->data[3] = which.num;
                        T_4_1.vec->data[4] = STR__040_047.num;
                        T_4_3.num = cond.vec->data[0];
                        T_4_1.vec->data[5] = T_4_3.num;
                        T_4_1.vec->data[6] = STR__047.num;
                        if (j.num < 1 || j.num > types.vec->size ) {
                            err = ERR_bounds;
                            goto ex_0;}
                        T_4_4.num = types.vec->data[j.num - 1];
                        err = c_envOPerrt(e, T_4_1, t, T_4_4);
                        if (err != ERR_ok) goto ex_0;
                        }
                        }
                        }/* end if */

  LINE(356);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = j.num + 1;
                     if ((T_3_1.num > 0 && j.num < 0 && 1 < 0) || 
                         (T_3_1.num < 0 && j.num > 0 && 1 > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    j.num = T_3_1.num;
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(359);
    {
    CLUREF T_1_1;
    T_1_1.num = (j.num <= h.num)? true : false;
    if (T_1_1.num == true) {

  LINE(360);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        sequenceOPnew2(CLU_7, &T_2_1);
        T_2_1.vec->data[0] = STR_too_040many_040values_040_050.num;
        err = intOPunparse(h, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        T_2_1.vec->data[2] = STR__051_040accompany_040.num;
        T_2_1.vec->data[3] = which.num;
        T_2_1.vec->data[4] = STR__040_047.num;
        T_2_3.num = cond.vec->data[0];
        T_2_1.vec->data[5] = T_2_3.num;
        T_2_1.vec->data[6] = STR__047.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_when_assn ****/


extern errcode c_envOPpush_resigs();
CLUREF STR_duplicate_040resignal_040_047;
CLUREF STR_resignal_040_047;
static int c_resignal_own_init = 0;

/**** BEGIN PROCEDURE c_resignal ****/

errcode c_resignal(e, rs)
CLUREF e;
CLUREF rs;
    {
    errcode err;
    errcode ecode2;
    CLUREF resig;
    CLUREF cnt;
    CLUREF sig;
    CLUREF xsig;
        if (c_resignal_own_init == 0) {
        stringOPcons("duplicate resignal \'", CLU_1, CLU_20, &STR_duplicate_040resignal_040_047);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        stringOPcons("failure", CLU_1, CLU_7, &STR_failure);
        stringOPcons("resignal \'", CLU_1, CLU_10, &STR_resignal_040_047);
        stringOPcons("\' not listed in header", CLU_1, CLU_22, &STR__047_040not_040listed_040in_040header);
        c_resignal_own_init = 1;
    }
    enter_proc(366);

  LINE(367);
    {
    CLUREF T_1_1;
    T_1_1.num = rs.vec->data[0];
    err = c_envOPpush_resigs(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(368);
    {
    CLUREF T_1_1;
    T_1_1.num = rs.vec->data[1];
    err = c_stmt(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(369);
    {
    err = c_envOPpop_handlers(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(370);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = rs.vec->data[0];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            resig.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(371);
            {
                {cnt.num = 0;
                }
                }

  LINE(372);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = rs.vec->data[0];
                T_2_3.num = T_2_1.vec->size; 
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    sig.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(373);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = ((resig.str->size != sig.str->size)? false :
                        !(bcmp(resig.str->data, sig.str->data, resig.str->size)));
                    if (T_3_1.num == true) {

  LINE(374);
                        {
                        CLUREF T_4_1;
                        T_4_1.num = cnt.num + 1;
                         if ((T_4_1.num > 0 && cnt.num < 0 && 1 < 0) || 
                             (T_4_1.num < 0 && cnt.num > 0 && 1 > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        cnt.num = T_4_1.num;
                        }
                        }
                        }/* end if */
                }
            }
            end_inline_for_2:;

  LINE(376);
            {
            CLUREF T_2_1;
            T_2_1.num = (cnt.num > 1)? true : false;
            if (T_2_1.num == true) {

  LINE(377);
                {
                CLUREF T_3_1;
                sequenceOPnew2(CLU_3, &T_3_1);
                T_3_1.vec->data[0] = STR_duplicate_040resignal_040_047.num;
                T_3_1.vec->data[1] = resig.num;
                T_3_1.vec->data[2] = STR__047.num;
                err = c_envOPerr(e, T_3_1);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */

  LINE(379);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
                err = c_envOPget_xsignals(e, &T_3_1);
                if (err != ERR_ok) goto ex_1;
                T_3_3.num = T_3_1.vec->size; 
                T_3_4 = T_3_1;
                for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                    xsig.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(380);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    T_4_1.num = xsig.vec->data[0];
                    T_4_2.num = ((resig.str->size != T_4_1.str->size)? false :
                        !(bcmp(resig.str->data, T_4_1.str->data, resig.str->size)));
                    if (T_4_2.num == true) {

  LINE(381);
                        {
                            err = "ERR_ok_UNIQ";
                            goto ex_1;
                            }
                        }
                        }/* end if */
                }
            }
            end_inline_for_3:;
                goto end_1;
                ex_1:
                    if (errcmp(err, "ERR_ok_UNIQ")) {

  LINE(382);
                        continue;
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;

  LINE(383);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = ((resig.str->size != STR_failure.str->size)? false :
                !(bcmp(resig.str->data, STR_failure.str->data, resig.str->size)));
            T_2_2.num = T_2_1.num ^ 1;
            if (T_2_2.num == true) {

  LINE(384);
                {
                CLUREF T_3_1;
                sequenceOPnew2(CLU_3, &T_3_1);
                T_3_1.vec->data[0] = STR_resignal_040_047.num;
                T_3_1.vec->data[1] = resig.num;
                T_3_1.vec->data[2] = STR__047_040not_040listed_040in_040header.num;
                err = c_envOPerr(e, T_3_1);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_resignal ****/


CLUREF STR__047_040caught_040by_040resignal_040statement;
CLUREF STR__047_054_040;
CLUREF STR_value_040;
CLUREF STR__040accompanying_040;
static int c_resig_catch_own_init = 0;

/**** BEGIN PROCEDURE c_resig_catch ****/

errcode c_resig_catch(e, cond, is_exit)
CLUREF e;
CLUREF cond;
CLUREF is_exit;
    {
    errcode err;
    errcode ecode2;
    CLUREF which;
    CLUREF n;
    CLUREF args;
    CLUREF types;
    CLUREF xsig;
    CLUREF cvt_;
    CLUREF i;
    CLUREF t;
        if (c_resig_catch_own_init == 0) {
        stringOPcons("exception", CLU_1, CLU_9, &STR_exception);
        stringOPcons("exit \'", CLU_1, CLU_6, &STR_exit_040_047);
        stringOPcons("\' caught by resignal statement", CLU_1, CLU_30, &STR__047_040caught_040by_040resignal_040statement);
        stringOPcons("exit", CLU_1, CLU_4, &STR_exit);
        stringOPcons(" values accompany ", CLU_1, CLU_18, &STR__040values_040accompany_040);
        stringOPcons(" \'", CLU_1, CLU_2, &STR__040_047);
        stringOPcons("\', ", CLU_1, CLU_3, &STR__047_054_040);
        stringOPcons(" expected", CLU_1, CLU_9, &STR__040expected);
        stringOPcons("value ", CLU_1, CLU_6, &STR_value_040);
        stringOPcons(" accompanying ", CLU_1, CLU_14, &STR__040accompanying_040);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        c_resig_catch_own_init = 1;
    }
    enter_proc(390);

  LINE(391);
    {
        {which = STR_exception;
        }
        }

  LINE(392);
    {
    if (is_exit.num == true) {

  LINE(393);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_3, &T_2_1);
        T_2_1.vec->data[0] = STR_exit_040_047.num;
        T_2_2.num = cond.vec->data[0];
        T_2_1.vec->data[1] = T_2_2.num;
        T_2_1.vec->data[2] = STR__047_040caught_040by_040resignal_040statement.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(395);
        {
        which = STR_exit;
        }
        }
        }/* end if */

  LINE(397);
    {
        {CLUREF T_1_1;
        T_1_1.num = cond.vec->data[0];
        n.num = T_1_1.num;
        }
        }

  LINE(398);
    {
        {CLUREF T_1_1;
        T_1_1.num = cond.vec->data[1];
        args.num = T_1_1.num;
        }
        }

  LINE(400);
    {

  LINE(401);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
            err = c_envOPget_xsignals(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            T_3_3.num = T_3_1.vec->size; 
            T_3_4 = T_3_1;
            for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                xsig.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(402);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = xsig.vec->data[0];
                T_4_2.num = ((n.str->size != T_4_1.str->size)? false :
                    !(bcmp(n.str->data, T_4_1.str->data, n.str->size)));
                if (T_4_2.num == true) {

  LINE(403);
                    {
                    CLUREF T_5_1;
                    T_5_1.num = xsig.vec->data[1];
                    types.num = T_5_1.num;
                    }

  LINE(404);
                    {
                        err = "ERR_ok_UNIQ";
                        goto ex_1;
                        }
                    }
                    }/* end if */
            }
        }
        end_inline_for_1:;

  LINE(407);
        {
        {signal (ERR_ok);}}
        }
        goto end_1;
        ex_1:
            if (errcmp(err, "ERR_ok_UNIQ")) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(409);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = args.vec->size;
    T_1_2.num = types.vec->size;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {

  LINE(410);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        sequenceOPnew2(CLU_8, &T_2_1);
        T_2_2.num = args.vec->size;
        err = intOPunparse(T_2_2, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[0] = T_2_3.num;
        T_2_1.vec->data[1] = STR__040values_040accompany_040.num;
        T_2_1.vec->data[2] = which.num;
        T_2_1.vec->data[3] = STR__040_047.num;
        T_2_1.vec->data[4] = n.num;
        T_2_1.vec->data[5] = STR__047_054_040.num;
        T_2_4.num = types.vec->size;
        err = intOPunparse(T_2_4, &T_2_5);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[6] = T_2_5.num;
        T_2_1.vec->data[7] = STR__040expected.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(415);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(417);
    {
        {CLUREF T_1_1;
        err = c_envOPget_cvt_type(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        cvt_.num = T_1_1.num;
        }
        }

  LINE(418);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = types.vec->size; 
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(419);
            {
                {CLUREF T_2_1;
                if (i.num < 1 || i.num > types.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = types.vec->data[i.num - 1];
                t.num = T_2_1.num;
                }
                }

  LINE(420);
            {
            CLUREF T_2_1;
            err = typespecOPequal(t, cvt_, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            if (T_2_1.num == true) {

  LINE(421);
                {
                CLUREF T_3_1;
                err = c_envOPget_down_type(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                t.num = T_3_1.num;
                }
                }
                }/* end if */

  LINE(422);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            if (i.num < 1 || i.num > args.vec->size ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = args.vec->data[i.num - 1];
            err = typespecOPmismatch2(t, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            if (T_2_2.num == true) {

  LINE(423);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                sequenceOPnew2(CLU_7, &T_3_1);
                T_3_1.vec->data[0] = STR_value_040.num;
                err = intOPunparse(i, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_1.vec->data[1] = T_3_2.num;
                T_3_1.vec->data[2] = STR__040accompanying_040.num;
                T_3_1.vec->data[3] = which.num;
                T_3_1.vec->data[4] = STR__040_047.num;
                T_3_1.vec->data[5] = n.num;
                T_3_1.vec->data[6] = STR__047.num;
                if (i.num < 1 || i.num > args.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_3_3.num = args.vec->data[i.num - 1];
                err = c_envOPerrt(e, T_3_1, t, T_3_3);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */
        }
    }
    end_inline_for_2:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_resig_catch ****/


extern errcode idnOPcreate();
extern errcode oneofOPmake_5();
extern errcode c_envOPget_type();
extern errcode oneofOPmake_25();
extern errcode c_envOPget_type_type();
extern errcode c_envOPdeclare();
extern errcode oneofOPmake_1();
extern errcode c_envOPbegin_specs();
extern errcode c_restrictlist();
extern errcode c_envOPend_specs();
extern errcode c_add_restricts();
extern errcode c_envOPadd_var();
CLUREF STR_FORCE_040expression;
static int c_forcestmt_own_init = 0;

/**** BEGIN PROCEDURE c_forcestmt ****/

errcode c_forcestmt(e, fs)
CLUREF e;
CLUREF fs;
    {
    errcode err;
    errcode ecode2;
    CLUREF t;
    CLUREF i;
    CLUREF ni;
    CLUREF nt;
    CLUREF x;
    CLUREF reqs;
        if (c_forcestmt_own_init == 0) {
        stringOPcons("FORCE expression", CLU_1, CLU_16, &STR_FORCE_040expression);
        c_forcestmt_own_init = 1;
    }
    enter_proc(431);

  LINE(432);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = fs.vec->data[0];
        err = c_expr(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        t.num = T_1_2.num;
        }
        }

  LINE(433);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = c_envOPget_any_type(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = typespecOPmismatch(t, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    if (T_1_2.num == true) {

  LINE(434);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_1, &T_2_1);
        T_2_1.vec->data[0] = STR_FORCE_040expression.num;
        err = c_envOPget_any_type(e, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        err = c_envOPerrt(e, T_2_1, T_2_2, t);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(435);
    {
        {CLUREF T_1_1;
        T_1_1.num = fs.vec->data[1];
        i.num = T_1_1.num;
        }
        }

  LINE(436);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        err = idnOPget_str(i, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        err = sequenceOPnew(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        CellAlloc(5, T_1_2.num, T_1_3);
        err = idnOPcreate(T_1_1, T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        ni.num = T_1_4.num;
        }
        }

  LINE(437);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CellAlloc(5, ni.num, T_1_1);
        err = c_envOPget_type(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        nt.num = T_1_2.num;
        }
        }

  LINE(438);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CellAlloc(25, nt.num, T_1_1);
        err = c_envOPget_type_type(e, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        err = exprOPcreate(T_1_1, T_1_2, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        x.num = T_1_3.num;
        }
        }

  LINE(439);
    {
    CLUREF T_1_1;
    CellAlloc(1, x.num, T_1_1);
    err = c_envOPdeclare(e, i, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(440);
    {
        {CLUREF T_1_1;
        T_1_1.num = fs.vec->data[3];
        reqs.num = T_1_1.num;
        }
        }

  LINE(441);
    {
    err = c_envOPbegin_specs(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(442);
    {
    err = c_restrictlist(e, reqs);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(443);
    {
    err = c_envOPend_specs(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(444);
    {
    err = c_add_restricts(e, reqs);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(445);
    {
    err = c_restrictlist(e, reqs);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(446);
    {
    CLUREF T_1_1;
    T_1_1.num = fs.vec->data[2];
    err = c_envOPadd_var(e, T_1_1, nt);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_forcestmt ****/

