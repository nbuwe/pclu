
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


extern errcode p_envOPget_peekline();
extern errcode p_envOPget_peek1();
extern errcode p_envOPnext_token();
extern errcode p_if();
extern errcode p_for();
extern errcode p_tagcase();
extern errcode p_while();
extern errcode boolOPnot();
extern errcode p_envOPin_proc();
extern errcode p_envOPspecd_vals();
extern errcode oneofOPmake_15();
extern errcode p_plist();
extern errcode p_expr();
extern errcode oneofOPmake_20();
extern errcode oneofOPmake_16();
extern errcode p_condition();
extern errcode oneofOPmake_9();
extern errcode oneofOPmake_4();
extern errcode oneofOPmake_5();
extern errcode oneofOPmake_3();
extern errcode p_body();
extern errcode p_end();
extern errcode p_ownstmt();
extern errcode p_envOPpeek();
extern errcode p_decl_or_assn();
extern errcode p_expr_stmt();
extern errcode p_forcestmt();
extern errcode p_envOPerr();
extern errcode oneofOPmake_2();
extern errcode p_find_a_stmt();
extern errcode p_except();
extern errcode stmtOPcreate();
extern struct REQS *p_plist_of_t_reqs;
extern struct OPS *expr_ops;
extern OWN_req p_plist_ownreqs;
struct OPS *p_plist_of_expr_table;
struct OPS *p_plist_of_expr_ops;
struct OPS *p_plist_of_expr_ops;
OWNPTR p_plist_of_expr_owns;
CLUREF STR_expression;
CLUREF STR_END_040of_040BEGIN_055END_040statement;
CLUREF STR_operator_040or_040_050_040starts_040statement;
CLUREF STR_EXCEPT_040clause_040not_040attached_040to_040statement;
static int p_stmt_own_init = 0;

/**** BEGIN PROCEDURE p_stmt ****/

errcode p_stmt(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF abs;
    CLUREF l;
    CLUREF k;
    CLUREF opt;
        if (p_stmt_own_init == 0) {
        add_parm_info_type(0, expr_ops, p_plist_of_t_reqs);
        find_prociter_instance(p_plist, 1, &p_plist_ownreqs, &(p_plist_of_expr_ops));
        stringOPcons("expression", CLU_1, CLU_10, &STR_expression);
        stringOPcons("END of BEGIN-END statement", CLU_1, CLU_26, &STR_END_040of_040BEGIN_055END_040statement);
        stringOPcons("operator or ( starts statement", CLU_1, CLU_30, &STR_operator_040or_040_050_040starts_040statement);
        stringOPcons("EXCEPT clause not attached to statement", CLU_1, CLU_39, &STR_EXCEPT_040clause_040not_040attached_040to_040statement);
        p_stmt_own_init = 1;
    }
    enter_proc(12);

  LINE(14);
    {
        {CLUREF T_1_1;
        err = p_envOPget_peekline(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        l.num = T_1_1.num;
        }
        }

  LINE(15);
    {
    CLUREF T_2_1;
    err = p_envOPget_peek1(e, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    switch (T_2_1.cell->tag) {
    case 34: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        k.num = T_2_2.num;

  LINE(17);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(18);
            {
            switch (k.cell->tag) {
            case 6: 
                 {

  LINE(19);
                    {
                    CLUREF T_4_1;
                    err = p_if(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    abs.num = T_4_1.num;
                    }
                    break;
                    }
            case 5: 
                 {

  LINE(20);
                    {
                    CLUREF T_4_1;
                    err = p_for(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    abs.num = T_4_1.num;
                    }
                    break;
                    }
            case 10: 
                 {

  LINE(21);
                    {
                    CLUREF T_4_1;
                    err = p_tagcase(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    abs.num = T_4_1.num;
                    }
                    break;
                    }
            case 11: 
                 {

  LINE(22);
                    {
                    CLUREF T_4_1;
                    err = p_while(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    abs.num = T_4_1.num;
                    }
                    break;
                    }
            case 8: 
                 {

  LINE(23);
                    {
                        {CLUREF T_4_1;
                        CLUREF T_4_2;
                        CLUREF T_4_3;
                        CLUREF T_4_4;
                        err = p_envOPin_proc(e, &T_4_2);
                        if (err != ERR_ok) goto ex_1;
                        T_4_1.num = T_4_2.num;
                        if (T_4_2.num) {
                            err = p_envOPspecd_vals(e, &T_4_3);
                            if (err != ERR_ok) goto ex_1;
                            T_4_1.num = T_4_3.num;
                        }
                        T_4_4.num = T_4_1.num ^ 1;
                        opt.num = T_4_4.num;
                        }
                        }

  LINE(25);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    CLUREF T_4_3;
                    err = proctypeOPnew(CLU_0, &T_4_1.proc);
                    if (err!= ERR_ok) goto ex_1;
                    T_4_1.proc->type_owns = 0;
                    T_4_1.proc->op_owns = 0;
                    T_4_1.proc->proc = p_expr;
                    generic_CLU_proc.type_owns = 0;
                    generic_CLU_proc.op_owns = (long)p_plist_of_expr_ops->op_owns;
                    generic_CLU_proc.proc = p_plist;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = p_plist(e, T_4_1, opt, CLU_0, STR_expression, &T_4_2);
                    if (err != ERR_ok) goto ex_1;
                    CellAlloc(15, T_4_2.num, T_4_3);
                    abs.num = T_4_3.num;
                    }
                    break;
                    }
            case 12: 
                 {

  LINE(28);
                    {
                        {CLUREF T_4_1;
                        CLUREF T_4_2;
                        CLUREF T_4_3;
                        CLUREF T_4_4;
                        err = p_envOPin_proc(e, &T_4_2);
                        if (err != ERR_ok) goto ex_1;
                        T_4_1.num = T_4_2.num;
                        if (!T_4_2.num) {
                            err = p_envOPspecd_vals(e, &T_4_3);
                            if (err != ERR_ok) goto ex_1;
                            T_4_4.num = T_4_3.num ^ 1;
                            T_4_1.num = T_4_4.num;
                        }
                        opt.num = T_4_1.num;
                        }
                        }

  LINE(30);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    CLUREF T_4_3;
                    err = proctypeOPnew(CLU_0, &T_4_1.proc);
                    if (err!= ERR_ok) goto ex_1;
                    T_4_1.proc->type_owns = 0;
                    T_4_1.proc->op_owns = 0;
                    T_4_1.proc->proc = p_expr;
                    generic_CLU_proc.type_owns = 0;
                    generic_CLU_proc.op_owns = (long)p_plist_of_expr_ops->op_owns;
                    generic_CLU_proc.proc = p_plist;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = p_plist(e, T_4_1, opt, CLU_0, STR_expression, &T_4_2);
                    if (err != ERR_ok) goto ex_1;
                    CellAlloc(20, T_4_2.num, T_4_3);
                    abs.num = T_4_3.num;
                    }
                    break;
                    }
            case 9: 
                 {

  LINE(33);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    err = p_condition(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    CellAlloc(16, T_4_1.num, T_4_2);
                    abs.num = T_4_2.num;
                    }
                    break;
                    }
            case 4: 
                 {

  LINE(34);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    err = p_condition(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    CellAlloc(9, T_4_1.num, T_4_2);
                    abs.num = T_4_2.num;
                    }
                    break;
                    }
            case 2: 
                 {

  LINE(35);
                    {
                    CLUREF T_4_1;
                    CellAlloc(4, nil, T_4_1);
                    abs.num = T_4_1.num;
                    }
                    break;
                    }
            case 3: 
                 {

  LINE(36);
                    {
                    CLUREF T_4_1;
                    CellAlloc(5, nil, T_4_1);
                    abs.num = T_4_1.num;
                    }
                    break;
                    }
            case 1: 
                 {

  LINE(37);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    err = p_body(e, CLU_3, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    CellAlloc(3, T_4_1.num, T_4_2);
                    abs.num = T_4_2.num;
                    }

  LINE(38);
                    {
                    err = p_end(e, STR_END_040of_040BEGIN_055END_040statement);
                    if (err != ERR_ok) goto ex_1;
                    }
                    break;
                    }
            case 7: 
                 {

  LINE(39);
                    {
                    CLUREF T_4_1;
                    err = p_ownstmt(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    abs.num = T_4_1.num;
                    }
                    break;
                    }
            }
            }
            break;
            }
    case 16: 
         {

  LINE(42);
            {
            CLUREF T_3_1;
            err = p_envOPpeek(e, CLU_2, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            switch (T_3_1.cell->tag) {
            case 3: 
            case 1: 
            case 2: 
                 {

  LINE(44);
                    {
                    CLUREF T_4_1;
                    err = p_decl_or_assn(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    abs.num = T_4_1.num;
                    }
                    break;
                    }
            case 11: 
                 {

  LINE(46);
                    {
                    CLUREF T_4_1;
                    err = p_envOPpeek(e, CLU_3, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    switch (T_4_1.cell->tag) {
                    case 4: 
                         {

  LINE(47);
                            {
                            {signal (ERR_none);}}
                            break;
                            }
                    default: {

  LINE(48);
                        {
                        CLUREF T_5_1;
                        err = p_decl_or_assn(e, &T_5_1);
                        if (err != ERR_ok) goto ex_1;
                        abs.num = T_5_1.num;
                        }
                    }
                    }
                    }
                    break;
                    }
            default: {

  LINE(51);
                {
                CLUREF T_4_1;
                err = p_expr_stmt(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                abs.num = T_4_1.num;
                }
            }
            }
            }
            break;
            }
    case 14: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        k.num = T_2_3.num;

  LINE(54);
            {
            switch (k.cell->tag) {
            case 2: 
                 {

  LINE(56);
                    {
                    CLUREF T_4_1;
                    err = p_envOPpeek(e, CLU_2, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    switch (T_4_1.cell->tag) {
                    case 16: 
                         {

  LINE(57);
                            {
                            CLUREF T_5_1;
                            err = p_forcestmt(e, &T_5_1);
                            if (err != ERR_ok) goto ex_1;
                            abs.num = T_5_1.num;
                            }
                            break;
                            }
                    default: {

  LINE(58);
                        {
                        CLUREF T_5_1;
                        err = p_expr_stmt(e, &T_5_1);
                        if (err != ERR_ok) goto ex_1;
                        abs.num = T_5_1.num;
                        }
                    }
                    }
                    }
                    break;
                    }
            default: {

  LINE(61);
                {
                CLUREF T_4_1;
                err = p_expr_stmt(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                abs.num = T_4_1.num;
                }
            }
            }
            }
            break;
            }
    case 37: 
    case 38: 
    case 13: 
         {

  LINE(64);
            {
            CLUREF T_3_1;
            err = p_expr_stmt(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            abs.num = T_3_1.num;
            }
            break;
            }
    case 23: 
    case 22: 
    case 21: 
         {

  LINE(66);
            {
            err = p_envOPerr(e, STR_operator_040or_040_050_040starts_040statement, CLU_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(67);
            {
            CLUREF T_3_1;
            err = p_expr_stmt(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            abs.num = T_3_1.num;
            }
            break;
            }
    case 12: 
         {

  LINE(69);
            {
            err = p_envOPerr(e, STR_EXCEPT_040clause_040not_040attached_040to_040statement, CLU_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(70);
            {
            CLUREF T_3_1;
            CellAlloc(2, nil, T_3_1);
            abs.num = T_3_1.num;
            }
            break;
            }
    default: {

  LINE(72);
        {
        CLUREF T_3_1;
        err = p_find_a_stmt(e, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        if (T_3_1.num == true) {

  LINE(73);
            {
            CLUREF T_4_1;
            CellAlloc(2, nil, T_4_1);
            abs.num = T_4_1.num;
            }
            }
        else {

  LINE(74);
            {
            {signal (ERR_none);}}
            }}/* end if */
    }
    }
    }
        goto end_1;
        ex_1:
            if ((err == ERR_bad)) {

  LINE(77);
                {
                CLUREF T_2_1;
                CellAlloc(2, nil, T_2_1);
                abs.num = T_2_1.num;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(78);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = stmtOPcreate(abs, l, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = p_except(e, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_stmt ****/


extern errcode sequenceOPnew();
extern errcode p_expr1();
extern errcode p_envOPassume();
extern errcode sequenceOPaddh();
extern errcode oneofOPmake_1();
extern errcode oneofOPmake_12();
CLUREF STR_THEN_040in_040IF_040statement;
CLUREF STR_END_040of_040IF_040statement;
static int p_if_own_init = 0;

/**** BEGIN PROCEDURE p_if ****/

errcode p_if(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF arms;
    CLUREF else_;
    CLUREF line;
    CLUREF x;
    CLUREF bod;
        if (p_if_own_init == 0) {
        stringOPcons("THEN in IF statement", CLU_1, CLU_20, &STR_THEN_040in_040IF_040statement);
        stringOPcons("END of IF statement", CLU_1, CLU_19, &STR_END_040of_040IF_040statement);
        p_if_own_init = 1;
    }
    enter_proc(85);

  LINE(86);
    {
        {CLUREF T_1_1;
        err = sequenceOPnew(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        arms.num = T_1_1.num;
        }
        }

  LINE(87);
    {
        {CLUREF T_1_1;
        CellAlloc(2, nil, T_1_1);
        else_.num = T_1_1.num;
        }
        }

  LINE(88);
    for (;;) {
        if (true != true) { break; }

  LINE(89);
        {
            {CLUREF T_2_1;
            err = p_envOPget_peekline(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            line.num = T_2_1.num;
            }
            }

  LINE(90);
        {
            {CLUREF T_2_1;
            err = p_expr1(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            x.num = T_2_1.num;
            }
            }

  LINE(91);
        {
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 36: 
             {

  LINE(92);
                {
                CLUREF T_3_1;
                err = p_envOPnext_token(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                }
                break;
                }
        default: {

  LINE(93);
            {
            err = p_envOPassume(e, STR_THEN_040in_040IF_040statement);
            if (err != ERR_ok) goto ex_0;
            }
        }
        }
        }

  LINE(95);
        {
            {CLUREF T_2_1;
            err = p_body(e, CLU_0, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            bod.num = T_2_1.num;
            }
            }

  LINE(96);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(3, T_2_1);
        T_2_1.vec->data[2]  = x.num;
        T_2_1.vec->data[0]  = bod.num;
        T_2_1.vec->data[1]  = line.num;
        err = sequenceOPaddh(arms, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        arms.num = T_2_2.num;
        }

  LINE(99);
        {
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 8: 
             {

  LINE(100);
                {
                CLUREF T_3_1;
                err = p_envOPnext_token(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(101);
                continue;
                break;
                }
        case 7: 
             {

  LINE(102);
                {
                CLUREF T_3_1;
                err = p_envOPnext_token(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(103);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                err = p_body(e, CLU_3, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                CellAlloc(1, T_3_1.num, T_3_2);
                else_.num = T_3_2.num;
                }
                break;
                }
        default: {
        }
        }
        }

  LINE(106);
        {
        err = p_end(e, STR_END_040of_040IF_040statement);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(108);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(2, T_2_1);
        T_2_1.vec->data[0]  = arms.num;
        T_2_1.vec->data[1]  = else_.num;
        CellAlloc(12, T_2_1.num, T_2_2);
        ret_1->num = T_2_2.num;
        }
        {signal (ERR_ok);}}
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_if ****/


extern errcode p_idns_or_decls();
extern errcode p_make_invoke();
extern errcode p_do();
extern errcode oneofOPmake_10();
CLUREF STR_use_040of_040_072_075_040instead_040of_040IN;
CLUREF STR_IN_040in_040FOR_040statement;
CLUREF STR_expression_040not_040an_040invocation;
static int p_for_own_init = 0;

/**** BEGIN PROCEDURE p_for ****/

errcode p_for(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF vars;
    CLUREF call;
    CLUREF bod;
        if (p_for_own_init == 0) {
        stringOPcons("use of := instead of IN", CLU_1, CLU_23, &STR_use_040of_040_072_075_040instead_040of_040IN);
        stringOPcons("IN in FOR statement", CLU_1, CLU_19, &STR_IN_040in_040FOR_040statement);
        stringOPcons("expression not an invocation", CLU_1, CLU_28, &STR_expression_040not_040an_040invocation);
        p_for_own_init = 1;
    }
    enter_proc(115);

  LINE(117);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 17: 
         {

  LINE(118);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = sequenceOPnew(&T_2_1);
            if (err != ERR_ok) goto ex_0;
            CellAlloc(2, T_2_1.num, T_2_2);
            vars.num = T_2_2.num;
            }
            break;
            }
    default: {

  LINE(119);
        {
        CLUREF T_2_1;
        err = p_idns_or_decls(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        vars.num = T_2_1.num;
        }
    }
    }
    }

  LINE(121);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 17: 
         {

  LINE(122);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 1: 
         {

  LINE(123);
            {
            err = p_envOPerr(e, STR_use_040of_040_072_075_040instead_040of_040IN, CLU_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(124);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(125);
        {
        err = p_envOPassume(e, STR_IN_040in_040FOR_040statement);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(127);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = p_expr1(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        err = p_make_invoke(e, T_1_1, STR_expression_040not_040an_040invocation, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        call.num = T_1_2.num;
        }
        }

  LINE(129);
    {
        {CLUREF T_1_1;
        err = p_do(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        bod.num = T_1_1.num;
        }
        }

  LINE(130);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(5, T_1_1);
    T_1_1.vec->data[3]  = vars.num;
    err = sequenceOPnew(&T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[0]  = T_1_2.num;
    T_1_1.vec->data[2]  = call.num;
    T_1_1.vec->data[1]  = bod.num;
    T_1_1.vec->data[4]  = false;
    CellAlloc(10, T_1_1.num, T_1_3);
    ret_1->num = T_1_3.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_for ****/


CLUREF STR_DO_040of_040DO_056_056_056END_040clause;
CLUREF STR_END_040of_040DO_056_056_056END_040clause;
static int p_do_own_init = 0;

/**** BEGIN PROCEDURE p_do ****/

errcode p_do(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF bod;
        if (p_do_own_init == 0) {
        stringOPcons("DO of DO...END clause", CLU_1, CLU_21, &STR_DO_040of_040DO_056_056_056END_040clause);
        stringOPcons("END of DO...END clause", CLU_1, CLU_22, &STR_END_040of_040DO_056_056_056END_040clause);
        p_do_own_init = 1;
    }
    enter_proc(139);

  LINE(140);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 5: 
         {

  LINE(141);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(142);
        {
        err = p_envOPassume(e, STR_DO_040of_040DO_056_056_056END_040clause);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(144);
    {
        {CLUREF T_1_1;
        err = p_body(e, CLU_3, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        bod.num = T_1_1.num;
        }
        }

  LINE(145);
    {
    err = p_end(e, STR_END_040of_040DO_056_056_056END_040clause);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(146);
    {
    {
    ret_1->num = bod.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_do ****/


extern errcode p_clist();
extern errcode p_idn();
extern errcode p_type1();
extern errcode p_decl();
extern errcode sequenceOPaddl();
extern struct REQS *p_clist_of_t_reqs;
extern struct OPS *idn_ops;
extern OWN_req p_clist_ownreqs;
struct OPS *p_clist_of_idn_table;
struct OPS *p_clist_of_idn_ops;
struct OPS *p_clist_of_idn_ops;
OWNPTR p_clist_of_idn_owns;
extern struct REQS *sequence_of_t_reqs;
extern OWN_req sequence_ownreqs;
extern struct OPS *sequence_ops;
struct OPS *sequence_of_idn_table;
struct OPS *sequence_of_idn_ops;
struct OPS *sequence_of_idn_ops;
OWNPTR sequence_of_idn_owns;
extern struct OPS *sequence_of_idn_ops;
extern struct OPS *typespec_ops;
struct OPS  *record_idns_type__ops;
extern struct OPS *record_idns_type__ops;
struct OPS *p_clist_of_record_idns_type__table;
struct OPS *p_clist_of_record_idns_type__ops;
struct OPS *p_clist_of_record_idns_type__ops;
OWNPTR p_clist_of_record_idns_type__owns;
CLUREF STR_idn;
CLUREF STR_decl;
static int p_idns_or_decls_own_init = 0;

/**** BEGIN PROCEDURE p_idns_or_decls ****/

errcode p_idns_or_decls(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF idns;
    CLUREF t;
    CLUREF decls;
        if (p_idns_or_decls_own_init == 0) {
        add_parm_info_type(0, idn_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_idn_ops));
        add_parm_info_type(0, idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, sequence_of_idn_ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_parm_info_type(0, record_idns_type__ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_record_idns_type__ops));
        stringOPcons("idn", CLU_1, CLU_3, &STR_idn);
        stringOPcons("decl", CLU_1, CLU_4, &STR_decl);
        p_idns_or_decls_own_init = 1;
    }
    enter_proc(151);

  LINE(152);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_idn;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_clist_of_idn_ops->op_owns;
        generic_CLU_proc.proc = p_clist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_clist(e, T_1_1, STR_idn, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        idns.num = T_1_2.num;
        }
        }

  LINE(153);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: 
         {

  LINE(155);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(156);
            {
                {CLUREF T_2_1;
                err = p_type1(e, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                t.num = T_2_1.num;
                }
                }

  LINE(158);
            {
            CLUREF T_2_1;
            err = p_envOPget_peek1(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_1.cell->tag) {
            case 3: 
                 {

  LINE(159);
                    {
                    CLUREF T_3_1;
                    err = p_envOPnext_token(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(160);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = proctypeOPnew(CLU_0, &T_3_1.proc);
                    if (err!= ERR_ok) goto ex_0;
                    T_3_1.proc->type_owns = 0;
                    T_3_1.proc->op_owns = 0;
                    T_3_1.proc->proc = p_decl;
                    generic_CLU_proc.type_owns = 0;
                    generic_CLU_proc.op_owns = (long)p_clist_of_record_idns_type__ops->op_owns;
                    generic_CLU_proc.proc = p_clist;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = p_clist(e, T_3_1, STR_decl, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    decls.num = T_3_2.num;
                    }
                    break;
                    }
            default: {

  LINE(161);
                {
                CLUREF T_3_1;
                err = sequenceOPnew(&T_3_1);
                if (err != ERR_ok) goto ex_0;
                decls.num = T_3_1.num;
                }
            }
            }
            }

  LINE(163);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            RecordAlloc(2, T_2_1);
            T_2_1.vec->data[0]  = idns.num;
            T_2_1.vec->data[1]  = t.num;
            err = sequenceOPaddl(decls, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            decls.num = T_2_2.num;
            }

  LINE(165);
            {
            {
            CLUREF T_2_1;
            CellAlloc(1, decls.num, T_2_1);
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(167);
        {
        {
        CLUREF T_2_1;
        CellAlloc(2, idns.num, T_2_1);
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_idns_or_decls ****/



/**** BEGIN PROCEDURE p_idn ****/

errcode p_idn(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF k;
    enter_proc(173);

  LINE(174);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 16: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(176);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(177);
            {
            {
            ret_1->num = k.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(179);
        {
        {signal (ERR_none);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_idn ****/



/**** BEGIN ITERATOR p_idn1 ****/

errcode p_idn1(e, proc, user_locals, iecode)
CLUREF e;
errcode (*proc)();
char **user_locals;
errcode *iecode;
    {
    errcode ecode;
    errcode err;
    errcode ecode2;
    bool body_ctrl_req;
    enter_proc(183);

  LINE(184);
    {
    CLUREF T_2_1;
    err = p_idn(e, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    err = proc(T_2_1, user_locals, iecode);
    if (err != ERR_ok) {
    if (err == ERR_break) {signal(ERR_break);}
    if (err == ERR_iterbodyreturn) {signal(ERR_iterbodyreturn);}
    if (err == ERR_iterbodyexit) {signal(ERR_iterbodyexit);}
    if (err == ERR_iterbodysignal) {signal(ERR_iterbodysignal);}
    {signal(err);
        }}
    }
        goto end_1;
        ex_1:
            if ((err == ERR_none)) {
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END ITERATOR p_idn1 ****/


extern errcode p_envOPget_unknown_type();
struct OPS *p_clist_of_idn_table;
struct OPS *p_clist_of_idn_ops;
struct OPS *p_clist_of_idn_ops;
OWNPTR p_clist_of_idn_owns;
CLUREF STR__072_040type_040in_040declaration;
static int p_decl_own_init = 0;

/**** BEGIN PROCEDURE p_decl ****/

errcode p_decl(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF idns;
    CLUREF t;
        if (p_decl_own_init == 0) {
        add_parm_info_type(0, idn_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_idn_ops));
        stringOPcons("idn", CLU_1, CLU_3, &STR_idn);
        stringOPcons(": type in declaration", CLU_1, CLU_21, &STR__072_040type_040in_040declaration);
        p_decl_own_init = 1;
    }
    enter_proc(192);

  LINE(193);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_idn;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_clist_of_idn_ops->op_owns;
        generic_CLU_proc.proc = p_clist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_clist(e, T_1_1, STR_idn, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        idns.num = T_1_2.num;
        }
        }

  LINE(195);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: 
         {

  LINE(196);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(197);
            {
            CLUREF T_2_1;
            err = p_type1(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            t.num = T_2_1.num;
            }
            break;
            }
    default: {

  LINE(198);
        {
        err = p_envOPassume(e, STR__072_040type_040in_040declaration);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(199);
        {
        CLUREF T_2_1;
        err = p_envOPget_unknown_type(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        t.num = T_2_1.num;
        }
    }
    }
    }

  LINE(201);
    {
    {
    CLUREF T_1_1;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[0]  = idns.num;
    T_1_1.vec->data[1]  = t.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_decl ****/


extern errcode p_list();
extern errcode p_tagarm();
extern errcode oneofOPmake_18();
extern errcode recordOPset_3();
extern errcode p_cbody();
extern struct OPS *equate_ops;
struct OPS *sequence_of_equate_table;
struct OPS *sequence_of_equate_ops;
struct OPS *sequence_of_equate_ops;
OWNPTR sequence_of_equate_owns;
extern struct OPS *stmt_ops;
struct OPS *sequence_of_stmt_table;
struct OPS *sequence_of_stmt_ops;
struct OPS *sequence_of_stmt_ops;
OWNPTR sequence_of_stmt_owns;
extern struct OPS *sequence_of_equate_ops;
extern struct OPS *sequence_of_stmt_ops;
struct OPS  *record_equates_stmts_ops;
extern struct OPS *string_ops;
struct OPS *sequence_of_string_table;
struct OPS *sequence_of_string_ops;
struct OPS *sequence_of_string_ops;
OWNPTR sequence_of_string_owns;
struct OPS *sequence_of_idn_table;
struct OPS *sequence_of_idn_ops;
struct OPS *sequence_of_idn_ops;
OWNPTR sequence_of_idn_owns;
struct OPS  *record_idns_type__ops;
extern struct OPS *null_ops;
struct OPS  *oneof_decl_none_ops;
extern struct OPS *record_equates_stmts_ops;
extern struct OPS *int_ops;
extern struct OPS *sequence_of_string_ops;
extern struct OPS *oneof_decl_none_ops;
struct OPS  *record_body_line_tags_var_ops;
extern struct REQS *p_list_of_t_reqs;
extern struct OPS *record_body_line_tags_var_ops;
extern OWN_req p_list_ownreqs;
struct OPS *p_list_of_record_body_line_tags_var_table;
struct OPS *p_list_of_record_body_line_tags_var_ops;
struct OPS *p_list_of_record_body_line_tags_var_ops;
OWNPTR p_list_of_record_body_line_tags_var_owns;
CLUREF STR_use_040of_040IN_040after_040tagcase_040expression;
CLUREF STR_TAG_040arm;
CLUREF STR__072_040in_040OTHERS_072_040body;
CLUREF STR_END_040of_040TAGCASE_040statement;
static int p_tagcase_own_init = 0;

/**** BEGIN PROCEDURE p_tagcase ****/

errcode p_tagcase(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF obj;
    CLUREF arms;
    CLUREF tst;
    CLUREF abs;
        if (p_tagcase_own_init == 0) {
        add_parm_info_type(0, equate_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_equate_ops));
        add_parm_info_type(0, stmt_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_stmt_ops));
        add_selector_info("equates", 0, sequence_of_equate_ops); 
        add_selector_info("stmts", 1, sequence_of_stmt_ops); 
        find_selector_ops("record", 2, &(record_equates_stmts_ops));
        add_parm_info_type(0, string_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_string_ops));
        add_parm_info_type(0, idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, sequence_of_idn_ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_selector_info("decl", 0, record_idns_type__ops); 
        add_selector_info("none", 1, null_ops); 
        find_selector_ops("oneof", 2, &(oneof_decl_none_ops));
        add_selector_info("body", 0, record_equates_stmts_ops); 
        add_selector_info("line", 1, int_ops); 
        add_selector_info("tags", 2, sequence_of_string_ops); 
        add_selector_info("var", 3, oneof_decl_none_ops); 
        find_selector_ops("record", 4, &(record_body_line_tags_var_ops));
        add_parm_info_type(0, record_body_line_tags_var_ops, p_list_of_t_reqs);
        find_prociter_instance(p_list, 1, &p_list_ownreqs, &(p_list_of_record_body_line_tags_var_ops));
        stringOPcons("use of IN after tagcase expression", CLU_1, CLU_34, &STR_use_040of_040IN_040after_040tagcase_040expression);
        stringOPcons("TAG arm", CLU_1, CLU_7, &STR_TAG_040arm);
        stringOPcons(": in OTHERS: body", CLU_1, CLU_17, &STR__072_040in_040OTHERS_072_040body);
        stringOPcons("END of TAGCASE statement", CLU_1, CLU_24, &STR_END_040of_040TAGCASE_040statement);
        p_tagcase_own_init = 1;
    }
    enter_proc(209);

  LINE(210);
    {
        {CLUREF T_1_1;
        err = p_expr1(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        obj.num = T_1_1.num;
        }
        }

  LINE(211);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 17: 
         {

  LINE(212);
            {
            err = p_envOPerr(e, STR_use_040of_040IN_040after_040tagcase_040expression, CLU_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(213);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {
    }
    }
    }

  LINE(216);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_tagarm;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_list_of_record_body_line_tags_var_ops->op_owns;
        generic_CLU_proc.proc = p_list;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_list(e, T_1_1, CLU_0, STR_TAG_040arm, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        arms.num = T_1_2.num;
        }
        }

  LINE(217);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        RecordAlloc(3, T_1_1);
        T_1_1.vec->data[1]  = obj.num;
        T_1_1.vec->data[0]  = arms.num;
        CellAlloc(2, nil, T_1_2);
        T_1_1.vec->data[2]  = T_1_2.num;
        tst.num = T_1_1.num;
        }
        }

  LINE(220);
    {
        {CLUREF T_1_1;
        CellAlloc(18, tst.num, T_1_1);
        abs.num = T_1_1.num;
        }
        }

  LINE(221);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 24: 
         {

  LINE(223);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(224);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = p_cbody(e, CLU_3, STR__072_040in_040OTHERS_072_040body, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            CellAlloc(1, T_2_1.num, T_2_2);
            tst.vec->data[2]  = T_2_2.num;
            }
            break;
            }
    default: {
    }
    }
    }

  LINE(228);
    {
    err = p_end(e, STR_END_040of_040TAGCASE_040statement);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(229);
    {
    {
    ret_1->num = abs.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_tagcase ****/


extern errcode p_envOPget_line();
extern errcode p_name();
extern errcode p_mdecl();
struct OPS *p_clist_of_string_table;
struct OPS *p_clist_of_string_ops;
struct OPS *p_clist_of_string_ops;
OWNPTR p_clist_of_string_owns;
CLUREF STR_name;
CLUREF STR__072_040in_040TAG_056_056_056_072_040body;
static int p_tagarm_own_init = 0;

/**** BEGIN PROCEDURE p_tagarm ****/

errcode p_tagarm(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF line;
    CLUREF tags;
    CLUREF var;
    CLUREF bod;
        if (p_tagarm_own_init == 0) {
        add_parm_info_type(0, string_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_string_ops));
        stringOPcons("name", CLU_1, CLU_4, &STR_name);
        stringOPcons(": in TAG...: body", CLU_1, CLU_17, &STR__072_040in_040TAG_056_056_056_072_040body);
        p_tagarm_own_init = 1;
    }
    enter_proc(234);

  LINE(235);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 35: 
         {

  LINE(236);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(237);
        {
        {signal (ERR_none);}}
    }
    }
    }

  LINE(239);
    {
        {CLUREF T_1_1;
        err = p_envOPget_line(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        line.num = T_1_1.num;
        }
        }

  LINE(240);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_name;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_clist_of_string_ops->op_owns;
        generic_CLU_proc.proc = p_clist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_clist(e, T_1_1, STR_name, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        tags.num = T_1_2.num;
        }
        }

  LINE(241);
    {
        {CLUREF T_1_1;
        err = p_mdecl(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        var.num = T_1_1.num;
        }
        }

  LINE(242);
    {
        {CLUREF T_1_1;
        err = p_cbody(e, CLU_1, STR__072_040in_040TAG_056_056_056_072_040body, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        bod.num = T_1_1.num;
        }
        }

  LINE(243);
    {
    {
    CLUREF T_1_1;
    RecordAlloc(4, T_1_1);
    T_1_1.vec->data[2]  = tags.num;
    T_1_1.vec->data[3]  = var.num;
    T_1_1.vec->data[0]  = bod.num;
    T_1_1.vec->data[1]  = line.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_tagarm ****/

