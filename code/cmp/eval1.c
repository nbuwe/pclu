
/* This file was automatically generated by pclu. */

#include "pclu_err.h"
#include "pclu_sys.h"



/**** BEGIN PROCEDURE e_expr ****/

extern errcode exprOPget_abs();
extern errcode idnOPget_kind();
extern errcode e_expr1();

errcode
e_expr(CLUREF e, CLUREF x, CLUREF *ret_1)
{
    errcode err;
    CLUREF i;
    enter_proc(6);

  LINE(7);
    { /* qtagcase */
    CLUREF T_1_1;
    err = exprOPget_abs(x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 13: /* idn */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        i.num = T_1_2.num;

  LINE(9);
        { /* qtagcase */
        CLUREF T_2_1;
        err = idnOPget_kind(i, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_1.cell->tag) {
        case 6: /* tparm */ /* FALLTHROUGH */
        case 10: /* vparm */ /* FALLTHROUGH */
        case 5: /* tconst */ {

  LINE(11);
            { /* return */
            {
            ret_1->num = x.num;
            }
            signal (ERR_ok);
            }
            break;
        }
        }
        } /* end qtagcase */
        break;
    }
    }
    } /* end qtagcase */

  LINE(16);
    { /* return */
    {
    CLUREF T_1_1;
    err = e_expr1(e, x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_expr ****/



/**** BEGIN PROCEDURE e_expr1 ****/

extern errcode oneofOPis_9();
extern errcode typespecOPget_abs();
extern errcode exprOPget_typespec();
extern errcode e_idn();
extern errcode e_condop();
extern errcode e_invoke();
extern errcode e_arraycons();
extern errcode e_selectcons();
extern errcode c_envOPerr1();
extern errcode c_envOPget_bad_expr();
static CLUREF STR_cand;
static CLUREF STR_cor;
static CLUREF STR_UP_040expression_040not_040a_040legal_040constant;
static CLUREF STR_DOWN_040expression_040not_040a_040legal_040constant;
static CLUREF STR_ANY_040expression_040not_040a_040legal_040constant;
static int e_expr1_own_init = 0;

errcode
e_expr1(CLUREF e, CLUREF x, CLUREF *ret_1)
{
    errcode err;
    CLUREF xa;
    if (e_expr1_own_init == 0) {
        stringOPcons("cand", CLU_1, CLUREF_make_num(4), &STR_cand);
        stringOPcons("cor", CLU_1, CLUREF_make_num(3), &STR_cor);
        stringOPcons("UP expression not a legal constant", CLU_1, CLUREF_make_num(34), &STR_UP_040expression_040not_040a_040legal_040constant);
        stringOPcons("DOWN expression not a legal constant", CLU_1, CLUREF_make_num(36), &STR_DOWN_040expression_040not_040a_040legal_040constant);
        stringOPcons("ANY expression not a legal constant", CLU_1, CLUREF_make_num(35), &STR_ANY_040expression_040not_040a_040legal_040constant);
        e_expr1_own_init = 1;
    }
    enter_proc(19);

  LINE(20);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = exprOPget_typespec(x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = typespecOPget_abs(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_2.cell->tag == 9) T_1_3.num = true; else T_1_3.num = false;
    if (T_1_3.num == true) { /* if */

  LINE(21);
        { /* return */
        {
        ret_1->num = x.num;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(22);
    { /* qtagcase */
    CLUREF T_1_1;
    err = exprOPget_abs(x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 19: /* null_ */ /* FALLTHROUGH */
    case 5: /* bool_ */ /* FALLTHROUGH */
    case 15: /* int_ */ /* FALLTHROUGH */
    case 21: /* real_ */ /* FALLTHROUGH */
    case 7: /* char_ */ /* FALLTHROUGH */
    case 24: /* str */ /* FALLTHROUGH */
    case 25: /* type_ */ /* FALLTHROUGH */
    case 3: /* apply */ /* FALLTHROUGH */
    case 20: /* op */ /* FALLTHROUGH */
    case 11: /* force_ */ {

  LINE(24);
        { /* return */
        {
        ret_1->num = x.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 13: /* idn */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        xa.num = T_1_2.num;

  LINE(26);
        { /* return */
        {
        CLUREF T_2_1;
        err = e_idn(e, x, xa, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 6: /* cand_ */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        xa.num = T_1_3.num;

  LINE(28);
        { /* return */
        {
        CLUREF T_2_1;
        err = e_condop(e, xa, STR_cand, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 8: /* cor_ */ {
        CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        xa.num = T_1_4.num;

  LINE(30);
        { /* return */
        {
        CLUREF T_2_1;
        err = e_condop(e, xa, STR_cor, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 16: /* invoke */ {
        CLUREF T_1_5;
        T_1_5.num = T_1_1.cell->value;
        xa.num = T_1_5.num;

  LINE(32);
        { /* return */
        {
        CLUREF T_2_1;
        err = e_invoke(e, x, xa, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 1: /* a_cons */ {
        CLUREF T_1_6;
        T_1_6.num = T_1_1.cell->value;
        xa.num = T_1_6.num;

  LINE(34);
        { /* return */
        {
        CLUREF T_2_1;
        err = e_arraycons(e, x, xa, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 23: /* s_cons */ {
        CLUREF T_1_7;
        T_1_7.num = T_1_1.cell->value;
        xa.num = T_1_7.num;

  LINE(36);
        { /* return */
        {
        CLUREF T_2_1;
        err = e_selectcons(e, x, xa, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 27: /* up_ */ {

  LINE(38);
        {
        err = c_envOPerr1(e, STR_UP_040expression_040not_040a_040legal_040constant);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    case 9: /* down_ */ {

  LINE(40);
        {
        err = c_envOPerr1(e, STR_DOWN_040expression_040not_040a_040legal_040constant);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    case 2: /* any_ */ {

  LINE(42);
        {
        err = c_envOPerr1(e, STR_ANY_040expression_040not_040a_040legal_040constant);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    case 4: /* bad */ {
        break;
    }
    }
    } /* end qtagcase */

  LINE(46);
    { /* return */
    {
    CLUREF T_1_1;
    err = c_envOPget_bad_expr(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_expr1 ****/



/**** BEGIN PROCEDURE e_idn ****/

extern errcode c_envOPerr();
extern errcode idnOPget_str();
static CLUREF STR_use_040of_040parameter_040_047;
static CLUREF STR__047_040as_040argument_040in_040constant_040expression;
static CLUREF STR_use_040of_040variable_040_047;
static CLUREF STR__047_040as_040constant;
static int e_idn_own_init = 0;

errcode
e_idn(CLUREF e, CLUREF x, CLUREF i, CLUREF *ret_1)
{
    errcode err;
    if (e_idn_own_init == 0) {
        stringOPcons("use of parameter \'", CLU_1, CLUREF_make_num(18), &STR_use_040of_040parameter_040_047);
        stringOPcons("\' as argument in constant expression", CLU_1, CLUREF_make_num(36), &STR__047_040as_040argument_040in_040constant_040expression);
        stringOPcons("use of variable \'", CLU_1, CLUREF_make_num(17), &STR_use_040of_040variable_040_047);
        stringOPcons("\' as constant", CLU_1, CLUREF_make_num(13), &STR__047_040as_040constant);
        e_idn_own_init = 1;
    }
    enter_proc(49);

  LINE(50);
    { /* qtagcase */
    CLUREF T_1_1;
    err = idnOPget_kind(i, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 6: /* tparm */ /* FALLTHROUGH */
    case 10: /* vparm */ /* FALLTHROUGH */
    case 5: /* tconst */ {

  LINE(52);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_3, &T_2_1);
        T_2_1.vec->data[0] = STR_use_040of_040parameter_040_047.num;
        err = idnOPget_str(i, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        T_2_1.vec->data[2] = STR__047_040as_040argument_040in_040constant_040expression.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    case 9: /* var */ /* FALLTHROUGH */
    case 4: /* ownvar */ {

  LINE(55);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_3, &T_2_1);
        T_2_1.vec->data[0] = STR_use_040of_040variable_040_047.num;
        err = idnOPget_str(i, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        T_2_1.vec->data[2] = STR__047_040as_040constant.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(58);
    { /* return */
    {
    CLUREF T_1_1;
    err = c_envOPget_bad_expr(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_idn ****/



/**** BEGIN PROCEDURE e_arraycons ****/

extern errcode recordOPget_3();
extern errcode boolOPnot();
extern errcode duOPequal();
extern errcode recordOPget_1();
extern errcode c_envOPget_seq_();
extern errcode sequenceOPindexes();
extern errcode sequenceOPfetch();
extern errcode exprOPequal();
extern errcode sequenceOPreplace();
extern errcode oneofOPmake_1();
extern errcode exprOPcreate();
static CLUREF STR_constructor_040not_040a_040legal_040constant;
static int e_arraycons_own_init = 0;

errcode
e_arraycons(CLUREF e, CLUREF x, CLUREF cons, CLUREF *ret_1)
{
    errcode err;
    CLUREF ta;
    CLUREF elts;
    CLUREF same;
    CLUREF i;
    CLUREF elt;
    CLUREF nelt;
    if (e_arraycons_own_init == 0) {
        stringOPcons("constructor not a legal constant", CLU_1, CLUREF_make_num(32), &STR_constructor_040not_040a_040legal_040constant);
        e_arraycons_own_init = 1;
    }
    enter_proc(61);

  LINE(62);
    { /* qtagcase */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = cons.vec->data[2];
    err = typespecOPget_abs(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_2.cell->tag) {
    case 3: /* cluster_ */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_2.cell->value;
        ta.num = T_1_3.num;

  LINE(64);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.num = ta.vec->data[0];
        err = c_envOPget_seq_(e, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        err = duOPequal(T_2_1, T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_4.num = !T_2_3.num;
        if (T_2_4.num == true) { /* if */

  LINE(65);
            {
            err = c_envOPerr1(e, STR_constructor_040not_040a_040legal_040constant);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(66);
            { /* return */
            {
            CLUREF T_3_1;
            err = c_envOPget_bad_expr(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            ret_1->num = T_3_1.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */
        break;
    }
    case 9: /* unknown */ {

  LINE(69);
        { /* return */
        {
        CLUREF T_2_1;
        err = c_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(71);
        {
        err = c_envOPerr1(e, STR_constructor_040not_040a_040legal_040constant);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(72);
        { /* return */
        {
        CLUREF T_2_1;
        err = c_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(74);
    {
    CLUREF T_1_1;
    T_1_1.num = cons.vec->data[0];
    elts.num = T_1_1.num;
    }

  LINE(75);
    {
    same.tf = true;
    }

  LINE(76);
    { /* for sequence$indexes */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = elts.vec->size;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        i.num = T_1_1.num;

  LINE(77);
        {
        CLUREF T_2_1;
        if (i.num < 1 || i.num > elts.vec->size) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.num = elts.vec->data[i.num - 1];
        elt.num = T_2_1.num;
        }

  LINE(78);
        {
        CLUREF T_2_1;
        err = e_expr1(e, elt, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        nelt.num = T_2_1.num;
        }

  LINE(79);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = exprOPequal(nelt, elt, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        T_2_2.num = !T_2_1.num;
        if (T_2_2.num == true) { /* if */

  LINE(80);
            {
            CLUREF T_3_1;
            err = sequenceOPreplace(elts, i, nelt, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            elts.num = T_3_1.num;
            }

  LINE(81);
            {
            same.tf = false;
            }
        }
        } /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(84);
    { /* if */
    if (same.num == true) { /* if */

  LINE(85);
        { /* return */
        {
        ret_1->num = x.num;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(86);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(3, T_1_1);
    T_1_2.num = cons.vec->data[2];
    T_1_1.vec->data[2] = T_1_2.num;
    CellAlloc(1, nil, T_1_3);
    T_1_1.vec->data[1] = T_1_3.num;
    T_1_1.vec->data[0] = elts.num;
    cons.num = T_1_1.num;
    }

  LINE(89);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CellAlloc(1, cons.num, T_1_1);
    T_1_2.num = cons.vec->data[2];
    err = exprOPcreate(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_3.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_arraycons ****/



/**** BEGIN PROCEDURE e_selectcons ****/

extern errcode recordOPget_2();
extern errcode c_envOPget_struct_();
extern errcode oneofOPmake_23();
static int e_selectcons_own_init = 0;

errcode
e_selectcons(CLUREF e, CLUREF x, CLUREF cons, CLUREF *ret_1)
{
    errcode err;
    CLUREF ta;
    CLUREF fields;
    CLUREF same;
    CLUREF i;
    CLUREF f;
    CLUREF nval;
    if (e_selectcons_own_init == 0) {
        stringOPcons("constructor not a legal constant", CLU_1, CLUREF_make_num(32), &STR_constructor_040not_040a_040legal_040constant);
        e_selectcons_own_init = 1;
    }
    enter_proc(92);

  LINE(93);
    { /* qtagcase */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = cons.vec->data[1];
    err = typespecOPget_abs(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_2.cell->tag) {
    case 7: /* select */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_2.cell->value;
        ta.num = T_1_3.num;

  LINE(95);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.num = ta.vec->data[0];
        err = c_envOPget_struct_(e, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        err = duOPequal(T_2_1, T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_4.num = !T_2_3.num;
        if (T_2_4.num == true) { /* if */

  LINE(96);
            {
            err = c_envOPerr1(e, STR_constructor_040not_040a_040legal_040constant);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(97);
            { /* return */
            {
            CLUREF T_3_1;
            err = c_envOPget_bad_expr(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            ret_1->num = T_3_1.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */
        break;
    }
    case 9: /* unknown */ {

  LINE(100);
        { /* return */
        {
        CLUREF T_2_1;
        err = c_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(102);
        {
        err = c_envOPerr1(e, STR_constructor_040not_040a_040legal_040constant);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(103);
        { /* return */
        {
        CLUREF T_2_1;
        err = c_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(105);
    {
    CLUREF T_1_1;
    T_1_1.num = cons.vec->data[0];
    fields.num = T_1_1.num;
    }

  LINE(106);
    {
    same.tf = true;
    }

  LINE(107);
    { /* for sequence$indexes */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = fields.vec->size;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        i.num = T_1_1.num;

  LINE(108);
        {
        CLUREF T_2_1;
        if (i.num < 1 || i.num > fields.vec->size) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.num = fields.vec->data[i.num - 1];
        f.num = T_2_1.num;
        }

  LINE(109);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = f.vec->data[2];
        err = e_expr1(e, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        nval.num = T_2_2.num;
        }

  LINE(110);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = f.vec->data[2];
        err = exprOPequal(nval, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_3.num = !T_2_2.num;
        if (T_2_3.num == true) { /* if */

  LINE(111);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            RecordAlloc(3, T_3_1);
            T_3_2.num = f.vec->data[1];
            T_3_1.vec->data[1] = T_3_2.num;
            T_3_1.vec->data[2] = nval.num;
            T_3_3.num = f.vec->data[0];
            T_3_1.vec->data[0] = T_3_3.num;
            f.num = T_3_1.num;
            }

  LINE(114);
            {
            CLUREF T_3_1;
            err = sequenceOPreplace(fields, i, f, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            fields.num = T_3_1.num;
            }

  LINE(115);
            {
            same.tf = false;
            }
        }
        } /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(118);
    { /* if */
    if (same.num == true) { /* if */

  LINE(119);
        { /* return */
        {
        ret_1->num = x.num;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(120);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(2, T_1_1);
    T_1_2.num = cons.vec->data[1];
    T_1_1.vec->data[1] = T_1_2.num;
    T_1_1.vec->data[0] = fields.num;
    cons.num = T_1_1.num;
    }

  LINE(122);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CellAlloc(23, cons.num, T_1_1);
    T_1_2.num = cons.vec->data[1];
    err = exprOPcreate(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_3.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_selectcons ****/



/**** BEGIN PROCEDURE e_invoke ****/

extern errcode e_exprlist();
extern errcode stringOPequal();
extern errcode typespecOPequal();
extern errcode c_envOPget_null_type();
extern errcode e_nullop();
extern errcode c_envOPget_bool_type();
extern errcode e_boolop();
extern errcode c_envOPget_int_type();
extern errcode e_intop();
extern errcode c_envOPget_real_type();
extern errcode e_realop();
extern errcode c_envOPget_char_type();
extern errcode e_charop();
extern errcode c_envOPget_str_type();
extern errcode e_strop();
extern errcode e_seqop();
extern errcode c_envOPget_oneof_();
extern errcode e_oneofop();
extern errcode e_structop();
extern errcode c_envOPget_proc_();
extern errcode c_envOPget_iter_();
extern errcode e_applyop();
extern errcode get_inv_print();
static CLUREF STR_encode;
static CLUREF STR_decode;
static CLUREF STR_print;
static CLUREF STR_invocation_040of_040_047;
static CLUREF STR__047_040evaluates_040to_040_047;
static CLUREF STR__047_040exception;
static CLUREF STR__047_040illegal_040in_040constant;
static int e_invoke_own_init = 0;

errcode
e_invoke(CLUREF e, CLUREF x, CLUREF inv, CLUREF *ret_1)
{
    errcode err;
    CLUREF p;
    CLUREF args;
    CLUREF pa;
    CLUREF op;
    CLUREF t;
    CLUREF ta;
    CLUREF err_UNIQ;
    if (e_invoke_own_init == 0) {
        stringOPcons("encode", CLU_1, CLUREF_make_num(6), &STR_encode);
        stringOPcons("decode", CLU_1, CLUREF_make_num(6), &STR_decode);
        stringOPcons("print", CLU_1, CLUREF_make_num(5), &STR_print);
        stringOPcons("invocation of \'", CLU_1, CLUREF_make_num(15), &STR_invocation_040of_040_047);
        stringOPcons("\' evaluates to \'", CLU_1, CLUREF_make_num(16), &STR__047_040evaluates_040to_040_047);
        stringOPcons("\' exception", CLU_1, CLUREF_make_num(11), &STR__047_040exception);
        stringOPcons("\' illegal in constant", CLU_1, CLUREF_make_num(21), &STR__047_040illegal_040in_040constant);
        e_invoke_own_init = 1;
    }
    enter_proc(125);

  LINE(126);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = inv.vec->data[0];
    err = e_expr1(e, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    p.num = T_1_2.num;
    }

  LINE(127);
    {
    CLUREF T_1_1;
    T_1_1.num = inv.vec->data[1];
    args.num = T_1_1.num;
    }

  LINE(128);
    {
    CLUREF T_1_1;
    err = e_exprlist(e, args, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    args.num = T_1_1.num;
    }

  LINE(129);
    { /* qtagcase */
    CLUREF T_2_1;
    err = exprOPget_abs(p, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    switch (T_2_1.cell->tag) {
    case 20: /* op */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        pa.num = T_2_2.num;

  LINE(131);
        {
        CLUREF T_3_1;
        T_3_1.num = pa.vec->data[0];
        op.num = T_3_1.num;
        }

  LINE(132);
        {
        CLUREF T_3_1;
        T_3_1.num = pa.vec->data[2];
        t.num = T_3_1.num;
        }

  LINE(133);
        { /* qtagcase */
        CLUREF T_3_1;
        err = typespecOPget_abs(t, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        switch (T_3_1.cell->tag) {
        case 3: /* cluster_ */ {
            CLUREF T_3_2;
            T_3_2.num = T_3_1.cell->value;
            ta.num = T_3_2.num;

  LINE(135);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            T_4_3.num = ((op.str->size != STR_encode.str->size)? false :
                !(memcmp(op.str->data, STR_encode.str->data, op.str->size)));
            T_4_2.num = T_4_3.num;
            if (!T_4_3.num) {
                T_4_4.num = ((op.str->size != STR_decode.str->size)? false :
                    !(memcmp(op.str->data, STR_decode.str->data, op.str->size)));
                T_4_2.num = T_4_4.num;
            }
            T_4_1.num = T_4_2.num;
            if (!T_4_2.num) {
                T_4_5.num = ((op.str->size != STR_print.str->size)? false :
                    !(memcmp(op.str->data, STR_print.str->data, op.str->size)));
                T_4_1.num = T_4_5.num;
            }
            if (T_4_1.num == true) { /* if */

  LINE(136);
                { /* exit */
                    err = ERR_illegal;
                    goto ex_1;
                }
            }
            else {

  LINE(137);
            CLUREF T_4_6;
            CLUREF T_4_7;
            err = c_envOPget_null_type(e, &T_4_6);
            if (err != ERR_ok)
                goto ex_1;
            err = typespecOPequal(t, T_4_6, &T_4_7);
            if (err != ERR_ok)
                goto ex_1;
            if (T_4_7.num == true) { /* elseif */

  LINE(138);
                { /* return */
                {
                CLUREF T_5_1;
                err = e_nullop(e, op, args, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                ret_1->num = T_5_1.num;
                }
                signal (ERR_ok);
                }
            }
            else {

  LINE(139);
            CLUREF T_4_8;
            CLUREF T_4_9;
            err = c_envOPget_bool_type(e, &T_4_8);
            if (err != ERR_ok)
                goto ex_1;
            err = typespecOPequal(t, T_4_8, &T_4_9);
            if (err != ERR_ok)
                goto ex_1;
            if (T_4_9.num == true) { /* elseif */

  LINE(140);
                { /* return */
                {
                CLUREF T_5_1;
                err = e_boolop(e, op, args, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                ret_1->num = T_5_1.num;
                }
                signal (ERR_ok);
                }
            }
            else {

  LINE(141);
            CLUREF T_4_10;
            CLUREF T_4_11;
            err = c_envOPget_int_type(e, &T_4_10);
            if (err != ERR_ok)
                goto ex_1;
            err = typespecOPequal(t, T_4_10, &T_4_11);
            if (err != ERR_ok)
                goto ex_1;
            if (T_4_11.num == true) { /* elseif */

  LINE(142);
                { /* return */
                {
                CLUREF T_5_1;
                err = e_intop(e, op, args, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                ret_1->num = T_5_1.num;
                }
                signal (ERR_ok);
                }
            }
            else {

  LINE(143);
            CLUREF T_4_12;
            CLUREF T_4_13;
            err = c_envOPget_real_type(e, &T_4_12);
            if (err != ERR_ok)
                goto ex_1;
            err = typespecOPequal(t, T_4_12, &T_4_13);
            if (err != ERR_ok)
                goto ex_1;
            if (T_4_13.num == true) { /* elseif */

  LINE(144);
                { /* return */
                {
                CLUREF T_5_1;
                err = e_realop(e, op, args, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                ret_1->num = T_5_1.num;
                }
                signal (ERR_ok);
                }
            }
            else {

  LINE(145);
            CLUREF T_4_14;
            CLUREF T_4_15;
            err = c_envOPget_char_type(e, &T_4_14);
            if (err != ERR_ok)
                goto ex_1;
            err = typespecOPequal(t, T_4_14, &T_4_15);
            if (err != ERR_ok)
                goto ex_1;
            if (T_4_15.num == true) { /* elseif */

  LINE(146);
                { /* return */
                {
                CLUREF T_5_1;
                err = e_charop(e, op, args, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                ret_1->num = T_5_1.num;
                }
                signal (ERR_ok);
                }
            }
            else {

  LINE(147);
            CLUREF T_4_16;
            CLUREF T_4_17;
            err = c_envOPget_str_type(e, &T_4_16);
            if (err != ERR_ok)
                goto ex_1;
            err = typespecOPequal(t, T_4_16, &T_4_17);
            if (err != ERR_ok)
                goto ex_1;
            if (T_4_17.num == true) { /* elseif */

  LINE(148);
                { /* return */
                {
                CLUREF T_5_1;
                err = e_strop(e, op, args, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                ret_1->num = T_5_1.num;
                }
                signal (ERR_ok);
                }
            }
            else {

  LINE(149);
            CLUREF T_4_18;
            CLUREF T_4_19;
            CLUREF T_4_20;
            T_4_18.num = ta.vec->data[0];
            err = c_envOPget_seq_(e, &T_4_19);
            if (err != ERR_ok)
                goto ex_1;
            err = duOPequal(T_4_18, T_4_19, &T_4_20);
            if (err != ERR_ok)
                goto ex_1;
            if (T_4_20.num == true) { /* elseif */

  LINE(150);
                { /* return */
                {
                CLUREF T_5_1;
                err = e_seqop(e, x, pa, args, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                ret_1->num = T_5_1.num;
                }
                signal (ERR_ok);
                }
            }
            }}}}}}}} /* end if */
            break;
        }
        case 7: /* select */ {
            CLUREF T_3_3;
            T_3_3.num = T_3_1.cell->value;
            ta.num = T_3_3.num;

  LINE(152);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = ta.vec->data[0];
            err = c_envOPget_oneof_(e, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            err = duOPequal(T_4_1, T_4_2, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            if (T_4_3.num == true) { /* if */

  LINE(153);
                { /* return */
                {
                CLUREF T_5_1;
                err = e_oneofop(e, x, pa, args, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                ret_1->num = T_5_1.num;
                }
                signal (ERR_ok);
                }
            }
            else {

  LINE(154);
            CLUREF T_4_4;
            CLUREF T_4_5;
            CLUREF T_4_6;
            T_4_4.num = ta.vec->data[0];
            err = c_envOPget_struct_(e, &T_4_5);
            if (err != ERR_ok)
                goto ex_1;
            err = duOPequal(T_4_4, T_4_5, &T_4_6);
            if (err != ERR_ok)
                goto ex_1;
            if (T_4_6.num == true) { /* elseif */

  LINE(155);
                { /* return */
                {
                CLUREF T_5_1;
                err = e_structop(e, x, pa, args, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                ret_1->num = T_5_1.num;
                }
                signal (ERR_ok);
                }
            }
            }} /* end if */
            break;
        }
        case 2: /* apply */ {
            CLUREF T_3_4;
            T_3_4.num = T_3_1.cell->value;
            ta.num = T_3_4.num;

  LINE(157);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            CLUREF T_4_6;
            CLUREF T_4_7;
            T_4_2.num = ta.vec->data[1];
            err = c_envOPget_proc_(e, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            err = duOPequal(T_4_2, T_4_3, &T_4_4);
            if (err != ERR_ok)
                goto ex_1;
            T_4_1.num = T_4_4.num;
            if (!T_4_4.num) {
                T_4_5.num = ta.vec->data[1];
                err = c_envOPget_iter_(e, &T_4_6);
                if (err != ERR_ok)
                    goto ex_1;
                err = duOPequal(T_4_5, T_4_6, &T_4_7);
                if (err != ERR_ok)
                    goto ex_1;
                T_4_1.num = T_4_7.num;
            }
            if (T_4_1.num == true) { /* if */

  LINE(158);
                { /* return */
                {
                CLUREF T_5_1;
                err = e_applyop(e, op, args, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                ret_1->num = T_5_1.num;
                }
                signal (ERR_ok);
                }
            }
            } /* end if */
            break;
        }
        }
        } /* end qtagcase */
        break;
    }
    case 3: /* apply */ /* FALLTHROUGH */
    case 11: /* force_ */ {
        break;
    }
    default: {

  LINE(163);
        { /* return */
        {
        CLUREF T_3_1;
        err = c_envOPget_bad_expr(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        ret_1->num = T_3_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_illegal) {
    }
    else if (err == ERR_bad) {

  LINE(166);
        { /* return */
        {
        CLUREF T_2_1;
        err = c_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
    }
    else if (err == ERR_error) {
        err_UNIQ.num = elist[0].num;

  LINE(168);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_5, &T_2_1);
        T_2_1.vec->data[0] = STR_invocation_040of_040_047.num;
        err = get_inv_print(inv, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        T_2_1.vec->data[2] = STR__047_040evaluates_040to_040_047.num;
        T_2_1.vec->data[3] = err_UNIQ.num;
        T_2_1.vec->data[4] = STR__047_040exception.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(172);
        { /* return */
        {
        CLUREF T_2_1;
        err = c_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(174);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    sequenceOPnew2(CLU_3, &T_1_1);
    T_1_1.vec->data[0] = STR_invocation_040of_040_047.num;
    err = get_inv_print(inv, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    T_1_1.vec->data[2] = STR__047_040illegal_040in_040constant.num;
    err = c_envOPerr(e, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(176);
    { /* return */
    {
    CLUREF T_1_1;
    err = c_envOPget_bad_expr(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_invoke ****/



/**** BEGIN PROCEDURE e_exprlist ****/

extern errcode sequenceOPnew();
extern errcode sequenceOPelements();
extern errcode sequenceOPaddh();

errcode
e_exprlist(CLUREF e, CLUREF exprs, CLUREF *ret_1)
{
    errcode err;
    CLUREF nexprs;
    CLUREF x;
    enter_proc(179);

  LINE(180);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    nexprs.num = T_1_1.num;
    }

  LINE(181);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = exprs.vec->size;
    T_1_3 = exprs;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        x.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(182);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = e_expr1(e, x, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = sequenceOPaddh(nexprs, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        nexprs.num = T_2_2.num;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(184);
    { /* return */
    {
    ret_1->num = nexprs.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_exprlist ****/



/**** BEGIN PROCEDURE e_n2e ****/

extern errcode oneofOPmake_19();

errcode
e_n2e(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    enter_proc(187);

  LINE(188);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CellAlloc(19, nil, T_1_1);
    err = c_envOPget_null_type(e, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    err = exprOPcreate(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_3.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_n2e ****/



/**** BEGIN PROCEDURE e_b2e ****/

extern errcode oneofOPmake_5();

errcode
e_b2e(CLUREF e, CLUREF b, CLUREF *ret_1)
{
    errcode err;
    enter_proc(191);

  LINE(192);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CellAlloc(5, b.num, T_1_1);
    err = c_envOPget_bool_type(e, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    err = exprOPcreate(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_3.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_b2e ****/



/**** BEGIN PROCEDURE e_i2e ****/

extern errcode oneofOPmake_15();

errcode
e_i2e(CLUREF e, CLUREF i, CLUREF *ret_1)
{
    errcode err;
    enter_proc(195);

  LINE(196);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CellAlloc(15, i.num, T_1_1);
    err = c_envOPget_int_type(e, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    err = exprOPcreate(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_3.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_i2e ****/



/**** BEGIN PROCEDURE e_r2e ****/

extern errcode oneofOPmake_21();

errcode
e_r2e(CLUREF e, CLUREF r, CLUREF *ret_1)
{
    errcode err;
    enter_proc(199);

  LINE(200);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CellAlloc(21, r.num, T_1_1);
    err = c_envOPget_real_type(e, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    err = exprOPcreate(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_3.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_r2e ****/



/**** BEGIN PROCEDURE e_h2e ****/

extern errcode oneofOPmake_7();

errcode
e_h2e(CLUREF e, CLUREF h, CLUREF *ret_1)
{
    errcode err;
    enter_proc(203);

  LINE(204);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CellAlloc(7, h.num, T_1_1);
    err = c_envOPget_char_type(e, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    err = exprOPcreate(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_3.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_h2e ****/



/**** BEGIN PROCEDURE e_s2e ****/

extern errcode oneofOPmake_24();

errcode
e_s2e(CLUREF e, CLUREF s, CLUREF *ret_1)
{
    errcode err;
    enter_proc(207);

  LINE(208);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CellAlloc(24, s.num, T_1_1);
    err = c_envOPget_str_type(e, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    err = exprOPcreate(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_3.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_s2e ****/



/**** BEGIN PROCEDURE e_condop ****/

extern errcode e_e2b();
static int e_condop_own_init = 0;

errcode
e_condop(CLUREF e, CLUREF args, CLUREF op, CLUREF *ret_1)
{
    errcode err;
    CLUREF x1;
    CLUREF b;
    CLUREF x2;
    if (e_condop_own_init == 0) {
        stringOPcons("cand", CLU_1, CLUREF_make_num(4), &STR_cand);
        stringOPcons("cor", CLU_1, CLUREF_make_num(3), &STR_cor);
        e_condop_own_init = 1;
    }
    enter_proc(211);

  LINE(212);
    { /* begin */

  LINE(213);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = args.vec->data[0];
        err = e_expr1(e, T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        x1.num = T_3_2.num;
        }

  LINE(214);
        {
        CLUREF T_3_1;
        err = e_e2b(x1, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        b.num = T_3_1.num;
        }

  LINE(215);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        T_3_3.num = ((op.str->size != STR_cand.str->size)? false :
            !(memcmp(op.str->data, STR_cand.str->data, op.str->size)));
        T_3_2.num = T_3_3.num;
        if (T_3_3.num) {
            T_3_4.num = !b.num;
            T_3_2.num = T_3_4.num;
        }
        T_3_1.num = T_3_2.num;
        if (!T_3_2.num) {
            T_3_6.num = ((op.str->size != STR_cor.str->size)? false :
                !(memcmp(op.str->data, STR_cor.str->data, op.str->size)));
            T_3_5.num = T_3_6.num;
            if (T_3_6.num) {
                T_3_5.num = b.num;
            }
            T_3_1.num = T_3_5.num;
        }
        if (T_3_1.num == true) { /* if */

  LINE(216);
            { /* return */
            {
            ret_1->num = x1.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(217);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = args.vec->data[1];
        err = e_expr1(e, T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        x2.num = T_3_2.num;
        }

  LINE(218);
        {
        CLUREF T_3_1;
        err = e_e2b(x2, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(219);
        { /* return */
        {
        ret_1->num = x2.num;
        }
        signal (ERR_ok);
        }
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_bad) {

  LINE(221);
        { /* return */
        {
        CLUREF T_2_1;
        err = c_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_condop ****/



/**** BEGIN PROCEDURE e_applyop ****/

extern errcode intOPequal();
extern errcode sequenceOPsize();
extern errcode sequenceOPbottom();
extern errcode oneofOPis_4();
extern errcode e_b2e();
extern errcode oneofOPsimilar();
extern const struct REQS * const sequence_of_t_reqs;
extern struct OPS *expr_ops;
extern const OWN_req sequence_ownreqs;
extern struct OPS *sequence_ops;
struct OPS *sequence_of_expr_ops __CLU_COMMON;
extern struct OPS *null_ops;
struct OPS *oneof_none_one_ops __CLU_COMMON;
extern struct OPS *sequence_of_expr_ops;
extern struct OPS *oneof_none_one_ops;
extern struct OPS *typespec_ops;
struct OPS *record_elts_low_type__ops __CLU_COMMON;
extern struct OPS *du_ops;
struct OPS *record_gen_parms_ops __CLU_COMMON;
struct OPS *record_left_right_ops __CLU_COMMON;
struct OPS *record_index_object_ops __CLU_COMMON;
extern struct OPS *string_ops;
struct OPS *record_object_sel_ops __CLU_COMMON;
extern struct OPS *bool_ops;
struct OPS *record_left_neg_op_right_ops __CLU_COMMON;
struct OPS *record_apply_args_ops __CLU_COMMON;
struct OPS *record_name_parms_type__ops __CLU_COMMON;
extern struct OPS *idn_ops;
struct OPS *record_idn_parms_ops __CLU_COMMON;
struct OPS *sequence_of_string_ops __CLU_COMMON;
extern struct OPS *int_ops;
extern struct OPS *sequence_of_string_ops;
struct OPS *record_line_sels_val_ops __CLU_COMMON;
extern struct OPS *record_line_sels_val_ops;
struct OPS *sequence_of_record_line_sels_val_ops __CLU_COMMON;
extern struct OPS *sequence_of_record_line_sels_val_ops;
struct OPS *record_fields_type__ops __CLU_COMMON;
extern struct OPS *record_elts_low_type__ops;
extern struct OPS *record_gen_parms_ops;
extern struct OPS *record_left_right_ops;
extern struct OPS *char_ops;
extern struct OPS *record_index_object_ops;
extern struct OPS *record_object_sel_ops;
extern struct OPS *record_left_neg_op_right_ops;
extern struct OPS *record_apply_args_ops;
extern struct OPS *record_name_parms_type__ops;
extern struct OPS *real_ops;
extern struct OPS *record_idn_parms_ops;
extern struct OPS *record_fields_type__ops;
struct OPS *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops __CLU_COMMON;
static int e_applyop_own_init = 0;

errcode
e_applyop(CLUREF e, CLUREF op, CLUREF args, CLUREF *ret_1)
{
    errcode err;
    CLUREF a1;
    CLUREF a2;
    if (e_applyop_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)expr_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_expr_ops));
        add_selector_info("none", 0, (struct OPS *)null_ops);
        add_selector_info("one", 1, (struct OPS *)expr_ops);
        find_selector_ops("oneof", 2, &(oneof_none_one_ops));
        add_selector_info("elts", 0, (struct OPS *)sequence_of_expr_ops);
        add_selector_info("low", 1, (struct OPS *)oneof_none_one_ops);
        add_selector_info("type_", 2, (struct OPS *)typespec_ops);
        find_selector_ops("record", 3, &(record_elts_low_type__ops));
        add_selector_info("gen", 0, (struct OPS *)du_ops);
        add_selector_info("parms", 1, (struct OPS *)sequence_of_expr_ops);
        find_selector_ops("record", 2, &(record_gen_parms_ops));
        add_selector_info("left", 0, (struct OPS *)expr_ops);
        add_selector_info("right", 1, (struct OPS *)expr_ops);
        find_selector_ops("record", 2, &(record_left_right_ops));
        add_selector_info("index", 0, (struct OPS *)expr_ops);
        add_selector_info("object", 1, (struct OPS *)expr_ops);
        find_selector_ops("record", 2, &(record_index_object_ops));
        add_selector_info("object", 0, (struct OPS *)expr_ops);
        add_selector_info("sel", 1, (struct OPS *)string_ops);
        find_selector_ops("record", 2, &(record_object_sel_ops));
        add_selector_info("left", 0, (struct OPS *)expr_ops);
        add_selector_info("neg", 1, (struct OPS *)bool_ops);
        add_selector_info("op", 2, (struct OPS *)string_ops);
        add_selector_info("right", 3, (struct OPS *)expr_ops);
        find_selector_ops("record", 4, &(record_left_neg_op_right_ops));
        add_selector_info("apply", 0, (struct OPS *)expr_ops);
        add_selector_info("args", 1, (struct OPS *)sequence_of_expr_ops);
        find_selector_ops("record", 2, &(record_apply_args_ops));
        add_selector_info("name", 0, (struct OPS *)string_ops);
        add_selector_info("parms", 1, (struct OPS *)sequence_of_expr_ops);
        add_selector_info("type_", 2, (struct OPS *)typespec_ops);
        find_selector_ops("record", 3, &(record_name_parms_type__ops));
        add_selector_info("idn", 0, (struct OPS *)idn_ops);
        add_selector_info("parms", 1, (struct OPS *)sequence_of_expr_ops);
        find_selector_ops("record", 2, &(record_idn_parms_ops));
        add_parm_info_type(0, (const struct OPS *)string_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_string_ops));
        add_selector_info("line", 0, (struct OPS *)int_ops);
        add_selector_info("sels", 1, (struct OPS *)sequence_of_string_ops);
        add_selector_info("val", 2, (struct OPS *)expr_ops);
        find_selector_ops("record", 3, &(record_line_sels_val_ops));
        add_parm_info_type(0, (const struct OPS *)record_line_sels_val_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_line_sels_val_ops));
        add_selector_info("fields", 0, (struct OPS *)sequence_of_record_line_sels_val_ops);
        add_selector_info("type_", 1, (struct OPS *)typespec_ops);
        find_selector_ops("record", 2, &(record_fields_type__ops));
        add_selector_info("a_cons", 0, (struct OPS *)record_elts_low_type__ops);
        add_selector_info("any_", 1, (struct OPS *)expr_ops);
        add_selector_info("apply", 2, (struct OPS *)record_gen_parms_ops);
        add_selector_info("bad", 3, (struct OPS *)null_ops);
        add_selector_info("bool_", 4, (struct OPS *)bool_ops);
        add_selector_info("cand_", 5, (struct OPS *)record_left_right_ops);
        add_selector_info("char_", 6, (struct OPS *)char_ops);
        add_selector_info("cor_", 7, (struct OPS *)record_left_right_ops);
        add_selector_info("down_", 8, (struct OPS *)expr_ops);
        add_selector_info("fetch", 9, (struct OPS *)record_index_object_ops);
        add_selector_info("force_", 10, (struct OPS *)typespec_ops);
        add_selector_info("get", 11, (struct OPS *)record_object_sel_ops);
        add_selector_info("idn", 12, (struct OPS *)idn_ops);
        add_selector_info("infix", 13, (struct OPS *)record_left_neg_op_right_ops);
        add_selector_info("int_", 14, (struct OPS *)int_ops);
        add_selector_info("invoke", 15, (struct OPS *)record_apply_args_ops);
        add_selector_info("minus", 16, (struct OPS *)expr_ops);
        add_selector_info("not", 17, (struct OPS *)expr_ops);
        add_selector_info("null_", 18, (struct OPS *)null_ops);
        add_selector_info("op", 19, (struct OPS *)record_name_parms_type__ops);
        add_selector_info("real_", 20, (struct OPS *)real_ops);
        add_selector_info("ref", 21, (struct OPS *)record_idn_parms_ops);
        add_selector_info("s_cons", 22, (struct OPS *)record_fields_type__ops);
        add_selector_info("str", 23, (struct OPS *)string_ops);
        add_selector_info("type_", 24, (struct OPS *)typespec_ops);
        add_selector_info("type_of_", 25, (struct OPS *)expr_ops);
        add_selector_info("up_", 26, (struct OPS *)expr_ops);
        find_selector_ops("oneof", 27, &(oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops));
        e_applyop_own_init = 1;
    }
    enter_proc(224);

  LINE(225);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = args.vec->size;
    T_1_2.num = (T_1_1.num == 1);
    if (T_1_2.num == true) { /* if */

  LINE(226);
        { /* return */
        {
        CLUREF T_2_1;
        err = sequenceOPbottom(args, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(227);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    if (1 < 1 || 1 > args.vec->size) {
        err = ERR_bounds;
        goto ex_0;
    }
    T_1_1.num = args.vec->data[1 - 1];
    err = exprOPget_abs(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    a1.num = T_1_2.num;
    }

  LINE(228);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    if (2 < 1 || 2 > args.vec->size) {
        err = ERR_bounds;
        goto ex_0;
    }
    T_1_1.num = args.vec->data[2 - 1];
    err = exprOPget_abs(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    a2.num = T_1_2.num;
    }

  LINE(229);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    if (a1.cell->tag == 4) T_1_2.num = true; else T_1_2.num = false;
    T_1_1.num = T_1_2.num;
    if (!T_1_2.num) {
        if (a2.cell->tag == 4) T_1_3.num = true; else T_1_3.num = false;
        T_1_1.num = T_1_3.num;
    }
    if (T_1_1.num == true) { /* if */

  LINE(230);
        { /* return */
        {
        CLUREF T_2_1;
        err = c_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
    }
    else { /* else */

  LINE(231);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        generic_CLU_proc.type_owns = NULL;
        generic_CLU_proc.op_owns = oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops->entry[1].fcn->op_owns;
        generic_CLU_proc.proc = oneofOPsimilar;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = oneofOPsimilar(a1, a2, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = e_b2e(e, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_2.num;
        }
        signal (ERR_ok);
        }
    }} /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_applyop ****/



/**** BEGIN PROCEDURE e_nullop ****/

extern errcode e_n2e();
static CLUREF STR_copy;
static int e_nullop_own_init = 0;

errcode
e_nullop(CLUREF e, CLUREF op, CLUREF args, CLUREF *ret_1)
{
    errcode err;
    if (e_nullop_own_init == 0) {
        stringOPcons("copy", CLU_1, CLUREF_make_num(4), &STR_copy);
        e_nullop_own_init = 1;
    }
    enter_proc(235);

  LINE(236);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = ((op.str->size != STR_copy.str->size)? false :
        !(memcmp(op.str->data, STR_copy.str->data, op.str->size)));
    if (T_1_1.num == true) { /* if */

  LINE(237);
        { /* return */
        {
        CLUREF T_2_1;
        err = e_n2e(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
    }
    else { /* else */

  LINE(238);
        { /* return */
        {
        CLUREF T_2_1;
        err = e_b2e(e, CLU_true, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
    }} /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_nullop ****/



/**** BEGIN PROCEDURE e_boolop ****/

extern errcode boolOPequal();
static CLUREF STR_not;
static CLUREF STR_and;
static CLUREF STR_or;
static int e_boolop_own_init = 0;

errcode
e_boolop(CLUREF e, CLUREF op, CLUREF args, CLUREF *ret_1)
{
    errcode err;
    CLUREF b1;
    CLUREF b2;
    if (e_boolop_own_init == 0) {
        stringOPcons("not", CLU_1, CLUREF_make_num(3), &STR_not);
        stringOPcons("copy", CLU_1, CLUREF_make_num(4), &STR_copy);
        stringOPcons("and", CLU_1, CLUREF_make_num(3), &STR_and);
        stringOPcons("or", CLU_1, CLUREF_make_num(2), &STR_or);
        e_boolop_own_init = 1;
    }
    enter_proc(242);

  LINE(244);
    { /* begin */

  LINE(245);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        if (1 < 1 || 1 > args.vec->size) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_1.num = args.vec->data[1 - 1];
        err = e_e2b(T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        b1.num = T_3_2.num;
        }

  LINE(246);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = ((op.str->size != STR_not.str->size)? false :
            !(memcmp(op.str->data, STR_not.str->data, op.str->size)));
        if (T_3_1.num == true) { /* if */

  LINE(247);
            {
            CLUREF T_4_1;
            T_4_1.num = !b1.num;
            b1.num = T_4_1.num;
            }
        }
        else {

  LINE(248);
        CLUREF T_3_2;
        CLUREF T_3_3;
        T_3_2.num = ((op.str->size != STR_copy.str->size)? false :
            !(memcmp(op.str->data, STR_copy.str->data, op.str->size)));
        T_3_3.num = !T_3_2.num;
        if (T_3_3.num == true) { /* elseif */

  LINE(249);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            if (2 < 1 || 2 > args.vec->size) {
                err = ERR_bounds;
                goto ex_1;
            }
            T_4_1.num = args.vec->data[2 - 1];
            err = e_e2b(T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            b2.num = T_4_2.num;
            }

  LINE(250);
            { /* if */
            CLUREF T_4_1;
            T_4_1.num = ((op.str->size != STR_and.str->size)? false :
                !(memcmp(op.str->data, STR_and.str->data, op.str->size)));
            if (T_4_1.num == true) { /* if */

  LINE(251);
                {
                CLUREF T_5_1;
                T_5_1.num = b1.num;
                if (b1.num) {
                    T_5_1.num = b2.num;
                }
                b1.num = T_5_1.num;
                }
            }
            else {

  LINE(252);
            CLUREF T_4_2;
            T_4_2.num = ((op.str->size != STR_or.str->size)? false :
                !(memcmp(op.str->data, STR_or.str->data, op.str->size)));
            if (T_4_2.num == true) { /* elseif */

  LINE(253);
                {
                CLUREF T_5_1;
                T_5_1.num = b1.num;
                if (!b1.num) {
                    T_5_1.num = b2.num;
                }
                b1.num = T_5_1.num;
                }
            }
            else { /* else */

  LINE(254);
                {
                CLUREF T_5_1;
                T_5_1.num = (b1.tf == b2.tf);
                b1.num = T_5_1.num;
                }
            }}} /* end if */
        }
        }} /* end if */

  LINE(256);
        { /* return */
        {
        CLUREF T_3_1;
        err = e_b2e(e, b1, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        ret_1->num = T_3_1.num;
        }
        signal (ERR_ok);
        }
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_bad)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_boolop ****/



/**** BEGIN PROCEDURE e_intop ****/

extern errcode e_i2e();
extern errcode intOPparse();
extern errcode e_e2s();
extern errcode e_e2i();
extern errcode e_s2e();
extern errcode intOPunparse();
extern errcode intOPminus();
extern errcode intOPabs();
extern errcode intOPadd();
extern errcode intOPsub();
extern errcode intOPmul();
extern errcode intOPdiv();
extern errcode intOPpower();
extern errcode intOPmod();
extern errcode intOPmin();
extern errcode intOPmax();
extern errcode intOPlt();
extern errcode intOPle();
extern errcode intOPge();
extern errcode intOPgt();
static CLUREF STR_from_137to_137by;
static CLUREF STR_from_137to;
static CLUREF STR_parse;
static CLUREF STR_unparse;
static CLUREF STR_minus;
static CLUREF STR_abs;
static CLUREF STR_add;
static CLUREF STR_sub;
static CLUREF STR_mul;
static CLUREF STR_div;
static CLUREF STR_power;
static CLUREF STR_mod;
static CLUREF STR_min;
static CLUREF STR_max;
static CLUREF STR_lt;
static CLUREF STR_le;
static CLUREF STR_ge;
static CLUREF STR_gt;
static int e_intop_own_init = 0;

errcode
e_intop(CLUREF e, CLUREF op, CLUREF args, CLUREF *ret_1)
{
    errcode err;
    CLUREF i1;
    CLUREF i2;
    CLUREF b;
    CLUREF err_UNIQ;
    if (e_intop_own_init == 0) {
        stringOPcons("from_to_by", CLU_1, CLUREF_make_num(10), &STR_from_137to_137by);
        stringOPcons("from_to", CLU_1, CLUREF_make_num(7), &STR_from_137to);
        stringOPcons("parse", CLU_1, CLUREF_make_num(5), &STR_parse);
        stringOPcons("unparse", CLU_1, CLUREF_make_num(7), &STR_unparse);
        stringOPcons("minus", CLU_1, CLUREF_make_num(5), &STR_minus);
        stringOPcons("abs", CLU_1, CLUREF_make_num(3), &STR_abs);
        stringOPcons("copy", CLU_1, CLUREF_make_num(4), &STR_copy);
        stringOPcons("add", CLU_1, CLUREF_make_num(3), &STR_add);
        stringOPcons("sub", CLU_1, CLUREF_make_num(3), &STR_sub);
        stringOPcons("mul", CLU_1, CLUREF_make_num(3), &STR_mul);
        stringOPcons("div", CLU_1, CLUREF_make_num(3), &STR_div);
        stringOPcons("power", CLU_1, CLUREF_make_num(5), &STR_power);
        stringOPcons("mod", CLU_1, CLUREF_make_num(3), &STR_mod);
        stringOPcons("min", CLU_1, CLUREF_make_num(3), &STR_min);
        stringOPcons("max", CLU_1, CLUREF_make_num(3), &STR_max);
        stringOPcons("lt", CLU_1, CLUREF_make_num(2), &STR_lt);
        stringOPcons("le", CLU_1, CLUREF_make_num(2), &STR_le);
        stringOPcons("ge", CLU_1, CLUREF_make_num(2), &STR_ge);
        stringOPcons("gt", CLU_1, CLUREF_make_num(2), &STR_gt);
        e_intop_own_init = 1;
    }
    enter_proc(260);

  LINE(262);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = ((op.str->size != STR_from_137to_137by.str->size)? false :
        !(memcmp(op.str->data, STR_from_137to_137by.str->data, op.str->size)));
    T_1_1.num = T_1_2.num;
    if (!T_1_2.num) {
        T_1_3.num = ((op.str->size != STR_from_137to.str->size)? false :
            !(memcmp(op.str->data, STR_from_137to.str->data, op.str->size)));
        T_1_1.num = T_1_3.num;
    }
    if (T_1_1.num == true) { /* if */

  LINE(263);
        { /* signal */
            signal(ERR_illegal);
        }
    }
    } /* end if */

  LINE(264);
    { /* begin */

  LINE(265);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = ((op.str->size != STR_parse.str->size)? false :
            !(memcmp(op.str->data, STR_parse.str->data, op.str->size)));
        if (T_3_1.num == true) { /* if */

  LINE(266);
            { /* return */
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            if (1 < 1 || 1 > args.vec->size) {
                err = ERR_bounds;
                goto ex_1;
            }
            T_4_1.num = args.vec->data[1 - 1];
            err = e_e2s(T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            err = intOPparse(T_4_2, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            err = e_i2e(e, T_4_3, &T_4_4);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_4.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(267);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        if (1 < 1 || 1 > args.vec->size) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_1.num = args.vec->data[1 - 1];
        err = e_e2i(T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        i1.num = T_3_2.num;
        }

  LINE(268);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = ((op.str->size != STR_unparse.str->size)? false :
            !(memcmp(op.str->data, STR_unparse.str->data, op.str->size)));
        if (T_3_1.num == true) { /* if */

  LINE(269);
            { /* return */
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            err = intOPunparse(i1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            err = e_s2e(e, T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_2.num;
            }
            signal (ERR_ok);
            }
        }
        else {

  LINE(270);
        CLUREF T_3_2;
        T_3_2.num = ((op.str->size != STR_minus.str->size)? false :
            !(memcmp(op.str->data, STR_minus.str->data, op.str->size)));
        if (T_3_2.num == true) { /* elseif */

  LINE(271);
            {
            CLUREF T_4_1;
            err = intOPminus(i1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            i1.num = T_4_1.num;
            }
        }
        else {

  LINE(272);
        CLUREF T_3_3;
        T_3_3.num = ((op.str->size != STR_abs.str->size)? false :
            !(memcmp(op.str->data, STR_abs.str->data, op.str->size)));
        if (T_3_3.num == true) { /* elseif */

  LINE(273);
            {
            CLUREF T_4_1;
            err = intOPabs(i1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            i1.num = T_4_1.num;
            }
        }
        else {

  LINE(274);
        CLUREF T_3_4;
        CLUREF T_3_5;
        T_3_4.num = ((op.str->size != STR_copy.str->size)? false :
            !(memcmp(op.str->data, STR_copy.str->data, op.str->size)));
        T_3_5.num = !T_3_4.num;
        if (T_3_5.num == true) { /* elseif */

  LINE(275);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            if (2 < 1 || 2 > args.vec->size) {
                err = ERR_bounds;
                goto ex_1;
            }
            T_4_1.num = args.vec->data[2 - 1];
            err = e_e2i(T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            i2.num = T_4_2.num;
            }

  LINE(276);
            { /* if */
            CLUREF T_4_1;
            T_4_1.num = ((op.str->size != STR_add.str->size)? false :
                !(memcmp(op.str->data, STR_add.str->data, op.str->size)));
            if (T_4_1.num == true) { /* if */

  LINE(277);
                {
                CLUREF T_5_1;
                T_5_1.num = i1.num + i2.num;
                if ((T_5_1.num > 0 && i1.num < 0 && i2.num < 0) ||
                    (T_5_1.num < 0 && i1.num > 0 && i2.num > 0)) {
                    err = ERR_overflow;
                    goto ex_1;
                }
                i1.num = T_5_1.num;
                }
            }
            else {

  LINE(278);
            CLUREF T_4_2;
            T_4_2.num = ((op.str->size != STR_sub.str->size)? false :
                !(memcmp(op.str->data, STR_sub.str->data, op.str->size)));
            if (T_4_2.num == true) { /* elseif */

  LINE(279);
                {
                CLUREF T_5_1;
                T_5_1.num = i1.num - i2.num;
                if ((T_5_1.num >= 0 && i1.num < 0 && (-i2.num) < 0) ||
                    (T_5_1.num <= 0 && i1.num > 0 && (-i2.num) > 0)) {
                    err = ERR_overflow;
                    goto ex_1;
                }
                i1.num = T_5_1.num;
                }
            }
            else {

  LINE(280);
            CLUREF T_4_3;
            T_4_3.num = ((op.str->size != STR_mul.str->size)? false :
                !(memcmp(op.str->data, STR_mul.str->data, op.str->size)));
            if (T_4_3.num == true) { /* elseif */

  LINE(281);
                {
                CLUREF T_5_1;
                err = intOPmul(i1, i2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                i1.num = T_5_1.num;
                }
            }
            else {

  LINE(282);
            CLUREF T_4_4;
            T_4_4.num = ((op.str->size != STR_div.str->size)? false :
                !(memcmp(op.str->data, STR_div.str->data, op.str->size)));
            if (T_4_4.num == true) { /* elseif */

  LINE(283);
                {
                CLUREF T_5_1;
                err = intOPdiv(i1, i2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                i1.num = T_5_1.num;
                }
            }
            else {

  LINE(284);
            CLUREF T_4_5;
            T_4_5.num = ((op.str->size != STR_power.str->size)? false :
                !(memcmp(op.str->data, STR_power.str->data, op.str->size)));
            if (T_4_5.num == true) { /* elseif */

  LINE(285);
                {
                CLUREF T_5_1;
                err = intOPpower(i1, i2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                i1.num = T_5_1.num;
                }
            }
            else {

  LINE(286);
            CLUREF T_4_6;
            T_4_6.num = ((op.str->size != STR_mod.str->size)? false :
                !(memcmp(op.str->data, STR_mod.str->data, op.str->size)));
            if (T_4_6.num == true) { /* elseif */

  LINE(287);
                {
                CLUREF T_5_1;
                err = intOPmod(i1, i2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                i1.num = T_5_1.num;
                }
            }
            else {

  LINE(288);
            CLUREF T_4_7;
            T_4_7.num = ((op.str->size != STR_min.str->size)? false :
                !(memcmp(op.str->data, STR_min.str->data, op.str->size)));
            if (T_4_7.num == true) { /* elseif */

  LINE(289);
                {
                CLUREF T_5_1;
                err = intOPmin(i1, i2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                i1.num = T_5_1.num;
                }
            }
            else {

  LINE(290);
            CLUREF T_4_8;
            T_4_8.num = ((op.str->size != STR_max.str->size)? false :
                !(memcmp(op.str->data, STR_max.str->data, op.str->size)));
            if (T_4_8.num == true) { /* elseif */

  LINE(291);
                {
                CLUREF T_5_1;
                err = intOPmax(i1, i2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                i1.num = T_5_1.num;
                }
            }
            else { /* else */

  LINE(293);
                { /* if */
                CLUREF T_5_1;
                T_5_1.num = ((op.str->size != STR_lt.str->size)? false :
                    !(memcmp(op.str->data, STR_lt.str->data, op.str->size)));
                if (T_5_1.num == true) { /* if */

  LINE(294);
                    {
                    CLUREF T_6_1;
                    T_6_1.num = (i1.num < i2.num);
                    b.num = T_6_1.num;
                    }
                }
                else {

  LINE(295);
                CLUREF T_5_2;
                T_5_2.num = ((op.str->size != STR_le.str->size)? false :
                    !(memcmp(op.str->data, STR_le.str->data, op.str->size)));
                if (T_5_2.num == true) { /* elseif */

  LINE(296);
                    {
                    CLUREF T_6_1;
                    T_6_1.num = (i1.num <= i2.num);
                    b.num = T_6_1.num;
                    }
                }
                else {

  LINE(297);
                CLUREF T_5_3;
                T_5_3.num = ((op.str->size != STR_ge.str->size)? false :
                    !(memcmp(op.str->data, STR_ge.str->data, op.str->size)));
                if (T_5_3.num == true) { /* elseif */

  LINE(298);
                    {
                    CLUREF T_6_1;
                    T_6_1.num = (i1.num >= i2.num);
                    b.num = T_6_1.num;
                    }
                }
                else {

  LINE(299);
                CLUREF T_5_4;
                T_5_4.num = ((op.str->size != STR_gt.str->size)? false :
                    !(memcmp(op.str->data, STR_gt.str->data, op.str->size)));
                if (T_5_4.num == true) { /* elseif */

  LINE(300);
                    {
                    CLUREF T_6_1;
                    T_6_1.num = (i1.num > i2.num);
                    b.num = T_6_1.num;
                    }
                }
                else { /* else */

  LINE(301);
                    {
                    CLUREF T_6_1;
                    T_6_1.num = (i1.num == i2.num);
                    b.num = T_6_1.num;
                    }
                }}}}} /* end if */

  LINE(302);
                { /* return */
                {
                CLUREF T_5_1;
                err = e_b2e(e, b, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                ret_1->num = T_5_1.num;
                }
                signal (ERR_ok);
                }
            }}}}}}}}} /* end if */
        }
        }}}} /* end if */

  LINE(305);
        { /* return */
        {
        CLUREF T_3_1;
        err = e_i2e(e, i1, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        ret_1->num = T_3_1.num;
        }
        signal (ERR_ok);
        }
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_bad) {

  LINE(306);
        { /* signal */
            signal(ERR_bad);
        }
    }
    else { /* others */
        err_UNIQ = _pclu_erstr(err);

  LINE(307);
        { /* signal */
            elist[0] = err_UNIQ;
            signal(ERR_error);
        }
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_intop ****/



/**** BEGIN PROCEDURE e_realop ****/

extern errcode e_r2e();
extern errcode realOPi2r();
extern errcode realOPparse();
extern errcode e_e2r();
extern errcode realOPr2i();
extern errcode realOPtrunc();
extern errcode realOPunparse();
extern errcode realOPexponent();
extern errcode realOPminus();
extern errcode realOPabs();
extern errcode realOPmantissa();
extern errcode realOPadd();
extern errcode realOPsub();
extern errcode realOPmul();
extern errcode realOPdiv();
extern errcode realOPpower();
extern errcode realOPmin();
extern errcode realOPmax();
extern errcode realOPlt();
extern errcode realOPle();
extern errcode realOPge();
extern errcode realOPgt();
extern errcode realOPequal();
static CLUREF STR_i2r;
static CLUREF STR_r2i;
static CLUREF STR_trunc;
static CLUREF STR_exponent;
static CLUREF STR_mantissa;
static int e_realop_own_init = 0;

errcode
e_realop(CLUREF e, CLUREF op, CLUREF args, CLUREF *ret_1)
{
    errcode err;
    CLUREF a1;
    CLUREF r1;
    CLUREF r2;
    CLUREF b;
    CLUREF err_UNIQ;
    if (e_realop_own_init == 0) {
        stringOPcons("i2r", CLU_1, CLUREF_make_num(3), &STR_i2r);
        stringOPcons("parse", CLU_1, CLUREF_make_num(5), &STR_parse);
        stringOPcons("r2i", CLU_1, CLUREF_make_num(3), &STR_r2i);
        stringOPcons("trunc", CLU_1, CLUREF_make_num(5), &STR_trunc);
        stringOPcons("unparse", CLU_1, CLUREF_make_num(7), &STR_unparse);
        stringOPcons("exponent", CLU_1, CLUREF_make_num(8), &STR_exponent);
        stringOPcons("minus", CLU_1, CLUREF_make_num(5), &STR_minus);
        stringOPcons("abs", CLU_1, CLUREF_make_num(3), &STR_abs);
        stringOPcons("mantissa", CLU_1, CLUREF_make_num(8), &STR_mantissa);
        stringOPcons("copy", CLU_1, CLUREF_make_num(4), &STR_copy);
        stringOPcons("add", CLU_1, CLUREF_make_num(3), &STR_add);
        stringOPcons("sub", CLU_1, CLUREF_make_num(3), &STR_sub);
        stringOPcons("mul", CLU_1, CLUREF_make_num(3), &STR_mul);
        stringOPcons("div", CLU_1, CLUREF_make_num(3), &STR_div);
        stringOPcons("power", CLU_1, CLUREF_make_num(5), &STR_power);
        stringOPcons("min", CLU_1, CLUREF_make_num(3), &STR_min);
        stringOPcons("max", CLU_1, CLUREF_make_num(3), &STR_max);
        stringOPcons("lt", CLU_1, CLUREF_make_num(2), &STR_lt);
        stringOPcons("le", CLU_1, CLUREF_make_num(2), &STR_le);
        stringOPcons("ge", CLU_1, CLUREF_make_num(2), &STR_ge);
        stringOPcons("gt", CLU_1, CLUREF_make_num(2), &STR_gt);
        e_realop_own_init = 1;
    }
    enter_proc(311);

  LINE(313);
    { /* begin */

  LINE(314);
        {
        CLUREF T_3_1;
        if (1 < 1 || 1 > args.vec->size) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_1.num = args.vec->data[1 - 1];
        a1.num = T_3_1.num;
        }

  LINE(315);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = ((op.str->size != STR_i2r.str->size)? false :
            !(memcmp(op.str->data, STR_i2r.str->data, op.str->size)));
        if (T_3_1.num == true) { /* if */

  LINE(316);
            { /* return */
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            err = e_e2i(a1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            err = realOPi2r(T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            err = e_r2e(e, T_4_2, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_3.num;
            }
            signal (ERR_ok);
            }
        }
        else {

  LINE(317);
        CLUREF T_3_2;
        T_3_2.num = ((op.str->size != STR_parse.str->size)? false :
            !(memcmp(op.str->data, STR_parse.str->data, op.str->size)));
        if (T_3_2.num == true) { /* elseif */

  LINE(318);
            { /* return */
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            err = e_e2s(a1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            err = realOPparse(T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            err = e_r2e(e, T_4_2, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_3.num;
            }
            signal (ERR_ok);
            }
        }
        }} /* end if */

  LINE(319);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        if (1 < 1 || 1 > args.vec->size) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_1.num = args.vec->data[1 - 1];
        err = e_e2r(T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        r1.num = T_3_2.num;
        }

  LINE(320);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = ((op.str->size != STR_r2i.str->size)? false :
            !(memcmp(op.str->data, STR_r2i.str->data, op.str->size)));
        if (T_3_1.num == true) { /* if */

  LINE(321);
            { /* return */
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            err = realOPr2i(r1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            err = e_i2e(e, T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_2.num;
            }
            signal (ERR_ok);
            }
        }
        else {

  LINE(322);
        CLUREF T_3_2;
        T_3_2.num = ((op.str->size != STR_trunc.str->size)? false :
            !(memcmp(op.str->data, STR_trunc.str->data, op.str->size)));
        if (T_3_2.num == true) { /* elseif */

  LINE(323);
            { /* return */
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            err = realOPtrunc(r1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            err = e_i2e(e, T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_2.num;
            }
            signal (ERR_ok);
            }
        }
        else {

  LINE(324);
        CLUREF T_3_3;
        T_3_3.num = ((op.str->size != STR_unparse.str->size)? false :
            !(memcmp(op.str->data, STR_unparse.str->data, op.str->size)));
        if (T_3_3.num == true) { /* elseif */

  LINE(325);
            { /* return */
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            err = realOPunparse(r1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            err = e_s2e(e, T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_2.num;
            }
            signal (ERR_ok);
            }
        }
        else {

  LINE(326);
        CLUREF T_3_4;
        T_3_4.num = ((op.str->size != STR_exponent.str->size)? false :
            !(memcmp(op.str->data, STR_exponent.str->data, op.str->size)));
        if (T_3_4.num == true) { /* elseif */

  LINE(327);
            { /* return */
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            err = realOPexponent(r1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            err = e_i2e(e, T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_2.num;
            }
            signal (ERR_ok);
            }
        }
        else {

  LINE(328);
        CLUREF T_3_5;
        T_3_5.num = ((op.str->size != STR_minus.str->size)? false :
            !(memcmp(op.str->data, STR_minus.str->data, op.str->size)));
        if (T_3_5.num == true) { /* elseif */

  LINE(329);
            {
            CLUREF T_4_1;
            err = realOPminus(r1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            r1.num = T_4_1.num;
            }
        }
        else {

  LINE(330);
        CLUREF T_3_6;
        T_3_6.num = ((op.str->size != STR_abs.str->size)? false :
            !(memcmp(op.str->data, STR_abs.str->data, op.str->size)));
        if (T_3_6.num == true) { /* elseif */

  LINE(331);
            {
            CLUREF T_4_1;
            err = realOPabs(r1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            r1.num = T_4_1.num;
            }
        }
        else {

  LINE(332);
        CLUREF T_3_7;
        T_3_7.num = ((op.str->size != STR_mantissa.str->size)? false :
            !(memcmp(op.str->data, STR_mantissa.str->data, op.str->size)));
        if (T_3_7.num == true) { /* elseif */

  LINE(333);
            {
            CLUREF T_4_1;
            err = realOPmantissa(r1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            r1.num = T_4_1.num;
            }
        }
        else {

  LINE(334);
        CLUREF T_3_8;
        CLUREF T_3_9;
        T_3_8.num = ((op.str->size != STR_copy.str->size)? false :
            !(memcmp(op.str->data, STR_copy.str->data, op.str->size)));
        T_3_9.num = !T_3_8.num;
        if (T_3_9.num == true) { /* elseif */

  LINE(335);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            if (2 < 1 || 2 > args.vec->size) {
                err = ERR_bounds;
                goto ex_1;
            }
            T_4_1.num = args.vec->data[2 - 1];
            err = e_e2r(T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            r2.num = T_4_2.num;
            }

  LINE(336);
            { /* if */
            CLUREF T_4_1;
            T_4_1.num = ((op.str->size != STR_add.str->size)? false :
                !(memcmp(op.str->data, STR_add.str->data, op.str->size)));
            if (T_4_1.num == true) { /* if */

  LINE(337);
                {
                CLUREF T_5_1;
                err = realOPadd(r1, r2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                r1.num = T_5_1.num;
                }
            }
            else {

  LINE(338);
            CLUREF T_4_2;
            T_4_2.num = ((op.str->size != STR_sub.str->size)? false :
                !(memcmp(op.str->data, STR_sub.str->data, op.str->size)));
            if (T_4_2.num == true) { /* elseif */

  LINE(339);
                {
                CLUREF T_5_1;
                err = realOPsub(r1, r2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                r1.num = T_5_1.num;
                }
            }
            else {

  LINE(340);
            CLUREF T_4_3;
            T_4_3.num = ((op.str->size != STR_mul.str->size)? false :
                !(memcmp(op.str->data, STR_mul.str->data, op.str->size)));
            if (T_4_3.num == true) { /* elseif */

  LINE(341);
                {
                CLUREF T_5_1;
                err = realOPmul(r1, r2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                r1.num = T_5_1.num;
                }
            }
            else {

  LINE(342);
            CLUREF T_4_4;
            T_4_4.num = ((op.str->size != STR_div.str->size)? false :
                !(memcmp(op.str->data, STR_div.str->data, op.str->size)));
            if (T_4_4.num == true) { /* elseif */

  LINE(343);
                {
                CLUREF T_5_1;
                err = realOPdiv(r1, r2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                r1.num = T_5_1.num;
                }
            }
            else {

  LINE(344);
            CLUREF T_4_5;
            T_4_5.num = ((op.str->size != STR_power.str->size)? false :
                !(memcmp(op.str->data, STR_power.str->data, op.str->size)));
            if (T_4_5.num == true) { /* elseif */

  LINE(345);
                {
                CLUREF T_5_1;
                err = realOPpower(r1, r2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                r1.num = T_5_1.num;
                }
            }
            else {

  LINE(346);
            CLUREF T_4_6;
            T_4_6.num = ((op.str->size != STR_min.str->size)? false :
                !(memcmp(op.str->data, STR_min.str->data, op.str->size)));
            if (T_4_6.num == true) { /* elseif */

  LINE(347);
                {
                CLUREF T_5_1;
                err = realOPmin(r1, r2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                r1.num = T_5_1.num;
                }
            }
            else {

  LINE(348);
            CLUREF T_4_7;
            T_4_7.num = ((op.str->size != STR_max.str->size)? false :
                !(memcmp(op.str->data, STR_max.str->data, op.str->size)));
            if (T_4_7.num == true) { /* elseif */

  LINE(349);
                {
                CLUREF T_5_1;
                err = realOPmax(r1, r2, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                r1.num = T_5_1.num;
                }
            }
            else { /* else */

  LINE(351);
                { /* if */
                CLUREF T_5_1;
                T_5_1.num = ((op.str->size != STR_lt.str->size)? false :
                    !(memcmp(op.str->data, STR_lt.str->data, op.str->size)));
                if (T_5_1.num == true) { /* if */

  LINE(352);
                    {
                    CLUREF T_6_1;
                    err = realOPlt(r1, r2, &T_6_1);
                    if (err != ERR_ok)
                        goto ex_1;
                    b.num = T_6_1.num;
                    }
                }
                else {

  LINE(353);
                CLUREF T_5_2;
                T_5_2.num = ((op.str->size != STR_le.str->size)? false :
                    !(memcmp(op.str->data, STR_le.str->data, op.str->size)));
                if (T_5_2.num == true) { /* elseif */

  LINE(354);
                    {
                    CLUREF T_6_1;
                    err = realOPle(r1, r2, &T_6_1);
                    if (err != ERR_ok)
                        goto ex_1;
                    b.num = T_6_1.num;
                    }
                }
                else {

  LINE(355);
                CLUREF T_5_3;
                T_5_3.num = ((op.str->size != STR_ge.str->size)? false :
                    !(memcmp(op.str->data, STR_ge.str->data, op.str->size)));
                if (T_5_3.num == true) { /* elseif */

  LINE(356);
                    {
                    CLUREF T_6_1;
                    err = realOPge(r1, r2, &T_6_1);
                    if (err != ERR_ok)
                        goto ex_1;
                    b.num = T_6_1.num;
                    }
                }
                else {

  LINE(357);
                CLUREF T_5_4;
                T_5_4.num = ((op.str->size != STR_gt.str->size)? false :
                    !(memcmp(op.str->data, STR_gt.str->data, op.str->size)));
                if (T_5_4.num == true) { /* elseif */

  LINE(358);
                    {
                    CLUREF T_6_1;
                    err = realOPgt(r1, r2, &T_6_1);
                    if (err != ERR_ok)
                        goto ex_1;
                    b.num = T_6_1.num;
                    }
                }
                else { /* else */

  LINE(359);
                    {
                    CLUREF T_6_1;
                    err = realOPequal(r1, r2, &T_6_1);
                    if (err != ERR_ok)
                        goto ex_1;
                    b.num = T_6_1.num;
                    }
                }}}}} /* end if */

  LINE(360);
                { /* return */
                {
                CLUREF T_5_1;
                err = e_b2e(e, b, &T_5_1);
                if (err != ERR_ok)
                    goto ex_1;
                ret_1->num = T_5_1.num;
                }
                signal (ERR_ok);
                }
            }}}}}}}} /* end if */
        }
        }}}}}}}} /* end if */

  LINE(363);
        { /* return */
        {
        CLUREF T_3_1;
        err = e_r2e(e, r1, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        ret_1->num = T_3_1.num;
        }
        signal (ERR_ok);
        }
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_bad) {

  LINE(364);
        { /* signal */
            signal(ERR_bad);
        }
    }
    else { /* others */
        err_UNIQ = _pclu_erstr(err);

  LINE(365);
        { /* signal */
            elist[0] = err_UNIQ;
            signal(ERR_error);
        }
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_realop ****/



/**** BEGIN PROCEDURE e_charop ****/

extern errcode e_h2e();
extern errcode charOPi2c();
extern errcode e_e2h();
extern errcode charOPc2i();
extern errcode charOPlt();
extern errcode charOPle();
extern errcode charOPge();
extern errcode charOPgt();
extern errcode charOPequal();
static CLUREF STR_i2c;
static CLUREF STR_c2i;
static int e_charop_own_init = 0;

errcode
e_charop(CLUREF e, CLUREF op, CLUREF args, CLUREF *ret_1)
{
    errcode err;
    CLUREF a1;
    CLUREF h1;
    CLUREF h2;
    CLUREF b;
    CLUREF err_UNIQ;
    if (e_charop_own_init == 0) {
        stringOPcons("i2c", CLU_1, CLUREF_make_num(3), &STR_i2c);
        stringOPcons("c2i", CLU_1, CLUREF_make_num(3), &STR_c2i);
        stringOPcons("copy", CLU_1, CLUREF_make_num(4), &STR_copy);
        stringOPcons("lt", CLU_1, CLUREF_make_num(2), &STR_lt);
        stringOPcons("le", CLU_1, CLUREF_make_num(2), &STR_le);
        stringOPcons("ge", CLU_1, CLUREF_make_num(2), &STR_ge);
        stringOPcons("gt", CLU_1, CLUREF_make_num(2), &STR_gt);
        e_charop_own_init = 1;
    }
    enter_proc(369);

  LINE(371);
    { /* begin */

  LINE(372);
        {
        CLUREF T_3_1;
        if (1 < 1 || 1 > args.vec->size) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_1.num = args.vec->data[1 - 1];
        a1.num = T_3_1.num;
        }

  LINE(373);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = ((op.str->size != STR_i2c.str->size)? false :
            !(memcmp(op.str->data, STR_i2c.str->data, op.str->size)));
        if (T_3_1.num == true) { /* if */

  LINE(374);
            { /* return */
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            err = e_e2i(a1, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            err = charOPi2c(T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            err = e_h2e(e, T_4_2, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_3.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(375);
        {
        CLUREF T_3_1;
        err = e_e2h(a1, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        h1.num = T_3_1.num;
        }

  LINE(376);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = ((op.str->size != STR_c2i.str->size)? false :
            !(memcmp(op.str->data, STR_c2i.str->data, op.str->size)));
        if (T_3_1.num == true) { /* if */

  LINE(377);
            { /* return */
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = (long)(h1.ch & 0xff);
            err = e_i2e(e, T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            ret_1->num = T_4_2.num;
            }
            signal (ERR_ok);
            }
        }
        else {

  LINE(378);
        CLUREF T_3_2;
        T_3_2.num = ((op.str->size != STR_copy.str->size)? false :
            !(memcmp(op.str->data, STR_copy.str->data, op.str->size)));
        if (T_3_2.num == true) { /* elseif */

  LINE(379);
            { /* return */
            {
            ret_1->num = a1.num;
            }
            signal (ERR_ok);
            }
        }
        }} /* end if */

  LINE(380);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        if (2 < 1 || 2 > args.vec->size) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_1.num = args.vec->data[2 - 1];
        err = e_e2h(T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        h2.num = T_3_2.num;
        }

  LINE(382);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = ((op.str->size != STR_lt.str->size)? false :
            !(memcmp(op.str->data, STR_lt.str->data, op.str->size)));
        if (T_3_1.num == true) { /* if */

  LINE(383);
            {
            CLUREF T_4_1;
            err = charOPlt(h1, h2, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            b.num = T_4_1.num;
            }
        }
        else {

  LINE(384);
        CLUREF T_3_2;
        T_3_2.num = ((op.str->size != STR_le.str->size)? false :
            !(memcmp(op.str->data, STR_le.str->data, op.str->size)));
        if (T_3_2.num == true) { /* elseif */

  LINE(385);
            {
            CLUREF T_4_1;
            err = charOPle(h1, h2, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            b.num = T_4_1.num;
            }
        }
        else {

  LINE(386);
        CLUREF T_3_3;
        T_3_3.num = ((op.str->size != STR_ge.str->size)? false :
            !(memcmp(op.str->data, STR_ge.str->data, op.str->size)));
        if (T_3_3.num == true) { /* elseif */

  LINE(387);
            {
            CLUREF T_4_1;
            err = charOPge(h1, h2, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            b.num = T_4_1.num;
            }
        }
        else {

  LINE(388);
        CLUREF T_3_4;
        T_3_4.num = ((op.str->size != STR_gt.str->size)? false :
            !(memcmp(op.str->data, STR_gt.str->data, op.str->size)));
        if (T_3_4.num == true) { /* elseif */

  LINE(389);
            {
            CLUREF T_4_1;
            err = charOPgt(h1, h2, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            b.num = T_4_1.num;
            }
        }
        else { /* else */

  LINE(390);
            {
            CLUREF T_4_1;
            T_4_1.num = (h1.ch == h2.ch);
            b.num = T_4_1.num;
            }
        }}}}} /* end if */

  LINE(391);
        { /* return */
        {
        CLUREF T_3_1;
        err = e_b2e(e, b, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        ret_1->num = T_3_1.num;
        }
        signal (ERR_ok);
        }
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_bad) {

  LINE(392);
        { /* signal */
            signal(ERR_bad);
        }
    }
    else { /* others */
        err_UNIQ = _pclu_erstr(err);

  LINE(393);
        { /* signal */
            elist[0] = err_UNIQ;
            signal(ERR_error);
        }
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE e_charop ****/

