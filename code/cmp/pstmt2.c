
/* This file was automatically generated by pclu. */

#include "pclu_err.h"
#include "pclu_sys.h"



/**** BEGIN PROCEDURE p_decl_or_assn ****/

extern errcode p_idns_or_decls();
extern errcode p_envOPget_peek1();
extern errcode p_envOPnext_token();
extern errcode p_assn_rhs();
extern errcode p_envOPerr();
extern errcode p_envOPassume();
extern errcode oneofOPmake_6();
extern errcode p_envOPget_unknown_type();
extern errcode intOPequal();
extern errcode sequenceOPsize();
extern errcode sequenceOPbottom();
extern errcode oneofOPmake_7();
extern errcode sequenceOPnew();
extern errcode p_envOPget_bad_expr();
static CLUREF STR_use_040of_040_075_040instead_040of_040_072_075;
static CLUREF STR__072_040type_040in_040declaration;
static CLUREF STR__072_075_040invocation_040after_040declarations;
static int p_decl_or_assn_own_init = 0;

errcode
p_decl_or_assn(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF vars;
    CLUREF idns;
    CLUREF decls;
    if (p_decl_or_assn_own_init == 0) {
        stringOPcons("use of = instead of :=", CLU_1, CLUREF_make_num(22), &STR_use_040of_040_075_040instead_040of_040_072_075);
        stringOPcons(": type in declaration", CLU_1, CLUREF_make_num(21), &STR__072_040type_040in_040declaration);
        stringOPcons(":= invocation after declarations", CLU_1, CLUREF_make_num(32), &STR__072_075_040invocation_040after_040declarations);
        p_decl_or_assn_own_init = 1;
    }
    enter_proc(9);

  LINE(10);
    {
    CLUREF T_1_1;
    err = p_idns_or_decls(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    vars.num = T_1_1.num;
    }

  LINE(11);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 1: /* assn */ {

  LINE(13);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(14);
        { /* return */
        {
        CLUREF T_2_1;
        err = p_assn_rhs(e, vars, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 11: /* equal */ {

  LINE(16);
        {
        err = p_envOPerr(e, STR_use_040of_040_075_040instead_040of_040_072_075, CLU_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(17);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(18);
        { /* return */
        {
        CLUREF T_2_1;
        err = p_assn_rhs(e, vars, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(21);
    { /* qtagcase */
    switch (vars.cell->tag) {
    case 2: /* old */ {
        CLUREF T_1_1;
        T_1_1.num = vars.cell->value;
        idns.num = T_1_1.num;

  LINE(23);
        {
        err = p_envOPassume(e, STR__072_040type_040in_040declaration);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(24);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        RecordAlloc(2, T_2_1);
        T_2_1.vec->data[0] = idns.num;
        err = p_envOPget_unknown_type(e, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        CellAlloc(6, T_2_1.num, T_2_3);
        ret_1->num = T_2_3.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 1: /* new */ {
        CLUREF T_1_2;
        T_1_2.num = vars.cell->value;
        decls.num = T_1_2.num;

  LINE(27);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = decls.vec->size;
        T_2_2.num = (T_2_1.num == 1);
        if (T_2_2.num == true) { /* if */

  LINE(28);
            { /* return */
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = sequenceOPbottom(decls, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            CellAlloc(6, T_3_1.num, T_3_2);
            ret_1->num = T_3_2.num;
            }
            signal (ERR_ok);
            }
        }
        else { /* else */

  LINE(29);
            {
            err = p_envOPassume(e, STR__072_075_040invocation_040after_040declarations);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(30);
            { /* return */
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            RecordAlloc(3, T_3_1);
            T_3_1.vec->data[1] = decls.num;
            err = sequenceOPnew(&T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            T_3_1.vec->data[0] = T_3_2.num;
            err = p_envOPget_bad_expr(e, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            T_3_1.vec->data[2] = T_3_3.num;
            CellAlloc(7, T_3_1.num, T_3_4);
            ret_1->num = T_3_4.num;
            }
            signal (ERR_ok);
            }
        }} /* end if */
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_decl_or_assn ****/



/**** BEGIN PROCEDURE p_assn_rhs ****/

extern errcode p_clist();
extern errcode p_expr();
extern errcode oneofOPmake_1();
extern const struct REQS * const p_clist_of_t_reqs;
extern struct OPS *expr_ops;
extern const OWN_req p_clist_ownreqs;
struct OPS *p_clist_of_expr_ops __CLU_COMMON;
static CLUREF STR_expression;
static CLUREF STR_only_0401_040expression_040allowed_040after_040_072_075_040in_040a_040multiple_040declaration;
static int p_assn_rhs_own_init = 0;

errcode
p_assn_rhs(CLUREF e, CLUREF vars, CLUREF *ret_1)
{
    errcode err;
    CLUREF exprs;
    CLUREF idns;
    CLUREF decls;
    CLUREF x;
    if (p_assn_rhs_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)expr_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_expr_ops));
        stringOPcons("expression", CLU_1, CLUREF_make_num(10), &STR_expression);
        stringOPcons("only 1 expression allowed after := in a multiple declaration", CLU_1, CLUREF_make_num(60), &STR_only_0401_040expression_040allowed_040after_040_072_075_040in_040a_040multiple_040declaration);
        p_assn_rhs_own_init = 1;
    }
    enter_proc(38);

  LINE(39);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_expr;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_clist_of_expr_ops->op_owns;
    generic_CLU_proc.proc = p_clist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_clist(e, T_1_1, STR_expression, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    exprs.num = T_1_2.num;
    }

  LINE(40);
    { /* qtagcase */
    switch (vars.cell->tag) {
    case 2: /* old */ {
        CLUREF T_1_1;
        T_1_1.num = vars.cell->value;
        idns.num = T_1_1.num;

  LINE(42);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        RecordAlloc(3, T_2_1);
        T_2_1.vec->data[1] = idns.num;
        err = sequenceOPnew(&T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[0] = T_2_2.num;
        T_2_1.vec->data[2] = exprs.num;
        CellAlloc(1, T_2_1.num, T_2_3);
        ret_1->num = T_2_3.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 1: /* new */ {
        CLUREF T_1_2;
        T_1_2.num = vars.cell->value;
        decls.num = T_1_2.num;

  LINE(47);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = exprs.vec->size;
        T_2_2.num = (T_2_1.num == 1);
        if (T_2_2.num == true) { /* if */

  LINE(48);
            {
            CLUREF T_3_1;
            err = sequenceOPbottom(exprs, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            x.num = T_3_1.num;
            }
        }
        else { /* else */

  LINE(49);
            {
            err = p_envOPerr(e, STR_only_0401_040expression_040allowed_040after_040_072_075_040in_040a_040multiple_040declaration, CLU_1);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(52);
            {
            CLUREF T_3_1;
            err = p_envOPget_bad_expr(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            x.num = T_3_1.num;
            }
        }} /* end if */

  LINE(54);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        RecordAlloc(3, T_2_1);
        T_2_1.vec->data[1] = decls.num;
        err = sequenceOPnew(&T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[0] = T_2_2.num;
        T_2_1.vec->data[2] = x.num;
        CellAlloc(7, T_2_1.num, T_2_3);
        ret_1->num = T_2_3.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_assn_rhs ****/



/**** BEGIN PROCEDURE p_condition ****/

extern errcode p_name();
extern errcode p_plist();
extern const struct REQS * const p_plist_of_t_reqs;
extern const OWN_req p_plist_ownreqs;
struct OPS *p_plist_of_expr_ops __CLU_COMMON;
static CLUREF STR_exceptional_040condition;
static int p_condition_own_init = 0;

errcode
p_condition(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF n;
    CLUREF args;
    if (p_condition_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)expr_ops, p_plist_of_t_reqs);
        find_prociter_instance(p_plist, 1, &p_plist_ownreqs, &(p_plist_of_expr_ops));
        stringOPcons("exceptional condition", CLU_1, CLUREF_make_num(21), &STR_exceptional_040condition);
        stringOPcons("expression", CLU_1, CLUREF_make_num(10), &STR_expression);
        p_condition_own_init = 1;
    }
    enter_proc(62);

  LINE(63);
    {
    CLUREF T_2_1;
    err = p_name(e, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    n.num = T_2_1.num;
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_none) {

  LINE(64);
        {
        err = p_envOPassume(e, STR_exceptional_040condition);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(65);
        { /* signal */
            signal(ERR_bad);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(67);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_expr;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_plist_of_expr_ops->op_owns;
    generic_CLU_proc.proc = p_plist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_plist(e, T_1_1, CLU_true, CLU_false, STR_expression, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    args.num = T_1_2.num;
    }

  LINE(69);
    { /* return */
    {
    CLUREF T_1_1;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[1] = n.num;
    T_1_1.vec->data[0] = args.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_condition ****/



/**** BEGIN PROCEDURE p_while ****/

extern errcode p_expr1();
extern errcode p_do();
extern errcode oneofOPmake_19();

errcode
p_while(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF test;
    CLUREF bod;
    enter_proc(75);

  LINE(76);
    {
    CLUREF T_1_1;
    err = p_expr1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    test.num = T_1_1.num;
    }

  LINE(77);
    {
    CLUREF T_1_1;
    err = p_do(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    bod.num = T_1_1.num;
    }

  LINE(78);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[1] = test.num;
    T_1_1.vec->data[0] = bod.num;
    CellAlloc(19, T_1_1.num, T_1_2);
    ret_1->num = T_1_2.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_while ****/



/**** BEGIN PROCEDURE p_expr_stmt ****/

extern errcode oneofOPmake_17();
extern errcode oneofOPmake_13();
extern errcode p_make_invoke();
static CLUREF STR_expression_040used_040as_040statement;
static int p_expr_stmt_own_init = 0;

errcode
p_expr_stmt(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF x;
    CLUREF right;
    if (p_expr_stmt_own_init == 0) {
        stringOPcons("expression used as statement", CLU_1, CLUREF_make_num(28), &STR_expression_040used_040as_040statement);
        p_expr_stmt_own_init = 1;
    }
    enter_proc(84);

  LINE(85);
    {
    CLUREF T_1_1;
    err = p_expr1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    x.num = T_1_1.num;
    }

  LINE(86);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 1: /* assn */ {

  LINE(88);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(89);
        {
        CLUREF T_2_1;
        err = p_expr1(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        right.num = T_2_1.num;
        }

  LINE(90);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(2, T_2_1);
        T_2_1.vec->data[0] = x.num;
        T_2_1.vec->data[1] = right.num;
        CellAlloc(17, T_2_1.num, T_2_2);
        ret_1->num = T_2_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(93);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = p_make_invoke(e, x, STR_expression_040used_040as_040statement, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        CellAlloc(13, T_2_1.num, T_2_2);
        ret_1->num = T_2_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_expr_stmt ****/



/**** BEGIN PROCEDURE p_make_invoke ****/

extern errcode exprOPget_abs();

errcode
p_make_invoke(CLUREF e, CLUREF x, CLUREF why, CLUREF *ret_1)
{
    errcode err;
    CLUREF abs;
    enter_proc(102);

  LINE(103);
    { /* qtagcase */
    CLUREF T_1_1;
    err = exprOPget_abs(x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 16: /* invoke */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        abs.num = T_1_2.num;

  LINE(105);
        { /* return */
        {
        ret_1->num = abs.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(107);
        {
        err = p_envOPerr(e, why, CLU_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(108);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        RecordAlloc(2, T_2_1);
        err = p_envOPget_bad_expr(e, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[0] = T_2_2.num;
        err = sequenceOPnew(&T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[1] = T_2_3.num;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_make_invoke ****/



/**** BEGIN PROCEDURE p_except ****/

extern errcode p_semi();
extern errcode p_envOPget_line();
extern errcode stmtOPcreate();
extern errcode oneofOPmake_14();
extern errcode p_list();
extern errcode p_whenarm();
extern errcode oneofOPmake_2();
extern errcode oneofOPmake_8();
extern errcode p_mdecl();
extern errcode p_cbody();
extern errcode recordOPset_2();
extern errcode p_end();
extern struct OPS *string_ops;
struct OPS *p_clist_of_string_ops __CLU_COMMON;
extern const struct REQS * const sequence_of_t_reqs;
extern struct OPS *equate_ops;
extern const OWN_req sequence_ownreqs;
extern struct OPS *sequence_ops;
struct OPS *sequence_of_equate_ops __CLU_COMMON;
extern struct OPS *stmt_ops;
struct OPS *sequence_of_stmt_ops __CLU_COMMON;
extern struct OPS *sequence_of_equate_ops;
extern struct OPS *sequence_of_stmt_ops;
struct OPS *record_equates_stmts_ops __CLU_COMMON;
struct OPS *sequence_of_string_ops __CLU_COMMON;
extern struct OPS *idn_ops;
struct OPS *sequence_of_idn_ops __CLU_COMMON;
extern struct OPS *sequence_of_idn_ops;
extern struct OPS *typespec_ops;
struct OPS *record_idns_type__ops __CLU_COMMON;
extern struct OPS *record_idns_type__ops;
struct OPS *sequence_of_record_idns_type__ops __CLU_COMMON;
extern struct OPS *sequence_of_record_idns_type__ops;
extern struct OPS *null_ops;
struct OPS *oneof_decls_none_star_ops __CLU_COMMON;
extern struct OPS *record_equates_stmts_ops;
extern struct OPS *int_ops;
extern struct OPS *sequence_of_string_ops;
extern struct OPS *oneof_decls_none_star_ops;
struct OPS *record_body_line_names_vars_ops __CLU_COMMON;
extern const struct REQS * const p_list_of_t_reqs;
extern struct OPS *record_body_line_names_vars_ops;
extern const OWN_req p_list_ownreqs;
struct OPS *p_list_of_record_body_line_names_vars_ops __CLU_COMMON;
static CLUREF STR_name;
static CLUREF STR_WHEN_040arm;
static CLUREF STR__072_040in_040OTHERS_056_056_056_072_040body;
static CLUREF STR_END_040of_040EXCEPT_040statement;
static int p_except_own_init = 0;

errcode
p_except(CLUREF e, CLUREF st, CLUREF *ret_1)
{
    errcode err;
    CLUREF l;
    CLUREF sigs;
    CLUREF rs;
    CLUREF arms;
    CLUREF xs;
    CLUREF line;
    CLUREF dec;
    CLUREF bod;
    if (p_except_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)string_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_string_ops));
        add_parm_info_type(0, (const struct OPS *)equate_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_equate_ops));
        add_parm_info_type(0, (const struct OPS *)stmt_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_stmt_ops));
        add_selector_info("equates", 0, (struct OPS *)sequence_of_equate_ops);
        add_selector_info("stmts", 1, (struct OPS *)sequence_of_stmt_ops);
        find_selector_ops("record", 2, &(record_equates_stmts_ops));
        add_parm_info_type(0, (const struct OPS *)string_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_string_ops));
        add_parm_info_type(0, (const struct OPS *)idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, (struct OPS *)sequence_of_idn_ops);
        add_selector_info("type_", 1, (struct OPS *)typespec_ops);
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_parm_info_type(0, (const struct OPS *)record_idns_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_idns_type__ops));
        add_selector_info("decls", 0, (struct OPS *)sequence_of_record_idns_type__ops);
        add_selector_info("none", 1, (struct OPS *)null_ops);
        add_selector_info("star", 2, (struct OPS *)null_ops);
        find_selector_ops("oneof", 3, &(oneof_decls_none_star_ops));
        add_selector_info("body", 0, (struct OPS *)record_equates_stmts_ops);
        add_selector_info("line", 1, (struct OPS *)int_ops);
        add_selector_info("names", 2, (struct OPS *)sequence_of_string_ops);
        add_selector_info("vars", 3, (struct OPS *)oneof_decls_none_star_ops);
        find_selector_ops("record", 4, &(record_body_line_names_vars_ops));
        add_parm_info_type(0, (const struct OPS *)record_body_line_names_vars_ops, p_list_of_t_reqs);
        find_prociter_instance(p_list, 1, &p_list_ownreqs, &(p_list_of_record_body_line_names_vars_ops));
        stringOPcons("name", CLU_1, CLUREF_make_num(4), &STR_name);
        stringOPcons("WHEN arm", CLU_1, CLUREF_make_num(8), &STR_WHEN_040arm);
        stringOPcons(": in OTHERS...: body", CLU_1, CLUREF_make_num(20), &STR__072_040in_040OTHERS_056_056_056_072_040body);
        stringOPcons("END of EXCEPT statement", CLU_1, CLUREF_make_num(23), &STR_END_040of_040EXCEPT_040statement);
        p_except_own_init = 1;
    }
    enter_proc(117);

  LINE(118);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(119);
        {
        err = p_semi(e);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(120);
        { /* qtagcase */
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_1.cell->tag) {
        case 12: /* except_ */ {

  LINE(122);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 29: /* resignal_ */ {

  LINE(124);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(125);
            {
            CLUREF T_3_1;
            err = p_envOPget_line(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            l.num = T_3_1.num;
            }

  LINE(126);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = proctypeOPnew(CLU_0, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            T_3_1.proc->type_owns = NULL;
            T_3_1.proc->op_owns = NULL;
            T_3_1.proc->proc = p_name;
            generic_CLU_proc.type_owns = NULL;
            generic_CLU_proc.op_owns = p_clist_of_string_ops->op_owns;
            generic_CLU_proc.proc = p_clist;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = p_clist(e, T_3_1, STR_name, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            sigs.num = T_3_2.num;
            }

  LINE(127);
            {
            CLUREF T_3_1;
            RecordAlloc(2, T_3_1);
            T_3_1.vec->data[1] = st.num;
            T_3_1.vec->data[0] = sigs.num;
            rs.num = T_3_1.num;
            }

  LINE(129);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CellAlloc(14, rs.num, T_3_1);
            err = stmtOPcreate(T_3_1, l, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            st.num = T_3_2.num;
            }

  LINE(130);
            continue;
            break;
        }
        default: {

  LINE(132);
            { /* return */
            {
            ret_1->num = st.num;
            }
            signal (ERR_ok);
            }
            break;
        }
        }
        } /* end qtagcase */

  LINE(134);
        {
        CLUREF T_2_1;
        err = p_envOPget_line(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        l.num = T_2_1.num;
        }

  LINE(135);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = proctypeOPnew(CLU_0, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.proc->type_owns = NULL;
        T_2_1.proc->op_owns = NULL;
        T_2_1.proc->proc = p_whenarm;
        generic_CLU_proc.type_owns = NULL;
        generic_CLU_proc.op_owns = p_list_of_record_body_line_names_vars_ops->op_owns;
        generic_CLU_proc.proc = p_list;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_list(e, T_2_1, CLU_true, STR_WHEN_040arm, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        arms.num = T_2_2.num;
        }

  LINE(137);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(3, T_2_1);
        T_2_1.vec->data[2] = st.num;
        T_2_1.vec->data[0] = arms.num;
        CellAlloc(2, nil, T_2_2);
        T_2_1.vec->data[1] = T_2_2.num;
        xs.num = T_2_1.num;
        }

  LINE(140);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CellAlloc(8, xs.num, T_2_1);
        err = stmtOPcreate(T_2_1, l, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        st.num = T_2_2.num;
        }

  LINE(141);
        { /* qtagcase */
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_1.cell->tag) {
        case 24: /* others_ */ {

  LINE(143);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(144);
            {
            CLUREF T_3_1;
            err = p_envOPget_line(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            line.num = T_3_1.num;
            }

  LINE(145);
            {
            CLUREF T_3_1;
            err = p_mdecl(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            dec.num = T_3_1.num;
            }

  LINE(146);
            {
            CLUREF T_3_1;
            err = p_cbody(e, CLU_3, STR__072_040in_040OTHERS_056_056_056_072_040body, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            bod.num = T_3_1.num;
            }

  LINE(147);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            RecordAlloc(3, T_3_1);
            T_3_1.vec->data[1] = dec.num;
            T_3_1.vec->data[0] = bod.num;
            T_3_1.vec->data[2] = line.num;
            CellAlloc(1, T_3_1.num, T_3_2);
            xs.vec->data[1] = T_3_2.num;
            }
            break;
        }
        }
        } /* end qtagcase */

  LINE(152);
        {
        err = p_end(e, STR_END_040of_040EXCEPT_040statement);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    end_while_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_except ****/



/**** BEGIN PROCEDURE p_whenarm ****/

extern errcode p_whendecl();
struct OPS *p_clist_of_string_ops __CLU_COMMON;
static CLUREF STR__072_040in_040WHEN_056_056_056_072_040body;
static int p_whenarm_own_init = 0;

errcode
p_whenarm(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF line;
    CLUREF names;
    CLUREF vars;
    CLUREF bod;
    if (p_whenarm_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)string_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_string_ops));
        stringOPcons("name", CLU_1, CLUREF_make_num(4), &STR_name);
        stringOPcons(": in WHEN...: body", CLU_1, CLUREF_make_num(18), &STR__072_040in_040WHEN_056_056_056_072_040body);
        p_whenarm_own_init = 1;
    }
    enter_proc(156);

  LINE(157);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 39: /* when_ */ {

  LINE(158);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    default: {

  LINE(159);
        { /* signal */
            signal(ERR_none);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(161);
    {
    CLUREF T_1_1;
    err = p_envOPget_line(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    line.num = T_1_1.num;
    }

  LINE(162);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_name;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_clist_of_string_ops->op_owns;
    generic_CLU_proc.proc = p_clist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_clist(e, T_1_1, STR_name, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    names.num = T_1_2.num;
    }

  LINE(163);
    {
    CLUREF T_1_1;
    err = p_whendecl(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    vars.num = T_1_1.num;
    }

  LINE(164);
    {
    CLUREF T_1_1;
    err = p_cbody(e, CLU_2, STR__072_040in_040WHEN_056_056_056_072_040body, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    bod.num = T_1_1.num;
    }

  LINE(165);
    { /* return */
    {
    CLUREF T_1_1;
    RecordAlloc(4, T_1_1);
    T_1_1.vec->data[2] = names.num;
    T_1_1.vec->data[3] = vars.num;
    T_1_1.vec->data[0] = bod.num;
    T_1_1.vec->data[1] = line.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_whenarm ****/



/**** BEGIN PROCEDURE p_mdecl ****/

extern errcode p_decl();
extern errcode intOPgt();
extern errcode recordOPget_1();
extern errcode recordOPset_1();
static CLUREF STR_more_040than_040one_040idn_040declared;
static CLUREF STR__051_040in_040_050idn_072_040type_051;
static int p_mdecl_own_init = 0;

errcode
p_mdecl(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF dec;
    if (p_mdecl_own_init == 0) {
        stringOPcons("more than one idn declared", CLU_1, CLUREF_make_num(26), &STR_more_040than_040one_040idn_040declared);
        stringOPcons(") in (idn: type)", CLU_1, CLUREF_make_num(16), &STR__051_040in_040_050idn_072_040type_051);
        p_mdecl_own_init = 1;
    }
    enter_proc(173);

  LINE(174);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 21: /* l_paren */ {

  LINE(175);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    default: {

  LINE(176);
        { /* return */
        {
        CLUREF T_2_1;
        CellAlloc(2, nil, T_2_1);
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(178);
    {
    CLUREF T_1_1;
    err = p_decl(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    dec.num = T_1_1.num;
    }

  LINE(179);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = dec.vec->data[0];
    T_1_2.num = T_1_1.vec->size;
    T_1_3.num = (T_1_2.num > 1);
    if (T_1_3.num == true) { /* if */

  LINE(180);
        {
        err = p_envOPerr(e, STR_more_040than_040one_040idn_040declared, CLU_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(181);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        sequenceOPnew2(CLU_1, &T_2_1);
        T_2_2.num = dec.vec->data[0];
        err = sequenceOPbottom(T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[0] = T_2_3.num;
        dec.vec->data[0] = T_2_1.num;
        }
    }
    } /* end if */

  LINE(183);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 28: /* r_paren */ {

  LINE(184);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    default: {

  LINE(185);
        {
        err = p_envOPassume(e, STR__051_040in_040_050idn_072_040type_051);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(187);
    { /* return */
    {
    CLUREF T_1_1;
    CellAlloc(1, dec.num, T_1_1);
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_mdecl ****/



/**** BEGIN PROCEDURE p_cbody ****/

extern errcode p_body();

errcode
p_cbody(CLUREF e, CLUREF kind, CLUREF assume, CLUREF *ret_1)
{
    errcode err;
    enter_proc(192);

  LINE(193);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: /* colon */ {

  LINE(194);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    default: {

  LINE(195);
        {
        err = p_envOPassume(e, assume);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(197);
    { /* return */
    {
    CLUREF T_1_1;
    err = p_body(e, kind, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_cbody ****/



/**** BEGIN PROCEDURE p_body ****/

extern errcode p_envOPbegin_body();
extern errcode p_slist();
extern errcode p_equate();
extern errcode p_stmt();
extern errcode p_envOPend_body();
extern const struct REQS * const p_slist_of_t_reqs;
extern const OWN_req p_slist_ownreqs;
struct OPS *p_slist_of_equate_ops __CLU_COMMON;
struct OPS *p_slist_of_stmt_ops __CLU_COMMON;
static int p_body_own_init = 0;

errcode
p_body(CLUREF e, CLUREF kind, CLUREF *ret_1)
{
    errcode err;
    CLUREF equates;
    CLUREF stmts;
    if (p_body_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        add_parm_info_type(0, (const struct OPS *)stmt_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_stmt_ops));
        p_body_own_init = 1;
    }
    enter_proc(202);

  LINE(203);
    {
    err = p_envOPbegin_body(e, kind);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(204);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_equate;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_slist_of_equate_ops->op_owns;
    generic_CLU_proc.proc = p_slist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_slist(e, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    equates.num = T_1_2.num;
    }

  LINE(205);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_stmt;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_slist_of_stmt_ops->op_owns;
    generic_CLU_proc.proc = p_slist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_slist(e, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    stmts.num = T_1_2.num;
    }

  LINE(206);
    {
    err = p_envOPend_body(e);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(207);
    { /* return */
    {
    CLUREF T_1_1;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[0] = equates.num;
    T_1_1.vec->data[1] = stmts.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_body ****/



/**** BEGIN PROCEDURE p_whendecl ****/

extern errcode stringOPequal();
extern errcode structOPget_2();
extern errcode boolOPnot();
extern errcode structOPget_1();
extern errcode oneofOPmake_3();
struct OPS *sequence_of_idn_ops __CLU_COMMON;
struct OPS *record_idns_type__ops __CLU_COMMON;
struct OPS *p_clist_of_record_idns_type__ops __CLU_COMMON;
static CLUREF STR_mul;
static CLUREF STR_declaration;
static CLUREF STR__051_040in_040_050declaration_137list_051_040or_040_050_052_051;
static int p_whendecl_own_init = 0;

errcode
p_whendecl(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF dec;
    CLUREF k;
    if (p_whendecl_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, (struct OPS *)sequence_of_idn_ops);
        add_selector_info("type_", 1, (struct OPS *)typespec_ops);
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_parm_info_type(0, (const struct OPS *)record_idns_type__ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_record_idns_type__ops));
        stringOPcons("mul", CLU_1, CLUREF_make_num(3), &STR_mul);
        stringOPcons("declaration", CLU_1, CLUREF_make_num(11), &STR_declaration);
        stringOPcons(") in (declaration_list) or (*)", CLU_1, CLUREF_make_num(30), &STR__051_040in_040_050declaration_137list_051_040or_040_050_052_051);
        p_whendecl_own_init = 1;
    }
    enter_proc(213);

  LINE(214);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 21: /* l_paren */ {

  LINE(215);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    default: {

  LINE(216);
        { /* return */
        {
        CLUREF T_2_1;
        CellAlloc(2, nil, T_2_1);
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(219);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 23: /* op */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(221);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_2.num = k.vec->data[1];
        T_2_3.num = ((STR_mul.str->size != T_2_2.str->size)? false :
            !(memcmp(STR_mul.str->data, T_2_2.str->data, STR_mul.str->size)));
        T_2_1.num = T_2_3.num;
        if (T_2_3.num) {
            T_2_4.num = k.vec->data[0];
            T_2_5.num = !T_2_4.num;
            T_2_1.num = T_2_5.num;
        }
        if (T_2_1.num == true) { /* if */

  LINE(222);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(223);
            {
            CLUREF T_3_1;
            CellAlloc(3, nil, T_3_1);
            dec.num = T_3_1.num;
            }
        }
        else { /* else */

  LINE(224);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = proctypeOPnew(CLU_0, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            T_3_1.proc->type_owns = NULL;
            T_3_1.proc->op_owns = NULL;
            T_3_1.proc->proc = p_decl;
            generic_CLU_proc.type_owns = NULL;
            generic_CLU_proc.op_owns = p_clist_of_record_idns_type__ops->op_owns;
            generic_CLU_proc.proc = p_clist;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = p_clist(e, T_3_1, STR_declaration, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            CellAlloc(1, T_3_2.num, T_3_3);
            dec.num = T_3_3.num;
            }
        }} /* end if */
        break;
    }
    default: {

  LINE(228);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = proctypeOPnew(CLU_0, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.proc->type_owns = NULL;
        T_2_1.proc->op_owns = NULL;
        T_2_1.proc->proc = p_decl;
        generic_CLU_proc.type_owns = NULL;
        generic_CLU_proc.op_owns = p_clist_of_record_idns_type__ops->op_owns;
        generic_CLU_proc.proc = p_clist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_clist(e, T_2_1, STR_declaration, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        CellAlloc(1, T_2_2.num, T_2_3);
        dec.num = T_2_3.num;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(231);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 28: /* r_paren */ {

  LINE(232);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    default: {

  LINE(233);
        {
        err = p_envOPassume(e, STR__051_040in_040_050declaration_137list_051_040or_040_050_052_051);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(235);
    { /* return */
    {
    ret_1->num = dec.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_whendecl ****/



/**** BEGIN PROCEDURE p_forcestmt ****/

extern errcode p_idn();
extern errcode p_where();
extern errcode oneofOPmake_11();
static CLUREF STR__072_040in_040FORCE_040statement;
static CLUREF STR_parameter_040in_040FORCE_040statement;
static CLUREF STR_use_040of_040_072_075_040instead_040of_040_075;
static CLUREF STR__075_040in_040FORCE_040statement;
static int p_forcestmt_own_init = 0;

errcode
p_forcestmt(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF val;
    CLUREF type_;
    CLUREF x;
    CLUREF rest;
    if (p_forcestmt_own_init == 0) {
        stringOPcons(": in FORCE statement", CLU_1, CLUREF_make_num(20), &STR__072_040in_040FORCE_040statement);
        stringOPcons("parameter in FORCE statement", CLU_1, CLUREF_make_num(28), &STR_parameter_040in_040FORCE_040statement);
        stringOPcons("use of := instead of =", CLU_1, CLUREF_make_num(22), &STR_use_040of_040_072_075_040instead_040of_040_075);
        stringOPcons("= in FORCE statement", CLU_1, CLUREF_make_num(20), &STR__075_040in_040FORCE_040statement);
        p_forcestmt_own_init = 1;
    }
    enter_proc(240);

  LINE(241);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(242);
    {
    CLUREF T_1_1;
    err = p_idn(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    val.num = T_1_1.num;
    }

  LINE(243);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: /* colon */ {

  LINE(244);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    default: {

  LINE(245);
        {
        err = p_envOPassume(e, STR__072_040in_040FORCE_040statement);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(247);
    {
    CLUREF T_2_1;
    err = p_idn(e, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    type_.num = T_2_1.num;
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_none) {

  LINE(248);
        {
        err = p_envOPerr(e, STR_parameter_040in_040FORCE_040statement, CLU_2);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(250);
        { /* signal */
            signal(ERR_bad);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(252);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 11: /* equal */ {

  LINE(254);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    case 1: /* assn */ {

  LINE(256);
        {
        err = p_envOPerr(e, STR_use_040of_040_072_075_040instead_040of_040_075, CLU_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(257);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    default: {

  LINE(259);
        {
        err = p_envOPassume(e, STR__075_040in_040FORCE_040statement);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(261);
    {
    CLUREF T_1_1;
    err = p_expr1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    x.num = T_1_1.num;
    }

  LINE(262);
    {
    CLUREF T_1_1;
    err = p_where(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    rest.num = T_1_1.num;
    }

  LINE(263);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(4, T_1_1);
    T_1_1.vec->data[2] = val.num;
    T_1_1.vec->data[1] = type_.num;
    T_1_1.vec->data[0] = x.num;
    T_1_1.vec->data[3] = rest.num;
    CellAlloc(11, T_1_1.num, T_1_2);
    ret_1->num = T_1_2.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_forcestmt ****/



/**** BEGIN PROCEDURE p_ownstmt ****/

extern errcode p_owninit();
static CLUREF STR_illegal_040use_040of_040OWN_040statement;
static int p_ownstmt_own_init = 0;

errcode
p_ownstmt(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    if (p_ownstmt_own_init == 0) {
        stringOPcons("illegal use of OWN statement", CLU_1, CLUREF_make_num(28), &STR_illegal_040use_040of_040OWN_040statement);
        p_ownstmt_own_init = 1;
    }
    enter_proc(269);

  LINE(270);
    {
    err = p_envOPerr(e, STR_illegal_040use_040of_040OWN_040statement, CLU_2);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(271);
    {
    CLUREF T_1_1;
    err = p_owninit(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(272);
    { /* signal */
        signal(ERR_bad);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_ownstmt ****/



/**** BEGIN PROCEDURE p_owninit ****/

struct OPS *sequence_of_idn_ops __CLU_COMMON;
struct OPS *record_idns_type__ops __CLU_COMMON;
struct OPS *p_clist_of_record_idns_type__ops __CLU_COMMON;
static CLUREF STR_initialization_040in_040OWN_040statement;
static int p_owninit_own_init = 0;

errcode
p_owninit(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF decls;
    CLUREF x;
    if (p_owninit_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, (struct OPS *)sequence_of_idn_ops);
        add_selector_info("type_", 1, (struct OPS *)typespec_ops);
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_parm_info_type(0, (const struct OPS *)record_idns_type__ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_record_idns_type__ops));
        stringOPcons("declaration", CLU_1, CLUREF_make_num(11), &STR_declaration);
        stringOPcons("use of = instead of :=", CLU_1, CLUREF_make_num(22), &STR_use_040of_040_075_040instead_040of_040_072_075);
        stringOPcons("initialization in OWN statement", CLU_1, CLUREF_make_num(31), &STR_initialization_040in_040OWN_040statement);
        p_owninit_own_init = 1;
    }
    enter_proc(275);

  LINE(276);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.proc->type_owns = NULL;
    T_1_1.proc->op_owns = NULL;
    T_1_1.proc->proc = p_decl;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = p_clist_of_record_idns_type__ops->op_owns;
    generic_CLU_proc.proc = p_clist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_clist(e, T_1_1, STR_declaration, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    decls.num = T_1_2.num;
    }

  LINE(278);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 1: /* assn */ {

  LINE(280);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(281);
        {
        CLUREF T_2_1;
        err = p_expr1(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        x.num = T_2_1.num;
        }
        break;
    }
    case 11: /* equal */ {

  LINE(283);
        {
        err = p_envOPerr(e, STR_use_040of_040_075_040instead_040of_040_072_075, CLU_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(284);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(285);
        {
        CLUREF T_2_1;
        err = p_expr1(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        x.num = T_2_1.num;
        }
        break;
    }
    default: {

  LINE(287);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = decls.vec->size;
        T_2_2.num = (T_2_1.num == 1);
        if (T_2_2.num == true) { /* if */

  LINE(288);
            { /* return */
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = sequenceOPbottom(decls, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            CellAlloc(1, T_3_1.num, T_3_2);
            ret_1->num = T_3_2.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(289);
        {
        err = p_envOPassume(e, STR_initialization_040in_040OWN_040statement);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(290);
        {
        CLUREF T_2_1;
        err = p_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        x.num = T_2_1.num;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(292);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(3, T_1_1);
    T_1_1.vec->data[1] = decls.num;
    err = sequenceOPnew(&T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[0] = T_1_2.num;
    T_1_1.vec->data[2] = x.num;
    CellAlloc(2, T_1_1.num, T_1_3);
    ret_1->num = T_1_3.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_owninit ****/



/**** BEGIN PROCEDURE p_end ****/

extern errcode p_envOPpeek();
extern errcode idnOPget_str();
extern errcode p_envOPget_applystr();
extern errcode p_envOPget_clustr();

errcode
p_end(CLUREF e, CLUREF assume)
{
    errcode err;
    CLUREF k;
    CLUREF s;
    enter_proc(297);

  LINE(298);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 9: /* end_ */ {
        break;
    }
    default: {

  LINE(300);
        {
        err = p_envOPassume(e, assume);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(301);
        { /* return */
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(303);
    { /* qtagcase */
    CLUREF T_1_1;
    err = p_envOPpeek(e, CLU_2, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 16: /* idn */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(305);
        {
        CLUREF T_2_1;
        err = idnOPget_str(k, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        s.num = T_2_1.num;
        }

  LINE(306);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        err = p_envOPget_applystr(e, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_3.num = ((s.str->size != T_2_2.str->size)? false :
            !(memcmp(s.str->data, T_2_2.str->data, s.str->size)));
        T_2_1.num = T_2_3.num;
        if (!T_2_3.num) {
            err = p_envOPget_clustr(e, &T_2_4);
            if (err != ERR_ok)
                goto ex_0;
            T_2_5.num = ((s.str->size != T_2_4.str->size)? false :
                !(memcmp(s.str->data, T_2_4.str->data, s.str->size)));
            T_2_1.num = T_2_5.num;
        }
        if (T_2_1.num == true) { /* if */

  LINE(307);
            { /* qtagcase */
            CLUREF T_3_1;
            err = p_envOPpeek(e, CLU_3, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            switch (T_3_1.cell->tag) {
            case 31: /* semi */ /* FALLTHROUGH */
            case 16: /* idn */ /* FALLTHROUGH */
            case 10: /* eof */ {

  LINE(308);
                {
                err = p_envOPassume(e, assume);
                if (err != ERR_ok)
                    goto ex_0;
                }

  LINE(309);
                { /* return */
                signal (ERR_ok);
                }
                break;
            }
            }
            } /* end qtagcase */
        }
        } /* end if */
        break;
    }
    }
    } /* end qtagcase */

  LINE(315);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE p_end ****/



/**** BEGIN PROCEDURE p_find_a_stmt ****/

extern errcode p_envOPin_body();
static CLUREF STR_looking_040for_040a_040statement;
static CLUREF STR_resuming_040parse_040at_040this_040point;
static int p_find_a_stmt_own_init = 0;

errcode
p_find_a_stmt(CLUREF e, CLUREF *ret_1)
{
    errcode err;
    CLUREF flushed;
    CLUREF found;
    if (p_find_a_stmt_own_init == 0) {
        stringOPcons("looking for a statement", CLU_1, CLUREF_make_num(23), &STR_looking_040for_040a_040statement);
        stringOPcons("resuming parse at this point", CLU_1, CLUREF_make_num(28), &STR_resuming_040parse_040at_040this_040point);
        p_find_a_stmt_own_init = 1;
    }
    enter_proc(321);

  LINE(322);
    {
    flushed.tf = false;
    }

  LINE(323);
    {
    found.tf = false;
    }

  LINE(324);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(325);
        { /* qtagcase */
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_1.cell->tag) {
        case 7: /* else_ */ /* FALLTHROUGH */
        case 8: /* elseif_ */ {

  LINE(327);
            { /* if */
            CLUREF T_3_1;
            err = p_envOPin_body(e, CLU_0, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            if (T_3_1.num == true) { /* if */
                goto end_while_1;
            }
            } /* end if */
            break;
        }
        case 35: /* tag_ */ {

  LINE(329);
            { /* if */
            CLUREF T_3_1;
            err = p_envOPin_body(e, CLU_1, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            if (T_3_1.num == true) { /* if */
                goto end_while_1;
            }
            } /* end if */
            break;
        }
        case 39: /* when_ */ {

  LINE(331);
            { /* if */
            CLUREF T_3_1;
            err = p_envOPin_body(e, CLU_2, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            if (T_3_1.num == true) { /* if */
                goto end_while_1;
            }
            } /* end if */
            break;
        }
        case 24: /* others_ */ {

  LINE(333);
            { /* if */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = p_envOPin_body(e, CLU_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            T_3_1.num = T_3_2.num;
            if (!T_3_2.num) {
                err = p_envOPin_body(e, CLU_2, &T_3_3);
                if (err != ERR_ok)
                    goto ex_0;
                T_3_1.num = T_3_3.num;
            }
            if (T_3_1.num == true) { /* if */

  LINE(334);
                goto end_while_1;
            }
            } /* end if */
            break;
        }
        case 9: /* end_ */ /* FALLTHROUGH */
        case 4: /* defnkey */ /* FALLTHROUGH */
        case 30: /* returns_ */ /* FALLTHROUGH */
        case 41: /* yields_ */ /* FALLTHROUGH */
        case 40: /* where_ */ /* FALLTHROUGH */
        case 18: /* is_ */ /* FALLTHROUGH */
        case 15: /* has_ */ /* FALLTHROUGH */
        case 10: /* eof */ {

  LINE(336);
            goto end_while_1;
            break;
        }
        case 34: /* stmtkey */ /* FALLTHROUGH */
        case 12: /* except_ */ {

  LINE(338);
            {
            found.tf = true;
            }

  LINE(339);
            goto end_while_1;
            break;
        }
        case 31: /* semi */ {

  LINE(341);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(342);
            {
            found.tf = true;
            }

  LINE(343);
            goto end_while_1;
            break;
        }
        }
        } /* end qtagcase */

  LINE(346);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = !flushed.num;
        if (T_2_1.num == true) { /* if */

  LINE(347);
            {
            err = p_envOPerr(e, STR_looking_040for_040a_040statement, CLU_2);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(348);
            {
            flushed.tf = true;
            }
        }
        } /* end if */

  LINE(350);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    end_while_1:
    __CLU_END_LABEL;

  LINE(352);
    { /* if */
    if (flushed.num == true) { /* if */

  LINE(353);
        {
        err = p_envOPerr(e, STR_resuming_040parse_040at_040this_040point, CLU_0);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(354);
    { /* return */
    {
    ret_1->num = found.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE p_find_a_stmt ****/

