
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


extern errcode p_idns_or_decls();
extern errcode p_envOPget_peek1();
extern errcode p_envOPnext_token();
extern errcode p_assn_rhs();
extern errcode p_envOPerr();
extern errcode p_envOPassume();
extern errcode oneofOPmake_6();
extern errcode p_envOPget_unknown_type();
extern errcode intOPequal();
extern errcode sequenceOPsize();
extern errcode sequenceOPbottom();
extern errcode oneofOPmake_7();
extern errcode sequenceOPnew();
extern errcode p_envOPget_bad_expr();
CLUREF STR_use_040of_040_075_040instead_040of_040_072_075;
CLUREF STR__072_040type_040in_040declaration;
CLUREF STR__072_075_040invocation_040after_040declarations;
static int p_decl_or_assn_own_init = 0;

/**** BEGIN PROCEDURE p_decl_or_assn ****/

errcode p_decl_or_assn(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF vars;
    CLUREF idns;
    CLUREF decls;
        if (p_decl_or_assn_own_init == 0) {
        stringOPcons("use of = instead of :=", CLU_1, CLU_22, &STR_use_040of_040_075_040instead_040of_040_072_075);
        stringOPcons(": type in declaration", CLU_1, CLU_21, &STR__072_040type_040in_040declaration);
        stringOPcons(":= invocation after declarations", CLU_1, CLU_32, &STR__072_075_040invocation_040after_040declarations);
        p_decl_or_assn_own_init = 1;
    }
    enter_proc(9);

  LINE(10);
    {
        {CLUREF T_1_1;
        err = p_idns_or_decls(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        vars.num = T_1_1.num;
        }
        }

  LINE(11);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 1: 
         {

  LINE(13);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(14);
            {
            {
            CLUREF T_2_1;
            err = p_assn_rhs(e, vars, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 11: 
         {

  LINE(16);
            {
            err = p_envOPerr(e, STR_use_040of_040_075_040instead_040of_040_072_075, CLU_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(17);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(18);
            {
            {
            CLUREF T_2_1;
            err = p_assn_rhs(e, vars, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {
    }
    }
    }

  LINE(21);
    {
    switch (vars.cell->tag) {
    case 2: 
         {CLUREF T_1_1;
        T_1_1.num = vars.cell->value;
        idns.num = T_1_1.num;

  LINE(23);
            {
            err = p_envOPassume(e, STR__072_040type_040in_040declaration);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(24);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            RecordAlloc(2, T_2_1);
            T_2_1.vec->data[0]  = idns.num;
            err = p_envOPget_unknown_type(e, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            T_2_1.vec->data[1]  = T_2_2.num;
            CellAlloc(6, T_2_1.num, T_2_3);
            ret_1->num = T_2_3.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 1: 
         {CLUREF T_1_2;
        T_1_2.num = vars.cell->value;
        decls.num = T_1_2.num;

  LINE(27);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = decls.vec->size;
            T_2_2.num = (T_2_1.num == 1)? true : false;
            if (T_2_2.num == true) {

  LINE(28);
                {
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                err = sequenceOPbottom(decls, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                CellAlloc(6, T_3_1.num, T_3_2);
                ret_1->num = T_3_2.num;
                }
                {signal (ERR_ok);}}
                }
            else {

  LINE(29);
                {
                err = p_envOPassume(e, STR__072_075_040invocation_040after_040declarations);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(30);
                {
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CLUREF T_3_4;
                RecordAlloc(3, T_3_1);
                T_3_1.vec->data[1]  = decls.num;
                err = sequenceOPnew(&T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_1.vec->data[0]  = T_3_2.num;
                err = p_envOPget_bad_expr(e, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                T_3_1.vec->data[2]  = T_3_3.num;
                CellAlloc(7, T_3_1.num, T_3_4);
                ret_1->num = T_3_4.num;
                }
                {signal (ERR_ok);}}
                }}/* end if */
            break;
            }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_decl_or_assn ****/


extern errcode p_clist();
extern errcode p_expr();
extern errcode oneofOPmake_1();
extern struct REQS *p_clist_of_t_reqs;
extern struct OPS *expr_ops;
extern OWN_req p_clist_ownreqs;
struct OPS *p_clist_of_expr_table;
struct OPS *p_clist_of_expr_ops;
struct OPS *p_clist_of_expr_ops;
OWNPTR p_clist_of_expr_owns;
CLUREF STR_expression;
CLUREF STR_only_0401_040expression_040allowed_040after_040_072_075_040in_040a_040multiple_040declaration;
static int p_assn_rhs_own_init = 0;

/**** BEGIN PROCEDURE p_assn_rhs ****/

errcode p_assn_rhs(e, vars, ret_1)
CLUREF e;
CLUREF vars;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF exprs;
    CLUREF idns;
    CLUREF decls;
    CLUREF x;
        if (p_assn_rhs_own_init == 0) {
        add_parm_info_type(0, expr_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_expr_ops));
        stringOPcons("expression", CLU_1, CLU_10, &STR_expression);
        CLU_string_size.num = 60;
        stringOPcons("only 1 expression allowed after := in a multiple declaration", CLU_1, CLU_string_size, &STR_only_0401_040expression_040allowed_040after_040_072_075_040in_040a_040multiple_040declaration);
        p_assn_rhs_own_init = 1;
    }
    enter_proc(38);

  LINE(39);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_expr;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_clist_of_expr_ops->op_owns;
        generic_CLU_proc.proc = p_clist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_clist(e, T_1_1, STR_expression, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        exprs.num = T_1_2.num;
        }
        }

  LINE(40);
    {
    switch (vars.cell->tag) {
    case 2: 
         {CLUREF T_1_1;
        T_1_1.num = vars.cell->value;
        idns.num = T_1_1.num;

  LINE(42);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            RecordAlloc(3, T_2_1);
            T_2_1.vec->data[1]  = idns.num;
            err = sequenceOPnew(&T_2_2);
            if (err != ERR_ok) goto ex_0;
            T_2_1.vec->data[0]  = T_2_2.num;
            T_2_1.vec->data[2]  = exprs.num;
            CellAlloc(1, T_2_1.num, T_2_3);
            ret_1->num = T_2_3.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 1: 
         {CLUREF T_1_2;
        T_1_2.num = vars.cell->value;
        decls.num = T_1_2.num;

  LINE(47);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = exprs.vec->size;
            T_2_2.num = (T_2_1.num == 1)? true : false;
            if (T_2_2.num == true) {

  LINE(48);
                {
                CLUREF T_3_1;
                err = sequenceOPbottom(exprs, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                x.num = T_3_1.num;
                }
                }
            else {

  LINE(49);
                {
                err = p_envOPerr(e, STR_only_0401_040expression_040allowed_040after_040_072_075_040in_040a_040multiple_040declaration, CLU_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(52);
                {
                CLUREF T_3_1;
                err = p_envOPget_bad_expr(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                x.num = T_3_1.num;
                }
                }}/* end if */

  LINE(54);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            RecordAlloc(3, T_2_1);
            T_2_1.vec->data[1]  = decls.num;
            err = sequenceOPnew(&T_2_2);
            if (err != ERR_ok) goto ex_0;
            T_2_1.vec->data[0]  = T_2_2.num;
            T_2_1.vec->data[2]  = x.num;
            CellAlloc(7, T_2_1.num, T_2_3);
            ret_1->num = T_2_3.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_assn_rhs ****/


extern errcode p_name();
extern errcode p_plist();
extern struct REQS *p_plist_of_t_reqs;
extern OWN_req p_plist_ownreqs;
struct OPS *p_plist_of_expr_table;
struct OPS *p_plist_of_expr_ops;
struct OPS *p_plist_of_expr_ops;
OWNPTR p_plist_of_expr_owns;
CLUREF STR_exceptional_040condition;
static int p_condition_own_init = 0;

/**** BEGIN PROCEDURE p_condition ****/

errcode p_condition(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF n;
    CLUREF args;
        if (p_condition_own_init == 0) {
        add_parm_info_type(0, expr_ops, p_plist_of_t_reqs);
        find_prociter_instance(p_plist, 1, &p_plist_ownreqs, &(p_plist_of_expr_ops));
        stringOPcons("exceptional condition", CLU_1, CLU_21, &STR_exceptional_040condition);
        stringOPcons("expression", CLU_1, CLU_10, &STR_expression);
        p_condition_own_init = 1;
    }
    enter_proc(62);

  LINE(63);
    {
        {CLUREF T_2_1;
        err = p_name(e, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        n.num = T_2_1.num;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_none)) {

  LINE(64);
                {
                err = p_envOPassume(e, STR_exceptional_040condition);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(65);
                {
                {signal (ERR_bad);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(67);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_expr;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_plist_of_expr_ops->op_owns;
        generic_CLU_proc.proc = p_plist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_plist(e, T_1_1, CLU_1, CLU_0, STR_expression, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        args.num = T_1_2.num;
        }
        }

  LINE(69);
    {
    {
    CLUREF T_1_1;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[1]  = n.num;
    T_1_1.vec->data[0]  = args.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_condition ****/


extern errcode p_expr1();
extern errcode p_do();
extern errcode oneofOPmake_19();

/**** BEGIN PROCEDURE p_while ****/

errcode p_while(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF test;
    CLUREF bod;
    enter_proc(75);

  LINE(76);
    {
        {CLUREF T_1_1;
        err = p_expr1(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        test.num = T_1_1.num;
        }
        }

  LINE(77);
    {
        {CLUREF T_1_1;
        err = p_do(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        bod.num = T_1_1.num;
        }
        }

  LINE(78);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[1]  = test.num;
    T_1_1.vec->data[0]  = bod.num;
    CellAlloc(19, T_1_1.num, T_1_2);
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_while ****/


extern errcode oneofOPmake_17();
extern errcode oneofOPmake_13();
extern errcode p_make_invoke();
CLUREF STR_expression_040used_040as_040statement;
static int p_expr_stmt_own_init = 0;

/**** BEGIN PROCEDURE p_expr_stmt ****/

errcode p_expr_stmt(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF x;
    CLUREF right;
        if (p_expr_stmt_own_init == 0) {
        stringOPcons("expression used as statement", CLU_1, CLU_28, &STR_expression_040used_040as_040statement);
        p_expr_stmt_own_init = 1;
    }
    enter_proc(84);

  LINE(85);
    {
        {CLUREF T_1_1;
        err = p_expr1(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        x.num = T_1_1.num;
        }
        }

  LINE(86);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 1: 
         {

  LINE(88);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(89);
            {
                {CLUREF T_2_1;
                err = p_expr1(e, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                right.num = T_2_1.num;
                }
                }

  LINE(90);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            RecordAlloc(2, T_2_1);
            T_2_1.vec->data[0]  = x.num;
            T_2_1.vec->data[1]  = right.num;
            CellAlloc(17, T_2_1.num, T_2_2);
            ret_1->num = T_2_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(93);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = p_make_invoke(e, x, STR_expression_040used_040as_040statement, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        CellAlloc(13, T_2_1.num, T_2_2);
        ret_1->num = T_2_2.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_expr_stmt ****/


extern errcode exprOPget_abs();

/**** BEGIN PROCEDURE p_make_invoke ****/

errcode p_make_invoke(e, x, why, ret_1)
CLUREF e;
CLUREF x;
CLUREF why;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF abs;
    enter_proc(102);

  LINE(103);
    {
    CLUREF T_1_1;
    err = exprOPget_abs(x, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 16: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        abs.num = T_1_2.num;

  LINE(105);
            {
            {
            ret_1->num = abs.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(107);
        {
        err = p_envOPerr(e, why, CLU_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(108);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        RecordAlloc(2, T_2_1);
        err = p_envOPget_bad_expr(e, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[0]  = T_2_2.num;
        err = sequenceOPnew(&T_2_3);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[1]  = T_2_3.num;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_make_invoke ****/


extern errcode p_semi();
extern errcode p_envOPget_line();
extern errcode stmtOPcreate();
extern errcode oneofOPmake_14();
extern errcode p_list();
extern errcode p_whenarm();
extern errcode oneofOPmake_2();
extern errcode oneofOPmake_8();
extern errcode p_mdecl();
extern errcode p_cbody();
extern errcode recordOPset_2();
extern errcode p_end();
extern struct OPS *string_ops;
struct OPS *p_clist_of_string_table;
struct OPS *p_clist_of_string_ops;
struct OPS *p_clist_of_string_ops;
OWNPTR p_clist_of_string_owns;
extern struct REQS *sequence_of_t_reqs;
extern struct OPS *equate_ops;
extern OWN_req sequence_ownreqs;
extern struct OPS *sequence_ops;
struct OPS *sequence_of_equate_table;
struct OPS *sequence_of_equate_ops;
struct OPS *sequence_of_equate_ops;
OWNPTR sequence_of_equate_owns;
extern struct OPS *stmt_ops;
struct OPS *sequence_of_stmt_table;
struct OPS *sequence_of_stmt_ops;
struct OPS *sequence_of_stmt_ops;
OWNPTR sequence_of_stmt_owns;
extern struct OPS *sequence_of_equate_ops;
extern struct OPS *sequence_of_stmt_ops;
struct OPS  *record_equates_stmts_ops;
struct OPS *sequence_of_string_table;
struct OPS *sequence_of_string_ops;
struct OPS *sequence_of_string_ops;
OWNPTR sequence_of_string_owns;
extern struct OPS *idn_ops;
struct OPS *sequence_of_idn_table;
struct OPS *sequence_of_idn_ops;
struct OPS *sequence_of_idn_ops;
OWNPTR sequence_of_idn_owns;
extern struct OPS *sequence_of_idn_ops;
extern struct OPS *typespec_ops;
struct OPS  *record_idns_type__ops;
extern struct OPS *record_idns_type__ops;
struct OPS *sequence_of_record_idns_type__table;
struct OPS *sequence_of_record_idns_type__ops;
struct OPS *sequence_of_record_idns_type__ops;
OWNPTR sequence_of_record_idns_type__owns;
extern struct OPS *sequence_of_record_idns_type__ops;
extern struct OPS *null_ops;
struct OPS  *oneof_decls_none_star_ops;
extern struct OPS *record_equates_stmts_ops;
extern struct OPS *int_ops;
extern struct OPS *sequence_of_string_ops;
extern struct OPS *oneof_decls_none_star_ops;
struct OPS  *record_body_line_names_vars_ops;
extern struct REQS *p_list_of_t_reqs;
extern struct OPS *record_body_line_names_vars_ops;
extern OWN_req p_list_ownreqs;
struct OPS *p_list_of_record_body_line_names_vars_table;
struct OPS *p_list_of_record_body_line_names_vars_ops;
struct OPS *p_list_of_record_body_line_names_vars_ops;
OWNPTR p_list_of_record_body_line_names_vars_owns;
CLUREF STR_name;
CLUREF STR_WHEN_040arm;
CLUREF STR__072_040in_040OTHERS_056_056_056_072_040body;
CLUREF STR_END_040of_040EXCEPT_040statement;
static int p_except_own_init = 0;

/**** BEGIN PROCEDURE p_except ****/

errcode p_except(e, st, ret_1)
CLUREF e;
CLUREF st;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF l;
    CLUREF sigs;
    CLUREF rs;
    CLUREF arms;
    CLUREF xs;
    CLUREF line;
    CLUREF dec;
    CLUREF bod;
        if (p_except_own_init == 0) {
        add_parm_info_type(0, string_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_string_ops));
        add_parm_info_type(0, equate_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_equate_ops));
        add_parm_info_type(0, stmt_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_stmt_ops));
        add_selector_info("equates", 0, sequence_of_equate_ops); 
        add_selector_info("stmts", 1, sequence_of_stmt_ops); 
        find_selector_ops("record", 2, &(record_equates_stmts_ops));
        add_parm_info_type(0, string_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_string_ops));
        add_parm_info_type(0, idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, sequence_of_idn_ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_parm_info_type(0, record_idns_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_idns_type__ops));
        add_selector_info("decls", 0, sequence_of_record_idns_type__ops); 
        add_selector_info("none", 1, null_ops); 
        add_selector_info("star", 2, null_ops); 
        find_selector_ops("oneof", 3, &(oneof_decls_none_star_ops));
        add_selector_info("body", 0, record_equates_stmts_ops); 
        add_selector_info("line", 1, int_ops); 
        add_selector_info("names", 2, sequence_of_string_ops); 
        add_selector_info("vars", 3, oneof_decls_none_star_ops); 
        find_selector_ops("record", 4, &(record_body_line_names_vars_ops));
        add_parm_info_type(0, record_body_line_names_vars_ops, p_list_of_t_reqs);
        find_prociter_instance(p_list, 1, &p_list_ownreqs, &(p_list_of_record_body_line_names_vars_ops));
        stringOPcons("name", CLU_1, CLU_4, &STR_name);
        stringOPcons("WHEN arm", CLU_1, CLU_8, &STR_WHEN_040arm);
        stringOPcons(": in OTHERS...: body", CLU_1, CLU_20, &STR__072_040in_040OTHERS_056_056_056_072_040body);
        stringOPcons("END of EXCEPT statement", CLU_1, CLU_23, &STR_END_040of_040EXCEPT_040statement);
        p_except_own_init = 1;
    }
    enter_proc(117);

  LINE(118);
    for (;;) {
        if (true != true) { break; }

  LINE(119);
        {
        err = p_semi(e);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(120);
        {
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 12: 
             {

  LINE(122);
                {
                CLUREF T_3_1;
                err = p_envOPnext_token(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                }
                break;
                }
        case 29: 
             {

  LINE(124);
                {
                CLUREF T_3_1;
                err = p_envOPnext_token(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(125);
                {
                    {CLUREF T_3_1;
                    err = p_envOPget_line(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    l.num = T_3_1.num;
                    }
                    }

  LINE(126);
                {
                    {CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = proctypeOPnew(CLU_0, &T_3_1.proc);
                    if (err!= ERR_ok) goto ex_0;
                    T_3_1.proc->type_owns = 0;
                    T_3_1.proc->op_owns = 0;
                    T_3_1.proc->proc = p_name;
                    generic_CLU_proc.type_owns = 0;
                    generic_CLU_proc.op_owns = (long)p_clist_of_string_ops->op_owns;
                    generic_CLU_proc.proc = p_clist;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = p_clist(e, T_3_1, STR_name, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    sigs.num = T_3_2.num;
                    }
                    }

  LINE(127);
                {
                    {CLUREF T_3_1;
                    RecordAlloc(2, T_3_1);
                    T_3_1.vec->data[1]  = st.num;
                    T_3_1.vec->data[0]  = sigs.num;
                    rs.num = T_3_1.num;
                    }
                    }

  LINE(129);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CellAlloc(14, rs.num, T_3_1);
                err = stmtOPcreate(T_3_1, l, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                st.num = T_3_2.num;
                }

  LINE(130);
                continue;
                break;
                }
        default: {

  LINE(132);
            {
            {
            ret_1->num = st.num;
            }
            {signal (ERR_ok);}}
        }
        }
        }

  LINE(134);
        {
            {CLUREF T_2_1;
            err = p_envOPget_line(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            l.num = T_2_1.num;
            }
            }

  LINE(135);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            err = proctypeOPnew(CLU_0, &T_2_1.proc);
            if (err!= ERR_ok) goto ex_0;
            T_2_1.proc->type_owns = 0;
            T_2_1.proc->op_owns = 0;
            T_2_1.proc->proc = p_whenarm;
            generic_CLU_proc.type_owns = 0;
            generic_CLU_proc.op_owns = (long)p_list_of_record_body_line_names_vars_ops->op_owns;
            generic_CLU_proc.proc = p_list;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = p_list(e, T_2_1, CLU_1, STR_WHEN_040arm, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            arms.num = T_2_2.num;
            }
            }

  LINE(137);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            RecordAlloc(3, T_2_1);
            T_2_1.vec->data[2]  = st.num;
            T_2_1.vec->data[0]  = arms.num;
            CellAlloc(2, nil, T_2_2);
            T_2_1.vec->data[1]  = T_2_2.num;
            xs.num = T_2_1.num;
            }
            }

  LINE(140);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CellAlloc(8, xs.num, T_2_1);
        err = stmtOPcreate(T_2_1, l, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        st.num = T_2_2.num;
        }

  LINE(141);
        {
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 24: 
             {

  LINE(143);
                {
                CLUREF T_3_1;
                err = p_envOPnext_token(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(144);
                {
                    {CLUREF T_3_1;
                    err = p_envOPget_line(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    line.num = T_3_1.num;
                    }
                    }

  LINE(145);
                {
                    {CLUREF T_3_1;
                    err = p_mdecl(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    dec.num = T_3_1.num;
                    }
                    }

  LINE(146);
                {
                    {CLUREF T_3_1;
                    err = p_cbody(e, CLU_3, STR__072_040in_040OTHERS_056_056_056_072_040body, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    bod.num = T_3_1.num;
                    }
                    }

  LINE(147);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                RecordAlloc(3, T_3_1);
                T_3_1.vec->data[1]  = dec.num;
                T_3_1.vec->data[0]  = bod.num;
                T_3_1.vec->data[2]  = line.num;
                CellAlloc(1, T_3_1.num, T_3_2);
                xs.vec->data[1]  = T_3_2.num;
                }
                break;
                }
        default: {
        }
        }
        }

  LINE(152);
        {
        err = p_end(e, STR_END_040of_040EXCEPT_040statement);
        if (err != ERR_ok) goto ex_0;
        }
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_except ****/


extern errcode p_whendecl();
struct OPS *p_clist_of_string_table;
struct OPS *p_clist_of_string_ops;
struct OPS *p_clist_of_string_ops;
OWNPTR p_clist_of_string_owns;
CLUREF STR__072_040in_040WHEN_056_056_056_072_040body;
static int p_whenarm_own_init = 0;

/**** BEGIN PROCEDURE p_whenarm ****/

errcode p_whenarm(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF line;
    CLUREF names;
    CLUREF vars;
    CLUREF bod;
        if (p_whenarm_own_init == 0) {
        add_parm_info_type(0, string_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_string_ops));
        stringOPcons("name", CLU_1, CLU_4, &STR_name);
        stringOPcons(": in WHEN...: body", CLU_1, CLU_18, &STR__072_040in_040WHEN_056_056_056_072_040body);
        p_whenarm_own_init = 1;
    }
    enter_proc(156);

  LINE(157);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 39: 
         {

  LINE(158);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(159);
        {
        {signal (ERR_none);}}
    }
    }
    }

  LINE(161);
    {
        {CLUREF T_1_1;
        err = p_envOPget_line(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        line.num = T_1_1.num;
        }
        }

  LINE(162);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_name;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_clist_of_string_ops->op_owns;
        generic_CLU_proc.proc = p_clist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_clist(e, T_1_1, STR_name, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        names.num = T_1_2.num;
        }
        }

  LINE(163);
    {
        {CLUREF T_1_1;
        err = p_whendecl(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        vars.num = T_1_1.num;
        }
        }

  LINE(164);
    {
        {CLUREF T_1_1;
        err = p_cbody(e, CLU_2, STR__072_040in_040WHEN_056_056_056_072_040body, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        bod.num = T_1_1.num;
        }
        }

  LINE(165);
    {
    {
    CLUREF T_1_1;
    RecordAlloc(4, T_1_1);
    T_1_1.vec->data[2]  = names.num;
    T_1_1.vec->data[3]  = vars.num;
    T_1_1.vec->data[0]  = bod.num;
    T_1_1.vec->data[1]  = line.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_whenarm ****/


extern errcode p_decl();
extern errcode intOPgt();
extern errcode recordOPget_1();
extern errcode recordOPset_1();
CLUREF STR_more_040than_040one_040idn_040declared;
CLUREF STR__051_040in_040_050idn_072_040type_051;
static int p_mdecl_own_init = 0;

/**** BEGIN PROCEDURE p_mdecl ****/

errcode p_mdecl(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF dec;
        if (p_mdecl_own_init == 0) {
        stringOPcons("more than one idn declared", CLU_1, CLU_26, &STR_more_040than_040one_040idn_040declared);
        stringOPcons(") in (idn: type)", CLU_1, CLU_16, &STR__051_040in_040_050idn_072_040type_051);
        p_mdecl_own_init = 1;
    }
    enter_proc(173);

  LINE(174);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 21: 
         {

  LINE(175);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(176);
        {
        {
        CLUREF T_2_1;
        CellAlloc(2, nil, T_2_1);
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(178);
    {
        {CLUREF T_1_1;
        err = p_decl(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        dec.num = T_1_1.num;
        }
        }

  LINE(179);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = dec.vec->data[0];
    T_1_2.num = T_1_1.vec->size;
    T_1_3.num = (T_1_2.num > 1)? true : false;
    if (T_1_3.num == true) {

  LINE(180);
        {
        err = p_envOPerr(e, STR_more_040than_040one_040idn_040declared, CLU_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(181);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        sequenceOPnew2(CLU_1, &T_2_1);
        T_2_2.num = dec.vec->data[0];
        err = sequenceOPbottom(T_2_2, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[0] = T_2_3.num;
        dec.vec->data[0]  = T_2_1.num;
        }
        }
        }/* end if */

  LINE(183);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 28: 
         {

  LINE(184);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(185);
        {
        err = p_envOPassume(e, STR__051_040in_040_050idn_072_040type_051);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(187);
    {
    {
    CLUREF T_1_1;
    CellAlloc(1, dec.num, T_1_1);
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_mdecl ****/


extern errcode p_body();

/**** BEGIN PROCEDURE p_cbody ****/

errcode p_cbody(e, kind, assume, ret_1)
CLUREF e;
CLUREF kind;
CLUREF assume;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    enter_proc(192);

  LINE(193);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: 
         {

  LINE(194);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(195);
        {
        err = p_envOPassume(e, assume);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(197);
    {
    {
    CLUREF T_1_1;
    err = p_body(e, kind, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_cbody ****/


extern errcode p_envOPbegin_body();
extern errcode p_slist();
extern errcode p_equate();
extern errcode p_stmt();
extern errcode p_envOPend_body();
extern struct REQS *p_slist_of_t_reqs;
extern OWN_req p_slist_ownreqs;
struct OPS *p_slist_of_equate_table;
struct OPS *p_slist_of_equate_ops;
struct OPS *p_slist_of_equate_ops;
OWNPTR p_slist_of_equate_owns;
struct OPS *p_slist_of_stmt_table;
struct OPS *p_slist_of_stmt_ops;
struct OPS *p_slist_of_stmt_ops;
OWNPTR p_slist_of_stmt_owns;
static int p_body_own_init = 0;

/**** BEGIN PROCEDURE p_body ****/

errcode p_body(e, kind, ret_1)
CLUREF e;
CLUREF kind;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF equates;
    CLUREF stmts;
        if (p_body_own_init == 0) {
        add_parm_info_type(0, equate_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_equate_ops));
        add_parm_info_type(0, stmt_ops, p_slist_of_t_reqs);
        find_prociter_instance(p_slist, 1, &p_slist_ownreqs, &(p_slist_of_stmt_ops));
        p_body_own_init = 1;
    }
    enter_proc(202);

  LINE(203);
    {
    err = p_envOPbegin_body(e, kind);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(204);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_equate;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_slist_of_equate_ops->op_owns;
        generic_CLU_proc.proc = p_slist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_slist(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        equates.num = T_1_2.num;
        }
        }

  LINE(205);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_stmt;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_slist_of_stmt_ops->op_owns;
        generic_CLU_proc.proc = p_slist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_slist(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        stmts.num = T_1_2.num;
        }
        }

  LINE(206);
    {
    err = p_envOPend_body(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(207);
    {
    {
    CLUREF T_1_1;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[0]  = equates.num;
    T_1_1.vec->data[1]  = stmts.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_body ****/


extern errcode stringOPequal();
extern errcode structOPget_2();
extern errcode boolOPnot();
extern errcode structOPget_1();
extern errcode oneofOPmake_3();
struct OPS *sequence_of_idn_table;
struct OPS *sequence_of_idn_ops;
struct OPS *sequence_of_idn_ops;
OWNPTR sequence_of_idn_owns;
struct OPS  *record_idns_type__ops;
struct OPS *p_clist_of_record_idns_type__table;
struct OPS *p_clist_of_record_idns_type__ops;
struct OPS *p_clist_of_record_idns_type__ops;
OWNPTR p_clist_of_record_idns_type__owns;
CLUREF STR_mul;
CLUREF STR_declaration;
CLUREF STR__051_040in_040_050declaration_137list_051_040or_040_050_052_051;
static int p_whendecl_own_init = 0;

/**** BEGIN PROCEDURE p_whendecl ****/

errcode p_whendecl(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF dec;
    CLUREF k;
        if (p_whendecl_own_init == 0) {
        add_parm_info_type(0, idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, sequence_of_idn_ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_parm_info_type(0, record_idns_type__ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_record_idns_type__ops));
        stringOPcons("mul", CLU_1, CLU_3, &STR_mul);
        stringOPcons("declaration", CLU_1, CLU_11, &STR_declaration);
        stringOPcons(") in (declaration_list) or (*)", CLU_1, CLU_30, &STR__051_040in_040_050declaration_137list_051_040or_040_050_052_051);
        p_whendecl_own_init = 1;
    }
    enter_proc(213);

  LINE(214);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 21: 
         {

  LINE(215);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(216);
        {
        {
        CLUREF T_2_1;
        CellAlloc(2, nil, T_2_1);
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(219);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 23: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(221);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            T_2_2.num = k.vec->data[1];
            T_2_3.num = ((STR_mul.str->size != T_2_2.str->size)? false :
                !(bcmp(STR_mul.str->data, T_2_2.str->data, STR_mul.str->size)));
            T_2_1.num = T_2_3.num;
            if (T_2_3.num) {
                T_2_4.num = k.vec->data[0];
                T_2_5.num = T_2_4.num ^ 1;
                T_2_1.num = T_2_5.num;
            }
            if (T_2_1.num == true) {

  LINE(222);
                {
                CLUREF T_3_1;
                err = p_envOPnext_token(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(223);
                {
                CLUREF T_3_1;
                CellAlloc(3, nil, T_3_1);
                dec.num = T_3_1.num;
                }
                }
            else {

  LINE(224);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                err = proctypeOPnew(CLU_0, &T_3_1.proc);
                if (err!= ERR_ok) goto ex_0;
                T_3_1.proc->type_owns = 0;
                T_3_1.proc->op_owns = 0;
                T_3_1.proc->proc = p_decl;
                generic_CLU_proc.type_owns = 0;
                generic_CLU_proc.op_owns = (long)p_clist_of_record_idns_type__ops->op_owns;
                generic_CLU_proc.proc = p_clist;
                CUR_PROC_VAR.proc = &generic_CLU_proc;
                err = p_clist(e, T_3_1, STR_declaration, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                CellAlloc(1, T_3_2.num, T_3_3);
                dec.num = T_3_3.num;
                }
                }}/* end if */
            break;
            }
    default: {

  LINE(228);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = proctypeOPnew(CLU_0, &T_2_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_2_1.proc->type_owns = 0;
        T_2_1.proc->op_owns = 0;
        T_2_1.proc->proc = p_decl;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_clist_of_record_idns_type__ops->op_owns;
        generic_CLU_proc.proc = p_clist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_clist(e, T_2_1, STR_declaration, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        CellAlloc(1, T_2_2.num, T_2_3);
        dec.num = T_2_3.num;
        }
    }
    }
    }

  LINE(231);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 28: 
         {

  LINE(232);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(233);
        {
        err = p_envOPassume(e, STR__051_040in_040_050declaration_137list_051_040or_040_050_052_051);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(235);
    {
    {
    ret_1->num = dec.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_whendecl ****/


extern errcode p_idn();
extern errcode p_where();
extern errcode oneofOPmake_11();
CLUREF STR__072_040in_040FORCE_040statement;
CLUREF STR_parameter_040in_040FORCE_040statement;
CLUREF STR_use_040of_040_072_075_040instead_040of_040_075;
CLUREF STR__075_040in_040FORCE_040statement;
static int p_forcestmt_own_init = 0;

/**** BEGIN PROCEDURE p_forcestmt ****/

errcode p_forcestmt(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF val;
    CLUREF type_;
    CLUREF x;
    CLUREF rest;
        if (p_forcestmt_own_init == 0) {
        stringOPcons(": in FORCE statement", CLU_1, CLU_20, &STR__072_040in_040FORCE_040statement);
        stringOPcons("parameter in FORCE statement", CLU_1, CLU_28, &STR_parameter_040in_040FORCE_040statement);
        stringOPcons("use of := instead of =", CLU_1, CLU_22, &STR_use_040of_040_072_075_040instead_040of_040_075);
        stringOPcons("= in FORCE statement", CLU_1, CLU_20, &STR__075_040in_040FORCE_040statement);
        p_forcestmt_own_init = 1;
    }
    enter_proc(240);

  LINE(241);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(242);
    {
        {CLUREF T_1_1;
        err = p_idn(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        val.num = T_1_1.num;
        }
        }

  LINE(243);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: 
         {

  LINE(244);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(245);
        {
        err = p_envOPassume(e, STR__072_040in_040FORCE_040statement);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(247);
    {
        {CLUREF T_2_1;
        err = p_idn(e, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        type_.num = T_2_1.num;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_none)) {

  LINE(248);
                {
                err = p_envOPerr(e, STR_parameter_040in_040FORCE_040statement, CLU_2);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(250);
                {
                {signal (ERR_bad);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(252);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 11: 
         {

  LINE(254);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 1: 
         {

  LINE(256);
            {
            err = p_envOPerr(e, STR_use_040of_040_072_075_040instead_040of_040_075, CLU_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(257);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(259);
        {
        err = p_envOPassume(e, STR__075_040in_040FORCE_040statement);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(261);
    {
        {CLUREF T_1_1;
        err = p_expr1(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        x.num = T_1_1.num;
        }
        }

  LINE(262);
    {
        {CLUREF T_1_1;
        err = p_where(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        rest.num = T_1_1.num;
        }
        }

  LINE(263);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(4, T_1_1);
    T_1_1.vec->data[2]  = val.num;
    T_1_1.vec->data[1]  = type_.num;
    T_1_1.vec->data[0]  = x.num;
    T_1_1.vec->data[3]  = rest.num;
    CellAlloc(11, T_1_1.num, T_1_2);
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_forcestmt ****/


extern errcode p_owninit();
CLUREF STR_illegal_040use_040of_040OWN_040statement;
static int p_ownstmt_own_init = 0;

/**** BEGIN PROCEDURE p_ownstmt ****/

errcode p_ownstmt(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (p_ownstmt_own_init == 0) {
        stringOPcons("illegal use of OWN statement", CLU_1, CLU_28, &STR_illegal_040use_040of_040OWN_040statement);
        p_ownstmt_own_init = 1;
    }
    enter_proc(269);

  LINE(270);
    {
    err = p_envOPerr(e, STR_illegal_040use_040of_040OWN_040statement, CLU_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(271);
    {
    CLUREF T_1_1;
    err = p_owninit(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(272);
    {
    {signal (ERR_bad);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_ownstmt ****/


struct OPS *sequence_of_idn_table;
struct OPS *sequence_of_idn_ops;
struct OPS *sequence_of_idn_ops;
OWNPTR sequence_of_idn_owns;
struct OPS  *record_idns_type__ops;
struct OPS *p_clist_of_record_idns_type__table;
struct OPS *p_clist_of_record_idns_type__ops;
struct OPS *p_clist_of_record_idns_type__ops;
OWNPTR p_clist_of_record_idns_type__owns;
CLUREF STR_initialization_040in_040OWN_040statement;
static int p_owninit_own_init = 0;

/**** BEGIN PROCEDURE p_owninit ****/

errcode p_owninit(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF decls;
    CLUREF x;
        if (p_owninit_own_init == 0) {
        add_parm_info_type(0, idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, sequence_of_idn_ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_parm_info_type(0, record_idns_type__ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_record_idns_type__ops));
        stringOPcons("declaration", CLU_1, CLU_11, &STR_declaration);
        stringOPcons("use of = instead of :=", CLU_1, CLU_22, &STR_use_040of_040_075_040instead_040of_040_072_075);
        stringOPcons("initialization in OWN statement", CLU_1, CLU_31, &STR_initialization_040in_040OWN_040statement);
        p_owninit_own_init = 1;
    }
    enter_proc(275);

  LINE(276);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_decl;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_clist_of_record_idns_type__ops->op_owns;
        generic_CLU_proc.proc = p_clist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_clist(e, T_1_1, STR_declaration, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        decls.num = T_1_2.num;
        }
        }

  LINE(278);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 1: 
         {

  LINE(280);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(281);
            {
            CLUREF T_2_1;
            err = p_expr1(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            x.num = T_2_1.num;
            }
            break;
            }
    case 11: 
         {

  LINE(283);
            {
            err = p_envOPerr(e, STR_use_040of_040_075_040instead_040of_040_072_075, CLU_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(284);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(285);
            {
            CLUREF T_2_1;
            err = p_expr1(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            x.num = T_2_1.num;
            }
            break;
            }
    default: {

  LINE(287);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = decls.vec->size;
        T_2_2.num = (T_2_1.num == 1)? true : false;
        if (T_2_2.num == true) {

  LINE(288);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = sequenceOPbottom(decls, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            CellAlloc(1, T_3_1.num, T_3_2);
            ret_1->num = T_3_2.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(289);
        {
        err = p_envOPassume(e, STR_initialization_040in_040OWN_040statement);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(290);
        {
        CLUREF T_2_1;
        err = p_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        x.num = T_2_1.num;
        }
    }
    }
    }

  LINE(292);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    RecordAlloc(3, T_1_1);
    T_1_1.vec->data[1]  = decls.num;
    err = sequenceOPnew(&T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[0]  = T_1_2.num;
    T_1_1.vec->data[2]  = x.num;
    CellAlloc(2, T_1_1.num, T_1_3);
    ret_1->num = T_1_3.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_owninit ****/


extern errcode p_envOPpeek();
extern errcode idnOPget_str();
extern errcode p_envOPget_applystr();
extern errcode p_envOPget_clustr();

/**** BEGIN PROCEDURE p_end ****/

errcode p_end(e, assume)
CLUREF e;
CLUREF assume;
    {
    errcode err;
    errcode ecode2;
    CLUREF k;
    CLUREF s;
    enter_proc(297);

  LINE(298);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 9: 
         {
            break;
            }
    default: {

  LINE(300);
        {
        err = p_envOPassume(e, assume);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(301);
        {
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(303);
    {
    CLUREF T_1_1;
    err = p_envOPpeek(e, CLU_2, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 16: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(305);
            {
                {CLUREF T_2_1;
                err = idnOPget_str(k, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                s.num = T_2_1.num;
                }
                }

  LINE(306);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            err = p_envOPget_applystr(e, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            T_2_3.num = ((s.str->size != T_2_2.str->size)? false :
                !(bcmp(s.str->data, T_2_2.str->data, s.str->size)));
            T_2_1.num = T_2_3.num;
            if (!T_2_3.num) {
                err = p_envOPget_clustr(e, &T_2_4);
                if (err != ERR_ok) goto ex_0;
                T_2_5.num = ((s.str->size != T_2_4.str->size)? false :
                    !(bcmp(s.str->data, T_2_4.str->data, s.str->size)));
                T_2_1.num = T_2_5.num;
            }
            if (T_2_1.num == true) {

  LINE(307);
                {
                CLUREF T_3_1;
                err = p_envOPpeek(e, CLU_3, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                switch (T_3_1.cell->tag) {
                case 31: 
                case 16: 
                case 10: 
                     {

  LINE(308);
                        {
                        err = p_envOPassume(e, assume);
                        if (err != ERR_ok) goto ex_0;
                        }

  LINE(309);
                        {
                        {signal (ERR_ok);}}
                        break;
                        }
                default: {
                }
                }
                }
                }
                }/* end if */
            break;
            }
    default: {
    }
    }
    }

  LINE(315);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE p_end ****/


extern errcode p_envOPin_body();
CLUREF STR_looking_040for_040a_040statement;
CLUREF STR_resuming_040parse_040at_040this_040point;
static int p_find_a_stmt_own_init = 0;

/**** BEGIN PROCEDURE p_find_a_stmt ****/

errcode p_find_a_stmt(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF flushed;
    CLUREF found;
        if (p_find_a_stmt_own_init == 0) {
        stringOPcons("looking for a statement", CLU_1, CLU_23, &STR_looking_040for_040a_040statement);
        stringOPcons("resuming parse at this point", CLU_1, CLU_28, &STR_resuming_040parse_040at_040this_040point);
        p_find_a_stmt_own_init = 1;
    }
    enter_proc(321);

  LINE(322);
    {
        {flushed.tf = false;
        }
        }

  LINE(323);
    {
        {found.tf = false;
        }
        }

  LINE(324);
    for (;;) {
        if (true != true) { break; }

  LINE(325);
        {
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 7: 
        case 8: 
             {

  LINE(327);
                {
                CLUREF T_3_1;
                err = p_envOPin_body(e, CLU_0, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                if (T_3_1.num == true) {
                    goto end_while_1;
                    }
                    }/* end if */
                break;
                }
        case 35: 
             {

  LINE(329);
                {
                CLUREF T_3_1;
                err = p_envOPin_body(e, CLU_1, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                if (T_3_1.num == true) {
                    goto end_while_1;
                    }
                    }/* end if */
                break;
                }
        case 39: 
             {

  LINE(331);
                {
                CLUREF T_3_1;
                err = p_envOPin_body(e, CLU_2, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                if (T_3_1.num == true) {
                    goto end_while_1;
                    }
                    }/* end if */
                break;
                }
        case 24: 
             {

  LINE(333);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                err = p_envOPin_body(e, CLU_1, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_1.num = T_3_2.num;
                if (!T_3_2.num) {
                    err = p_envOPin_body(e, CLU_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    T_3_1.num = T_3_3.num;
                }
                if (T_3_1.num == true) {

  LINE(334);
                    goto end_while_1;
                    }
                    }/* end if */
                break;
                }
        case 9: 
        case 4: 
        case 30: 
        case 41: 
        case 40: 
        case 18: 
        case 15: 
        case 10: 
             {

  LINE(336);
                goto end_while_1;
                break;
                }
        case 34: 
        case 12: 
             {

  LINE(338);
                {
                found.tf = true;
                }

  LINE(339);
                goto end_while_1;
                break;
                }
        case 31: 
             {

  LINE(341);
                {
                CLUREF T_3_1;
                err = p_envOPnext_token(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(342);
                {
                found.tf = true;
                }

  LINE(343);
                goto end_while_1;
                break;
                }
        default: {
        }
        }
        }

  LINE(346);
        {
        CLUREF T_2_1;
        T_2_1.num = flushed.num ^ 1;
        if (T_2_1.num == true) {

  LINE(347);
            {
            err = p_envOPerr(e, STR_looking_040for_040a_040statement, CLU_2);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(348);
            {
            flushed.tf = true;
            }
            }
            }/* end if */

  LINE(350);
        {
        CLUREF T_2_1;
        err = p_envOPnext_token(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        end_while_1:;

  LINE(352);
    {
    if (flushed.num == true) {

  LINE(353);
        {
        err = p_envOPerr(e, STR_resuming_040parse_040at_040this_040point, CLU_0);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(354);
    {
    {
    ret_1->num = found.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_find_a_stmt ****/

