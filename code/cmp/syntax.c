
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER typespec ****/

extern errcode oneofOPis_9();
extern errcode recordOPget_2();
extern errcode recordOPset_2();
extern errcode recordOPget_1();
extern errcode recordOPset_1();
extern errcode intOPequal();
extern errcode oneofOPis_2();
extern errcode boolOPnot();
extern errcode duOPequal();
extern errcode sequenceOPequal();
extern errcode recordOPget_4();
extern errcode sequenceOPelements();
extern errcode recordOPget_3();
extern errcode recordOPsimilar();
extern errcode oneofOPis_8();
extern errcode typespecOPmismatch();
extern errcode recordOP_gcd();
extern struct REQS *sequence_of_t_reqs;
extern struct OPS *typespec_ops;
extern OWN_req sequence_ownreqs;
extern struct OPS *sequence_ops;
struct OPS *sequence_of_typespec_table;
struct OPS *sequence_of_typespec_ops;
struct OPS *sequence_of_typespec_ops;
OWNPTR sequence_of_typespec_owns;
extern struct OPS *string_ops;
extern struct OPS *sequence_of_typespec_ops;
struct OPS  *record_name_types_ops;
extern struct OPS *record_name_types_ops;
struct OPS *sequence_of_record_name_types_table;
struct OPS *sequence_of_record_name_types_ops;
struct OPS *sequence_of_record_name_types_ops;
OWNPTR sequence_of_record_name_types_owns;
extern struct OPS *du_ops;
extern struct OPS *sequence_of_record_name_types_ops;
struct OPS  *record_args_gen_sigs_vals_ops;
extern struct OPS *expr_ops;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
extern struct OPS *sequence_of_expr_ops;
struct OPS  *record_gen_parms_ops;
struct OPS  *record_name_parms_type__ops;
extern struct OPS *record_gen_parms_ops;
extern struct OPS *record_name_parms_type__ops;
struct OPS  *oneof_du_op_return__ops;
struct OPS  *record_sel_type__ops;
extern struct OPS *record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__table;
struct OPS *sequence_of_record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__ops;
OWNPTR sequence_of_record_sel_type__owns;
extern struct OPS *sequence_of_record_sel_type__ops;
struct OPS  *record_gen_parms_1_ops;
extern struct OPS *idn_ops;
struct OPS  *record_idn_parms_ops;
struct OPS  *record_idn_parms_1_ops;
extern struct OPS *null_ops;
extern struct OPS *record_args_gen_sigs_vals_ops;
extern struct OPS *oneof_du_op_return__ops;
extern struct OPS *record_gen_parms_1_ops;
extern struct OPS *record_idn_parms_ops;
extern struct OPS *record_idn_parms_1_ops;
struct OPS  *oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops;
extern struct OPS *int_ops;
extern struct OPS *oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops;
struct OPS  *record_id_type__ops;
static int typespec_own_init = 0;
OWN_req typespec_ownreqs = {0,0};
errcode typespec_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (typespec_own_init == 0) {
        add_parm_info_type(0, typespec_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_typespec_ops));
        add_selector_info("name", 0, string_ops); 
        add_selector_info("types", 1, sequence_of_typespec_ops); 
        find_selector_ops("record", 2, &(record_name_types_ops));
        add_parm_info_type(0, record_name_types_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_name_types_ops));
        add_selector_info("args", 0, sequence_of_typespec_ops); 
        add_selector_info("gen", 1, du_ops); 
        add_selector_info("sigs", 2, sequence_of_record_name_types_ops); 
        add_selector_info("vals", 3, sequence_of_typespec_ops); 
        find_selector_ops("record", 4, &(record_args_gen_sigs_vals_ops));
        add_parm_info_type(0, expr_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_expr_ops));
        add_selector_info("gen", 0, du_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        find_selector_ops("record", 2, &(record_gen_parms_ops));
        add_selector_info("name", 0, string_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        add_selector_info("type_", 2, typespec_ops); 
        find_selector_ops("record", 3, &(record_name_parms_type__ops));
        add_selector_info("du", 0, record_gen_parms_ops); 
        add_selector_info("op", 1, record_name_parms_type__ops); 
        add_selector_info("return_", 2, typespec_ops); 
        find_selector_ops("oneof", 3, &(oneof_du_op_return__ops));
        add_selector_info("sel", 0, string_ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_sel_type__ops));
        add_parm_info_type(0, record_sel_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_sel_type__ops));
        add_selector_info("gen", 0, du_ops); 
        add_selector_info("parms", 1, sequence_of_record_sel_type__ops); 
        find_selector_ops("record", 2, &(record_gen_parms_1_ops));
        add_selector_info("idn", 0, idn_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        find_selector_ops("record", 2, &(record_idn_parms_ops));
        add_selector_info("idn", 0, idn_ops); 
        add_selector_info("parms", 1, sequence_of_record_sel_type__ops); 
        find_selector_ops("record", 2, &(record_idn_parms_1_ops));
        add_selector_info("any_", 0, null_ops); 
        add_selector_info("apply", 1, record_args_gen_sigs_vals_ops); 
        add_selector_info("cluster_", 2, record_gen_parms_ops); 
        add_selector_info("cvt_", 3, null_ops); 
        add_selector_info("idn", 4, idn_ops); 
        add_selector_info("other", 5, oneof_du_op_return__ops); 
        add_selector_info("select", 6, record_gen_parms_1_ops); 
        add_selector_info("type_", 7, record_gen_parms_ops); 
        add_selector_info("unknown", 8, null_ops); 
        add_selector_info("xclu", 9, record_idn_parms_ops); 
        add_selector_info("xsel", 10, record_idn_parms_1_ops); 
        find_selector_ops("oneof", 11, &(oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops));
        add_selector_info("id", 0, int_ops); 
        add_selector_info("type_", 1, oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops); 
        find_selector_ops("record", 2, &(record_id_type__ops));
        typespec_own_init = 1;
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE create ****/

errcode typespecOPcreate(ta, id, ret_1)
CLUREF ta;
CLUREF id;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (typespec_own_init == 0) {
            err = typespec_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(32);

  LINE(33);
    {
    {
    CLUREF T_1_1;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[1]  = ta.num;
    T_1_1.vec->data[0]  = id.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE create ****/


/**** BEGIN PROCEDURE is_unknown ****/

errcode typespecOPis_unknown(t, ret_1)
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (typespec_own_init == 0) {
            err = typespec_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(37);

  LINE(38);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = t.vec->data[1];
    if (T_1_1.cell->tag == 9) T_1_2.num = true; else T_1_2.num = false;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE is_unknown ****/


/**** BEGIN PROCEDURE get_abs ****/

errcode typespecOPget_abs(t, ret_1)
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (typespec_own_init == 0) {
            err = typespec_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(41);

  LINE(42);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = t.vec->data[1];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_abs ****/


/**** BEGIN PROCEDURE set_abs ****/

errcode typespecOPset_abs(t, abs)
CLUREF t;
CLUREF abs;
    {
    errcode err;
    errcode ecode2;
        if (typespec_own_init == 0) {
            err = typespec_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(45);

  LINE(46);
    {
    t.vec->data[1]  = abs.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_abs ****/


/**** BEGIN PROCEDURE get_id ****/

errcode typespecOPget_id(t, ret_1)
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (typespec_own_init == 0) {
            err = typespec_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(49);

  LINE(50);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = t.vec->data[0];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_id ****/


/**** BEGIN PROCEDURE set_id ****/

errcode typespecOPset_id(t, id)
CLUREF t;
CLUREF id;
    {
    errcode err;
    errcode ecode2;
        if (typespec_own_init == 0) {
            err = typespec_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(53);

  LINE(54);
    {
    t.vec->data[0]  = id.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_id ****/


/**** BEGIN PROCEDURE copy ****/

errcode typespecOPcopy(t, ret_1)
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (typespec_own_init == 0) {
            err = typespec_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(57);

  LINE(58);
    {
    {
    ret_1->num = t.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE copy ****/


/**** BEGIN PROCEDURE equal ****/

errcode typespecOPequal(t1, t2, ret_1)
CLUREF t1;
CLUREF t2;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (typespec_own_init == 0) {
            err = typespec_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(61);

  LINE(62);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = t1.vec->data[0];
    T_1_2.num = t2.vec->data[0];
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    ret_1->num = T_1_3.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE equal ****/


/**** BEGIN PROCEDURE similar ****/

errcode typespecOPsimilar(t1, t2, ret_1)
CLUREF t1;
CLUREF t2;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (typespec_own_init == 0) {
            err = typespec_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(65);

  LINE(66);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = t1.vec->data[0];
    T_1_2.num = t2.vec->data[0];
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    ret_1->num = T_1_3.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE similar ****/

struct OPS *sequence_of_typespec_table;
struct OPS *sequence_of_typespec_ops;
struct OPS *sequence_of_typespec_ops;
OWNPTR sequence_of_typespec_owns;
struct OPS  *record_name_types_ops;
static int typespecOPmismatch_own_init = 0;

/**** BEGIN PROCEDURE mismatch ****/

errcode typespecOPmismatch(t1, t2, ret_1)
CLUREF t1;
CLUREF t2;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ta2;
    CLUREF ot;
    CLUREF xa1;
    CLUREF xa2;
    CLUREF x;
    CLUREF y;
        if (typespecOPmismatch_own_init == 0) {
        if (typespec_own_init == 0) {
            err = typespec_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        typespecOPmismatch_own_init = 1;
    }
    enter_proc(75);

  LINE(76);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = t1.vec->data[0];
    T_1_2.num = t2.vec->data[0];
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(77);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(78);
    {
        {CLUREF T_1_1;
        T_1_1.num = t2.vec->data[1];
        ta2.num = T_1_1.num;
        }
        }

  LINE(79);
    {
    CLUREF T_1_1;
    T_1_1.num = t1.vec->data[1];
    switch (T_1_1.cell->tag) {
    case 9: 
         {

  LINE(81);
            {
            {
            ret_1->tf = false;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 1: 
         {

  LINE(83);
            {
            CLUREF T_2_1;
            T_2_1.num = t2.vec->data[1];
            switch (T_2_1.cell->tag) {
            case 9: 
                 {

  LINE(85);
                    {
                    {
                    ret_1->tf = false;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            default: {

  LINE(87);
                {
                {signal (ERR_anyize);}}
            }
            }
            }
            break;
            }
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        ot.num = T_1_2.num;

  LINE(90);
            {
            switch (ot.cell->tag) {
            case 3: 
                 {

  LINE(92);
                    {
                    {
                    ret_1->tf = false;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            default: {

  LINE(94);
                {
                switch (ta2.cell->tag) {
                case 9: 
                case 2: 
                case 6: 
                     {

  LINE(96);
                        {
                        {
                        ret_1->tf = false;
                        }
                        {signal (ERR_ok);}}
                        break;
                        }
                case 8: 
                     {

  LINE(98);
                        {
                        {
                        CLUREF T_4_1;
                        if (ot.cell->tag == 2) T_4_1.num = true; else T_4_1.num = false;
                        ret_1->num = T_4_1.num;
                        }
                        {signal (ERR_ok);}}
                        break;
                        }
                default: {

  LINE(100);
                    {
                    {
                    ret_1->tf = true;
                    }
                    {signal (ERR_ok);}}
                }
                }
                }
            }
            }
            }
            break;
            }
    case 2: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        xa1.num = T_1_3.num;

  LINE(104);
            {
            switch (ta2.cell->tag) {
            case 2: 
                 {CLUREF T_2_1;
                T_2_1.num = ta2.cell->value;
                xa2.num = T_2_1.num;

  LINE(107);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                    CLUREF T_3_5;
                    CLUREF T_3_6;
                    CLUREF T_3_7;
                    CLUREF T_3_8;
                    CLUREF T_3_9;
                    CLUREF T_3_10;
                    CLUREF T_3_11;
                    CLUREF T_3_12;
                    T_3_3.num = xa1.vec->data[1];
                    T_3_4.num = xa2.vec->data[1];
                    err = duOPequal(T_3_3, T_3_4, &T_3_5);
                    if (err != ERR_ok) goto ex_0;
                    T_3_2.num = T_3_5.num;
                    if (T_3_5.num) {
                        T_3_6.num = xa1.vec->data[0];
                        T_3_7.num = xa2.vec->data[0];
                        generic_CLU_proc.type_owns = sequence_of_typespec_ops->type_owns;
                        generic_CLU_proc.proc = sequenceOPequal;
                        CUR_PROC_VAR.proc = &generic_CLU_proc;
                        err = sequenceOPequal(T_3_6, T_3_7, &T_3_8);
                        if (err != ERR_ok) goto ex_0;
                        T_3_2.num = T_3_8.num;
                    }
                    T_3_1.num = T_3_2.num;
                    if (T_3_2.num) {
                        T_3_9.num = xa1.vec->data[3];
                        T_3_10.num = xa2.vec->data[3];
                        generic_CLU_proc.type_owns = sequence_of_typespec_ops->type_owns;
                        generic_CLU_proc.proc = sequenceOPequal;
                        CUR_PROC_VAR.proc = &generic_CLU_proc;
                        err = sequenceOPequal(T_3_9, T_3_10, &T_3_11);
                        if (err != ERR_ok) goto ex_0;
                        T_3_1.num = T_3_11.num;
                    }
                    T_3_12.num = T_3_1.num ^ 1;
                    if (T_3_12.num == true) {

  LINE(110);
                        {
                        {
                        ret_1->tf = true;
                        }
                        {signal (ERR_ok);}}
                        }
                        }/* end if */

  LINE(111);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = xa2.vec->data[2];
                        T_3_3.num = T_3_1.vec->size; 
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            x.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(112);
                            {

  LINE(113);
                                {
                                CLUREF T_6_1;
                                CLUREF T_6_2;
                                CLUREF T_6_3;
                                CLUREF T_6_4;
                                    T_6_1.num = xa1.vec->data[2];
                                    T_6_3.num = T_6_1.vec->size; 
                                    T_6_4 = T_6_1;
                                    for (T_6_2.num = 1; T_6_2.num <= T_6_3.num; T_6_2.num++) {
                                        y.num = T_6_4.vec->data[T_6_2.num - 1];

  LINE(114);
                                        {
                                        CLUREF T_7_1;
                                        generic_CLU_proc.type_owns = 0;
                                        generic_CLU_proc.op_owns = record_name_types_ops->entry[0].fcn->op_owns;
                                        generic_CLU_proc.proc = recordOPsimilar;
                                        CUR_PROC_VAR.proc = &generic_CLU_proc;
                                        err = recordOPsimilar(x, y, &T_7_1);
                                        if (err != ERR_ok) goto ex_1;
                                        if (T_7_1.num == true) {

  LINE(115);
                                            {
                                                err = "ERR_ok_UNIQ";
                                                goto ex_1;
                                                }
                                            }
                                            }/* end if */
                                    }
                                }
                                end_inline_for_2:;

  LINE(117);
                                {
                                {
                                ret_1->tf = true;
                                }
                                {signal (ERR_ok);}}
                                }
                                goto end_1;
                                ex_1:
                                    if (errcmp(err, "ERR_ok_UNIQ")) {
                                    }
                                    else {
                                        goto ex_0;
                                    }
                                end_1:;
                        }
                    }
                    end_inline_for_1:;

  LINE(120);
                    {
                    {
                    ret_1->tf = false;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            case 9: 
            case 6: 
                 {

  LINE(122);
                    {
                    {
                    ret_1->tf = false;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            default: {

  LINE(124);
                {
                {
                ret_1->tf = true;
                }
                {signal (ERR_ok);}}
            }
            }
            }
            break;
            }
    default: {

  LINE(127);
        {
        switch (ta2.cell->tag) {
        case 9: 
             {

  LINE(129);
                {
                {
                ret_1->tf = false;
                }
                {signal (ERR_ok);}}
                break;
                }
        case 6: 
             {CLUREF T_2_1;
            T_2_1.num = ta2.cell->value;
            ot.num = T_2_1.num;

  LINE(131);
                {
                switch (ot.cell->tag) {
                case 3: 
                     {

  LINE(132);
                        {
                        {
                        ret_1->tf = false;
                        }
                        {signal (ERR_ok);}}
                        break;
                        }
                case 1: 
                     {

  LINE(133);
                        {
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        CLUREF T_4_3;
                        T_4_1.num = t1.vec->data[1];
                        if (T_4_1.cell->tag == 8) T_4_2.num = true; else T_4_2.num = false;
                        T_4_3.num = T_4_2.num ^ 1;
                        ret_1->num = T_4_3.num;
                        }
                        {signal (ERR_ok);}}
                        break;
                        }
                default: {

  LINE(134);
                    {
                    {
                    ret_1->tf = true;
                    }
                    {signal (ERR_ok);}}
                }
                }
                }
                break;
                }
        default: {

  LINE(137);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
        }
        }
        }
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE mismatch ****/


/**** BEGIN PROCEDURE mismatch2 ****/

errcode typespecOPmismatch2(t1, t2, ret_1)
CLUREF t1;
CLUREF t2;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (typespec_own_init == 0) {
            err = typespec_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(142);

  LINE(143);
    {
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    err = typespecOPmismatch(t1, t2, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    T_2_1.num = T_2_2.num;
    if (!T_2_2.num) {
        err = typespecOPmismatch(t2, t1, &T_2_3);
        if (err != ERR_ok) goto ex_1;
        T_2_1.num = T_2_3.num;
    }
    ret_1->num = T_2_1.num;
    }
    {signal (ERR_ok);}}
        goto end_1;
        ex_1:
            if ((err == ERR_anyize)) {

  LINE(144);
                {
                {
                ret_1->tf = true;
                }
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE mismatch2 ****/

struct OPS *sequence_of_typespec_table;
struct OPS *sequence_of_typespec_ops;
struct OPS *sequence_of_typespec_ops;
OWNPTR sequence_of_typespec_owns;
struct OPS  *record_name_types_ops;
struct OPS *sequence_of_record_name_types_table;
struct OPS *sequence_of_record_name_types_ops;
struct OPS *sequence_of_record_name_types_ops;
OWNPTR sequence_of_record_name_types_owns;
struct OPS  *record_args_gen_sigs_vals_ops;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_gen_parms_ops;
struct OPS  *record_name_parms_type__ops;
struct OPS  *oneof_du_op_return__ops;
struct OPS  *record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__table;
struct OPS *sequence_of_record_sel_type__ops;
struct OPS *sequence_of_record_sel_type__ops;
OWNPTR sequence_of_record_sel_type__owns;
struct OPS  *record_gen_parms_1_ops;
struct OPS  *record_idn_parms_ops;
struct OPS  *record_idn_parms_1_ops;
struct OPS  *oneof_any__apply_cluster__cvt__idn_other_select_type__unknown_xclu_xsel_ops;
struct OPS  *record_id_type__ops;
static int typespecOP_gcd_own_init = 0;

/**** BEGIN PROCEDURE _gcd ****/

errcode typespecOP_gcd(t, tab, ret_1)
CLUREF t;
CLUREF tab;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (typespecOP_gcd_own_init == 0) {
        if (typespec_own_init == 0) {
            err = typespec_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        typespecOP_gcd_own_init = 1;
    }
    enter_proc(147);

  LINE(148);
    {
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = 0;
    generic_CLU_proc.op_owns = record_id_type__ops->entry[6].fcn->op_owns;
    generic_CLU_proc.proc = recordOP_gcd;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = recordOP_gcd(t, tab, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE _gcd ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[12];
} typespec_OPS;

CLU_proc typespec_oe__gcd = {{0,0,0,0}, typespecOP_gcd, 0};
CLU_proc typespec_oe_copy = {{0,0,0,0}, typespecOPcopy, 0};
CLU_proc typespec_oe_create = {{0,0,0,0}, typespecOPcreate, 0};
CLU_proc typespec_oe_equal = {{0,0,0,0}, typespecOPequal, 0};
CLU_proc typespec_oe_get_abs = {{0,0,0,0}, typespecOPget_abs, 0};
CLU_proc typespec_oe_get_id = {{0,0,0,0}, typespecOPget_id, 0};
CLU_proc typespec_oe_is_unknown = {{0,0,0,0}, typespecOPis_unknown, 0};
CLU_proc typespec_oe_mismatch = {{0,0,0,0}, typespecOPmismatch, 0};
CLU_proc typespec_oe_mismatch2 = {{0,0,0,0}, typespecOPmismatch2, 0};
CLU_proc typespec_oe_set_abs = {{0,0,0,0}, typespecOPset_abs, 0};
CLU_proc typespec_oe_set_id = {{0,0,0,0}, typespecOPset_id, 0};
CLU_proc typespec_oe_similar = {{0,0,0,0}, typespecOPsimilar, 0};

typespec_OPS typespec_ops_actual = {12, (OWNPTR)&typespec_own_init, (OWNPTR)&typespec_own_init, {
    {&typespec_oe__gcd, "_gcd"},
    {&typespec_oe_copy, "copy"},
    {&typespec_oe_create, "create"},
    {&typespec_oe_equal, "equal"},
    {&typespec_oe_get_abs, "get_abs"},
    {&typespec_oe_get_id, "get_id"},
    {&typespec_oe_is_unknown, "is_unknown"},
    {&typespec_oe_mismatch, "mismatch"},
    {&typespec_oe_mismatch2, "mismatch2"},
    {&typespec_oe_set_abs, "set_abs"},
    {&typespec_oe_set_id, "set_id"},
    {&typespec_oe_similar, "similar"}}};

struct OPS *typespec_ops = (struct OPS *)&typespec_ops_actual;

/**** END CLUSTER typespec ****/

/**** BEGIN CLUSTER equate ****/

extern errcode stringOPequal();
extern errcode idnOPget_str();
extern errcode recordOPequal();
extern errcode idnOPequal();
extern errcode oneofOPsimilar();
extern struct OPS *equate_ops;
struct OPS *sequence_of_equate_table;
struct OPS *sequence_of_equate_ops;
struct OPS *sequence_of_equate_ops;
OWNPTR sequence_of_equate_owns;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
extern struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS  *record_line_opers_ops;
extern struct OPS *record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_table;
struct OPS *sequence_of_record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_ops;
OWNPTR sequence_of_record_line_opers_owns;
extern struct OPS *sequence_of_equate_ops;
extern struct OPS *sequence_of_record_line_opers_ops;
struct OPS  *record_equates_idn_ops_ops;
extern struct OPS *record_equates_idn_ops_ops;
struct OPS  *oneof_du_expr_typeset_ops;
extern struct OPS *oneof_du_expr_typeset_ops;
struct OPS  *record_idn_line_val_ops;
CLUREF STR_REP;
static int equate_own_init = 0;
OWN_req equate_ownreqs = {0,0};
errcode equate_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (equate_own_init == 0) {
        add_parm_info_type(0, equate_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_equate_ops));
        add_parm_info_type(0, expr_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_expr_ops));
        add_selector_info("name", 0, string_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        add_selector_info("type_", 2, typespec_ops); 
        find_selector_ops("record", 3, &(record_name_parms_type__ops));
        add_parm_info_type(0, record_name_parms_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_name_parms_type__ops));
        add_selector_info("line", 0, int_ops); 
        add_selector_info("opers", 1, sequence_of_record_name_parms_type__ops); 
        find_selector_ops("record", 2, &(record_line_opers_ops));
        add_parm_info_type(0, record_line_opers_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_line_opers_ops));
        add_selector_info("equates", 0, sequence_of_equate_ops); 
        add_selector_info("idn", 1, idn_ops); 
        add_selector_info("ops", 2, sequence_of_record_line_opers_ops); 
        find_selector_ops("record", 3, &(record_equates_idn_ops_ops));
        add_selector_info("du", 0, string_ops); 
        add_selector_info("expr", 1, expr_ops); 
        add_selector_info("typeset", 2, record_equates_idn_ops_ops); 
        find_selector_ops("oneof", 3, &(oneof_du_expr_typeset_ops));
        add_selector_info("idn", 0, idn_ops); 
        add_selector_info("line", 1, int_ops); 
        add_selector_info("val", 2, oneof_du_expr_typeset_ops); 
        find_selector_ops("record", 3, &(record_idn_line_val_ops));
        stringOPcons("REP", CLU_1, CLU_3, &STR_REP);
        equate_own_init = 1;
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE create ****/

errcode equateOPcreate(id, val, line, ret_1)
CLUREF id;
CLUREF val;
CLUREF line;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (equate_own_init == 0) {
            err = equate_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(169);

  LINE(170);
    {
    {
    CLUREF T_1_1;
    RecordAlloc(3, T_1_1);
    T_1_1.vec->data[0]  = id.num;
    T_1_1.vec->data[2]  = val.num;
    T_1_1.vec->data[1]  = line.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE create ****/

static int equateOPis_rep_own_init = 0;

/**** BEGIN PROCEDURE is_rep ****/

errcode equateOPis_rep(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (equateOPis_rep_own_init == 0) {
        if (equate_own_init == 0) {
            err = equate_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        equateOPis_rep_own_init = 1;
    }
    enter_proc(175);

  LINE(176);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = e.vec->data[0];
    err = idnOPget_str(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_3.num = ((STR_REP.str->size != T_1_2.str->size)? false :
        !(bcmp(STR_REP.str->data, T_1_2.str->data, STR_REP.str->size)));
    ret_1->num = T_1_3.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE is_rep ****/


/**** BEGIN PROCEDURE get_idn ****/

errcode equateOPget_idn(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (equate_own_init == 0) {
            err = equate_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(179);

  LINE(180);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[0];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_idn ****/


/**** BEGIN PROCEDURE get_val ****/

errcode equateOPget_val(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (equate_own_init == 0) {
            err = equate_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(183);

  LINE(184);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[2];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_val ****/


/**** BEGIN PROCEDURE get_line ****/

errcode equateOPget_line(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (equate_own_init == 0) {
            err = equate_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(187);

  LINE(188);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = e.vec->data[1];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_line ****/


/**** BEGIN PROCEDURE copy ****/

errcode equateOPcopy(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (equate_own_init == 0) {
            err = equate_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(191);

  LINE(192);
    {
    {
    ret_1->num = e.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE copy ****/


/**** BEGIN PROCEDURE equal ****/

errcode equateOPequal(e1, e2, ret_1)
CLUREF e1;
CLUREF e2;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (equate_own_init == 0) {
            err = equate_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(195);

  LINE(196);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = (e1.num == e2.num)? true : false;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE equal ****/

struct OPS *sequence_of_equate_table;
struct OPS *sequence_of_equate_ops;
struct OPS *sequence_of_equate_ops;
OWNPTR sequence_of_equate_owns;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_table;
struct OPS *sequence_of_record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_ops;
OWNPTR sequence_of_record_line_opers_owns;
struct OPS  *record_equates_idn_ops_ops;
struct OPS  *oneof_du_expr_typeset_ops;
static int equateOPsimilar_own_init = 0;

/**** BEGIN PROCEDURE similar ****/

errcode equateOPsimilar(e1, e2, ret_1)
CLUREF e1;
CLUREF e2;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (equateOPsimilar_own_init == 0) {
        if (equate_own_init == 0) {
            err = equate_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        equateOPsimilar_own_init = 1;
    }
    enter_proc(199);

  LINE(200);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = e1.vec->data[0];
    T_1_2.num = e2.vec->data[0];
    err = idnOPequal(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    if (T_1_3.num == true) {

  LINE(201);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = e1.vec->data[2];
        T_2_2.num = e2.vec->data[2];
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = oneof_du_expr_typeset_ops->entry[1].fcn->op_owns;
        generic_CLU_proc.proc = oneofOPsimilar;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = oneofOPsimilar(T_2_1, T_2_2, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_3.num;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(202);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE similar ****/

struct OPS *sequence_of_equate_table;
struct OPS *sequence_of_equate_ops;
struct OPS *sequence_of_equate_ops;
OWNPTR sequence_of_equate_owns;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_table;
struct OPS *sequence_of_record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_ops;
OWNPTR sequence_of_record_line_opers_owns;
struct OPS  *record_equates_idn_ops_ops;
struct OPS  *oneof_du_expr_typeset_ops;
struct OPS  *record_idn_line_val_ops;
static int equateOP_gcd_own_init = 0;

/**** BEGIN PROCEDURE _gcd ****/

errcode equateOP_gcd(e, tab, ret_1)
CLUREF e;
CLUREF tab;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (equateOP_gcd_own_init == 0) {
        if (equate_own_init == 0) {
            err = equate_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        equateOP_gcd_own_init = 1;
    }
    enter_proc(206);

  LINE(207);
    {
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = 0;
    generic_CLU_proc.op_owns = record_idn_line_val_ops->entry[6].fcn->op_owns;
    generic_CLU_proc.proc = recordOP_gcd;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = recordOP_gcd(e, tab, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE _gcd ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[9];
} equate_OPS;

CLU_proc equate_oe__gcd = {{0,0,0,0}, equateOP_gcd, 0};
CLU_proc equate_oe_copy = {{0,0,0,0}, equateOPcopy, 0};
CLU_proc equate_oe_create = {{0,0,0,0}, equateOPcreate, 0};
CLU_proc equate_oe_equal = {{0,0,0,0}, equateOPequal, 0};
CLU_proc equate_oe_get_idn = {{0,0,0,0}, equateOPget_idn, 0};
CLU_proc equate_oe_get_line = {{0,0,0,0}, equateOPget_line, 0};
CLU_proc equate_oe_get_val = {{0,0,0,0}, equateOPget_val, 0};
CLU_proc equate_oe_is_rep = {{0,0,0,0}, equateOPis_rep, 0};
CLU_proc equate_oe_similar = {{0,0,0,0}, equateOPsimilar, 0};

equate_OPS equate_ops_actual = {9, (OWNPTR)&equate_own_init, (OWNPTR)&equate_own_init, {
    {&equate_oe__gcd, "_gcd"},
    {&equate_oe_copy, "copy"},
    {&equate_oe_create, "create"},
    {&equate_oe_equal, "equal"},
    {&equate_oe_get_idn, "get_idn"},
    {&equate_oe_get_line, "get_line"},
    {&equate_oe_get_val, "get_val"},
    {&equate_oe_is_rep, "is_rep"},
    {&equate_oe_similar, "similar"}}};

struct OPS *equate_ops = (struct OPS *)&equate_ops_actual;

/**** END CLUSTER equate ****/

/**** BEGIN CLUSTER stmt ****/

struct OPS *sequence_of_idn_table;
struct OPS *sequence_of_idn_ops;
struct OPS *sequence_of_idn_ops;
OWNPTR sequence_of_idn_owns;
extern struct OPS *sequence_of_idn_ops;
struct OPS  *record_idns_type__ops;
extern struct OPS *record_idns_type__ops;
struct OPS *sequence_of_record_idns_type__table;
struct OPS *sequence_of_record_idns_type__ops;
struct OPS *sequence_of_record_idns_type__ops;
OWNPTR sequence_of_record_idns_type__owns;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
extern struct OPS *sequence_of_record_idns_type__ops;
struct OPS  *record_anys_left_right_ops;
struct OPS *sequence_of_equate_table;
struct OPS *sequence_of_equate_ops;
struct OPS *sequence_of_equate_ops;
OWNPTR sequence_of_equate_owns;
extern struct OPS *stmt_ops;
struct OPS *sequence_of_stmt_table;
struct OPS *sequence_of_stmt_ops;
struct OPS *sequence_of_stmt_ops;
OWNPTR sequence_of_stmt_owns;
extern struct OPS *sequence_of_stmt_ops;
struct OPS  *record_equates_stmts_ops;
struct OPS  *record_anys_decls_expr_ops;
struct OPS *sequence_of_string_table;
struct OPS *sequence_of_string_ops;
struct OPS *sequence_of_string_ops;
OWNPTR sequence_of_string_owns;
struct OPS  *oneof_decls_none_star_ops;
extern struct OPS *record_equates_stmts_ops;
extern struct OPS *sequence_of_string_ops;
extern struct OPS *oneof_decls_none_star_ops;
struct OPS  *record_body_line_names_vars_ops;
extern struct OPS *record_body_line_names_vars_ops;
struct OPS *sequence_of_record_body_line_names_vars_table;
struct OPS *sequence_of_record_body_line_names_vars_ops;
struct OPS *sequence_of_record_body_line_names_vars_ops;
OWNPTR sequence_of_record_body_line_names_vars_owns;
struct OPS  *oneof_decl_none_ops;
extern struct OPS *oneof_decl_none_ops;
struct OPS  *record_body_decl_line_ops;
extern struct OPS *record_body_decl_line_ops;
struct OPS  *oneof_arm_none_ops;
extern struct OPS *sequence_of_record_body_line_names_vars_ops;
extern struct OPS *oneof_arm_none_ops;
struct OPS  *record_arms_others__stmt_ops;
struct OPS  *record_args_name_ops;
struct OPS  *record_apply_args_ops;
struct OPS  *oneof_new_old_ops;
extern struct OPS *record_apply_args_ops;
extern struct OPS *oneof_new_old_ops;
extern struct OPS *bool_ops;
struct OPS  *record_anys_body_call_vars_xent_ops;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_table;
struct OPS *sequence_of_record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_ops;
OWNPTR sequence_of_record_line_opers_owns;
struct OPS  *record_equates_idn_ops_ops;
struct OPS  *oneof_has__idn_set_ops;
extern struct OPS *oneof_has__idn_set_ops;
struct OPS  *record_idn_kind_line_ops;
extern struct OPS *record_idn_kind_line_ops;
struct OPS *sequence_of_record_idn_kind_line_table;
struct OPS *sequence_of_record_idn_kind_line_ops;
struct OPS *sequence_of_record_idn_kind_line_ops;
OWNPTR sequence_of_record_idn_kind_line_owns;
extern struct OPS *sequence_of_record_idn_kind_line_ops;
struct OPS  *record_expr_type__val_where__ops;
struct OPS  *record_body_line_test_ops;
extern struct OPS *record_body_line_test_ops;
struct OPS *sequence_of_record_body_line_test_table;
struct OPS *sequence_of_record_body_line_test_ops;
struct OPS *sequence_of_record_body_line_test_ops;
OWNPTR sequence_of_record_body_line_test_owns;
struct OPS  *oneof_body_none_ops;
extern struct OPS *sequence_of_record_body_line_test_ops;
extern struct OPS *oneof_body_none_ops;
struct OPS  *record_arms_else__ops;
struct OPS  *record_resigs_stmt_ops;
struct OPS  *record_left_right_ops;
struct OPS  *record_body_line_tags_var_ops;
extern struct OPS *record_body_line_tags_var_ops;
struct OPS *sequence_of_record_body_line_tags_var_table;
struct OPS *sequence_of_record_body_line_tags_var_ops;
struct OPS *sequence_of_record_body_line_tags_var_ops;
OWNPTR sequence_of_record_body_line_tags_var_owns;
extern struct OPS *sequence_of_record_body_line_tags_var_ops;
struct OPS  *record_arms_obj_others__ops;
struct OPS  *record_body_test_ops;
extern struct OPS *record_anys_left_right_ops;
extern struct OPS *record_anys_decls_expr_ops;
extern struct OPS *record_arms_others__stmt_ops;
extern struct OPS *record_args_name_ops;
extern struct OPS *record_anys_body_call_vars_xent_ops;
extern struct OPS *record_expr_type__val_where__ops;
extern struct OPS *record_arms_else__ops;
extern struct OPS *record_resigs_stmt_ops;
extern struct OPS *record_left_right_ops;
extern struct OPS *record_arms_obj_others__ops;
extern struct OPS *record_body_test_ops;
struct OPS  *oneof_assn_bad_body_break__continue__decl_declinit_except__exit__for__force__if__invoke_resignal__return__signal__sugarassn_tag__while__yield__ops;
extern struct OPS *oneof_assn_bad_body_break__continue__decl_declinit_except__exit__for__force__if__invoke_resignal__return__signal__sugarassn_tag__while__yield__ops;
struct OPS  *record_line_stmt_ops;
static int stmt_own_init = 0;
OWN_req stmt_ownreqs = {0,0};
errcode stmt_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (stmt_own_init == 0) {
        add_parm_info_type(0, idn_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_idn_ops));
        add_selector_info("idns", 0, sequence_of_idn_ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_idns_type__ops));
        add_parm_info_type(0, record_idns_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_idns_type__ops));
        add_parm_info_type(0, expr_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_expr_ops));
        add_selector_info("anys", 0, sequence_of_record_idns_type__ops); 
        add_selector_info("left", 1, sequence_of_idn_ops); 
        add_selector_info("right", 2, sequence_of_expr_ops); 
        find_selector_ops("record", 3, &(record_anys_left_right_ops));
        add_parm_info_type(0, equate_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_equate_ops));
        add_parm_info_type(0, stmt_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_stmt_ops));
        add_selector_info("equates", 0, sequence_of_equate_ops); 
        add_selector_info("stmts", 1, sequence_of_stmt_ops); 
        find_selector_ops("record", 2, &(record_equates_stmts_ops));
        add_selector_info("anys", 0, sequence_of_record_idns_type__ops); 
        add_selector_info("decls", 1, sequence_of_record_idns_type__ops); 
        add_selector_info("expr", 2, expr_ops); 
        find_selector_ops("record", 3, &(record_anys_decls_expr_ops));
        add_parm_info_type(0, string_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_string_ops));
        add_selector_info("decls", 0, sequence_of_record_idns_type__ops); 
        add_selector_info("none", 1, null_ops); 
        add_selector_info("star", 2, null_ops); 
        find_selector_ops("oneof", 3, &(oneof_decls_none_star_ops));
        add_selector_info("body", 0, record_equates_stmts_ops); 
        add_selector_info("line", 1, int_ops); 
        add_selector_info("names", 2, sequence_of_string_ops); 
        add_selector_info("vars", 3, oneof_decls_none_star_ops); 
        find_selector_ops("record", 4, &(record_body_line_names_vars_ops));
        add_parm_info_type(0, record_body_line_names_vars_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_body_line_names_vars_ops));
        add_selector_info("decl", 0, record_idns_type__ops); 
        add_selector_info("none", 1, null_ops); 
        find_selector_ops("oneof", 2, &(oneof_decl_none_ops));
        add_selector_info("body", 0, record_equates_stmts_ops); 
        add_selector_info("decl", 1, oneof_decl_none_ops); 
        add_selector_info("line", 2, int_ops); 
        find_selector_ops("record", 3, &(record_body_decl_line_ops));
        add_selector_info("arm", 0, record_body_decl_line_ops); 
        add_selector_info("none", 1, null_ops); 
        find_selector_ops("oneof", 2, &(oneof_arm_none_ops));
        add_selector_info("arms", 0, sequence_of_record_body_line_names_vars_ops); 
        add_selector_info("others_", 1, oneof_arm_none_ops); 
        add_selector_info("stmt", 2, stmt_ops); 
        find_selector_ops("record", 3, &(record_arms_others__stmt_ops));
        add_selector_info("args", 0, sequence_of_expr_ops); 
        add_selector_info("name", 1, string_ops); 
        find_selector_ops("record", 2, &(record_args_name_ops));
        add_selector_info("apply", 0, expr_ops); 
        add_selector_info("args", 1, sequence_of_expr_ops); 
        find_selector_ops("record", 2, &(record_apply_args_ops));
        add_selector_info("new", 0, sequence_of_record_idns_type__ops); 
        add_selector_info("old", 1, sequence_of_idn_ops); 
        find_selector_ops("oneof", 2, &(oneof_new_old_ops));
        add_selector_info("anys", 0, sequence_of_record_idns_type__ops); 
        add_selector_info("body", 1, record_equates_stmts_ops); 
        add_selector_info("call", 2, record_apply_args_ops); 
        add_selector_info("vars", 3, oneof_new_old_ops); 
        add_selector_info("xent", 4, bool_ops); 
        find_selector_ops("record", 5, &(record_anys_body_call_vars_xent_ops));
        add_selector_info("name", 0, string_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        add_selector_info("type_", 2, typespec_ops); 
        find_selector_ops("record", 3, &(record_name_parms_type__ops));
        add_parm_info_type(0, record_name_parms_type__ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_name_parms_type__ops));
        add_selector_info("line", 0, int_ops); 
        add_selector_info("opers", 1, sequence_of_record_name_parms_type__ops); 
        find_selector_ops("record", 2, &(record_line_opers_ops));
        add_parm_info_type(0, record_line_opers_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_line_opers_ops));
        add_selector_info("equates", 0, sequence_of_equate_ops); 
        add_selector_info("idn", 1, idn_ops); 
        add_selector_info("ops", 2, sequence_of_record_line_opers_ops); 
        find_selector_ops("record", 3, &(record_equates_idn_ops_ops));
        add_selector_info("has_", 0, sequence_of_record_line_opers_ops); 
        add_selector_info("idn", 1, idn_ops); 
        add_selector_info("set", 2, record_equates_idn_ops_ops); 
        find_selector_ops("oneof", 3, &(oneof_has__idn_set_ops));
        add_selector_info("idn", 0, idn_ops); 
        add_selector_info("kind", 1, oneof_has__idn_set_ops); 
        add_selector_info("line", 2, int_ops); 
        find_selector_ops("record", 3, &(record_idn_kind_line_ops));
        add_parm_info_type(0, record_idn_kind_line_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_idn_kind_line_ops));
        add_selector_info("expr", 0, expr_ops); 
        add_selector_info("type_", 1, idn_ops); 
        add_selector_info("val", 2, idn_ops); 
        add_selector_info("where_", 3, sequence_of_record_idn_kind_line_ops); 
        find_selector_ops("record", 4, &(record_expr_type__val_where__ops));
        add_selector_info("body", 0, record_equates_stmts_ops); 
        add_selector_info("line", 1, int_ops); 
        add_selector_info("test", 2, expr_ops); 
        find_selector_ops("record", 3, &(record_body_line_test_ops));
        add_parm_info_type(0, record_body_line_test_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_body_line_test_ops));
        add_selector_info("body", 0, record_equates_stmts_ops); 
        add_selector_info("none", 1, null_ops); 
        find_selector_ops("oneof", 2, &(oneof_body_none_ops));
        add_selector_info("arms", 0, sequence_of_record_body_line_test_ops); 
        add_selector_info("else_", 1, oneof_body_none_ops); 
        find_selector_ops("record", 2, &(record_arms_else__ops));
        add_selector_info("resigs", 0, sequence_of_string_ops); 
        add_selector_info("stmt", 1, stmt_ops); 
        find_selector_ops("record", 2, &(record_resigs_stmt_ops));
        add_selector_info("left", 0, expr_ops); 
        add_selector_info("right", 1, expr_ops); 
        find_selector_ops("record", 2, &(record_left_right_ops));
        add_selector_info("body", 0, record_equates_stmts_ops); 
        add_selector_info("line", 1, int_ops); 
        add_selector_info("tags", 2, sequence_of_string_ops); 
        add_selector_info("var", 3, oneof_decl_none_ops); 
        find_selector_ops("record", 4, &(record_body_line_tags_var_ops));
        add_parm_info_type(0, record_body_line_tags_var_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_body_line_tags_var_ops));
        add_selector_info("arms", 0, sequence_of_record_body_line_tags_var_ops); 
        add_selector_info("obj", 1, expr_ops); 
        add_selector_info("others_", 2, oneof_body_none_ops); 
        find_selector_ops("record", 3, &(record_arms_obj_others__ops));
        add_selector_info("body", 0, record_equates_stmts_ops); 
        add_selector_info("test", 1, expr_ops); 
        find_selector_ops("record", 2, &(record_body_test_ops));
        add_selector_info("assn", 0, record_anys_left_right_ops); 
        add_selector_info("bad", 1, null_ops); 
        add_selector_info("body", 2, record_equates_stmts_ops); 
        add_selector_info("break_", 3, null_ops); 
        add_selector_info("continue_", 4, null_ops); 
        add_selector_info("decl", 5, record_idns_type__ops); 
        add_selector_info("declinit", 6, record_anys_decls_expr_ops); 
        add_selector_info("except_", 7, record_arms_others__stmt_ops); 
        add_selector_info("exit_", 8, record_args_name_ops); 
        add_selector_info("for_", 9, record_anys_body_call_vars_xent_ops); 
        add_selector_info("force_", 10, record_expr_type__val_where__ops); 
        add_selector_info("if_", 11, record_arms_else__ops); 
        add_selector_info("invoke", 12, record_apply_args_ops); 
        add_selector_info("resignal_", 13, record_resigs_stmt_ops); 
        add_selector_info("return_", 14, sequence_of_expr_ops); 
        add_selector_info("signal_", 15, record_args_name_ops); 
        add_selector_info("sugarassn", 16, record_left_right_ops); 
        add_selector_info("tag_", 17, record_arms_obj_others__ops); 
        add_selector_info("while_", 18, record_body_test_ops); 
        add_selector_info("yield_", 19, sequence_of_expr_ops); 
        find_selector_ops("oneof", 20, &(oneof_assn_bad_body_break__continue__decl_declinit_except__exit__for__force__if__invoke_resignal__return__signal__sugarassn_tag__while__yield__ops));
        add_selector_info("line", 0, int_ops); 
        add_selector_info("stmt", 1, oneof_assn_bad_body_break__continue__decl_declinit_except__exit__for__force__if__invoke_resignal__return__signal__sugarassn_tag__while__yield__ops); 
        find_selector_ops("record", 2, &(record_line_stmt_ops));
        stmt_own_init = 1;
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE create ****/

errcode stmtOPcreate(s, l, ret_1)
CLUREF s;
CLUREF l;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stmt_own_init == 0) {
            err = stmt_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(226);

  LINE(227);
    {
    {
    CLUREF T_1_1;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[1]  = s.num;
    T_1_1.vec->data[0]  = l.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE create ****/


/**** BEGIN PROCEDURE get_abs ****/

errcode stmtOPget_abs(s, ret_1)
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stmt_own_init == 0) {
            err = stmt_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(231);

  LINE(232);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = s.vec->data[1];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_abs ****/


/**** BEGIN PROCEDURE set_abs ****/

errcode stmtOPset_abs(s, a)
CLUREF s;
CLUREF a;
    {
    errcode err;
    errcode ecode2;
        if (stmt_own_init == 0) {
            err = stmt_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(235);

  LINE(236);
    {
    s.vec->data[1]  = a.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_abs ****/


/**** BEGIN PROCEDURE get_line ****/

errcode stmtOPget_line(s, ret_1)
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stmt_own_init == 0) {
            err = stmt_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(239);

  LINE(240);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = s.vec->data[0];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_line ****/


/**** BEGIN PROCEDURE copy ****/

errcode stmtOPcopy(s, ret_1)
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stmt_own_init == 0) {
            err = stmt_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(243);

  LINE(244);
    {
    {
    ret_1->num = s.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE copy ****/


/**** BEGIN PROCEDURE equal ****/

errcode stmtOPequal(s1, s2, ret_1)
CLUREF s1;
CLUREF s2;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stmt_own_init == 0) {
            err = stmt_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(247);

  LINE(248);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = (s1.num == s2.num)? true : false;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE equal ****/

struct OPS *sequence_of_idn_table;
struct OPS *sequence_of_idn_ops;
struct OPS *sequence_of_idn_ops;
OWNPTR sequence_of_idn_owns;
struct OPS  *record_idns_type__ops;
struct OPS *sequence_of_record_idns_type__table;
struct OPS *sequence_of_record_idns_type__ops;
struct OPS *sequence_of_record_idns_type__ops;
OWNPTR sequence_of_record_idns_type__owns;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_anys_left_right_ops;
struct OPS *sequence_of_equate_table;
struct OPS *sequence_of_equate_ops;
struct OPS *sequence_of_equate_ops;
OWNPTR sequence_of_equate_owns;
struct OPS *sequence_of_stmt_table;
struct OPS *sequence_of_stmt_ops;
struct OPS *sequence_of_stmt_ops;
OWNPTR sequence_of_stmt_owns;
struct OPS  *record_equates_stmts_ops;
struct OPS  *record_anys_decls_expr_ops;
struct OPS *sequence_of_string_table;
struct OPS *sequence_of_string_ops;
struct OPS *sequence_of_string_ops;
OWNPTR sequence_of_string_owns;
struct OPS  *oneof_decls_none_star_ops;
struct OPS  *record_body_line_names_vars_ops;
struct OPS *sequence_of_record_body_line_names_vars_table;
struct OPS *sequence_of_record_body_line_names_vars_ops;
struct OPS *sequence_of_record_body_line_names_vars_ops;
OWNPTR sequence_of_record_body_line_names_vars_owns;
struct OPS  *oneof_decl_none_ops;
struct OPS  *record_body_decl_line_ops;
struct OPS  *oneof_arm_none_ops;
struct OPS  *record_arms_others__stmt_ops;
struct OPS  *record_args_name_ops;
struct OPS  *record_apply_args_ops;
struct OPS  *oneof_new_old_ops;
struct OPS  *record_anys_body_call_vars_xent_ops;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_table;
struct OPS *sequence_of_record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_ops;
OWNPTR sequence_of_record_line_opers_owns;
struct OPS  *record_equates_idn_ops_ops;
struct OPS  *oneof_has__idn_set_ops;
struct OPS  *record_idn_kind_line_ops;
struct OPS *sequence_of_record_idn_kind_line_table;
struct OPS *sequence_of_record_idn_kind_line_ops;
struct OPS *sequence_of_record_idn_kind_line_ops;
OWNPTR sequence_of_record_idn_kind_line_owns;
struct OPS  *record_expr_type__val_where__ops;
struct OPS  *record_body_line_test_ops;
struct OPS *sequence_of_record_body_line_test_table;
struct OPS *sequence_of_record_body_line_test_ops;
struct OPS *sequence_of_record_body_line_test_ops;
OWNPTR sequence_of_record_body_line_test_owns;
struct OPS  *oneof_body_none_ops;
struct OPS  *record_arms_else__ops;
struct OPS  *record_resigs_stmt_ops;
struct OPS  *record_left_right_ops;
struct OPS  *record_body_line_tags_var_ops;
struct OPS *sequence_of_record_body_line_tags_var_table;
struct OPS *sequence_of_record_body_line_tags_var_ops;
struct OPS *sequence_of_record_body_line_tags_var_ops;
OWNPTR sequence_of_record_body_line_tags_var_owns;
struct OPS  *record_arms_obj_others__ops;
struct OPS  *record_body_test_ops;
struct OPS  *oneof_assn_bad_body_break__continue__decl_declinit_except__exit__for__force__if__invoke_resignal__return__signal__sugarassn_tag__while__yield__ops;
static int stmtOPsimilar_own_init = 0;

/**** BEGIN PROCEDURE similar ****/

errcode stmtOPsimilar(s1, s2, ret_1)
CLUREF s1;
CLUREF s2;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stmtOPsimilar_own_init == 0) {
        if (stmt_own_init == 0) {
            err = stmt_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        stmtOPsimilar_own_init = 1;
    }
    enter_proc(251);

  LINE(252);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = s1.vec->data[1];
    T_1_2.num = s2.vec->data[1];
    generic_CLU_proc.type_owns = 0;
    generic_CLU_proc.op_owns = oneof_assn_bad_body_break__continue__decl_declinit_except__exit__for__force__if__invoke_resignal__return__signal__sugarassn_tag__while__yield__ops->entry[1].fcn->op_owns;
    generic_CLU_proc.proc = oneofOPsimilar;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = oneofOPsimilar(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_3.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE similar ****/

struct OPS *sequence_of_idn_table;
struct OPS *sequence_of_idn_ops;
struct OPS *sequence_of_idn_ops;
OWNPTR sequence_of_idn_owns;
struct OPS  *record_idns_type__ops;
struct OPS *sequence_of_record_idns_type__table;
struct OPS *sequence_of_record_idns_type__ops;
struct OPS *sequence_of_record_idns_type__ops;
OWNPTR sequence_of_record_idns_type__owns;
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *record_anys_left_right_ops;
struct OPS *sequence_of_equate_table;
struct OPS *sequence_of_equate_ops;
struct OPS *sequence_of_equate_ops;
OWNPTR sequence_of_equate_owns;
struct OPS *sequence_of_stmt_table;
struct OPS *sequence_of_stmt_ops;
struct OPS *sequence_of_stmt_ops;
OWNPTR sequence_of_stmt_owns;
struct OPS  *record_equates_stmts_ops;
struct OPS  *record_anys_decls_expr_ops;
struct OPS *sequence_of_string_table;
struct OPS *sequence_of_string_ops;
struct OPS *sequence_of_string_ops;
OWNPTR sequence_of_string_owns;
struct OPS  *oneof_decls_none_star_ops;
struct OPS  *record_body_line_names_vars_ops;
struct OPS *sequence_of_record_body_line_names_vars_table;
struct OPS *sequence_of_record_body_line_names_vars_ops;
struct OPS *sequence_of_record_body_line_names_vars_ops;
OWNPTR sequence_of_record_body_line_names_vars_owns;
struct OPS  *oneof_decl_none_ops;
struct OPS  *record_body_decl_line_ops;
struct OPS  *oneof_arm_none_ops;
struct OPS  *record_arms_others__stmt_ops;
struct OPS  *record_args_name_ops;
struct OPS  *record_apply_args_ops;
struct OPS  *oneof_new_old_ops;
struct OPS  *record_anys_body_call_vars_xent_ops;
struct OPS  *record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__table;
struct OPS *sequence_of_record_name_parms_type__ops;
struct OPS *sequence_of_record_name_parms_type__ops;
OWNPTR sequence_of_record_name_parms_type__owns;
struct OPS  *record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_table;
struct OPS *sequence_of_record_line_opers_ops;
struct OPS *sequence_of_record_line_opers_ops;
OWNPTR sequence_of_record_line_opers_owns;
struct OPS  *record_equates_idn_ops_ops;
struct OPS  *oneof_has__idn_set_ops;
struct OPS  *record_idn_kind_line_ops;
struct OPS *sequence_of_record_idn_kind_line_table;
struct OPS *sequence_of_record_idn_kind_line_ops;
struct OPS *sequence_of_record_idn_kind_line_ops;
OWNPTR sequence_of_record_idn_kind_line_owns;
struct OPS  *record_expr_type__val_where__ops;
struct OPS  *record_body_line_test_ops;
struct OPS *sequence_of_record_body_line_test_table;
struct OPS *sequence_of_record_body_line_test_ops;
struct OPS *sequence_of_record_body_line_test_ops;
OWNPTR sequence_of_record_body_line_test_owns;
struct OPS  *oneof_body_none_ops;
struct OPS  *record_arms_else__ops;
struct OPS  *record_resigs_stmt_ops;
struct OPS  *record_left_right_ops;
struct OPS  *record_body_line_tags_var_ops;
struct OPS *sequence_of_record_body_line_tags_var_table;
struct OPS *sequence_of_record_body_line_tags_var_ops;
struct OPS *sequence_of_record_body_line_tags_var_ops;
OWNPTR sequence_of_record_body_line_tags_var_owns;
struct OPS  *record_arms_obj_others__ops;
struct OPS  *record_body_test_ops;
struct OPS  *oneof_assn_bad_body_break__continue__decl_declinit_except__exit__for__force__if__invoke_resignal__return__signal__sugarassn_tag__while__yield__ops;
struct OPS  *record_line_stmt_ops;
static int stmtOP_gcd_own_init = 0;

/**** BEGIN PROCEDURE _gcd ****/

errcode stmtOP_gcd(s, tab, ret_1)
CLUREF s;
CLUREF tab;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (stmtOP_gcd_own_init == 0) {
        if (stmt_own_init == 0) {
            err = stmt_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        stmtOP_gcd_own_init = 1;
    }
    enter_proc(255);

  LINE(256);
    {
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = 0;
    generic_CLU_proc.op_owns = record_line_stmt_ops->entry[6].fcn->op_owns;
    generic_CLU_proc.proc = recordOP_gcd;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = recordOP_gcd(s, tab, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE _gcd ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[8];
} stmt_OPS;

CLU_proc stmt_oe__gcd = {{0,0,0,0}, stmtOP_gcd, 0};
CLU_proc stmt_oe_copy = {{0,0,0,0}, stmtOPcopy, 0};
CLU_proc stmt_oe_create = {{0,0,0,0}, stmtOPcreate, 0};
CLU_proc stmt_oe_equal = {{0,0,0,0}, stmtOPequal, 0};
CLU_proc stmt_oe_get_abs = {{0,0,0,0}, stmtOPget_abs, 0};
CLU_proc stmt_oe_get_line = {{0,0,0,0}, stmtOPget_line, 0};
CLU_proc stmt_oe_set_abs = {{0,0,0,0}, stmtOPset_abs, 0};
CLU_proc stmt_oe_similar = {{0,0,0,0}, stmtOPsimilar, 0};

stmt_OPS stmt_ops_actual = {8, (OWNPTR)&stmt_own_init, (OWNPTR)&stmt_own_init, {
    {&stmt_oe__gcd, "_gcd"},
    {&stmt_oe_copy, "copy"},
    {&stmt_oe_create, "create"},
    {&stmt_oe_equal, "equal"},
    {&stmt_oe_get_abs, "get_abs"},
    {&stmt_oe_get_line, "get_line"},
    {&stmt_oe_set_abs, "set_abs"},
    {&stmt_oe_similar, "similar"}}};

struct OPS *stmt_ops = (struct OPS *)&stmt_ops_actual;

/**** END CLUSTER stmt ****/

/**** BEGIN CLUSTER expr ****/

extern errcode recordOPcopy();
struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *oneof_none_one_ops;
extern struct OPS *oneof_none_one_ops;
struct OPS  *record_elts_low_type__ops;
struct OPS  *record_gen_parms_ops;
struct OPS  *record_left_right_ops;
struct OPS  *record_index_object_ops;
struct OPS  *record_object_sel_ops;
struct OPS  *record_left_neg_op_right_ops;
struct OPS  *record_apply_args_ops;
struct OPS  *record_name_parms_type__ops;
struct OPS  *record_idn_parms_ops;
struct OPS *sequence_of_string_table;
struct OPS *sequence_of_string_ops;
struct OPS *sequence_of_string_ops;
OWNPTR sequence_of_string_owns;
struct OPS  *record_line_sels_val_ops;
extern struct OPS *record_line_sels_val_ops;
struct OPS *sequence_of_record_line_sels_val_table;
struct OPS *sequence_of_record_line_sels_val_ops;
struct OPS *sequence_of_record_line_sels_val_ops;
OWNPTR sequence_of_record_line_sels_val_owns;
extern struct OPS *sequence_of_record_line_sels_val_ops;
struct OPS  *record_fields_type__ops;
extern struct OPS *record_elts_low_type__ops;
extern struct OPS *char_ops;
extern struct OPS *record_index_object_ops;
extern struct OPS *record_object_sel_ops;
extern struct OPS *record_left_neg_op_right_ops;
extern struct OPS *real_ops;
extern struct OPS *record_fields_type__ops;
struct OPS  *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops;
extern struct OPS *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops;
struct OPS  *record_expr_type__ops;
static int expr_own_init = 0;
OWN_req expr_ownreqs = {0,0};
errcode expr_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (expr_own_init == 0) {
        add_parm_info_type(0, expr_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_expr_ops));
        add_selector_info("none", 0, null_ops); 
        add_selector_info("one", 1, expr_ops); 
        find_selector_ops("oneof", 2, &(oneof_none_one_ops));
        add_selector_info("elts", 0, sequence_of_expr_ops); 
        add_selector_info("low", 1, oneof_none_one_ops); 
        add_selector_info("type_", 2, typespec_ops); 
        find_selector_ops("record", 3, &(record_elts_low_type__ops));
        add_selector_info("gen", 0, du_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        find_selector_ops("record", 2, &(record_gen_parms_ops));
        add_selector_info("left", 0, expr_ops); 
        add_selector_info("right", 1, expr_ops); 
        find_selector_ops("record", 2, &(record_left_right_ops));
        add_selector_info("index", 0, expr_ops); 
        add_selector_info("object", 1, expr_ops); 
        find_selector_ops("record", 2, &(record_index_object_ops));
        add_selector_info("object", 0, expr_ops); 
        add_selector_info("sel", 1, string_ops); 
        find_selector_ops("record", 2, &(record_object_sel_ops));
        add_selector_info("left", 0, expr_ops); 
        add_selector_info("neg", 1, bool_ops); 
        add_selector_info("op", 2, string_ops); 
        add_selector_info("right", 3, expr_ops); 
        find_selector_ops("record", 4, &(record_left_neg_op_right_ops));
        add_selector_info("apply", 0, expr_ops); 
        add_selector_info("args", 1, sequence_of_expr_ops); 
        find_selector_ops("record", 2, &(record_apply_args_ops));
        add_selector_info("name", 0, string_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        add_selector_info("type_", 2, typespec_ops); 
        find_selector_ops("record", 3, &(record_name_parms_type__ops));
        add_selector_info("idn", 0, idn_ops); 
        add_selector_info("parms", 1, sequence_of_expr_ops); 
        find_selector_ops("record", 2, &(record_idn_parms_ops));
        add_parm_info_type(0, string_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_string_ops));
        add_selector_info("line", 0, int_ops); 
        add_selector_info("sels", 1, sequence_of_string_ops); 
        add_selector_info("val", 2, expr_ops); 
        find_selector_ops("record", 3, &(record_line_sels_val_ops));
        add_parm_info_type(0, record_line_sels_val_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_record_line_sels_val_ops));
        add_selector_info("fields", 0, sequence_of_record_line_sels_val_ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_fields_type__ops));
        add_selector_info("a_cons", 0, record_elts_low_type__ops); 
        add_selector_info("any_", 1, expr_ops); 
        add_selector_info("apply", 2, record_gen_parms_ops); 
        add_selector_info("bad", 3, null_ops); 
        add_selector_info("bool_", 4, bool_ops); 
        add_selector_info("cand_", 5, record_left_right_ops); 
        add_selector_info("char_", 6, char_ops); 
        add_selector_info("cor_", 7, record_left_right_ops); 
        add_selector_info("down_", 8, expr_ops); 
        add_selector_info("fetch", 9, record_index_object_ops); 
        add_selector_info("force_", 10, typespec_ops); 
        add_selector_info("get", 11, record_object_sel_ops); 
        add_selector_info("idn", 12, idn_ops); 
        add_selector_info("infix", 13, record_left_neg_op_right_ops); 
        add_selector_info("int_", 14, int_ops); 
        add_selector_info("invoke", 15, record_apply_args_ops); 
        add_selector_info("minus", 16, expr_ops); 
        add_selector_info("not", 17, expr_ops); 
        add_selector_info("null_", 18, null_ops); 
        add_selector_info("op", 19, record_name_parms_type__ops); 
        add_selector_info("real_", 20, real_ops); 
        add_selector_info("ref", 21, record_idn_parms_ops); 
        add_selector_info("s_cons", 22, record_fields_type__ops); 
        add_selector_info("str", 23, string_ops); 
        add_selector_info("type_", 24, typespec_ops); 
        add_selector_info("type_of_", 25, expr_ops); 
        add_selector_info("up_", 26, expr_ops); 
        find_selector_ops("oneof", 27, &(oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops));
        add_selector_info("expr", 0, oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_expr_type__ops));
        expr_own_init = 1;
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE create ****/

errcode exprOPcreate(x, t, ret_1)
CLUREF x;
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (expr_own_init == 0) {
            err = expr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(276);

  LINE(277);
    {
    {
    CLUREF T_1_1;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[0]  = x.num;
    T_1_1.vec->data[1]  = t.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE create ****/


/**** BEGIN PROCEDURE get_abs ****/

errcode exprOPget_abs(x, ret_1)
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (expr_own_init == 0) {
            err = expr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(281);

  LINE(282);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = x.vec->data[0];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_abs ****/


/**** BEGIN PROCEDURE set_abs ****/

errcode exprOPset_abs(x, a)
CLUREF x;
CLUREF a;
    {
    errcode err;
    errcode ecode2;
        if (expr_own_init == 0) {
            err = expr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(285);

  LINE(286);
    {
    x.vec->data[0]  = a.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_abs ****/


/**** BEGIN PROCEDURE get_typespec ****/

errcode exprOPget_typespec(x, ret_1)
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (expr_own_init == 0) {
            err = expr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(289);

  LINE(290);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = x.vec->data[1];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_typespec ****/


/**** BEGIN PROCEDURE set_typespec ****/

errcode exprOPset_typespec(x, t)
CLUREF x;
CLUREF t;
    {
    errcode err;
    errcode ecode2;
        if (expr_own_init == 0) {
            err = expr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(293);

  LINE(294);
    {
    x.vec->data[1]  = t.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_typespec ****/

struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *oneof_none_one_ops;
struct OPS  *record_elts_low_type__ops;
struct OPS  *record_gen_parms_ops;
struct OPS  *record_left_right_ops;
struct OPS  *record_index_object_ops;
struct OPS  *record_object_sel_ops;
struct OPS  *record_left_neg_op_right_ops;
struct OPS  *record_apply_args_ops;
struct OPS  *record_name_parms_type__ops;
struct OPS  *record_idn_parms_ops;
struct OPS *sequence_of_string_table;
struct OPS *sequence_of_string_ops;
struct OPS *sequence_of_string_ops;
OWNPTR sequence_of_string_owns;
struct OPS  *record_line_sels_val_ops;
struct OPS *sequence_of_record_line_sels_val_table;
struct OPS *sequence_of_record_line_sels_val_ops;
struct OPS *sequence_of_record_line_sels_val_ops;
OWNPTR sequence_of_record_line_sels_val_owns;
struct OPS  *record_fields_type__ops;
struct OPS  *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops;
struct OPS  *record_expr_type__ops;
static int exprOPcopy_own_init = 0;

/**** BEGIN PROCEDURE copy ****/

errcode exprOPcopy(x, ret_1)
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (exprOPcopy_own_init == 0) {
        if (expr_own_init == 0) {
            err = expr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        exprOPcopy_own_init = 1;
    }
    enter_proc(297);

  LINE(298);
    {
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = 0;
    generic_CLU_proc.op_owns = record_expr_type__ops->entry[2].fcn->op_owns;
    generic_CLU_proc.proc = recordOPcopy;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = recordOPcopy(x, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE copy ****/


/**** BEGIN PROCEDURE equal ****/

errcode exprOPequal(x1, x2, ret_1)
CLUREF x1;
CLUREF x2;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (expr_own_init == 0) {
            err = expr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(301);

  LINE(302);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = (x1.num == x2.num)? true : false;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE equal ****/

struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *oneof_none_one_ops;
struct OPS  *record_elts_low_type__ops;
struct OPS  *record_gen_parms_ops;
struct OPS  *record_left_right_ops;
struct OPS  *record_index_object_ops;
struct OPS  *record_object_sel_ops;
struct OPS  *record_left_neg_op_right_ops;
struct OPS  *record_apply_args_ops;
struct OPS  *record_name_parms_type__ops;
struct OPS  *record_idn_parms_ops;
struct OPS *sequence_of_string_table;
struct OPS *sequence_of_string_ops;
struct OPS *sequence_of_string_ops;
OWNPTR sequence_of_string_owns;
struct OPS  *record_line_sels_val_ops;
struct OPS *sequence_of_record_line_sels_val_table;
struct OPS *sequence_of_record_line_sels_val_ops;
struct OPS *sequence_of_record_line_sels_val_ops;
OWNPTR sequence_of_record_line_sels_val_owns;
struct OPS  *record_fields_type__ops;
struct OPS  *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops;
static int exprOPsimilar_own_init = 0;

/**** BEGIN PROCEDURE similar ****/

errcode exprOPsimilar(x1, x2, ret_1)
CLUREF x1;
CLUREF x2;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (exprOPsimilar_own_init == 0) {
        if (expr_own_init == 0) {
            err = expr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        exprOPsimilar_own_init = 1;
    }
    enter_proc(305);

  LINE(306);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = x1.vec->data[0];
    T_1_2.num = x2.vec->data[0];
    generic_CLU_proc.type_owns = 0;
    generic_CLU_proc.op_owns = oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops->entry[1].fcn->op_owns;
    generic_CLU_proc.proc = oneofOPsimilar;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = oneofOPsimilar(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_3.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE similar ****/

struct OPS *sequence_of_expr_table;
struct OPS *sequence_of_expr_ops;
struct OPS *sequence_of_expr_ops;
OWNPTR sequence_of_expr_owns;
struct OPS  *oneof_none_one_ops;
struct OPS  *record_elts_low_type__ops;
struct OPS  *record_gen_parms_ops;
struct OPS  *record_left_right_ops;
struct OPS  *record_index_object_ops;
struct OPS  *record_object_sel_ops;
struct OPS  *record_left_neg_op_right_ops;
struct OPS  *record_apply_args_ops;
struct OPS  *record_name_parms_type__ops;
struct OPS  *record_idn_parms_ops;
struct OPS *sequence_of_string_table;
struct OPS *sequence_of_string_ops;
struct OPS *sequence_of_string_ops;
OWNPTR sequence_of_string_owns;
struct OPS  *record_line_sels_val_ops;
struct OPS *sequence_of_record_line_sels_val_table;
struct OPS *sequence_of_record_line_sels_val_ops;
struct OPS *sequence_of_record_line_sels_val_ops;
OWNPTR sequence_of_record_line_sels_val_owns;
struct OPS  *record_fields_type__ops;
struct OPS  *oneof_a_cons_any__apply_bad_bool__cand__char__cor__down__fetch_force__get_idn_infix_int__invoke_minus_not_null__op_real__ref_s_cons_str_type__type_of__up__ops;
struct OPS  *record_expr_type__ops;
static int exprOP_gcd_own_init = 0;

/**** BEGIN PROCEDURE _gcd ****/

errcode exprOP_gcd(x, tab, ret_1)
CLUREF x;
CLUREF tab;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (exprOP_gcd_own_init == 0) {
        if (expr_own_init == 0) {
            err = expr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        exprOP_gcd_own_init = 1;
    }
    enter_proc(309);

  LINE(310);
    {
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = 0;
    generic_CLU_proc.op_owns = record_expr_type__ops->entry[6].fcn->op_owns;
    generic_CLU_proc.proc = recordOP_gcd;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = recordOP_gcd(x, tab, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE _gcd ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[9];
} expr_OPS;

CLU_proc expr_oe__gcd = {{0,0,0,0}, exprOP_gcd, 0};
CLU_proc expr_oe_copy = {{0,0,0,0}, exprOPcopy, 0};
CLU_proc expr_oe_create = {{0,0,0,0}, exprOPcreate, 0};
CLU_proc expr_oe_equal = {{0,0,0,0}, exprOPequal, 0};
CLU_proc expr_oe_get_abs = {{0,0,0,0}, exprOPget_abs, 0};
CLU_proc expr_oe_get_typespec = {{0,0,0,0}, exprOPget_typespec, 0};
CLU_proc expr_oe_set_abs = {{0,0,0,0}, exprOPset_abs, 0};
CLU_proc expr_oe_set_typespec = {{0,0,0,0}, exprOPset_typespec, 0};
CLU_proc expr_oe_similar = {{0,0,0,0}, exprOPsimilar, 0};

expr_OPS expr_ops_actual = {9, (OWNPTR)&expr_own_init, (OWNPTR)&expr_own_init, {
    {&expr_oe__gcd, "_gcd"},
    {&expr_oe_copy, "copy"},
    {&expr_oe_create, "create"},
    {&expr_oe_equal, "equal"},
    {&expr_oe_get_abs, "get_abs"},
    {&expr_oe_get_typespec, "get_typespec"},
    {&expr_oe_set_abs, "set_abs"},
    {&expr_oe_set_typespec, "set_typespec"},
    {&expr_oe_similar, "similar"}}};

struct OPS *expr_ops = (struct OPS *)&expr_ops_actual;

/**** END CLUSTER expr ****/
