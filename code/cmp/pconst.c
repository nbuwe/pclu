
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


extern errcode p_type();
extern errcode p_envOPassume();
extern errcode p_envOPget_unknown_type();
CLUREF STR_typespec;
static int p_type1_own_init = 0;

/**** BEGIN PROCEDURE p_type1 ****/

errcode p_type1(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (p_type1_own_init == 0) {
        stringOPcons("typespec", CLU_1, CLU_8, &STR_typespec);
        p_type1_own_init = 1;
    }
    enter_proc(6);

  LINE(7);
    {
    {
    CLUREF T_2_1;
    err = p_type(e, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    ret_1->num = T_2_1.num;
    }
    {signal (ERR_ok);}}
        goto end_1;
        ex_1:
            if ((err == ERR_none)) {

  LINE(8);
                {
                err = p_envOPassume(e, STR_typespec);
                if (err != ERR_ok) goto ex_0;
                }
            }
            else if ((err == ERR_bad)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(11);
    {
    {
    CLUREF T_1_1;
    err = p_envOPget_unknown_type(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_type1 ****/


extern errcode p_envOPget_peek1();
extern errcode p_envOPnext_token();
extern errcode p_clutype();
extern errcode p_seltype();
extern errcode sequenceOPnew();
extern errcode typespecOPcreate();
extern errcode oneofOPmake_10();
extern errcode p_applytype();
extern errcode p_idn_type();

/**** BEGIN PROCEDURE p_type ****/

errcode p_type(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF k;
    CLUREF d;
    CLUREF xclu;
    enter_proc(19);

  LINE(20);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 37: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(22);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(23);
            {
            {
            ret_1->num = k.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 38: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        k.num = T_1_3.num;

  LINE(25);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(26);
            {
            switch (k.cell->tag) {
            case 2: 
                 {CLUREF T_2_1;
                T_2_1.num = k.cell->value;
                d.num = T_2_1.num;

  LINE(28);
                    {
                    {
                    CLUREF T_3_1;
                    err = p_clutype(e, d, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    ret_1->num = T_3_1.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            case 4: 
                 {CLUREF T_2_2;
                T_2_2.num = k.cell->value;
                d.num = T_2_2.num;

  LINE(30);
                    {
                    {
                    CLUREF T_3_1;
                    err = p_seltype(e, d, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    ret_1->num = T_3_1.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            case 3: 
                 {CLUREF T_2_3;
                T_2_3.num = k.cell->value;
                d.num = T_2_3.num;

  LINE(32);
                    {
                        {CLUREF T_3_1;
                        CLUREF T_3_2;
                        RecordAlloc(2, T_3_1);
                        T_3_1.vec->data[0]  = d.num;
                        err = sequenceOPnew(&T_3_2);
                        if (err != ERR_ok) goto ex_0;
                        T_3_1.vec->data[1]  = T_3_2.num;
                        xclu.num = T_3_1.num;
                        }
                        }

  LINE(34);
                    {
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CellAlloc(10, xclu.num, T_3_1);
                    err = typespecOPcreate(T_3_1, CLU_0, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    ret_1->num = T_3_2.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            case 1: 
                 {CLUREF T_2_4;
                T_2_4.num = k.cell->value;
                d.num = T_2_4.num;

  LINE(36);
                    {
                    {
                    CLUREF T_3_1;
                    err = p_applytype(e, d, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    ret_1->num = T_3_1.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            }
            }
            break;
            }
    case 16: 
         {CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        k.num = T_1_4.num;

  LINE(39);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(40);
            {
            {
            CLUREF T_2_1;
            err = p_idn_type(e, k, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(42);
        {
        {signal (ERR_none);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_type ****/


extern errcode p_fieldspeclist();
extern errcode oneofOPmake_7();

/**** BEGIN PROCEDURE p_seltype ****/

errcode p_seltype(e, gen, ret_1)
CLUREF e;
CLUREF gen;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF parms;
    CLUREF selt;
    enter_proc(46);

  LINE(47);
    {
        {CLUREF T_1_1;
        err = p_fieldspeclist(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        parms.num = T_1_1.num;
        }
        }

  LINE(48);
    {
        {CLUREF T_1_1;
        RecordAlloc(2, T_1_1);
        T_1_1.vec->data[0]  = gen.num;
        T_1_1.vec->data[1]  = parms.num;
        selt.num = T_1_1.num;
        }
        }

  LINE(50);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(7, selt.num, T_1_1);
    err = typespecOPcreate(T_1_1, CLU_0, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_seltype ****/


extern errcode p_blist();
extern errcode p_expr();
extern errcode oneofOPmake_3();
extern struct REQS *p_blist_of_t_reqs;
extern struct OPS *expr_ops;
extern OWN_req p_blist_ownreqs;
struct OPS *p_blist_of_expr_table;
struct OPS *p_blist_of_expr_ops;
struct OPS *p_blist_of_expr_ops;
OWNPTR p_blist_of_expr_owns;
CLUREF STR_constant;
static int p_clutype_own_init = 0;

/**** BEGIN PROCEDURE p_clutype ****/

errcode p_clutype(e, gen, ret_1)
CLUREF e;
CLUREF gen;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF parms;
    CLUREF clut;
        if (p_clutype_own_init == 0) {
        add_parm_info_type(0, expr_ops, p_blist_of_t_reqs);
        find_prociter_instance(p_blist, 1, &p_blist_ownreqs, &(p_blist_of_expr_ops));
        stringOPcons("constant", CLU_1, CLU_8, &STR_constant);
        p_clutype_own_init = 1;
    }
    enter_proc(53);

  LINE(54);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_expr;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_blist_of_expr_ops->op_owns;
        generic_CLU_proc.proc = p_blist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_blist(e, T_1_1, CLU_1, STR_constant, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        parms.num = T_1_2.num;
        }
        }

  LINE(55);
    {
        {CLUREF T_1_1;
        RecordAlloc(2, T_1_1);
        T_1_1.vec->data[0]  = gen.num;
        T_1_1.vec->data[1]  = parms.num;
        clut.num = T_1_1.num;
        }
        }

  LINE(57);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(3, clut.num, T_1_1);
    err = typespecOPcreate(T_1_1, CLU_0, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_clutype ****/


extern errcode p_plist();
extern errcode p_values();
extern errcode boolOPnot();
extern errcode stringOPequal();
extern errcode duOPget_unique();
extern errcode p_signals();
extern errcode oneofOPmake_2();
extern struct REQS *p_plist_of_t_reqs;
extern struct OPS *typespec_ops;
extern OWN_req p_plist_ownreqs;
struct OPS *p_plist_of_typespec_table;
struct OPS *p_plist_of_typespec_ops;
struct OPS *p_plist_of_typespec_ops;
OWNPTR p_plist_of_typespec_owns;
CLUREF STR_itertype;
static int p_applytype_own_init = 0;

/**** BEGIN PROCEDURE p_applytype ****/

errcode p_applytype(e, gen, ret_1)
CLUREF e;
CLUREF gen;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF args;
    CLUREF vals;
    CLUREF sigs;
    CLUREF at;
        if (p_applytype_own_init == 0) {
        add_parm_info_type(0, typespec_ops, p_plist_of_t_reqs);
        find_prociter_instance(p_plist, 1, &p_plist_ownreqs, &(p_plist_of_typespec_ops));
        stringOPcons("typespec", CLU_1, CLU_8, &STR_typespec);
        stringOPcons("itertype", CLU_1, CLU_8, &STR_itertype);
        p_applytype_own_init = 1;
    }
    enter_proc(60);

  LINE(61);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_type;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_plist_of_typespec_ops->op_owns;
        generic_CLU_proc.proc = p_plist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_plist(e, T_1_1, CLU_0, CLU_1, STR_typespec, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        args.num = T_1_2.num;
        }
        }

  LINE(63);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        err = duOPget_unique(gen, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = ((T_1_1.str->size != STR_itertype.str->size)? false :
            !(bcmp(T_1_1.str->data, STR_itertype.str->data, T_1_1.str->size)));
        T_1_3.num = T_1_2.num ^ 1;
        err = p_values(e, T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        vals.num = T_1_4.num;
        }
        }

  LINE(64);
    {
        {CLUREF T_1_1;
        err = p_signals(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        sigs.num = T_1_1.num;
        }
        }

  LINE(65);
    {
        {CLUREF T_1_1;
        RecordAlloc(4, T_1_1);
        T_1_1.vec->data[1]  = gen.num;
        T_1_1.vec->data[0]  = args.num;
        T_1_1.vec->data[3]  = vals.num;
        T_1_1.vec->data[2]  = sigs.num;
        at.num = T_1_1.num;
        }
        }

  LINE(69);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(2, at.num, T_1_1);
    err = typespecOPcreate(T_1_1, CLU_0, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_applytype ****/


extern errcode p_is_seltype();
extern errcode oneofOPmake_11();
extern errcode oneofOPmake_5();
struct OPS *p_blist_of_expr_table;
struct OPS *p_blist_of_expr_ops;
struct OPS *p_blist_of_expr_ops;
OWNPTR p_blist_of_expr_owns;
static int p_idn_type_own_init = 0;

/**** BEGIN PROCEDURE p_idn_type ****/

errcode p_idn_type(e, id, ret_1)
CLUREF e;
CLUREF id;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF abs;
    CLUREF parms;
        if (p_idn_type_own_init == 0) {
        add_parm_info_type(0, expr_ops, p_blist_of_t_reqs);
        find_prociter_instance(p_blist, 1, &p_blist_ownreqs, &(p_blist_of_expr_ops));
        stringOPcons("constant", CLU_1, CLU_8, &STR_constant);
        p_idn_type_own_init = 1;
    }
    enter_proc(72);

  LINE(74);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 19: 
         {

  LINE(76);
            {
            CLUREF T_2_1;
            err = p_is_seltype(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            if (T_2_1.num == true) {

  LINE(77);
                {
                    {CLUREF T_3_1;
                    err = p_fieldspeclist(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    parms.num = T_3_1.num;
                    }
                    }

  LINE(78);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                RecordAlloc(2, T_3_1);
                T_3_1.vec->data[0]  = id.num;
                T_3_1.vec->data[1]  = parms.num;
                CellAlloc(11, T_3_1.num, T_3_2);
                abs.num = T_3_2.num;
                }
                }
            else {

  LINE(80);
                {
                    {CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = proctypeOPnew(CLU_0, &T_3_1.proc);
                    if (err!= ERR_ok) goto ex_0;
                    T_3_1.proc->type_owns = 0;
                    T_3_1.proc->op_owns = 0;
                    T_3_1.proc->proc = p_expr;
                    generic_CLU_proc.type_owns = 0;
                    generic_CLU_proc.op_owns = (long)p_blist_of_expr_ops->op_owns;
                    generic_CLU_proc.proc = p_blist;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = p_blist(e, T_3_1, CLU_1, STR_constant, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    parms.num = T_3_2.num;
                    }
                    }

  LINE(82);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                RecordAlloc(2, T_3_1);
                T_3_1.vec->data[0]  = id.num;
                T_3_1.vec->data[1]  = parms.num;
                CellAlloc(10, T_3_1.num, T_3_2);
                abs.num = T_3_2.num;
                }
                }}/* end if */
            break;
            }
    default: {

  LINE(86);
        {
        CLUREF T_2_1;
        CellAlloc(5, id.num, T_2_1);
        abs.num = T_2_1.num;
        }
    }
    }
    }

  LINE(88);
    {
    {
    CLUREF T_1_1;
    err = typespecOPcreate(abs, CLU_0, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_idn_type ****/


extern errcode p_envOPpeek();
extern errcode intOPadd();

/**** BEGIN PROCEDURE p_is_seltype ****/

errcode p_is_seltype(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF i;
    enter_proc(91);

  LINE(92);
    {
        {i.num = 2;
        }
        }

  LINE(93);
    for (;;) {
        if (true != true) { break; }

  LINE(94);
        {
        CLUREF T_2_1;
        err = p_envOPpeek(e, i, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 16: 
             {
                break;
                }
        default: {

  LINE(96);
            {
            {
            ret_1->tf = false;
            }
            {signal (ERR_ok);}}
        }
        }
        }

  LINE(98);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = i.num + 1;
         if ((T_2_1.num > 0 && i.num < 0 && 1 < 0) || 
             (T_2_1.num < 0 && i.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = p_envOPpeek(e, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_2.cell->tag) {
        case 2: 
             {

  LINE(99);
                {
                {
                ret_1->tf = true;
                }
                {signal (ERR_ok);}}
                break;
                }
        case 3: 
             {

  LINE(100);
                {
                CLUREF T_3_1;
                T_3_1.num = i.num + 2;
                 if ((T_3_1.num > 0 && i.num < 0 && 2 < 0) || 
                     (T_3_1.num < 0 && i.num > 0 && 2 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                i.num = T_3_1.num;
                }
                break;
                }
        default: {

  LINE(101);
            {
            {
            ret_1->tf = false;
            }
            {signal (ERR_ok);}}
        }
        }
        }
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_is_seltype ****/


extern errcode p_order();
extern errcode p_fieldspec();
extern errcode recordOPget_1();
extern struct OPS *string_ops;
struct OPS  *record_sel_type__ops;
extern struct REQS *p_order_of_t_reqs;
extern struct OPS *record_sel_type__ops;
extern OWN_req p_order_ownreqs;
struct OPS *p_order_of_record_sel_type__table;
struct OPS *p_order_of_record_sel_type__ops;
struct OPS *p_order_of_record_sel_type__ops;
OWNPTR p_order_of_record_sel_type__owns;
CLUREF STR__133field_137spec_137list_135;
CLUREF STR_fieldspec;
CLUREF STR__135_040in_040_133fieldspec_137list_135;
static int p_fieldspeclist_own_init = 0;

/**** BEGIN PROCEDURE p_fieldspeclist ****/

errcode p_fieldspeclist(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF specs;
        if (p_fieldspeclist_own_init == 0) {
        add_selector_info("sel", 0, string_ops); 
        add_selector_info("type_", 1, typespec_ops); 
        find_selector_ops("record", 2, &(record_sel_type__ops));
        add_parm_info_type(0, record_sel_type__ops, p_order_of_t_reqs);
        find_prociter_instance(p_order, 1, &p_order_ownreqs, &(p_order_of_record_sel_type__ops));
        stringOPcons("[field_spec_list]", CLU_1, CLU_17, &STR__133field_137spec_137list_135);
        stringOPcons("fieldspec", CLU_1, CLU_9, &STR_fieldspec);
        stringOPcons("] in [fieldspec_list]", CLU_1, CLU_21, &STR__135_040in_040_133fieldspec_137list_135);
        p_fieldspeclist_own_init = 1;
    }
    enter_proc(109);

  LINE(110);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 19: 
         {

  LINE(111);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(112);
        {
        err = p_envOPassume(e, STR__133field_137spec_137list_135);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(113);
        {
        {
        CLUREF T_2_1;
        err = sequenceOPnew(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(115);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_fieldspec;
        err = proctypeOPnew(CLU_1, &T_1_2.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_2.proc->proc = recordOPget_1;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_order_of_record_sel_type__ops->op_owns;
        generic_CLU_proc.proc = p_order;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_order(e, T_1_1, T_1_2, STR_fieldspec, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        specs.num = T_1_3.num;
        }
        }

  LINE(117);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 26: 
         {

  LINE(118);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(119);
        {
        err = p_envOPassume(e, STR__135_040in_040_133fieldspec_137list_135);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(121);
    {
    {
    ret_1->num = specs.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_fieldspeclist ****/


extern errcode p_clist();
extern errcode p_name();
extern errcode p_type1();
extern errcode sequenceOPelements();
extern struct REQS *p_clist_of_t_reqs;
extern OWN_req p_clist_ownreqs;
struct OPS *p_clist_of_string_table;
struct OPS *p_clist_of_string_ops;
struct OPS *p_clist_of_string_ops;
OWNPTR p_clist_of_string_owns;
CLUREF STR_name;
CLUREF STR__072_040type_040in_040field_137spec;
static int p_fieldspec_own_init = 0;

/**** BEGIN ITERATOR p_fieldspec ****/

errcode p_fieldspec(e, proc, user_locals, iecode)
CLUREF e;
errcode (*proc)();
char **user_locals;
errcode *iecode;
    {
    errcode ecode;
    errcode err;
    errcode ecode2;
    bool body_ctrl_req;
    CLUREF sels;
    CLUREF t;
    CLUREF sel;
        if (p_fieldspec_own_init == 0) {
        add_parm_info_type(0, string_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_string_ops));
        stringOPcons("name", CLU_1, CLU_4, &STR_name);
        stringOPcons(": type in field_spec", CLU_1, CLU_20, &STR__072_040type_040in_040field_137spec);
        p_fieldspec_own_init = 1;
    }
    enter_proc(126);

  LINE(127);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 16: 
         {
            break;
            }
    default: {

  LINE(129);
        {
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(131);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_name;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_clist_of_string_ops->op_owns;
        generic_CLU_proc.proc = p_clist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_clist(e, T_1_1, STR_name, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        sels.num = T_1_2.num;
        }
        }

  LINE(133);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: 
         {

  LINE(134);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(135);
            {
            CLUREF T_2_1;
            err = p_type1(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            t.num = T_2_1.num;
            }
            break;
            }
    default: {

  LINE(136);
        {
        err = p_envOPassume(e, STR__072_040type_040in_040field_137spec);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(137);
        {
        CLUREF T_2_1;
        err = p_envOPget_unknown_type(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        t.num = T_2_1.num;
        }
    }
    }
    }

  LINE(139);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = sels.vec->size; 
        T_1_3 = sels;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            sel.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(140);
            {
            CLUREF T_2_1;
            RecordAlloc(2, T_2_1);
            T_2_1.vec->data[0]  = sel.num;
            T_2_1.vec->data[1]  = t.num;
            err = proc(T_2_1, user_locals, iecode);
            if (err != ERR_ok) {
            if (err == ERR_break) {signal(ERR_break);}
            if (err == ERR_iterbodyreturn) {signal(ERR_iterbodyreturn);}
            if (err == ERR_iterbodyexit) {signal(ERR_iterbodyexit);}
            if (err == ERR_iterbodysignal) {signal(ERR_iterbodysignal);}
            {signal(err);
                }}
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END ITERATOR p_fieldspec ****/


extern errcode p_envOPerr();
struct OPS *p_plist_of_typespec_table;
struct OPS *p_plist_of_typespec_ops;
struct OPS *p_plist_of_typespec_ops;
OWNPTR p_plist_of_typespec_owns;
CLUREF STR_use_040of_040returns_040instead_040of_040yields;
CLUREF STR_use_040of_040yields_040instead_040of_040returns;
static int p_values_own_init = 0;

/**** BEGIN PROCEDURE p_values ****/

errcode p_values(e, procdef, ret_1)
CLUREF e;
CLUREF procdef;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (p_values_own_init == 0) {
        add_parm_info_type(0, typespec_ops, p_plist_of_t_reqs);
        find_prociter_instance(p_plist, 1, &p_plist_ownreqs, &(p_plist_of_typespec_ops));
        stringOPcons("use of returns instead of yields", CLU_1, CLU_32, &STR_use_040of_040returns_040instead_040of_040yields);
        stringOPcons("use of yields instead of returns", CLU_1, CLU_32, &STR_use_040of_040yields_040instead_040of_040returns);
        stringOPcons("typespec", CLU_1, CLU_8, &STR_typespec);
        p_values_own_init = 1;
    }
    enter_proc(148);

  LINE(149);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 30: 
         {

  LINE(150);
            {
            CLUREF T_2_1;
            T_2_1.num = procdef.num ^ 1;
            if (T_2_1.num == true) {

  LINE(151);
                {
                err = p_envOPerr(e, STR_use_040of_040returns_040instead_040of_040yields, CLU_1);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */
            break;
            }
    case 41: 
         {

  LINE(153);
            {
            if (procdef.num == true) {

  LINE(154);
                {
                err = p_envOPerr(e, STR_use_040of_040yields_040instead_040of_040returns, CLU_1);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */
            break;
            }
    default: {

  LINE(156);
        {
        {
        CLUREF T_2_1;
        err = sequenceOPnew(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(158);
    {
    CLUREF T_1_1;
    err = p_envOPnext_token(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(159);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = proctypeOPnew(CLU_0, &T_1_1.proc);
    if (err!= ERR_ok) goto ex_0;
    T_1_1.proc->type_owns = 0;
    T_1_1.proc->op_owns = 0;
    T_1_1.proc->proc = p_type;
    generic_CLU_proc.type_owns = 0;
    generic_CLU_proc.op_owns = (long)p_plist_of_typespec_ops->op_owns;
    generic_CLU_proc.proc = p_plist;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = p_plist(e, T_1_1, CLU_0, CLU_0, STR_typespec, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_values ****/


extern errcode p_exceptionlist();

/**** BEGIN PROCEDURE p_signals ****/

errcode p_signals(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    enter_proc(164);

  LINE(165);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 33: 
         {

  LINE(166);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(167);
            {
            {
            CLUREF T_2_1;
            err = p_exceptionlist(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(168);
        {
        {
        CLUREF T_2_1;
        err = sequenceOPnew(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_signals ****/


extern errcode p_exception();
extern struct REQS *sequence_of_t_reqs;
extern OWN_req sequence_ownreqs;
extern struct OPS *sequence_ops;
struct OPS *sequence_of_typespec_table;
struct OPS *sequence_of_typespec_ops;
struct OPS *sequence_of_typespec_ops;
OWNPTR sequence_of_typespec_owns;
extern struct OPS *sequence_of_typespec_ops;
struct OPS  *record_name_types_ops;
extern struct OPS *record_name_types_ops;
struct OPS *p_order_of_record_name_types_table;
struct OPS *p_order_of_record_name_types_ops;
struct OPS *p_order_of_record_name_types_ops;
OWNPTR p_order_of_record_name_types_owns;
CLUREF STR__050exception_137list_051;
CLUREF STR_exception;
CLUREF STR__051_040in_040_050exception_137list_051;
static int p_exceptionlist_own_init = 0;

/**** BEGIN PROCEDURE p_exceptionlist ****/

errcode p_exceptionlist(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF sigs;
        if (p_exceptionlist_own_init == 0) {
        add_parm_info_type(0, typespec_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_typespec_ops));
        add_selector_info("name", 0, string_ops); 
        add_selector_info("types", 1, sequence_of_typespec_ops); 
        find_selector_ops("record", 2, &(record_name_types_ops));
        add_parm_info_type(0, record_name_types_ops, p_order_of_t_reqs);
        find_prociter_instance(p_order, 1, &p_order_ownreqs, &(p_order_of_record_name_types_ops));
        stringOPcons("(exception_list)", CLU_1, CLU_16, &STR__050exception_137list_051);
        stringOPcons("exception", CLU_1, CLU_9, &STR_exception);
        stringOPcons(") in (exception_list)", CLU_1, CLU_21, &STR__051_040in_040_050exception_137list_051);
        p_exceptionlist_own_init = 1;
    }
    enter_proc(180);

  LINE(181);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 21: 
         {

  LINE(182);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(183);
        {
        err = p_envOPassume(e, STR__050exception_137list_051);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(184);
        {
        {
        CLUREF T_2_1;
        err = sequenceOPnew(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(186);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_exception;
        err = proctypeOPnew(CLU_1, &T_1_2.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_2.proc->proc = recordOPget_1;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_order_of_record_name_types_ops->op_owns;
        generic_CLU_proc.proc = p_order;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_order(e, T_1_1, T_1_2, STR_exception, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        sigs.num = T_1_3.num;
        }
        }

  LINE(188);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 28: 
         {

  LINE(189);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(190);
        {
        err = p_envOPassume(e, STR__051_040in_040_050exception_137list_051);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(192);
    {
    {
    ret_1->num = sigs.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_exceptionlist ****/


struct OPS *p_plist_of_typespec_table;
struct OPS *p_plist_of_typespec_ops;
struct OPS *p_plist_of_typespec_ops;
OWNPTR p_plist_of_typespec_owns;
static int p_exception_own_init = 0;

/**** BEGIN ITERATOR p_exception ****/

errcode p_exception(e, proc, user_locals, iecode)
CLUREF e;
errcode (*proc)();
char **user_locals;
errcode *iecode;
    {
    errcode ecode;
    errcode err;
    errcode ecode2;
    bool body_ctrl_req;
    CLUREF n;
    CLUREF types;
        if (p_exception_own_init == 0) {
        add_parm_info_type(0, typespec_ops, p_plist_of_t_reqs);
        find_prociter_instance(p_plist, 1, &p_plist_ownreqs, &(p_plist_of_typespec_ops));
        stringOPcons("typespec", CLU_1, CLU_8, &STR_typespec);
        p_exception_own_init = 1;
    }
    enter_proc(195);

  LINE(196);
    {
        {CLUREF T_2_1;
        err = p_name(e, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        n.num = T_2_1.num;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_none)) {

  LINE(197);
                {
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(198);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_type;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_plist_of_typespec_ops->op_owns;
        generic_CLU_proc.proc = p_plist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_plist(e, T_1_1, CLU_1, CLU_0, STR_typespec, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        types.num = T_1_2.num;
        }
        }

  LINE(200);
    {
    CLUREF T_1_1;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[0]  = n.num;
    T_1_1.vec->data[1]  = types.num;
    err = proc(T_1_1, user_locals, iecode);
    if (err != ERR_ok) {
    if (err == ERR_break) {signal(ERR_break);}
    if (err == ERR_iterbodyreturn) {signal(ERR_iterbodyreturn);}
    if (err == ERR_iterbodyexit) {signal(ERR_iterbodyexit);}
    if (err == ERR_iterbodysignal) {signal(ERR_iterbodysignal);}
    {signal(err);
        }}
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END ITERATOR p_exception ****/


extern errcode idnOPget_str();

/**** BEGIN PROCEDURE p_name ****/

errcode p_name(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF k;
    enter_proc(206);

  LINE(207);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 16: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(209);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(210);
            {
            {
            CLUREF T_2_1;
            err = idnOPget_str(k, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(212);
        {
        {signal (ERR_none);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_name ****/



typedef struct {
long count;
} p_order_of_t_REQS;

p_order_of_t_REQS p_order_of_t_reqs_actual = {0};

struct REQS * p_order_of_t_reqs = (struct REQS *)&p_order_of_t_reqs_actual;


typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    } p_order_of_t_OPS;

extern errcode p_order_IB_1();
extern errcode arrayOPnew();
extern errcode intOPle();
extern errcode stringOPgt();
extern errcode arrayOPfetch();
extern errcode stringOPconcat();
extern errcode intOPfrom_to();
extern errcode arrayOPstore();
extern errcode arrayOPaddh();
extern errcode intOPequal();
extern errcode sequenceOPa2s();
CLUREF STR_duplicate_040name_040_047;
CLUREF STR__047_040in_040;
CLUREF STR__137list;
CLUREF STR_extra_040comma_040at_040end_040of_040;

typedef struct {
    long p_order_own_init;
    p_order_of_t_OPS *t_ops;
    } p_order_OWN_DEFN;
OWN_req p_order_ownreqs = {sizeof(p_order_OWN_DEFN), 1};


/**** BEGIN PROCEDURE p_order ****/

errcode p_order(e, p_t, get, what, ret_1)
CLUREF e;
CLUREF p_t;
CLUREF get;
CLUREF what;
CLUREF *ret_1;
    {
    struct {
        errcode err;
        errcode ecode2;
        p_order_OWN_DEFN *op_own_ptr;
        CLUREF list;
        CLUREF high;
        CLUREF none;
        CLUREF x;
        CLUREF s;
        CLUREF i;
        CLUREF j;
        CLUREF ox;
        CLUREF e;
        CLUREF p_t;
        CLUREF get;
        CLUREF what;
        } locals;
    locals.e = e;
    locals.p_t = p_t;
    locals.get = get;
    locals.what = what;
    locals.op_own_ptr = (p_order_OWN_DEFN*) CUR_PROC_VAR.proc->op_owns;
        if (locals.op_own_ptr->p_order_own_init == 0) {
        stringOPcons("duplicate name \'", CLU_1, CLU_16, &STR_duplicate_040name_040_047);
        stringOPcons("\' in ", CLU_1, CLU_5, &STR__047_040in_040);
        stringOPcons("_list", CLU_1, CLU_5, &STR__137list);
        stringOPcons("extra comma at end of ", CLU_1, CLU_22, &STR_extra_040comma_040at_040end_040of_040);
        }
        if (locals.op_own_ptr->p_order_own_init == 0) {
        locals.op_own_ptr->p_order_own_init = 1;
    }
    enter_proc(218);

  LINE(223);
    {
        {CLUREF T_1_1;
        locals.err = arrayOPnew(&T_1_1);
        if (locals.err != ERR_ok) goto ex_0;
        locals.list.num = T_1_1.num;
        }
        }

  LINE(224);
    {
        {locals.high.num = 0;
        }
        }

  LINE(225);
    for (;;) {
        if (true != true) { break; }

  LINE(226);
        {
            {locals.none.tf = true;
            }
            }

  LINE(227);
        {
            CUR_PROC_VAR = locals.p_t;
            locals.err = locals.p_t.proc->proc(locals.e, p_order_IB_1, &locals, &locals.ecode2);
            if (locals.err == ERR_iterbodyreturn) {
            ret_1->num = elist[0].num;
            signal(ERR_ok);}
            if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
            if (locals.err == ERR_break) locals.err = ERR_ok;
            if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
            if (locals.err != ERR_ok) goto ex_0;
            }

  LINE(249);
        {
        if (locals.none.num == true) {

  LINE(250);
            {
            CLUREF T_3_1;
            locals.err = stringOPconcat(locals.what, STR__137list, &T_3_1);
            if (locals.err != ERR_ok) goto ex_0;
            locals.what.num = T_3_1.num;
            }

  LINE(251);
            {
            CLUREF T_3_1;
            T_3_1.num = (locals.high.num == 0)? true : false;
            if (T_3_1.num == true) {

  LINE(252);
                {
                locals.err = p_envOPassume(locals.e, locals.what);
                if (locals.err != ERR_ok) goto ex_0;
                }
                }
            else {

  LINE(253);
                {
                CLUREF T_4_1;
                locals.err = stringOPconcat(STR_extra_040comma_040at_040end_040of_040, locals.what, &T_4_1);
                if (locals.err != ERR_ok) goto ex_0;
                locals.err = p_envOPerr(locals.e, T_4_1, CLU_1);
                if (locals.err != ERR_ok) goto ex_0;
                }
                }}/* end if */

  LINE(256);
            {
            {
            CLUREF T_3_1;
            locals.err = sequenceOPa2s(locals.list, &T_3_1);
            if (locals.err != ERR_ok) goto ex_0;
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(258);
        {
        CLUREF T_2_1;
        locals.err = p_envOPget_peek1(locals.e, &T_2_1);
        if (locals.err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 3: 
             {

  LINE(259);
                {
                CLUREF T_3_1;
                locals.err = p_envOPnext_token(locals.e, &T_3_1);
                if (locals.err != ERR_ok) goto ex_0;
                }
                break;
                }
        default: {

  LINE(260);
            {
            {
            CLUREF T_3_1;
            locals.err = sequenceOPa2s(locals.list, &T_3_1);
            if (locals.err != ERR_ok) goto ex_0;
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
        }
        }
        }
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_order ****/


/**** BEGIN ITERATOR BODIES for p_order ****/

errcode p_order_IB_1(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    errcode err;
    errcode ecode2;
p_order_OWN_DEFN *op_own_ptr;
    CLUREF list;
    CLUREF high;
    CLUREF none;
    CLUREF x;
    CLUREF s;
    CLUREF i;
    CLUREF j;
    CLUREF ox;
    CLUREF e;
    CLUREF p_t;
    CLUREF get;
    CLUREF what;
    } *locals;
{
    locals->x.num = iv_1.num;
    enter_iter_body_proc(228);

  FB_LINE(228);
    {
    locals->none.tf = false;
    }

  FB_LINE(229);
    {
        {CLUREF T_1_1;
        CUR_PROC_VAR = locals->get;
        locals->err = locals->get.proc->proc(locals->x, &T_1_1);
        if (locals->err != ERR_ok) goto ex_0;
        locals->s.num = T_1_1.num;
        }
        }

  FB_LINE(230);
    {
        {locals->i.num = 1;
        }
        }

  FB_LINE(231);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        T_1_2.num = (locals->i.num <= locals->high.num)? true : false;
        T_1_1.num = T_1_2.num;
        if (T_1_2.num) {
            if (locals->i.num < locals->list.array->ext_low || locals->i.num > locals->list.array->ext_high ) {
                locals->err = ERR_bounds;
                goto ex_0;}
            T_1_3.num = locals->list.array->store->data[locals->i.num - locals->list.array->ext_low + locals->list.array->int_low];
            CUR_PROC_VAR = locals->get;
            locals->err = locals->get.proc->proc(T_1_3, &T_1_4);
            if (locals->err != ERR_ok) goto ex_0;
            locals->err = stringOPgt(locals->s, T_1_4, &T_1_5);
            if (locals->err != ERR_ok) goto ex_0;
            T_1_1.num = T_1_5.num;
        }
        if (T_1_1.num != true) { break; }

  FB_LINE(232);
        {
        CLUREF T_2_1;
        T_2_1.num = locals->i.num + 1;
         if ((T_2_1.num > 0 && locals->i.num < 0 && 1 < 0) || 
             (T_2_1.num < 0 && locals->i.num > 0 && 1 > 0)) {
            locals->err = ERR_overflow;
            goto ex_0;}
        locals->i.num = T_2_1.num;
        }
        }
        end_while_2:;

  FB_LINE(234);
    {
    CLUREF T_1_1;
    T_1_1.num = (locals->i.num <= locals->high.num)? true : false;
    if (T_1_1.num == true) {

  FB_LINE(235);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        if (locals->i.num < locals->list.array->ext_low || locals->i.num > locals->list.array->ext_high ) {
            locals->err = ERR_bounds;
            goto ex_0;}
        T_2_1.num = locals->list.array->store->data[locals->i.num - locals->list.array->ext_low + locals->list.array->int_low];
        CUR_PROC_VAR = locals->get;
        locals->err = locals->get.proc->proc(T_2_1, &T_2_2);
        if (locals->err != ERR_ok) goto ex_0;
        T_2_3.num = ((locals->s.str->size != T_2_2.str->size)? false :
            !(bcmp(locals->s.str->data, T_2_2.str->data, locals->s.str->size)));
        if (T_2_3.num == true) {

  FB_LINE(236);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            locals->err = stringOPconcat(STR_duplicate_040name_040_047, locals->s, &T_3_1);
            if (locals->err != ERR_ok) goto ex_0;
            locals->err = stringOPconcat(T_3_1, STR__047_040in_040, &T_3_2);
            if (locals->err != ERR_ok) goto ex_0;
            locals->err = stringOPconcat(T_3_2, locals->what, &T_3_3);
            if (locals->err != ERR_ok) goto ex_0;
            locals->err = stringOPconcat(T_3_3, STR__137list, &T_3_4);
            if (locals->err != ERR_ok) goto ex_0;
            locals->err = p_envOPerr(locals->e, T_3_4, CLU_1);
            if (locals->err != ERR_ok) goto ex_0;
            }

  FB_LINE(238);
            {signal(ERR_ok);}
            }
            }/* end if */

  FB_LINE(240);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
            T_2_2.num = locals->high.num;
            for (T_2_1.num = locals->i.num; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                locals->j.num = T_2_1.num;

  FB_LINE(241);
                {
                    {CLUREF T_3_1;
                    if (locals->j.num < locals->list.array->ext_low || locals->j.num > locals->list.array->ext_high ) {
                        locals->err = ERR_bounds;
                        goto ex_0;}
                    T_3_1.num = locals->list.array->store->data[locals->j.num - locals->list.array->ext_low + locals->list.array->int_low];
                    locals->ox.num = T_3_1.num;
                    }
                    }

  FB_LINE(242);
                {
                {
                if (locals->j.num < locals->list.array->ext_low || locals->j.num > locals->list.array->ext_high) {
                    locals->err = ERR_bounds;
                    goto ex_0;}
                locals->list.array->store->data[locals->j.num + locals->list.array->int_low - locals->list.array->ext_low] = locals->x.num;
                }
                }

  FB_LINE(243);
                {
                locals->x.num = locals->ox.num;
                }
            }
        }
        end_inline_for_1:;
        }
        }/* end if */

  FB_LINE(246);
    {
    {
    if ((locals->list.array->int_low + locals->list.array->ext_size + 1) < locals->list.array->int_size) {
        locals->list.array->store->data[locals->list.array->int_low + locals->list.array->ext_size] = locals->x.num;
        locals->list.array->ext_size++; locals->list.array->ext_high++;}
    else {
        locals->err = arrayOPaddh(locals->list, locals->x);
        if (locals->err != ERR_ok) goto ex_0;}
    }
    }

  FB_LINE(247);
    {
    CLUREF T_1_1;
    T_1_1.num = locals->high.num + 1;
     if ((T_1_1.num > 0 && locals->high.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && locals->high.num > 0 && 1 > 0)) {
        locals->err = ERR_overflow;
        goto ex_0;}
    locals->high.num = T_1_1.num;
    }
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end p_order_IB_1 */

/**** END ITERATOR BODIES for p_order ****/

