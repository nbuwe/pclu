
/* This file was automatically generated by pclu. */

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER typ ****/

extern errcode sequenceOPnew();
extern errcode sequenceOPelements();
extern errcode typOPfix_type();
extern errcode recordOPget_1();
extern errcode idnOPset_kind();
extern errcode oneofOPmake_9();
extern errcode recordOPget_2();
extern errcode sequenceOPaddh();
extern errcode typOPfix_own_type();
extern errcode oneofOPmake_4();
extern errcode typOPfix_parm_type();
extern errcode typespecOPget_abs();
extern errcode oneofOPmake_6();
extern errcode oneofOPmake_10();
extern errcode compiler_logit();
extern errcode typespec_print();
extern errcode oneofOPmake_8();
static CLUREF STR_not_040fixing_040each_137idn_056str;
static int typ_own_init = 0;
const OWN_req typ_ownreqs = { 0, 0 };
CLUREF typOPundo_global_idn_type_list;
CLUREF typOPundo_local_idn_type_list;

errcode
typ_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (typ_own_init == 0) {
        stringOPcons("not fixing each_idn.str", CLU_1, CLUREF_make_num(23), &STR_not_040fixing_040each_137idn_056str);
        typ_own_init = 1;
        {
        CLUREF T_0_1;
        err = sequenceOPnew(&T_0_1);
        if (err != ERR_ok)
            goto ex_0;
        typOPundo_global_idn_type_list.num = T_0_1.num;
        }
        {
        CLUREF T_0_2;
        err = sequenceOPnew(&T_0_2);
        if (err != ERR_ok)
            goto ex_0;
        typOPundo_local_idn_type_list.num = T_0_2.num;
        }
        signal(ERR_ok);
      ex_0:
        __CLU_EX_HANDLER;
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE begin_local_idn_types ****/


errcode
typOPbegin_local_idn_types(void)
{
    errcode err;
    if (typ_own_init == 0) {
        err = typ_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(15);

  LINE(17);
    {
    typOPundo_global_idn_type_list.num = typOPundo_local_idn_type_list.num;
    }

  LINE(18);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    typOPundo_local_idn_type_list.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE begin_local_idn_types ****/


/**** BEGIN PROCEDURE fix_typelist ****/


errcode
typOPfix_typelist(CLUREF d)
{
    errcode err;
    CLUREF each_d;
    if (typ_own_init == 0) {
        err = typ_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(22);

  LINE(24);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = d.vec->size;
    T_1_3 = d;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        each_d.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(25);
        {
        err = typOPfix_type(each_d);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE fix_typelist ****/


/**** BEGIN PROCEDURE fix_type ****/


errcode
typOPfix_type(CLUREF d)
{
    errcode err;
    CLUREF each_idn;
    if (typ_own_init == 0) {
        err = typ_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(30);

  LINE(32);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = d.vec->data[0];
    T_1_3.num = T_1_1.vec->size;
    T_1_4 = T_1_1;
    for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
        each_idn.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(33);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = d.vec->data[1];
        CellAlloc(9, T_2_1.num, T_2_2);
        err = idnOPset_kind(each_idn, T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(34);
        {
        CLUREF T_2_1;
        err = sequenceOPaddh(typOPundo_local_idn_type_list, each_idn, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        typOPundo_local_idn_type_list.num = T_2_1.num;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE fix_type ****/


/**** BEGIN PROCEDURE fix_own_typelist ****/


errcode
typOPfix_own_typelist(CLUREF d)
{
    errcode err;
    CLUREF each_d;
    if (typ_own_init == 0) {
        err = typ_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(39);

  LINE(41);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = d.vec->size;
    T_1_3 = d;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        each_d.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(42);
        {
        err = typOPfix_own_type(each_d);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE fix_own_typelist ****/


/**** BEGIN PROCEDURE fix_own_type ****/


errcode
typOPfix_own_type(CLUREF d)
{
    errcode err;
    CLUREF each_idn;
    if (typ_own_init == 0) {
        err = typ_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(47);

  LINE(49);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = d.vec->data[0];
    T_1_3.num = T_1_1.vec->size;
    T_1_4 = T_1_1;
    for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
        each_idn.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(50);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = d.vec->data[1];
        CellAlloc(4, T_2_1.num, T_2_2);
        err = idnOPset_kind(each_idn, T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(51);
        {
        CLUREF T_2_1;
        err = sequenceOPaddh(typOPundo_local_idn_type_list, each_idn, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        typOPundo_local_idn_type_list.num = T_2_1.num;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE fix_own_type ****/


/**** BEGIN PROCEDURE fix_parm_typelist ****/


errcode
typOPfix_parm_typelist(CLUREF d)
{
    errcode err;
    CLUREF each_d;
    if (typ_own_init == 0) {
        err = typ_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(56);

  LINE(58);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = d.vec->size;
    T_1_3 = d;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        each_d.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(59);
        {
        err = typOPfix_parm_type(each_d);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE fix_parm_typelist ****/


/**** BEGIN PROCEDURE fix_parm_type ****/

static int typOPfix_parm_type_own_init = 0;

errcode
typOPfix_parm_type(CLUREF d)
{
    errcode err;
    CLUREF each_idn;
    if (typOPfix_parm_type_own_init == 0) {
        if (typ_own_init == 0) {
            err = typ_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        typOPfix_parm_type_own_init = 1;
    }
    enter_proc(64);

  LINE(66);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = d.vec->data[0];
    T_1_3.num = T_1_1.vec->size;
    T_1_4 = T_1_1;
    for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
        each_idn.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(67);
        { /* qtagcase */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = d.vec->data[1];
        err = typespecOPget_abs(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_2.cell->tag) {
        case 8: /* type_ */ {

  LINE(69);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = sequenceOPnew(&T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            CellAlloc(6, T_3_1.num, T_3_2);
            err = idnOPset_kind(each_idn, T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 3: /* cluster_ */ {

  LINE(71);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = d.vec->data[1];
            CellAlloc(10, T_3_1.num, T_3_2);
            err = idnOPset_kind(each_idn, T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        default: {

  LINE(73);
            {
            CLUREF T_3_1;
            T_3_1.num = 720;
            err = compiler_logit(T_3_1, STR_not_040fixing_040each_137idn_056str);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(74);
            {
            CLUREF T_3_1;
            T_3_1.num = d.vec->data[1];
            err = typespec_print(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        }
        } /* end qtagcase */

  LINE(76);
        {
        CLUREF T_2_1;
        err = sequenceOPaddh(typOPundo_local_idn_type_list, each_idn, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        typOPundo_local_idn_type_list.num = T_2_1.num;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE fix_parm_type ****/


/**** BEGIN PROCEDURE undo_local_idn_types ****/


errcode
typOPundo_local_idn_types(void)
{
    errcode err;
    CLUREF this_idn;
    if (typ_own_init == 0) {
        err = typ_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(81);

  LINE(83);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = typOPundo_local_idn_type_list.vec->size;
    T_1_3 = typOPundo_local_idn_type_list;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        this_idn.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(84);
        {
        CLUREF T_2_1;
        CellAlloc(8, nil, T_2_1);
        err = idnOPset_kind(this_idn, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(86);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    typOPundo_local_idn_type_list.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE undo_local_idn_types ****/


/**** BEGIN PROCEDURE undo_global_idn_types ****/


errcode
typOPundo_global_idn_types(void)
{
    errcode err;
    CLUREF this_idn;
    if (typ_own_init == 0) {
        err = typ_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(89);

  LINE(91);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = typOPundo_global_idn_type_list.vec->size;
    T_1_3 = typOPundo_global_idn_type_list;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        this_idn.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(92);
        {
        CLUREF T_2_1;
        CellAlloc(8, nil, T_2_1);
        err = idnOPset_kind(this_idn, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(94);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    typOPundo_global_idn_type_list.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE undo_global_idn_types ****/

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[9];
} typ_OPS;

static CLU_proc typ_oe_begin_local_idn_types = { .proc = typOPbegin_local_idn_types };
static CLU_proc typ_oe_fix_own_type = { .proc = typOPfix_own_type };
static CLU_proc typ_oe_fix_own_typelist = { .proc = typOPfix_own_typelist };
static CLU_proc typ_oe_fix_parm_type = { .proc = typOPfix_parm_type };
static CLU_proc typ_oe_fix_parm_typelist = { .proc = typOPfix_parm_typelist };
static CLU_proc typ_oe_fix_type = { .proc = typOPfix_type };
static CLU_proc typ_oe_fix_typelist = { .proc = typOPfix_typelist };
static CLU_proc typ_oe_undo_global_idn_types = { .proc = typOPundo_global_idn_types };
static CLU_proc typ_oe_undo_local_idn_types = { .proc = typOPundo_local_idn_types };

static typ_OPS typ_ops_actual = {9, (OWNPTR)&typ_own_init, (OWNPTR)&typ_own_init, {
    {&typ_oe_begin_local_idn_types, "begin_local_idn_types"},
    {&typ_oe_fix_own_type, "fix_own_type"},
    {&typ_oe_fix_own_typelist, "fix_own_typelist"},
    {&typ_oe_fix_parm_type, "fix_parm_type"},
    {&typ_oe_fix_parm_typelist, "fix_parm_typelist"},
    {&typ_oe_fix_type, "fix_type"},
    {&typ_oe_fix_typelist, "fix_typelist"},
    {&typ_oe_undo_global_idn_types, "undo_global_idn_types"},
    {&typ_oe_undo_local_idn_types, "undo_local_idn_types"}}};

struct OPS *typ_ops = (struct OPS *)&typ_ops_actual;

/**** END CLUSTER typ ****/

/**** BEGIN CLUSTER sig ****/

extern errcode arrayOPpredict();
extern errcode sigOPlookup();
extern errcode boolOPnot();
extern errcode stringOPconcat();
extern errcode sigOPinit_known();
extern errcode stringOPequal();
extern errcode arrayOPelements();
extern errcode err_name();
extern errcode streamOPopen();
extern errcode streamOPgetl();
extern errcode stringOPindexs();
extern errcode intOPequal();
extern errcode intOPlt();
extern errcode stringOPrest();
extern errcode intOPmin();
extern errcode arrayOPaddh();
extern errcode stringOPsubstr();
extern errcode intOPsub();
static CLUREF STR__050_050errcode_051;
static CLUREF STR__051;
static CLUREF STR_ok;
static CLUREF STR__042ERR_137ok_137UNIQ_042;
static CLUREF STR_ERR_137;
static CLUREF STR__042ERR_137;
static CLUREF STR__042;
static CLUREF STR_read;
static CLUREF STR__043define;
static CLUREF STR__040;
static CLUREF STR__011;
static int sig_own_init = 0;
const OWN_req sig_ownreqs = { 0, 0 };
CLUREF sigOPknown;
CLUREF sigOPinit;

errcode
sig_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (sig_own_init == 0) {
        stringOPcons("((errcode)", CLU_1, CLUREF_make_num(10), &STR__050_050errcode_051);
        stringOPcons(")", CLU_1, CLUREF_make_num(1), &STR__051);
        stringOPcons("ok", CLU_1, CLUREF_make_num(2), &STR_ok);
        stringOPcons("\"ERR_ok_UNIQ\"", CLU_1, CLUREF_make_num(13), &STR__042ERR_137ok_137UNIQ_042);
        stringOPcons("ERR_", CLU_1, CLUREF_make_num(4), &STR_ERR_137);
        stringOPcons("\"ERR_", CLU_1, CLUREF_make_num(5), &STR__042ERR_137);
        stringOPcons("\"", CLU_1, CLUREF_make_num(1), &STR__042);
        stringOPcons("read", CLU_1, CLUREF_make_num(4), &STR_read);
        stringOPcons("#define", CLU_1, CLUREF_make_num(7), &STR__043define);
        stringOPcons(" ", CLU_1, CLUREF_make_num(1), &STR__040);
        stringOPcons("\t", CLU_1, CLUREF_make_num(1), &STR__011);
        sig_own_init = 1;
        {
        CLUREF T_0_1;
        CLUREF T_0_2;
        T_0_1.num = 100;
        err = arrayOPpredict(CLU_1, T_0_1, &T_0_2);
        if (err != ERR_ok)
            goto ex_0;
        sigOPknown.num = T_0_2.num;
        }
        {
        sigOPinit.tf = false;
        }
        signal(ERR_ok);
      ex_0:
        __CLU_EX_HANDLER;
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE name ****/


errcode
sigOPname(CLUREF nm, CLUREF *ret_1)
{
    errcode err;
    CLUREF sig_name;
    CLUREF predefined;
    if (sig_own_init == 0) {
        err = sig_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(110);

  LINE(111);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = sigOPlookup(nm, &T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    sig_name.num = T_1_1.num;
    predefined.num = T_1_2.num;
    }

  LINE(112);
    { /* return */
    {
    ret_1->num = sig_name.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE name ****/


/**** BEGIN PROCEDURE expr ****/

static int sigOPexpr_own_init = 0;

errcode
sigOPexpr(CLUREF nm, CLUREF *ret_1)
{
    errcode err;
    CLUREF sig_name;
    CLUREF predefined;
    if (sigOPexpr_own_init == 0) {
        if (sig_own_init == 0) {
            err = sig_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        sigOPexpr_own_init = 1;
    }
    enter_proc(116);

  LINE(117);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = sigOPlookup(nm, &T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    sig_name.num = T_1_1.num;
    predefined.num = T_1_2.num;
    }

  LINE(118);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = !predefined.num;
    if (T_1_1.num == true) { /* if */

  LINE(119);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = stringOPconcat(STR__050_050errcode_051, sig_name, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_1, STR__051, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        sig_name.num = T_2_2.num;
        }
    }
    } /* end if */

  LINE(121);
    { /* return */
    {
    ret_1->num = sig_name.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE expr ****/


/**** BEGIN PROCEDURE lookup ****/

static int sigOPlookup_own_init = 0;

errcode
sigOPlookup(CLUREF nm, CLUREF *ret_1, CLUREF *ret_2)
{
    errcode err;
    CLUREF each_s;
    if (sigOPlookup_own_init == 0) {
        if (sig_own_init == 0) {
            err = sig_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        sigOPlookup_own_init = 1;
    }
    enter_proc(124);

  LINE(125);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = !sigOPinit.num;
    if (T_1_1.num == true) { /* if */
        {
        err = sigOPinit_known();
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(129);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = ((nm.str->size != STR_ok.str->size)? false :
        !(memcmp(nm.str->data, STR_ok.str->data, nm.str->size)));
    if (T_1_1.num == true) { /* if */

  LINE(130);
        { /* return */
        {
        ret_1->str = STR__042ERR_137ok_137UNIQ_042.str;
        }
        {
        ret_2->tf = false;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(133);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = sigOPknown.array->ext_high;
    T_1_3 = sigOPknown;
    for (T_1_1.num = sigOPknown.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        each_s.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(134);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = ((nm.str->size != each_s.str->size)? false :
            !(memcmp(nm.str->data, each_s.str->data, nm.str->size)));
        if (T_2_1.num == true) { /* if */

  LINE(136);
            { /* return */
            {
            CLUREF T_3_1;
            err = stringOPconcat(STR_ERR_137, nm, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            ret_1->num = T_3_1.num;
            }
            {
            ret_2->tf = true;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(140);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = stringOPconcat(STR__042ERR_137, nm, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = stringOPconcat(T_1_1, STR__042, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_2.num;
    }
    {
    ret_2->tf = false;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE lookup ****/


/**** BEGIN PROCEDURE init_known ****/

static int sigOPinit_known_own_init = 0;

errcode
sigOPinit_known(void)
{
    errcode err;
    CLUREF err_file_name;
    CLUREF err_stream;
    CLUREF l;
    CLUREF pos;
    CLUREF pos2;
    CLUREF l2;
    CLUREF pos3;
    CLUREF pos4;
    if (sigOPinit_known_own_init == 0) {
        if (sig_own_init == 0) {
            err = sig_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        sigOPinit_known_own_init = 1;
    }
    enter_proc(144);

  LINE(145);
    { /* if */
    if (sigOPinit.num == true) { /* if */
        { /* return */
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(146);
    {
    sigOPinit.tf = true;
    }

  LINE(148);
    {
    CLUREF T_1_1;
    err = err_name(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err_file_name.num = T_1_1.num;
    }

  LINE(149);
    {
    CLUREF T_2_1;
    err = streamOPopen(err_file_name, STR_read, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    err_stream.num = T_2_1.num;
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    { /* others */

  LINE(150);
        { /* return */
        signal (ERR_ok);
        }
    }
  end_1:;

  LINE(152);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(153);
        {
        CLUREF T_3_1;
        err = streamOPgetl(err_stream, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        l.num = T_3_1.num;
        }

  LINE(154);
        {
        CLUREF T_3_1;
        err = stringOPindexs(STR__043define, l, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        pos.num = T_3_1.num;
        }

  LINE(155);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = (pos.num == 0);
        if (T_3_1.num == true) { /* if */
            continue;
        }
        } /* end if */

  LINE(156);
        {
        CLUREF T_3_1;
        err = stringOPindexs(STR_ERR_137, l, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        pos2.num = T_3_1.num;
        }

  LINE(157);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = (pos2.num < pos.num);
        if (T_3_1.num == true) { /* if */
            continue;
        }
        } /* end if */

  LINE(158);
        {
        CLUREF T_3_1;
        err = stringOPrest(l, pos2, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        l2.num = T_3_1.num;
        }

  LINE(159);
        {
        CLUREF T_3_1;
        err = stringOPindexs(STR__040, l2, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        pos3.num = T_3_1.num;
        }

  LINE(160);
        {
        CLUREF T_3_1;
        err = stringOPindexs(STR__011, l2, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        pos4.num = T_3_1.num;
        }

  LINE(161);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = (pos4.num == 0);
        if (T_3_1.num == true) { /* if */
            {
            pos4.num = pos3.num;
            }
        }
        } /* end if */

  LINE(162);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = (pos3.num == 0);
        if (T_3_1.num == true) { /* if */
            {
            pos3.num = pos4.num;
            }
        }
        } /* end if */

  LINE(163);
        { /* if */
        CLUREF T_3_1;
        T_3_1.num = (pos3.num == 0);
        if (T_3_1.num == true) { /* if */
            continue;
        }
        } /* end if */

  LINE(164);
        {
        CLUREF T_3_1;
        err = intOPmin(pos3, pos4, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        pos3.num = T_3_1.num;
        }

  LINE(165);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = pos3.num - 5;
        if ((T_3_1.num >= 0 && pos3.num < 0 && (-5) < 0) ||
            (T_3_1.num <= 0 && pos3.num > 0 && (-5) > 0)) {
            err = ERR_overflow;
            goto ex_2;
        }
        err = stringOPsubstr(l2, CLU_5, T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_2;
        {
        if ((sigOPknown.array->int_low + sigOPknown.array->ext_size + 1) < sigOPknown.array->int_size) {
            sigOPknown.array->store->data[sigOPknown.array->int_low + sigOPknown.array->ext_size] = T_3_2.num;
            sigOPknown.array->ext_size++;
            sigOPknown.array->ext_high++;
        }
        else {
            err = arrayOPaddh(sigOPknown, T_3_2);
            if (err != ERR_ok)
                goto ex_2;
        }
        }
        }
    }
    end_while_1:
    __CLU_END_LABEL;
    goto end_2;
  ex_2: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file) {

  LINE(167);
        { /* return */
        signal (ERR_ok);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_2:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE init_known ****/

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[3];
} sig_OPS;

static CLU_proc sig_oe_expr = { .proc = sigOPexpr };
static CLU_proc sig_oe_lookup = { .proc = sigOPlookup };
static CLU_proc sig_oe_name = { .proc = sigOPname };

static sig_OPS sig_ops_actual = {3, (OWNPTR)&sig_own_init, (OWNPTR)&sig_own_init, {
    {&sig_oe_expr, "expr"},
    {&sig_oe_lookup, "lookup"},
    {&sig_oe_name, "name"}}};

struct OPS *sig_ops = (struct OPS *)&sig_ops_actual;

/**** END CLUSTER sig ****/

/**** BEGIN CLUSTER int_const ****/

extern errcode intOPle();
extern errcode int_constOPexists();
extern errcode g_envOPputs();
extern errcode intOPunparse();
static CLUREF STR_CLUREF_137make_137num_050;
static CLUREF STR_CLU_137;
static int int_const_own_init = 0;
const OWN_req int_const_ownreqs = { 0, 0 };

errcode
int_const_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (int_const_own_init == 0) {
        stringOPcons("CLUREF_make_num(", CLU_1, CLUREF_make_num(16), &STR_CLUREF_137make_137num_050);
        stringOPcons("CLU_", CLU_1, CLUREF_make_num(4), &STR_CLU_137);
        stringOPcons(")", CLU_1, CLUREF_make_num(1), &STR__051);
        int_const_own_init = 1;
        signal(ERR_ok);
      ex_0:
        __CLU_EX_HANDLER;
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE exists ****/


errcode
int_constOPexists(CLUREF i, CLUREF *ret_1)
{
    errcode err;
    if (int_const_own_init == 0) {
        err = int_const_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(189);

  LINE(190);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = (0 <= i.num);
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        T_1_3.num = (i.num <= 50);
        T_1_1.num = T_1_3.num;
    }
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE exists ****/


/**** BEGIN PROCEDURE g_emit ****/

static int int_constOPg_emit_own_init = 0;

errcode
int_constOPg_emit(CLUREF e, CLUREF i)
{
    errcode err;
    CLUREF make_num;
    if (int_constOPg_emit_own_init == 0) {
        if (int_const_own_init == 0) {
            err = int_const_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        int_constOPg_emit_own_init = 1;
    }
    enter_proc(193);

  LINE(194);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = int_constOPexists(i, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_2.num = !T_1_1.num;
    make_num.num = T_1_2.num;
    }

  LINE(195);
    { /* if */
    if (make_num.num == true) { /* if */
        {
        err = g_envOPputs(e, STR_CLUREF_137make_137num_050);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    else { /* else */

  LINE(196);
        {
        err = g_envOPputs(e, STR_CLU_137);
        if (err != ERR_ok)
            goto ex_0;
        }
    }} /* end if */

  LINE(197);
    {
    CLUREF T_1_1;
    err = intOPunparse(i, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = g_envOPputs(e, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(198);
    { /* if */
    if (make_num.num == true) { /* if */
        {
        err = g_envOPputs(e, STR__051);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE g_emit ****/

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[2];
} int_const_OPS;

static CLU_proc int_const_oe_exists = { .proc = int_constOPexists };
static CLU_proc int_const_oe_g_emit = { .proc = int_constOPg_emit };

static int_const_OPS int_const_ops_actual = {2, (OWNPTR)&int_const_own_init, (OWNPTR)&int_const_own_init, {
    {&int_const_oe_exists, "exists"},
    {&int_const_oe_g_emit, "g_emit"}}};

struct OPS *int_const_ops = (struct OPS *)&int_const_ops_actual;

/**** END CLUSTER int_const ****/

/**** BEGIN CLUSTER g_xref ****/

extern errcode file_nameOPparse();
extern errcode stringOPsize();
extern errcode stringOPempty();
extern errcode charOPequal();
extern errcode stringOPfetch();
extern errcode streamOPclose();
extern errcode stringOPindexc();
extern errcode streamOPputs();
extern errcode streamOPputl();
extern errcode boolOPequal();
extern errcode g_xrefOPsetup();
extern errcode current_applyOPget_short_name();
extern errcode current_typeOPexists();
extern errcode current_typeOPget_name();
extern errcode arrayOPsize();
extern errcode recordOPset_2();
extern errcode s_externalize();
extern errcode delete_file();
extern errcode rename_file();
static CLUREF STR_pclu_056xref;
static CLUREF STR__040couldn_047t_040open_040pclu_056xref_040;
static CLUREF STR__044own_137init_137proc;
static CLUREF STR__044;
static CLUREF STR_pclu_056xref_056new;
static CLUREF STR_write;
static CLUREF STR__072;
static int g_xref_own_init = 0;
const OWN_req g_xref_ownreqs = { 0, 0 };
CLUREF g_xrefOPinit;
CLUREF g_xrefOPdb;
CLUREF g_xrefOPmodified;

errcode
g_xref_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (g_xref_own_init == 0) {
        stringOPcons("pclu.xref", CLU_1, CLUREF_make_num(9), &STR_pclu_056xref);
        stringOPcons("read", CLU_1, CLUREF_make_num(4), &STR_read);
        stringOPcons(" couldn\'t open pclu.xref ", CLU_1, CLUREF_make_num(25), &STR__040couldn_047t_040open_040pclu_056xref_040);
        stringOPcons("\t", CLU_1, CLUREF_make_num(1), &STR__011);
        stringOPcons("$own_init_proc", CLU_1, CLUREF_make_num(14), &STR__044own_137init_137proc);
        stringOPcons("$", CLU_1, CLUREF_make_num(1), &STR__044);
        stringOPcons("pclu.xref.new", CLU_1, CLUREF_make_num(13), &STR_pclu_056xref_056new);
        stringOPcons("write", CLU_1, CLUREF_make_num(5), &STR_write);
        stringOPcons(":", CLU_1, CLUREF_make_num(1), &STR__072);
        g_xref_own_init = 1;
        {
        g_xrefOPinit.tf = false;
        }
        {
        CLUREF T_0_1;
        err = arrayOPpredict(CLU_1, CLU_30, &T_0_1);
        if (err != ERR_ok)
            goto ex_0;
        g_xrefOPdb.num = T_0_1.num;
        }
        {
        g_xrefOPmodified.tf = false;
        }
        signal(ERR_ok);
      ex_0:
        __CLU_EX_HANDLER;
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE setup ****/

static int g_xrefOPsetup_own_init = 0;

errcode
g_xrefOPsetup(void)
{
    errcode err;
    CLUREF ofn;
    CLUREF inst;
    CLUREF l;
    CLUREF sz;
    CLUREF nm;
    CLUREF refs;
    if (g_xrefOPsetup_own_init == 0) {
        if (g_xref_own_init == 0) {
            err = g_xref_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        g_xrefOPsetup_own_init = 1;
    }
    enter_proc(214);

  LINE(215);
    {
    g_xrefOPinit.tf = true;
    }

  LINE(217);
    {
    CLUREF T_1_1;
    err = file_nameOPparse(STR_pclu_056xref, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ofn.num = T_1_1.num;
    }

  LINE(218);
    { /* begin */

  LINE(219);
        {
        CLUREF T_3_1;
        err = streamOPopen(ofn, STR_read, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        inst.num = T_3_1.num;
        }

  LINE(220);
        { /* begin */

  LINE(221);
            for (;;) { /* while */
                if (true != true)
                    break;

  LINE(222);
                {
                CLUREF T_6_1;
                err = streamOPgetl(inst, &T_6_1);
                if (err != ERR_ok)
                    goto ex_2;
                l.num = T_6_1.num;
                }

  LINE(223);
                {
                CLUREF T_6_1;
                err = stringOPsize(l, &T_6_1);
                if (err != ERR_ok)
                    goto ex_2;
                sz.num = T_6_1.num;
                }

  LINE(224);
                { /* if */
                CLUREF T_6_1;
                CLUREF T_6_2;
                CLUREF T_6_3;
                CLUREF T_6_4;
                CLUREF T_6_5;
                CLUREF T_6_6;
                err = stringOPempty(l, &T_6_2);
                if (err != ERR_ok)
                    goto ex_2;
                T_6_3.num = !T_6_2.num;
                T_6_1.num = T_6_3.num;
                if (T_6_3.num) {
                    err = stringOPfetch(l, sz, &T_6_4);
                    if (err != ERR_ok)
                        goto ex_2;
                    T_6_5.ch = ':';
                    T_6_6.num = (T_6_4.ch == T_6_5.ch);
                    T_6_1.num = T_6_6.num;
                }
                if (T_6_1.num == true) { /* if */

  LINE(225);
                    {
                    CLUREF T_7_1;
                    CLUREF T_7_2;
                    T_7_1.num = sz.num - 1;
                    if ((T_7_1.num >= 0 && sz.num < 0 && (-1) < 0) ||
                        (T_7_1.num <= 0 && sz.num > 0 && (-1) > 0)) {
                        err = ERR_overflow;
                        goto ex_2;
                    }
                    err = stringOPsubstr(l, CLU_1, T_7_1, &T_7_2);
                    if (err != ERR_ok)
                        goto ex_2;
                    nm.num = T_7_2.num;
                    }

  LINE(226);
                    {
                    CLUREF T_7_1;
                    err = arrayOPpredict(CLU_1, CLU_20, &T_7_1);
                    if (err != ERR_ok)
                        goto ex_2;
                    refs.num = T_7_1.num;
                    }

  LINE(227);
                    for (;;) { /* while */
                        if (true != true)
                            break;

  LINE(228);
                        {
                        CLUREF T_8_1;
                        err = streamOPgetl(inst, &T_8_1);
                        if (err != ERR_ok)
                            goto ex_2;
                        l.num = T_8_1.num;
                        }

  LINE(229);
                        { /* if */
                        CLUREF T_8_1;
                        CLUREF T_8_2;
                        err = stringOPempty(l, &T_8_1);
                        if (err != ERR_ok)
                            goto ex_2;
                        T_8_2.num = !T_8_1.num;
                        if (T_8_2.num == true) { /* if */

  LINE(231);
                            {
                            {
                            if ((refs.array->int_low + refs.array->ext_size + 1) < refs.array->int_size) {
                                refs.array->store->data[refs.array->int_low + refs.array->ext_size] = l.num;
                                refs.array->ext_size++;
                                refs.array->ext_high++;
                            }
                            else {
                                err = arrayOPaddh(refs, l);
                                if (err != ERR_ok)
                                    goto ex_2;
                            }
                            }
                            }
                        }
                        else { /* else */

  LINE(233);
                            {
                            CLUREF T_9_1;
                            RecordAlloc(2, T_9_1);
                            T_9_1.vec->data[0] = nm.num;
                            T_9_1.vec->data[1] = refs.num;
                            {
                            if ((g_xrefOPdb.array->int_low + g_xrefOPdb.array->ext_size + 1) < g_xrefOPdb.array->int_size) {
                                g_xrefOPdb.array->store->data[g_xrefOPdb.array->int_low + g_xrefOPdb.array->ext_size] = T_9_1.num;
                                g_xrefOPdb.array->ext_size++;
                                g_xrefOPdb.array->ext_high++;
                            }
                            else {
                                err = arrayOPaddh(g_xrefOPdb, T_9_1);
                                if (err != ERR_ok)
                                    goto ex_2;
                            }
                            }
                            }

  LINE(234);
                            goto end_while_2;
                        }} /* end if */
                    }
                    end_while_2:
                    __CLU_END_LABEL;
                }
                } /* end if */
            }
            end_while_1:
            __CLU_END_LABEL;
        }
        goto end_2;
      ex_2: /* except */
        __CLU_EX_HANDLER;
        { /* others */

  LINE(240);
            {
            err = streamOPclose(inst);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
      end_2:;
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    { /* others */
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE setup ****/


/**** BEGIN PROCEDURE lookup ****/

static int g_xrefOPlookup_own_init = 0;

errcode
g_xrefOPlookup(CLUREF tyo, CLUREF nm)
{
    errcode err;
    CLUREF infn;
    CLUREF inst;
    CLUREF found;
    CLUREF loc_left;
    CLUREF loc_sep;
    CLUREF current_entry;
    CLUREF l;
    CLUREF sz;
    CLUREF why;
    if (g_xrefOPlookup_own_init == 0) {
        if (g_xref_own_init == 0) {
            err = g_xref_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        g_xrefOPlookup_own_init = 1;
    }
    enter_proc(245);

  LINE(248);
    {
    CLUREF T_1_1;
    err = file_nameOPparse(STR_pclu_056xref, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    infn.num = T_1_1.num;
    }

  LINE(249);
    {
    CLUREF T_2_1;
    err = streamOPopen(infn, STR_read, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    inst.num = T_2_1.num;
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    { /* others */

  LINE(251);
        { /* signal */
            elist[0] = STR__040couldn_047t_040open_040pclu_056xref_040;
            signal(ERR_not_possible);
        }
    }
  end_1:;

  LINE(254);
    {
    found.tf = false;
    }

  LINE(257);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = '[';
    err = stringOPindexc(T_1_1, nm, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    loc_left.num = T_1_2.num;
    }

  LINE(258);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = (loc_left.num == 0);
    T_1_2.num = !T_1_1.num;
    if (T_1_2.num == true) { /* if */

  LINE(259);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.ch = '$';
        err = stringOPindexc(T_2_1, nm, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        loc_sep.num = T_2_2.num;
        }

  LINE(260);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_2.num = (loc_sep.num == 0);
        T_2_1.num = T_2_2.num;
        if (!T_2_2.num) {
            T_2_3.num = (loc_sep.num < loc_left.num);
            T_2_1.num = T_2_3.num;
        }
        if (T_2_1.num == true) { /* if */

  LINE(261);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = loc_left.num - 1;
            if ((T_3_1.num >= 0 && loc_left.num < 0 && (-1) < 0) ||
                (T_3_1.num <= 0 && loc_left.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            err = stringOPsubstr(nm, CLU_1, T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            nm.num = T_3_2.num;
            }
        }
        else { /* else */

  LINE(263);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_1.num = loc_left.num - 1;
            if ((T_3_1.num >= 0 && loc_left.num < 0 && (-1) < 0) ||
                (T_3_1.num <= 0 && loc_left.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_0;
            }
            err = stringOPsubstr(nm, CLU_1, T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPrest(nm, loc_sep, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_2, T_3_3, &T_3_4);
            if (err != ERR_ok)
                goto ex_0;
            nm.num = T_3_4.num;
            }

  LINE(265);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.ch = '[';
            err = stringOPindexc(T_3_1, nm, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            loc_left.num = T_3_2.num;
            }

  LINE(266);
            { /* if */
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = (loc_left.num == 0);
            T_3_2.num = !T_3_1.num;
            if (T_3_2.num == true) { /* if */

  LINE(267);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = loc_left.num - 1;
                if ((T_4_1.num >= 0 && loc_left.num < 0 && (-1) < 0) ||
                    (T_4_1.num <= 0 && loc_left.num > 0 && (-1) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;
                }
                err = stringOPsubstr(nm, CLU_1, T_4_1, &T_4_2);
                if (err != ERR_ok)
                    goto ex_0;
                nm.num = T_4_2.num;
                }
            }
            } /* end if */
        }} /* end if */
    }
    } /* end if */

  LINE(272);
    {
    current_entry = CLU_empty_string;
    }

  LINE(273);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(274);
        {
        CLUREF T_3_1;
        err = streamOPgetl(inst, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        l.num = T_3_1.num;
        }

  LINE(275);
        { /* if */
        CLUREF T_3_1;
        err = stringOPempty(l, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        if (T_3_1.num == true) { /* if */
            continue;
        }
        } /* end if */

  LINE(276);
        {
        CLUREF T_3_1;
        err = stringOPsize(l, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        sz.num = T_3_1.num;
        }

  LINE(277);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        err = stringOPfetch(l, sz, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        T_3_2.ch = ':';
        T_3_3.num = (T_3_1.ch == T_3_2.ch);
        if (T_3_3.num == true) { /* if */

  LINE(279);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = sz.num - 1;
            if ((T_4_1.num >= 0 && sz.num < 0 && (-1) < 0) ||
                (T_4_1.num <= 0 && sz.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_2;
            }
            err = stringOPsubstr(l, CLU_1, T_4_1, &T_4_2);
            if (err != ERR_ok)
                goto ex_2;
            current_entry.num = T_4_2.num;
            }
        }
        else { /* else */

  LINE(281);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            err = stringOPrest(l, CLU_2, &T_4_1);
            if (err != ERR_ok)
                goto ex_2;
            T_4_2.num = ((nm.str->size != T_4_1.str->size)? false :
                !(memcmp(nm.str->data, T_4_1.str->data, nm.str->size)));
            if (T_4_2.num == true) { /* if */

  LINE(282);
                {
                found.tf = true;
                }

  LINE(283);
                {
                err = streamOPputs(tyo, STR__011);
                if (err != ERR_ok)
                    goto ex_2;
                }

  LINE(284);
                {
                err = streamOPputl(tyo, current_entry);
                if (err != ERR_ok)
                    goto ex_2;
                }
            }
            } /* end if */
        }} /* end if */
    }
    end_while_1:
    __CLU_END_LABEL;
    goto end_2;
  ex_2: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file) {

  LINE(289);
        {
        err = streamOPclose(inst);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(290);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = (found.tf == false);
        if (T_2_1.num == true) { /* if */

  LINE(291);
            { /* signal */
                signal(ERR_not_found);
            }
        }
        else { /* else */

  LINE(292);
            { /* return */
            signal (ERR_ok);
            }
        }} /* end if */
    }
    else { /* others */
        why = _pclu_erstr(err);

  LINE(294);
        {
        err = streamOPclose(inst);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(295);
        { /* signal */
            elist[0] = why;
            signal(ERR_not_possible);
        }
    }
  end_2:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE lookup ****/


/**** BEGIN PROCEDURE add_ent ****/

static int g_xrefOPadd_ent_own_init = 0;

errcode
g_xrefOPadd_ent(CLUREF refs)
{
    errcode err;
    CLUREF nm;
    CLUREF apnm;
    CLUREF each_entry;
    CLUREF found;
    CLUREF each_ref;
    CLUREF old_ref;
    if (g_xrefOPadd_ent_own_init == 0) {
        if (g_xref_own_init == 0) {
            err = g_xref_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        g_xrefOPadd_ent_own_init = 1;
    }
    enter_proc(299);

  LINE(306);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = !g_xrefOPinit.num;
    if (T_1_1.num == true) { /* if */
        {
        err = g_xrefOPsetup();
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(309);
    {
    nm = CLU_empty_string;
    }

  LINE(310);
    {
    CLUREF T_1_1;
    err = current_applyOPget_short_name(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    apnm.num = T_1_1.num;
    }

  LINE(311);
    { /* if */
    CLUREF T_1_1;
    err = current_typeOPexists(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_1.num == true) { /* if */

  LINE(312);
        { /* if */
        CLUREF T_2_1;
        err = stringOPempty(apnm, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        if (T_2_1.num == true) { /* if */

  LINE(313);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = current_typeOPget_name(&T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_1, STR__044own_137init_137proc, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            nm.num = T_3_2.num;
            }
        }
        else { /* else */

  LINE(315);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = current_typeOPget_name(&T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_1, STR__044, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_2, apnm, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            nm.num = T_3_3.num;
            }
        }} /* end if */
    }
    else { /* else */

  LINE(318);
        {
        nm.num = apnm.num;
        }
    }} /* end if */

  LINE(321);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = g_xrefOPdb.array->ext_high;
    T_1_3 = g_xrefOPdb;
    for (T_1_1.num = g_xrefOPdb.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        each_entry.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(322);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = each_entry.vec->data[0];
        T_2_2.num = ((T_2_1.str->size != nm.str->size)? false :
            !(memcmp(T_2_1.str->data, nm.str->data, T_2_1.str->size)));
        T_2_3.num = !T_2_2.num;
        if (T_2_3.num == true) { /* if */
            continue;
        }
        } /* end if */

  LINE(324);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_1.num = refs.array->ext_size;
        T_2_2.num = each_entry.vec->data[1];
        T_2_3.num = T_2_2.array->ext_size;
        T_2_4.num = (T_2_1.num == T_2_3.num);
        T_2_5.num = !T_2_4.num;
        if (T_2_5.num == true) { /* if */

  LINE(325);
            {
            each_entry.vec->data[1] = refs.num;
            }

  LINE(326);
            {
            g_xrefOPmodified.tf = true;
            }

  LINE(327);
            { /* return */
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(329);
        {
        found.tf = false;
        }

  LINE(330);
        { /* for array$elements */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_2.num = refs.array->ext_high;
        T_2_3 = refs;
        for (T_2_1.num = refs.array->ext_low; T_2_1.num <= T_2_2.num; T_2_1.num++) {
            if (T_2_1.num > T_2_3.array->ext_high || T_2_1.num < T_2_3.array->ext_low) {
                err = ERR_failure;
                elist[0] = array_bounds_exception_STRING;
                goto ex_0;
            }
            each_ref.num = T_2_3.array->store->data[T_2_1.num - T_2_3.array->ext_low + T_2_3.array->int_low];

  LINE(331);
            {
            found.tf = false;
            }

  LINE(332);
            { /* for array$elements */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_1.num = each_entry.vec->data[1];
            T_3_3.num = T_3_1.array->ext_high;
            T_3_4 = T_3_1;
            for (T_3_2.num = T_3_1.array->ext_low; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                if (T_3_2.num > T_3_4.array->ext_high || T_3_2.num < T_3_4.array->ext_low) {
                    err = ERR_failure;
                    elist[0] = array_bounds_exception_STRING;
                    goto ex_0;
                }
                old_ref.num = T_3_4.array->store->data[T_3_2.num - T_3_4.array->ext_low + T_3_4.array->int_low];

  LINE(333);
                { /* if */
                CLUREF T_4_1;
                T_4_1.num = ((each_ref.str->size != old_ref.str->size)? false :
                    !(memcmp(each_ref.str->data, old_ref.str->data, each_ref.str->size)));
                if (T_4_1.num == true) { /* if */

  LINE(334);
                    {
                    found.tf = true;
                    }

  LINE(335);
                    goto end_inline_for_3;
                }
                } /* end if */
            }
            }
            end_inline_for_3:
            __CLU_END_LABEL;

  LINE(338);
            { /* if */
            CLUREF T_3_1;
            T_3_1.num = !found.num;
            if (T_3_1.num == true) { /* if */
                goto end_inline_for_2;
            }
            } /* end if */
        }
        }
        end_inline_for_2:
        __CLU_END_LABEL;

  LINE(340);
        { /* if */
        if (found.num == true) { /* if */
            { /* return */
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(342);
        {
        each_entry.vec->data[1] = refs.num;
        }

  LINE(343);
        {
        g_xrefOPmodified.tf = true;
        }

  LINE(344);
        { /* return */
        signal (ERR_ok);
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(347);
    {
    CLUREF T_1_1;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[0] = nm.num;
    T_1_1.vec->data[1] = refs.num;
    {
    if ((g_xrefOPdb.array->int_low + g_xrefOPdb.array->ext_size + 1) < g_xrefOPdb.array->int_size) {
        g_xrefOPdb.array->store->data[g_xrefOPdb.array->int_low + g_xrefOPdb.array->ext_size] = T_1_1.num;
        g_xrefOPdb.array->ext_size++;
        g_xrefOPdb.array->ext_high++;
    }
    else {
        err = arrayOPaddh(g_xrefOPdb, T_1_1);
        if (err != ERR_ok)
            goto ex_0;
    }
    }
    }

  LINE(348);
    {
    g_xrefOPmodified.tf = true;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE add_ent ****/


/**** BEGIN PROCEDURE flush ****/

static int g_xrefOPflush_own_init = 0;

errcode
g_xrefOPflush(void)
{
    errcode err;
    CLUREF ofn;
    CLUREF nfn;
    CLUREF outst;
    CLUREF each_entry;
    CLUREF each_nm;
    if (g_xrefOPflush_own_init == 0) {
        if (g_xref_own_init == 0) {
            err = g_xref_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        g_xrefOPflush_own_init = 1;
    }
    enter_proc(351);

  LINE(353);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = !g_xrefOPmodified.num;
    if (T_1_1.num == true) { /* if */
        { /* return */
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(354);
    {
    CLUREF T_1_1;
    err = file_nameOPparse(STR_pclu_056xref, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ofn.num = T_1_1.num;
    }

  LINE(357);
    {
    CLUREF T_1_1;
    err = file_nameOPparse(STR_pclu_056xref_056new, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    nfn.num = T_1_1.num;
    }

  LINE(358);
    {
    CLUREF T_1_1;
    err = streamOPopen(nfn, STR_write, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    outst.num = T_1_1.num;
    }

  LINE(359);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = g_xrefOPdb.array->ext_high;
    T_1_3 = g_xrefOPdb;
    for (T_1_1.num = g_xrefOPdb.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        each_entry.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(360);
        {
        CLUREF T_2_1;
        T_2_1.num = each_entry.vec->data[0];
        err = streamOPputs(outst, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(361);
        {
        err = streamOPputl(outst, STR__072);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(362);
        { /* for array$elements */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.num = each_entry.vec->data[1];
        T_2_3.num = T_2_1.array->ext_high;
        T_2_4 = T_2_1;
        for (T_2_2.num = T_2_1.array->ext_low; T_2_2.num <= T_2_3.num; T_2_2.num++) {
            if (T_2_2.num > T_2_4.array->ext_high || T_2_2.num < T_2_4.array->ext_low) {
                err = ERR_failure;
                elist[0] = array_bounds_exception_STRING;
                goto ex_0;
            }
            each_nm.num = T_2_4.array->store->data[T_2_2.num - T_2_4.array->ext_low + T_2_4.array->int_low];

  LINE(363);
            {
            err = streamOPputs(outst, STR__011);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(364);
            {
            CLUREF T_3_1;
            err = s_externalize(each_nm, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            err = streamOPputl(outst, T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        }
        end_inline_for_2:
        __CLU_END_LABEL;

  LINE(366);
        {
        err = streamOPputl(outst, CLU_empty_string);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(368);
    {
    err = streamOPclose(outst);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(371);
    {
    err = delete_file(ofn);
    if (err != ERR_ok)
        goto ex_1;
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    { /* others */
    }
  end_1:;

  LINE(373);
    {
    err = rename_file(nfn, ofn);
    if (err != ERR_ok)
        goto ex_2;
    }
    goto end_2;
  ex_2: /* except */
    __CLU_EX_HANDLER;
    { /* others */
    }
  end_2:;

  LINE(375);
    {
    g_xrefOPmodified.tf = false;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE flush ****/

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[3];
} g_xref_OPS;

static CLU_proc g_xref_oe_add_ent = { .proc = g_xrefOPadd_ent };
static CLU_proc g_xref_oe_flush = { .proc = g_xrefOPflush };
static CLU_proc g_xref_oe_lookup = { .proc = g_xrefOPlookup };

static g_xref_OPS g_xref_ops_actual = {3, (OWNPTR)&g_xref_own_init, (OWNPTR)&g_xref_own_init, {
    {&g_xref_oe_add_ent, "add_ent"},
    {&g_xref_oe_flush, "flush"},
    {&g_xref_oe_lookup, "lookup"}}};

struct OPS *g_xref_ops = (struct OPS *)&g_xref_ops_actual;

/**** END CLUSTER g_xref ****/


/**** BEGIN PROCEDURE s_externalize ****/

extern errcode intOPadd();
static CLUREF STR_OP;
static int s_externalize_own_init = 0;
CLUREF s_externalizeOPsep_size;

errcode
s_externalize(CLUREF nm, CLUREF *ret_1)
{
    errcode err;
    CLUREF off;
    CLUREF head;
    CLUREF tail;
    if (s_externalize_own_init == 0) {
        stringOPcons("OP", CLU_1, CLUREF_make_num(2), &STR_OP);
        stringOPcons("$", CLU_1, CLUREF_make_num(1), &STR__044);
        s_externalize_own_init = 1;
        {
        CLUREF T_0_1;
        err = stringOPsize(STR_OP, &T_0_1);
        if (err != ERR_ok)
            goto ex_0;
        s_externalizeOPsep_size.num = T_0_1.num;
        }
    }
    enter_proc(380);

  LINE(382);
    {
    CLUREF T_1_1;
    err = stringOPindexs(STR_OP, nm, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    off.num = T_1_1.num;
    }

  LINE(383);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (off.num == 0);
    if (T_1_1.num == true) { /* if */
        { /* return */
        {
        ret_1->num = nm.num;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(384);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = off.num - 1;
    if ((T_1_1.num >= 0 && off.num < 0 && (-1) < 0) ||
        (T_1_1.num <= 0 && off.num > 0 && (-1) > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    err = stringOPsubstr(nm, CLU_1, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    head.num = T_1_2.num;
    }

  LINE(385);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = off.num + s_externalizeOPsep_size.num;
    if ((T_1_1.num > 0 && off.num < 0 && s_externalizeOPsep_size.num < 0) ||
        (T_1_1.num < 0 && off.num > 0 && s_externalizeOPsep_size.num > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    err = stringOPrest(nm, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    tail.num = T_1_2.num;
    }

  LINE(386);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = stringOPconcat(head, STR__044, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = stringOPconcat(T_1_1, tail, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_2.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE s_externalize ****/



/**** BEGIN PROCEDURE g_check_handlers ****/

extern errcode handlersOPinit();
extern errcode g_check_handlers_main();
extern errcode handlersOPdone();

errcode
g_check_handlers(CLUREF e, CLUREF stmts)
{
    errcode err;
    enter_proc(392);

  LINE(393);
    { /* return */
    signal (ERR_ok);
    }

  LINE(394);
    {
    err = handlersOPinit(e);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(395);
    {
    err = g_check_handlers_main(stmts);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(396);
    {
    err = handlersOPdone();
    if (err != ERR_ok)
        goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE g_check_handlers ****/



/**** BEGIN PROCEDURE g_check_handlers_main ****/

extern errcode handlersOPset_lineno();
extern errcode stmtOPget_line();
extern errcode stmtOPget_abs();
extern errcode g_check_handlers_exprs();
extern errcode recordOPget_3();
extern errcode handlersOPnew_signals();
extern errcode g_check_handlers_exprlist();
extern errcode handlersOPadd_signal();
extern errcode handlersOPenter();
extern errcode sequenceOPfill();
extern errcode handlersOPleave_except();
extern errcode handlersOPleave_resig();
static CLUREF STR_exit;
static int g_check_handlers_main_own_init = 0;

errcode
g_check_handlers_main(CLUREF stmts)
{
    errcode err;
    CLUREF s;
    CLUREF di;
    CLUREF inv;
    CLUREF as;
    CLUREF w;
    CLUREF f;
    CLUREF i;
    CLUREF arm;
    CLUREF b;
    CLUREF t;
    CLUREF el;
    CLUREF c;
    CLUREF e;
    CLUREF ah;
    CLUREF o;
    CLUREF r;
    CLUREF save_lineno;
    if (g_check_handlers_main_own_init == 0) {
        stringOPcons("exit", CLU_1, CLUREF_make_num(4), &STR_exit);
        g_check_handlers_main_own_init = 1;
    }
    enter_proc(399);

  LINE(400);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = stmts.vec->size;
    T_1_3 = stmts;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        s.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(401);
        {
        CLUREF T_2_1;
        err = stmtOPget_line(s, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = handlersOPset_lineno(T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(402);
        { /* qtagcase */
        CLUREF T_2_1;
        err = stmtOPget_abs(s, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_1.cell->tag) {
        case 7: /* declinit */ {
            CLUREF T_2_2;
            T_2_2.num = T_2_1.cell->value;
            di.num = T_2_2.num;

  LINE(404);
            {
            CLUREF T_3_1;
            T_3_1.num = di.vec->data[2];
            err = g_check_handlers_exprs(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 13: /* invoke */ {
            CLUREF T_2_3;
            T_2_3.num = T_2_1.cell->value;
            inv.num = T_2_3.num;

  LINE(406);
            {
            CLUREF T_3_1;
            T_3_1.num = inv.vec->data[0];
            err = g_check_handlers_exprs(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(407);
            {
            CLUREF T_3_1;
            T_3_1.num = inv.vec->data[0];
            err = handlersOPnew_signals(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(408);
            {
            CLUREF T_3_1;
            T_3_1.num = inv.vec->data[1];
            err = g_check_handlers_exprlist(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 1: /* assn */ {
            CLUREF T_2_4;
            T_2_4.num = T_2_1.cell->value;
            as.num = T_2_4.num;

  LINE(410);
            {
            CLUREF T_3_1;
            T_3_1.num = as.vec->data[2];
            err = g_check_handlers_exprlist(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 17: /* sugarassn */ {
            CLUREF T_2_5;
            T_2_5.num = T_2_1.cell->value;
            as.num = T_2_5.num;

  LINE(412);
            {
            CLUREF T_3_1;
            T_3_1.num = as.vec->data[1];
            err = g_check_handlers_exprs(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(413);
            {
            CLUREF T_3_1;
            T_3_1.num = as.vec->data[0];
            err = g_check_handlers_exprs(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 19: /* while_ */ {
            CLUREF T_2_6;
            T_2_6.num = T_2_1.cell->value;
            w.num = T_2_6.num;

  LINE(415);
            {
            CLUREF T_3_1;
            T_3_1.num = w.vec->data[1];
            err = g_check_handlers_exprs(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(416);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = w.vec->data[0];
            T_3_2.num = T_3_1.vec->data[1];
            err = g_check_handlers_main(T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 10: /* for_ */ {
            CLUREF T_2_7;
            T_2_7.num = T_2_1.cell->value;
            f.num = T_2_7.num;

  LINE(418);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = f.vec->data[2];
            T_3_2.num = T_3_1.vec->data[0];
            err = handlersOPnew_signals(T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(419);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = f.vec->data[2];
            T_3_2.num = T_3_1.vec->data[0];
            err = g_check_handlers_exprs(T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(420);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = f.vec->data[2];
            T_3_2.num = T_3_1.vec->data[1];
            err = g_check_handlers_exprlist(T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(421);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = f.vec->data[1];
            T_3_2.num = T_3_1.vec->data[1];
            err = g_check_handlers_main(T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 12: /* if_ */ {
            CLUREF T_2_8;
            T_2_8.num = T_2_1.cell->value;
            i.num = T_2_8.num;

  LINE(423);
            { /* for sequence$elements */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_1.num = i.vec->data[0];
            T_3_3.num = T_3_1.vec->size;
            T_3_4 = T_3_1;
            for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                arm.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(424);
                {
                CLUREF T_4_1;
                T_4_1.num = arm.vec->data[2];
                err = g_check_handlers_exprs(T_4_1);
                if (err != ERR_ok)
                    goto ex_0;
                }

  LINE(425);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = arm.vec->data[0];
                T_4_2.num = T_4_1.vec->data[1];
                err = g_check_handlers_main(T_4_2);
                if (err != ERR_ok)
                    goto ex_0;
                }
            }
            }
            end_inline_for_2:
            __CLU_END_LABEL;

  LINE(427);
            { /* qtagcase */
            CLUREF T_3_1;
            T_3_1.num = i.vec->data[1];
            switch (T_3_1.cell->tag) {
            case 1: /* body */ {
                CLUREF T_3_2;
                T_3_2.num = T_3_1.cell->value;
                b.num = T_3_2.num;

  LINE(429);
                {
                CLUREF T_4_1;
                T_4_1.num = b.vec->data[1];
                err = g_check_handlers_main(T_4_1);
                if (err != ERR_ok)
                    goto ex_0;
                }
                break;
            }
            }
            } /* end qtagcase */
            break;
        }
        case 18: /* tag_ */ {
            CLUREF T_2_9;
            T_2_9.num = T_2_1.cell->value;
            t.num = T_2_9.num;

  LINE(433);
            {
            CLUREF T_3_1;
            T_3_1.num = t.vec->data[1];
            err = g_check_handlers_exprs(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(442);
            { /* for sequence$elements */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_1.num = t.vec->data[0];
            T_3_3.num = T_3_1.vec->size;
            T_3_4 = T_3_1;
            for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                arm.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(450);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = arm.vec->data[0];
                T_4_2.num = T_4_1.vec->data[1];
                err = g_check_handlers_main(T_4_2);
                if (err != ERR_ok)
                    goto ex_0;
                }
            }
            }
            end_inline_for_3:
            __CLU_END_LABEL;

  LINE(452);
            { /* qtagcase */
            CLUREF T_3_1;
            T_3_1.num = t.vec->data[2];
            switch (T_3_1.cell->tag) {
            case 1: /* body */ {
                CLUREF T_3_2;
                T_3_2.num = T_3_1.cell->value;
                b.num = T_3_2.num;

  LINE(454);
                {
                CLUREF T_4_1;
                T_4_1.num = b.vec->data[1];
                err = g_check_handlers_main(T_4_1);
                if (err != ERR_ok)
                    goto ex_0;
                }
                break;
            }
            }
            } /* end qtagcase */
            break;
        }
        case 15: /* return_ */ {
            CLUREF T_2_10;
            T_2_10.num = T_2_1.cell->value;
            el.num = T_2_10.num;

  LINE(458);
            {
            err = g_check_handlers_exprlist(el);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 20: /* yield_ */ {
            CLUREF T_2_11;
            T_2_11.num = T_2_1.cell->value;
            el.num = T_2_11.num;

  LINE(460);
            {
            err = g_check_handlers_exprlist(el);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 16: /* signal_ */ {
            CLUREF T_2_12;
            T_2_12.num = T_2_1.cell->value;
            c.num = T_2_12.num;

  LINE(462);
            {
            CLUREF T_3_1;
            T_3_1.num = c.vec->data[0];
            err = g_check_handlers_exprlist(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 9: /* exit_ */ {
            CLUREF T_2_13;
            T_2_13.num = T_2_1.cell->value;
            c.num = T_2_13.num;

  LINE(464);
            {
            CLUREF T_3_1;
            T_3_1.num = c.vec->data[1];
            err = handlersOPadd_signal(T_3_1, STR_exit);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(465);
            {
            CLUREF T_3_1;
            T_3_1.num = c.vec->data[0];
            err = g_check_handlers_exprlist(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 3: /* body */ {
            CLUREF T_2_14;
            T_2_14.num = T_2_1.cell->value;
            b.num = T_2_14.num;

  LINE(467);
            {
            CLUREF T_3_1;
            T_3_1.num = b.vec->data[1];
            err = g_check_handlers_main(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 8: /* except_ */ {
            CLUREF T_2_15;
            T_2_15.num = T_2_1.cell->value;
            e.num = T_2_15.num;

  LINE(469);
            {
            err = handlersOPenter();
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(470);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = e.vec->data[2];
            err = sequenceOPfill(CLU_1, T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            err = g_check_handlers_main(T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(471);
            {
            err = handlersOPleave_except(e);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(472);
            { /* for sequence$elements */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_1.num = e.vec->data[0];
            T_3_3.num = T_3_1.vec->size;
            T_3_4 = T_3_1;
            for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                ah.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(473);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = ah.vec->data[0];
                T_4_2.num = T_4_1.vec->data[1];
                err = g_check_handlers_main(T_4_2);
                if (err != ERR_ok)
                    goto ex_0;
                }
            }
            }
            end_inline_for_4:
            __CLU_END_LABEL;

  LINE(475);
            { /* qtagcase */
            CLUREF T_3_1;
            T_3_1.num = e.vec->data[1];
            switch (T_3_1.cell->tag) {
            case 1: /* arm */ {
                CLUREF T_3_2;
                T_3_2.num = T_3_1.cell->value;
                o.num = T_3_2.num;

  LINE(477);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = o.vec->data[0];
                T_4_2.num = T_4_1.vec->data[1];
                err = g_check_handlers_main(T_4_2);
                if (err != ERR_ok)
                    goto ex_0;
                }
                break;
            }
            }
            } /* end qtagcase */
            break;
        }
        case 11: /* force_ */ {
            CLUREF T_2_16;
            T_2_16.num = T_2_1.cell->value;
            f.num = T_2_16.num;

  LINE(482);
            {
            CLUREF T_3_1;
            T_3_1.num = f.vec->data[0];
            err = g_check_handlers_exprs(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 14: /* resignal_ */ {
            CLUREF T_2_17;
            T_2_17.num = T_2_1.cell->value;
            r.num = T_2_17.num;

  LINE(484);
            {
            CLUREF T_3_1;
            err = stmtOPget_line(s, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            save_lineno.num = T_3_1.num;
            }

  LINE(485);
            {
            err = handlersOPenter();
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(486);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = r.vec->data[1];
            err = sequenceOPfill(CLU_1, T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            err = g_check_handlers_main(T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(487);
            {
            err = handlersOPleave_resig(r, save_lineno);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        case 6: /* decl */ /* FALLTHROUGH */
        case 4: /* break_ */ /* FALLTHROUGH */
        case 5: /* continue_ */ /* FALLTHROUGH */
        case 2: /* bad */ {
            break;
        }
        }
        } /* end qtagcase */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE g_check_handlers_main ****/



/**** BEGIN PROCEDURE g_check_handlers_exprlist ****/


errcode
g_check_handlers_exprlist(CLUREF el)
{
    errcode err;
    CLUREF each_expr;
    enter_proc(493);

  LINE(494);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = el.vec->size;
    T_1_3 = el;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        each_expr.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(495);
        {
        err = g_check_handlers_exprs(each_expr);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE g_check_handlers_exprlist ****/



/**** BEGIN PROCEDURE g_check_handlers_exprs ****/

extern errcode exprOPget_abs();
extern errcode oneofOPis_2();
extern errcode oneofOPvalue_2();

errcode
g_check_handlers_exprs(CLUREF ex)
{
    errcode err;
    CLUREF e;
    CLUREF c;
    CLUREF inv;
    CLUREF ar;
    CLUREF each_elt;
    CLUREF xa;
    CLUREF each_field;
    CLUREF ct;
    CLUREF cop;
    enter_proc(499);

  LINE(501);
    { /* qtagcase */
    CLUREF T_1_1;
    err = exprOPget_abs(ex, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: /* any_ */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        e.num = T_1_2.num;

  LINE(503);
        {
        err = g_check_handlers_exprs(e);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    case 6: /* cand_ */ /* FALLTHROUGH */
    case 8: /* cor_ */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        c.num = T_1_3.num;

  LINE(505);
        {
        CLUREF T_2_1;
        T_2_1.num = c.vec->data[0];
        err = g_check_handlers_exprs(T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(506);
        {
        CLUREF T_2_1;
        T_2_1.num = c.vec->data[1];
        err = g_check_handlers_exprs(T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    case 16: /* invoke */ {
        CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        inv.num = T_1_4.num;

  LINE(508);
        {
        CLUREF T_2_1;
        T_2_1.num = inv.vec->data[0];
        err = g_check_handlers_exprs(T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(509);
        {
        CLUREF T_2_1;
        T_2_1.num = inv.vec->data[0];
        err = handlersOPnew_signals(T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(510);
        {
        CLUREF T_2_1;
        T_2_1.num = inv.vec->data[1];
        err = g_check_handlers_exprlist(T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    case 1: /* a_cons */ {
        CLUREF T_1_5;
        T_1_5.num = T_1_1.cell->value;
        ar.num = T_1_5.num;

  LINE(513);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = ar.vec->data[1];
        if (T_2_1.cell->tag == 2) T_2_2.num = true; else T_2_2.num = false;
        if (T_2_2.num == true) { /* if */

  LINE(514);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = ar.vec->data[1];
            if (T_3_1.cell->tag != 2) {
                err = ERR_wrong_tag;
                goto ex_0;
            }
            T_3_2.num = T_3_1.cell->value;
            err = g_check_handlers_exprs(T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        } /* end if */

  LINE(515);
        { /* for sequence$elements */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.num = ar.vec->data[0];
        T_2_3.num = T_2_1.vec->size;
        T_2_4 = T_2_1;
        for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
            each_elt.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(516);
            {
            err = g_check_handlers_exprs(each_elt);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        }
        end_inline_for_1:
        __CLU_END_LABEL;
        break;
    }
    case 23: /* s_cons */ {
        CLUREF T_1_6;
        T_1_6.num = T_1_1.cell->value;
        xa.num = T_1_6.num;

  LINE(519);
        { /* for sequence$elements */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.num = xa.vec->data[0];
        T_2_3.num = T_2_1.vec->size;
        T_2_4 = T_2_1;
        for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
            each_field.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(520);
            {
            CLUREF T_3_1;
            T_3_1.num = each_field.vec->data[2];
            err = g_check_handlers_exprs(T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        }
        end_inline_for_2:
        __CLU_END_LABEL;
        break;
    }
    case 3: /* apply */ {
        CLUREF T_1_7;
        T_1_7.num = T_1_1.cell->value;
        ct.num = T_1_7.num;
        break;
    }
    case 20: /* op */ {
        CLUREF T_1_8;
        T_1_8.num = T_1_1.cell->value;
        cop.num = T_1_8.num;
        break;
    }
    case 26: /* type_of_ */ {
        CLUREF T_1_9;
        T_1_9.num = T_1_1.cell->value;
        e.num = T_1_9.num;

  LINE(527);
        {
        err = g_check_handlers_exprs(e);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    case 27: /* up_ */ {
        CLUREF T_1_10;
        T_1_10.num = T_1_1.cell->value;
        e.num = T_1_10.num;

  LINE(529);
        {
        err = g_check_handlers_exprs(e);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    case 9: /* down_ */ {
        CLUREF T_1_11;
        T_1_11.num = T_1_1.cell->value;
        e.num = T_1_11.num;

  LINE(531);
        {
        err = g_check_handlers_exprs(e);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE g_check_handlers_exprs ****/


/**** BEGIN CLUSTER handlers ****/

extern errcode arrayOPnew();
extern errcode g_envOPwarn();
extern errcode arrayOPfill();
extern errcode arrayOPindexes();
extern errcode arrayOPfetch();
extern errcode arrayOPstore();
extern errcode arrayOPtop();
extern errcode arrayOPremh();
extern errcode duOPread_specs();
extern errcode oneofOPis_4();
extern errcode duOPget_common();
extern errcode tinfo_op_sigs();
extern errcode field_index();
extern errcode exprOPget_typespec();
extern errcode idnOPget_str();
extern errcode expr_print();
static CLUREF STR__072_011unhandled_040signal_040_042;
static CLUREF STR__040from_040;
static CLUREF STR_failure;
static CLUREF STR__072_011signal_040_042;
static CLUREF STR__042_040resignalled_054_040but_040cannot_040occur;
static CLUREF STR__042_040caught_054_040but_040cannot_040occur;
static CLUREF STR_newsignals_057ty_056abs_040not_040dealing_040with_040non_055applytype;
static CLUREF STR_newsignals_057apply_040not_040dealing_040with_040non_055applyinfo;
static CLUREF STR_handlers_040not_040dealing_040with_040applyinfo;
static CLUREF STR_handlers_040not_040dealing_040with_040some_040typeinfo;
static CLUREF STR_handlers_057select_040not_040dealing_040with_040applyinfo;
static CLUREF STR_handlers_057select_040not_040dealing_040with_040some_040typeinfo;
static CLUREF STR_handlers_040not_040dealing_040with_040some_040typespec;
static CLUREF STR_force;
static CLUREF STR_handlers_040not_040dealing_040with_040some_040expr_040;
static int handlers_own_init = 0;
const OWN_req handlers_ownreqs = { 0, 0 };
CLUREF handlersOPscopes;
CLUREF handlersOPcurrent_scope;
CLUREF handlersOPlineno;
CLUREF handlersOPenv;

errcode
handlers_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (handlers_own_init == 0) {
        stringOPcons(":\tunhandled signal \"", CLU_1, CLUREF_make_num(20), &STR__072_011unhandled_040signal_040_042);
        stringOPcons("\"", CLU_1, CLUREF_make_num(1), &STR__042);
        stringOPcons(" from ", CLU_1, CLUREF_make_num(6), &STR__040from_040);
        stringOPcons("failure", CLU_1, CLUREF_make_num(7), &STR_failure);
        stringOPcons(":\tsignal \"", CLU_1, CLUREF_make_num(10), &STR__072_011signal_040_042);
        stringOPcons("\" resignalled, but cannot occur", CLU_1, CLUREF_make_num(31), &STR__042_040resignalled_054_040but_040cannot_040occur);
        stringOPcons("\" caught, but cannot occur", CLU_1, CLUREF_make_num(26), &STR__042_040caught_054_040but_040cannot_040occur);
        stringOPcons("newsignals/ty.abs not dealing with non-applytype", CLU_1, CLUREF_make_num(48), &STR_newsignals_057ty_056abs_040not_040dealing_040with_040non_055applytype);
        stringOPcons("newsignals/apply not dealing with non-applyinfo", CLU_1, CLUREF_make_num(47), &STR_newsignals_057apply_040not_040dealing_040with_040non_055applyinfo);
        stringOPcons("handlers not dealing with applyinfo", CLU_1, CLUREF_make_num(35), &STR_handlers_040not_040dealing_040with_040applyinfo);
        stringOPcons("$", CLU_1, CLUREF_make_num(1), &STR__044);
        stringOPcons("handlers not dealing with some typeinfo", CLU_1, CLUREF_make_num(39), &STR_handlers_040not_040dealing_040with_040some_040typeinfo);
        stringOPcons("handlers/select not dealing with applyinfo", CLU_1, CLUREF_make_num(42), &STR_handlers_057select_040not_040dealing_040with_040applyinfo);
        stringOPcons("handlers/select not dealing with some typeinfo", CLU_1, CLUREF_make_num(46), &STR_handlers_057select_040not_040dealing_040with_040some_040typeinfo);
        stringOPcons("handlers not dealing with some typespec", CLU_1, CLUREF_make_num(39), &STR_handlers_040not_040dealing_040with_040some_040typespec);
        stringOPcons("force", CLU_1, CLUREF_make_num(5), &STR_force);
        stringOPcons("handlers not dealing with some expr ", CLU_1, CLUREF_make_num(36), &STR_handlers_040not_040dealing_040with_040some_040expr_040);
        handlers_own_init = 1;
        {
        handlersOPlineno.num = 0;
        }
        signal(ERR_ok);
      ex_0:
        __CLU_EX_HANDLER;
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE init ****/


errcode
handlersOPinit(CLUREF ge)
{
    errcode err;
    if (handlers_own_init == 0) {
        err = handlers_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(548);

  LINE(549);
    {
    handlersOPenv.num = ge.num;
    }

  LINE(550);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    handlersOPscopes.num = T_1_1.num;
    }

  LINE(551);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    handlersOPcurrent_scope.num = T_1_1.num;
    }

  LINE(552);
    {
    handlersOPlineno.num = 0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE init ****/


/**** BEGIN PROCEDURE set_lineno ****/


errcode
handlersOPset_lineno(CLUREF l)
{
    errcode err;
    if (handlers_own_init == 0) {
        err = handlers_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(555);

  LINE(556);
    {
    handlersOPlineno.num = l.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_lineno ****/


/**** BEGIN PROCEDURE done ****/

static int handlersOPdone_own_init = 0;

errcode
handlersOPdone(void)
{
    errcode err;
    CLUREF e;
    CLUREF warn;
    if (handlersOPdone_own_init == 0) {
        if (handlers_own_init == 0) {
            err = handlers_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        handlersOPdone_own_init = 1;
    }
    enter_proc(559);

  LINE(560);
    { /* for array$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = handlersOPcurrent_scope.array->ext_high;
    T_1_3 = handlersOPcurrent_scope;
    for (T_1_1.num = handlersOPcurrent_scope.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
            err = ERR_failure;
            elist[0] = array_bounds_exception_STRING;
            goto ex_0;
        }
        e.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(561);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        T_2_1.num = e.vec->data[0];
        err = intOPunparse(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_2, STR__072_011unhandled_040signal_040_042, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_4.num = e.vec->data[2];
        err = stringOPconcat(T_2_3, T_2_4, &T_2_5);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_5, STR__042, &T_2_6);
        if (err != ERR_ok)
            goto ex_0;
        warn.num = T_2_6.num;
        }

  LINE(563);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = e.vec->data[1];
        err = stringOPempty(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_3.num = !T_2_2.num;
        if (T_2_3.num == true) { /* if */

  LINE(564);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = stringOPconcat(warn, STR__040from_040, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            T_3_2.num = e.vec->data[1];
            err = stringOPconcat(T_3_1, T_3_2, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            warn.num = T_3_3.num;
            }
        }
        } /* end if */

  LINE(565);
        {
        err = g_envOPwarn(handlersOPenv, warn);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE done ****/


/**** BEGIN PROCEDURE enter ****/


errcode
handlersOPenter(void)
{
    errcode err;
    if (handlers_own_init == 0) {
        err = handlers_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(569);

  LINE(570);
    {
    {
    if ((handlersOPscopes.array->int_low + handlersOPscopes.array->ext_size + 1) < handlersOPscopes.array->int_size) {
        handlersOPscopes.array->store->data[handlersOPscopes.array->int_low + handlersOPscopes.array->ext_size] = handlersOPcurrent_scope.num;
        handlersOPscopes.array->ext_size++;
        handlersOPscopes.array->ext_high++;
    }
    else {
        err = arrayOPaddh(handlersOPscopes, handlersOPcurrent_scope);
        if (err != ERR_ok)
            goto ex_0;
    }
    }
    }

  LINE(571);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    handlersOPcurrent_scope.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE enter ****/


/**** BEGIN PROCEDURE leave_resig ****/

static int handlersOPleave_resig_own_init = 0;

errcode
handlersOPleave_resig(CLUREF r, CLUREF line)
{
    errcode err;
    CLUREF handled;
    CLUREF each_name;
    CLUREF found;
    CLUREF i;
    if (handlersOPleave_resig_own_init == 0) {
        if (handlers_own_init == 0) {
            err = handlers_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        handlersOPleave_resig_own_init = 1;
    }
    enter_proc(574);

  LINE(575);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = handlersOPcurrent_scope.array->ext_size;
    err = arrayOPfill(CLU_1, T_1_1, CLU_false, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    handled.num = T_1_2.num;
    }

  LINE(576);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = r.vec->data[0];
    T_1_3.num = T_1_1.vec->size;
    T_1_4 = T_1_1;
    for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
        each_name.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(577);
        {
        found.tf = false;
        }

  LINE(578);
        { /* for array$indexes */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_2.num = handlersOPcurrent_scope.array->ext_high;
        for (T_2_1.num = handlersOPcurrent_scope.array->ext_low; T_2_1.num <= T_2_2.num; T_2_1.num++) {
            i.num = T_2_1.num;

  LINE(579);
            { /* if */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            if (i.num < handlersOPcurrent_scope.array->ext_low || i.num > handlersOPcurrent_scope.array->ext_high) {
                err = ERR_bounds;
                goto ex_0;
            }
            T_3_1.num = handlersOPcurrent_scope.array->store->data[i.num - handlersOPcurrent_scope.array->ext_low + handlersOPcurrent_scope.array->int_low];
            T_3_2.num = T_3_1.vec->data[2];
            T_3_3.num = ((T_3_2.str->size != each_name.str->size)? false :
                !(memcmp(T_3_2.str->data, each_name.str->data, T_3_2.str->size)));
            if (T_3_3.num == true) { /* if */

  LINE(580);
                {
                {
                if (i.num < handled.array->ext_low || i.num > handled.array->ext_high) {
                    err = ERR_bounds;
                    goto ex_0;
                }
                handled.array->store->data[i.num + handled.array->int_low - handled.array->ext_low] = true;
                }
                }

  LINE(581);
                {
                found.tf = true;
                }
            }
            } /* end if */
        }
        }
        end_inline_for_2:
        __CLU_END_LABEL;

  LINE(584);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_2.num = !found.num;
        T_2_1.num = T_2_2.num;
        if (T_2_2.num) {
            T_2_3.num = ((each_name.str->size != STR_failure.str->size)? false :
                !(memcmp(each_name.str->data, STR_failure.str->data, each_name.str->size)));
            T_2_4.num = !T_2_3.num;
            T_2_1.num = T_2_4.num;
        }
        if (T_2_1.num == true) { /* if */

  LINE(585);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            err = intOPunparse(line, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_1, STR__072_011signal_040_042, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_2, each_name, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_3, STR__042_040resignalled_054_040but_040cannot_040occur, &T_3_4);
            if (err != ERR_ok)
                goto ex_0;
            err = g_envOPwarn(handlersOPenv, T_3_4);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        } /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(589);
    { /* for array$indexes */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = handled.array->ext_high;
    for (T_1_1.num = handled.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        i.num = T_1_1.num;

  LINE(590);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (i.num < handled.array->ext_low || i.num > handled.array->ext_high) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.num = handled.array->store->data[i.num - handled.array->ext_low + handled.array->int_low];
        T_2_2.num = !T_2_1.num;
        if (T_2_2.num == true) { /* if */

  LINE(591);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = arrayOPtop(handlersOPscopes, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            if (i.num < handlersOPcurrent_scope.array->ext_low || i.num > handlersOPcurrent_scope.array->ext_high) {
                err = ERR_bounds;
                goto ex_0;
            }
            T_3_2.num = handlersOPcurrent_scope.array->store->data[i.num - handlersOPcurrent_scope.array->ext_low + handlersOPcurrent_scope.array->int_low];
            {
            if ((T_3_1.array->int_low + T_3_1.array->ext_size + 1) < T_3_1.array->int_size) {
                T_3_1.array->store->data[T_3_1.array->int_low + T_3_1.array->ext_size] = T_3_2.num;
                T_3_1.array->ext_size++;
                T_3_1.array->ext_high++;
            }
            else {
                err = arrayOPaddh(T_3_1, T_3_2);
                if (err != ERR_ok)
                    goto ex_0;
            }
            }
            }
        }
        } /* end if */
    }
    }
    end_inline_for_3:
    __CLU_END_LABEL;

  LINE(594);
    {
    CLUREF T_1_1;
    err = arrayOPremh(handlersOPscopes, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    handlersOPcurrent_scope.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE leave_resig ****/


/**** BEGIN PROCEDURE leave_except ****/

static int handlersOPleave_except_own_init = 0;

errcode
handlersOPleave_except(CLUREF exc)
{
    errcode err;
    CLUREF handled;
    CLUREF each_arm;
    CLUREF each_name;
    CLUREF found;
    CLUREF i;
    if (handlersOPleave_except_own_init == 0) {
        if (handlers_own_init == 0) {
            err = handlers_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        handlersOPleave_except_own_init = 1;
    }
    enter_proc(597);

  LINE(598);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = handlersOPcurrent_scope.array->ext_size;
    err = arrayOPfill(CLU_1, T_1_1, CLU_false, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    handled.num = T_1_2.num;
    }

  LINE(599);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = exc.vec->data[0];
    T_1_3.num = T_1_1.vec->size;
    T_1_4 = T_1_1;
    for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
        each_arm.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(600);
        { /* for sequence$elements */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.num = each_arm.vec->data[2];
        T_2_3.num = T_2_1.vec->size;
        T_2_4 = T_2_1;
        for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
            each_name.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(601);
            {
            found.tf = false;
            }

  LINE(602);
            { /* for array$indexes */
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_2.num = handlersOPcurrent_scope.array->ext_high;
            for (T_3_1.num = handlersOPcurrent_scope.array->ext_low; T_3_1.num <= T_3_2.num; T_3_1.num++) {
                i.num = T_3_1.num;

  LINE(603);
                { /* if */
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                if (i.num < handlersOPcurrent_scope.array->ext_low || i.num > handlersOPcurrent_scope.array->ext_high) {
                    err = ERR_bounds;
                    goto ex_0;
                }
                T_4_1.num = handlersOPcurrent_scope.array->store->data[i.num - handlersOPcurrent_scope.array->ext_low + handlersOPcurrent_scope.array->int_low];
                T_4_2.num = T_4_1.vec->data[2];
                T_4_3.num = ((T_4_2.str->size != each_name.str->size)? false :
                    !(memcmp(T_4_2.str->data, each_name.str->data, T_4_2.str->size)));
                if (T_4_3.num == true) { /* if */

  LINE(604);
                    {
                    {
                    if (i.num < handled.array->ext_low || i.num > handled.array->ext_high) {
                        err = ERR_bounds;
                        goto ex_0;
                    }
                    handled.array->store->data[i.num + handled.array->int_low - handled.array->ext_low] = true;
                    }
                    }

  LINE(605);
                    {
                    found.tf = true;
                    }
                }
                } /* end if */
            }
            }
            end_inline_for_3:
            __CLU_END_LABEL;

  LINE(608);
            { /* if */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_2.num = !found.num;
            T_3_1.num = T_3_2.num;
            if (T_3_2.num) {
                T_3_3.num = ((each_name.str->size != STR_failure.str->size)? false :
                    !(memcmp(each_name.str->data, STR_failure.str->data, each_name.str->size)));
                T_3_4.num = !T_3_3.num;
                T_3_1.num = T_3_4.num;
            }
            if (T_3_1.num == true) { /* if */

  LINE(609);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                CLUREF T_4_4;
                CLUREF T_4_5;
                T_4_1.num = each_arm.vec->data[1];
                err = intOPunparse(T_4_1, &T_4_2);
                if (err != ERR_ok)
                    goto ex_0;
                err = stringOPconcat(T_4_2, STR__072_011signal_040_042, &T_4_3);
                if (err != ERR_ok)
                    goto ex_0;
                err = stringOPconcat(T_4_3, each_name, &T_4_4);
                if (err != ERR_ok)
                    goto ex_0;
                err = stringOPconcat(T_4_4, STR__042_040caught_054_040but_040cannot_040occur, &T_4_5);
                if (err != ERR_ok)
                    goto ex_0;
                err = g_envOPwarn(handlersOPenv, T_4_5);
                if (err != ERR_ok)
                    goto ex_0;
                }
            }
            } /* end if */
        }
        }
        end_inline_for_2:
        __CLU_END_LABEL;
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(615);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = exc.vec->data[1];
    if (T_1_1.cell->tag == 2) T_1_2.num = true; else T_1_2.num = false;
    if (T_1_2.num == true) { /* if */

  LINE(616);
        { /* for array$indexes */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_2.num = handled.array->ext_high;
        for (T_2_1.num = handled.array->ext_low; T_2_1.num <= T_2_2.num; T_2_1.num++) {
            i.num = T_2_1.num;

  LINE(617);
            { /* if */
            CLUREF T_3_1;
            CLUREF T_3_2;
            if (i.num < handled.array->ext_low || i.num > handled.array->ext_high) {
                err = ERR_bounds;
                goto ex_0;
            }
            T_3_1.num = handled.array->store->data[i.num - handled.array->ext_low + handled.array->int_low];
            T_3_2.num = !T_3_1.num;
            if (T_3_2.num == true) { /* if */

  LINE(618);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                err = arrayOPtop(handlersOPscopes, &T_4_1);
                if (err != ERR_ok)
                    goto ex_0;
                if (i.num < handlersOPcurrent_scope.array->ext_low || i.num > handlersOPcurrent_scope.array->ext_high) {
                    err = ERR_bounds;
                    goto ex_0;
                }
                T_4_2.num = handlersOPcurrent_scope.array->store->data[i.num - handlersOPcurrent_scope.array->ext_low + handlersOPcurrent_scope.array->int_low];
                {
                if ((T_4_1.array->int_low + T_4_1.array->ext_size + 1) < T_4_1.array->int_size) {
                    T_4_1.array->store->data[T_4_1.array->int_low + T_4_1.array->ext_size] = T_4_2.num;
                    T_4_1.array->ext_size++;
                    T_4_1.array->ext_high++;
                }
                else {
                    err = arrayOPaddh(T_4_1, T_4_2);
                    if (err != ERR_ok)
                        goto ex_0;
                }
                }
                }
            }
            } /* end if */
        }
        }
        end_inline_for_4:
        __CLU_END_LABEL;
    }
    } /* end if */

  LINE(622);
    {
    CLUREF T_1_1;
    err = arrayOPremh(handlersOPscopes, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    handlersOPcurrent_scope.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE leave_except ****/


/**** BEGIN PROCEDURE new_signals ****/

static int handlersOPnew_signals_own_init = 0;

errcode
handlersOPnew_signals(CLUREF ex)
{
    errcode err;
    CLUREF ty;
    CLUREF nm;
    CLUREF ct;
    CLUREF specs;
    CLUREF b;
    CLUREF ap;
    CLUREF apt;
    CLUREF each_sig;
    CLUREF cop;
    CLUREF tyinfo;
    CLUREF sigs;
    CLUREF st;
    CLUREF nm2;
    CLUREF j;
    CLUREF id;
    CLUREF inv;
    CLUREF t;
    if (handlersOPnew_signals_own_init == 0) {
        if (handlers_own_init == 0) {
            err = handlers_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        handlersOPnew_signals_own_init = 1;
    }
    enter_proc(625);

  LINE(627);
    {
    nm = CLU_empty_string;
    }

  LINE(631);
    { /* qtagcase */
    CLUREF T_1_1;
    err = exprOPget_abs(ex, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 3: /* apply */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        ct.num = T_1_2.num;

  LINE(633);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = ct.vec->data[0];
        err = duOPread_specs(T_2_1, &T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        specs.num = T_2_2.num;
        b.num = T_2_3.num;
        }

  LINE(634);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (specs.cell->tag == 4) T_2_1.num = true; else T_2_1.num = false;
        T_2_2.num = !T_2_1.num;
        if (T_2_2.num == true) { /* if */

  LINE(635);
            { /* qtagcase */
            switch (specs.cell->tag) {
            case 1: /* apply */ {
                CLUREF T_3_1;
                T_3_1.num = specs.cell->value;
                ap.num = T_3_1.num;

  LINE(637);
                {
                CLUREF T_4_1;
                T_4_1.num = ap.vec->data[1];
                ty.num = T_4_1.num;
                }

  LINE(638);
                { /* qtagcase */
                CLUREF T_4_1;
                err = typespecOPget_abs(ty, &T_4_1);
                if (err != ERR_ok)
                    goto ex_0;
                switch (T_4_1.cell->tag) {
                case 2: /* apply */ {
                    CLUREF T_4_2;
                    T_4_2.num = T_4_1.cell->value;
                    apt.num = T_4_2.num;

  LINE(640);
                    { /* for sequence$elements */
                    CLUREF T_5_1;
                    CLUREF T_5_2;
                    CLUREF T_5_3;
                    CLUREF T_5_4;
                    T_5_1.num = apt.vec->data[2];
                    T_5_3.num = T_5_1.vec->size;
                    T_5_4 = T_5_1;
                    for (T_5_2.num = 1; T_5_2.num <= T_5_3.num; T_5_2.num++) {
                        each_sig.num = T_5_4.vec->data[T_5_2.num - 1];

  LINE(641);
                        {
                        CLUREF T_6_1;
                        CLUREF T_6_2;
                        CLUREF T_6_3;
                        T_6_1.num = each_sig.vec->data[0];
                        T_6_2.num = ct.vec->data[0];
                        err = duOPget_common(T_6_2, &T_6_3);
                        if (err != ERR_ok)
                            goto ex_0;
                        err = handlersOPadd_signal(T_6_1, T_6_3);
                        if (err != ERR_ok)
                            goto ex_0;
                        }
                    }
                    }
                    end_inline_for_1:
                    __CLU_END_LABEL;
                    break;
                }
                default: {

  LINE(647);
                    {
                    CLUREF T_5_1;
                    T_5_1.num = 993;
                    err = compiler_logit(T_5_1, STR_newsignals_057ty_056abs_040not_040dealing_040with_040non_055applytype);
                    if (err != ERR_ok)
                        goto ex_0;
                    }
                    break;
                }
                }
                } /* end qtagcase */
                break;
            }
            default: {

  LINE(650);
                {
                CLUREF T_4_1;
                T_4_1.num = 994;
                err = compiler_logit(T_4_1, STR_newsignals_057apply_040not_040dealing_040with_040non_055applyinfo);
                if (err != ERR_ok)
                    goto ex_0;
                }
                break;
            }
            }
            } /* end qtagcase */
        }
        } /* end if */
        break;
    }
    case 20: /* op */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        cop.num = T_1_3.num;

  LINE(654);
        {
        CLUREF T_2_1;
        T_2_1.num = cop.vec->data[0];
        nm.num = T_2_1.num;
        }

  LINE(655);
        {
        CLUREF T_2_1;
        T_2_1.num = cop.vec->data[2];
        ty.num = T_2_1.num;
        }

  LINE(656);
        { /* qtagcase */
        CLUREF T_3_1;
        err = typespecOPget_abs(ty, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        switch (T_3_1.cell->tag) {
        case 2: /* apply */ {
            CLUREF T_3_2;
            T_3_2.num = T_3_1.cell->value;
            ap.num = T_3_2.num;

  LINE(658);
            { /* for sequence$elements */
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            T_4_1.num = ap.vec->data[2];
            T_4_3.num = T_4_1.vec->size;
            T_4_4 = T_4_1;
            for (T_4_2.num = 1; T_4_2.num <= T_4_3.num; T_4_2.num++) {
                each_sig.num = T_4_4.vec->data[T_4_2.num - 1];

  LINE(659);
                {
                CLUREF T_5_1;
                T_5_1.num = each_sig.vec->data[0];
                err = handlersOPadd_signal(T_5_1, CLU_empty_string);
                if (err != ERR_ok)
                    goto ex_1;
                }
            }
            }
            end_inline_for_2:
            __CLU_END_LABEL;
            break;
        }
        case 3: /* cluster_ */ {
            CLUREF T_3_3;
            T_3_3.num = T_3_1.cell->value;
            ct.num = T_3_3.num;

  LINE(664);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = ct.vec->data[0];
            err = duOPread_specs(T_4_1, &T_4_2, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            specs.num = T_4_2.num;
            b.num = T_4_3.num;
            }

  LINE(665);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            if (specs.cell->tag == 4) T_4_1.num = true; else T_4_1.num = false;
            T_4_2.num = !T_4_1.num;
            if (T_4_2.num == true) { /* if */

  LINE(666);
                { /* qtagcase */
                switch (specs.cell->tag) {
                case 1: /* apply */ {
                    CLUREF T_5_1;
                    T_5_1.num = specs.cell->value;
                    ap.num = T_5_1.num;

  LINE(668);
                    {
                    CLUREF T_6_1;
                    T_6_1.num = 997;
                    err = compiler_logit(T_6_1, STR_handlers_040not_040dealing_040with_040applyinfo);
                    if (err != ERR_ok)
                        goto ex_1;
                    }
                    break;
                }
                case 3: /* cluster_ */ {
                    CLUREF T_5_2;
                    T_5_2.num = specs.cell->value;
                    tyinfo.num = T_5_2.num;

  LINE(670);
                    {
                    CLUREF T_6_1;
                    err = tinfo_op_sigs(tyinfo, nm, &T_6_1);
                    if (err != ERR_ok)
                        goto ex_1;
                    sigs.num = T_6_1.num;
                    }

  LINE(671);
                    { /* for sequence$elements */
                    CLUREF T_6_1;
                    CLUREF T_6_2;
                    CLUREF T_6_3;
                    T_6_2.num = sigs.vec->size;
                    T_6_3 = sigs;
                    for (T_6_1.num = 1; T_6_1.num <= T_6_2.num; T_6_1.num++) {
                        each_sig.num = T_6_3.vec->data[T_6_1.num - 1];

  LINE(672);
                        {
                        CLUREF T_7_1;
                        CLUREF T_7_2;
                        CLUREF T_7_3;
                        CLUREF T_7_4;
                        CLUREF T_7_5;
                        T_7_1.num = each_sig.vec->data[0];
                        T_7_2.num = ct.vec->data[0];
                        err = duOPget_common(T_7_2, &T_7_3);
                        if (err != ERR_ok)
                            goto ex_1;
                        err = stringOPconcat(T_7_3, STR__044, &T_7_4);
                        if (err != ERR_ok)
                            goto ex_1;
                        err = stringOPconcat(T_7_4, nm, &T_7_5);
                        if (err != ERR_ok)
                            goto ex_1;
                        err = handlersOPadd_signal(T_7_1, T_7_5);
                        if (err != ERR_ok)
                            goto ex_1;
                        }
                    }
                    }
                    end_inline_for_3:
                    __CLU_END_LABEL;
                    break;
                }
                case 5: /* select */ /* FALLTHROUGH */
                case 2: /* atype */ {
                    CLUREF T_5_3;
                    T_5_3.num = specs.cell->value;
                    tyinfo.num = T_5_3.num;

  LINE(680);
                    {
                    CLUREF T_6_1;
                    T_6_1.num = 996;
                    err = compiler_logit(T_6_1, STR_handlers_040not_040dealing_040with_040some_040typeinfo);
                    if (err != ERR_ok)
                        goto ex_1;
                    }
                    break;
                }
                }
                } /* end qtagcase */
            }
            else { /* else */
            }} /* end if */
            break;
        }
        case 7: /* select */ {
            CLUREF T_3_4;
            T_3_4.num = T_3_1.cell->value;
            st.num = T_3_4.num;

  LINE(687);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = st.vec->data[0];
            err = duOPread_specs(T_4_1, &T_4_2, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            specs.num = T_4_2.num;
            b.num = T_4_3.num;
            }

  LINE(688);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            if (specs.cell->tag == 4) T_4_1.num = true; else T_4_1.num = false;
            T_4_2.num = !T_4_1.num;
            if (T_4_2.num == true) { /* if */

  LINE(689);
                { /* qtagcase */
                switch (specs.cell->tag) {
                case 1: /* apply */ {
                    CLUREF T_5_1;
                    T_5_1.num = specs.cell->value;
                    ap.num = T_5_1.num;

  LINE(691);
                    {
                    CLUREF T_6_1;
                    T_6_1.num = 997;
                    err = compiler_logit(T_6_1, STR_handlers_057select_040not_040dealing_040with_040applyinfo);
                    if (err != ERR_ok)
                        goto ex_1;
                    }
                    break;
                }
                case 5: /* select */ {
                    CLUREF T_5_2;
                    T_5_2.num = specs.cell->value;
                    tyinfo.num = T_5_2.num;

  LINE(694);
                    {
                    CLUREF T_6_1;
                    CLUREF T_6_2;
                    CLUREF T_6_3;
                    T_6_1.num = st.vec->data[1];
                    err = field_index(nm, T_6_1, &T_6_2, &T_6_3);
                    if (err != ERR_ok)
                        goto ex_1;
                    nm2.num = T_6_2.num;
                    j.num = T_6_3.num;
                    }

  LINE(695);
                    {
                    CLUREF T_6_1;
                    err = tinfo_op_sigs(tyinfo, nm2, &T_6_1);
                    if (err != ERR_ok)
                        goto ex_1;
                    sigs.num = T_6_1.num;
                    }

  LINE(696);
                    { /* for sequence$elements */
                    CLUREF T_6_1;
                    CLUREF T_6_2;
                    CLUREF T_6_3;
                    T_6_2.num = sigs.vec->size;
                    T_6_3 = sigs;
                    for (T_6_1.num = 1; T_6_1.num <= T_6_2.num; T_6_1.num++) {
                        each_sig.num = T_6_3.vec->data[T_6_1.num - 1];

  LINE(697);
                        {
                        CLUREF T_7_1;
                        CLUREF T_7_2;
                        CLUREF T_7_3;
                        CLUREF T_7_4;
                        CLUREF T_7_5;
                        T_7_1.num = each_sig.vec->data[0];
                        T_7_2.num = st.vec->data[0];
                        err = duOPget_common(T_7_2, &T_7_3);
                        if (err != ERR_ok)
                            goto ex_1;
                        err = stringOPconcat(T_7_3, STR__044, &T_7_4);
                        if (err != ERR_ok)
                            goto ex_1;
                        err = stringOPconcat(T_7_4, nm, &T_7_5);
                        if (err != ERR_ok)
                            goto ex_1;
                        err = handlersOPadd_signal(T_7_1, T_7_5);
                        if (err != ERR_ok)
                            goto ex_1;
                        }
                    }
                    }
                    end_inline_for_4:
                    __CLU_END_LABEL;
                    break;
                }
                case 3: /* cluster_ */ /* FALLTHROUGH */
                case 2: /* atype */ {
                    CLUREF T_5_3;
                    T_5_3.num = specs.cell->value;
                    tyinfo.num = T_5_3.num;

  LINE(704);
                    {
                    CLUREF T_6_1;
                    T_6_1.num = 996;
                    err = compiler_logit(T_6_1, STR_handlers_057select_040not_040dealing_040with_040some_040typeinfo);
                    if (err != ERR_ok)
                        goto ex_1;
                    }
                    break;
                }
                }
                } /* end qtagcase */
            }
            } /* end if */
            break;
        }
        case 5: /* idn */ {
            CLUREF T_3_5;
            T_3_5.num = T_3_1.cell->value;
            id.num = T_3_5.num;

  LINE(710);
            {
            CLUREF T_4_1;
            err = exprOPget_typespec(ex, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            ty.num = T_4_1.num;
            }

  LINE(711);
            { /* qtagcase */
            CLUREF T_4_1;
            err = typespecOPget_abs(ty, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            switch (T_4_1.cell->tag) {
            case 2: /* apply */ {
                CLUREF T_4_2;
                T_4_2.num = T_4_1.cell->value;
                ap.num = T_4_2.num;

  LINE(713);
                { /* for sequence$elements */
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                CLUREF T_5_4;
                T_5_1.num = ap.vec->data[2];
                T_5_3.num = T_5_1.vec->size;
                T_5_4 = T_5_1;
                for (T_5_2.num = 1; T_5_2.num <= T_5_3.num; T_5_2.num++) {
                    each_sig.num = T_5_4.vec->data[T_5_2.num - 1];

  LINE(714);
                    {
                    CLUREF T_6_1;
                    CLUREF T_6_2;
                    T_6_1.num = each_sig.vec->data[0];
                    err = idnOPget_str(id, &T_6_2);
                    if (err != ERR_ok)
                        goto ex_1;
                    err = handlersOPadd_signal(T_6_1, T_6_2);
                    if (err != ERR_ok)
                        goto ex_1;
                    }
                }
                }
                end_inline_for_5:
                __CLU_END_LABEL;
                break;
            }
            }
            } /* end qtagcase */
            break;
        }
        default: {

  LINE(723);
            {
            CLUREF T_4_1;
            T_4_1.num = 999;
            err = compiler_logit(T_4_1, STR_handlers_040not_040dealing_040with_040some_040typespec);
            if (err != ERR_ok)
                goto ex_1;
            }

  LINE(724);
            {
            err = typespec_print(ty);
            if (err != ERR_ok)
                goto ex_1;
            }
            break;
        }
        }
        } /* end qtagcase */
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_not_found) {
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;
        break;
    }
    case 16: /* invoke */ {
        CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        inv.num = T_1_4.num;

  LINE(730);
        {
        CLUREF T_2_1;
        err = exprOPget_typespec(ex, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ty.num = T_2_1.num;
        }

  LINE(731);
        { /* qtagcase */
        CLUREF T_2_1;
        err = typespecOPget_abs(ty, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_1.cell->tag) {
        case 2: /* apply */ {
            CLUREF T_2_2;
            T_2_2.num = T_2_1.cell->value;
            ap.num = T_2_2.num;

  LINE(733);
            { /* for sequence$elements */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_1.num = ap.vec->data[2];
            T_3_3.num = T_3_1.vec->size;
            T_3_4 = T_3_1;
            for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                each_sig.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(734);
                {
                CLUREF T_4_1;
                T_4_1.num = each_sig.vec->data[0];
                err = handlersOPadd_signal(T_4_1, CLU_empty_string);
                if (err != ERR_ok)
                    goto ex_0;
                }
            }
            }
            end_inline_for_6:
            __CLU_END_LABEL;
            break;
        }
        }
        } /* end qtagcase */
        break;
    }
    case 13: /* idn */ {
        CLUREF T_1_5;
        T_1_5.num = T_1_1.cell->value;
        id.num = T_1_5.num;

  LINE(743);
        {
        CLUREF T_2_1;
        err = exprOPget_typespec(ex, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ty.num = T_2_1.num;
        }

  LINE(744);
        { /* qtagcase */
        CLUREF T_2_1;
        err = typespecOPget_abs(ty, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_1.cell->tag) {
        case 2: /* apply */ {
            CLUREF T_2_2;
            T_2_2.num = T_2_1.cell->value;
            ap.num = T_2_2.num;

  LINE(746);
            { /* for sequence$elements */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_1.num = ap.vec->data[2];
            T_3_3.num = T_3_1.vec->size;
            T_3_4 = T_3_1;
            for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                each_sig.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(747);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = each_sig.vec->data[0];
                err = idnOPget_str(id, &T_4_2);
                if (err != ERR_ok)
                    goto ex_0;
                err = handlersOPadd_signal(T_4_1, T_4_2);
                if (err != ERR_ok)
                    goto ex_0;
                }
            }
            }
            end_inline_for_7:
            __CLU_END_LABEL;
            break;
        }
        }
        } /* end qtagcase */
        break;
    }
    case 11: /* force_ */ {
        CLUREF T_1_6;
        T_1_6.num = T_1_1.cell->value;
        t.num = T_1_6.num;

  LINE(756);
        {
        CLUREF T_2_1;
        err = exprOPget_typespec(ex, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ty.num = T_2_1.num;
        }

  LINE(757);
        { /* qtagcase */
        CLUREF T_2_1;
        err = typespecOPget_abs(ty, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_1.cell->tag) {
        case 2: /* apply */ {
            CLUREF T_2_2;
            T_2_2.num = T_2_1.cell->value;
            ap.num = T_2_2.num;

  LINE(759);
            { /* for sequence$elements */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_1.num = ap.vec->data[2];
            T_3_3.num = T_3_1.vec->size;
            T_3_4 = T_3_1;
            for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                each_sig.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(760);
                {
                CLUREF T_4_1;
                T_4_1.num = each_sig.vec->data[0];
                err = handlersOPadd_signal(T_4_1, STR_force);
                if (err != ERR_ok)
                    goto ex_0;
                }
            }
            }
            end_inline_for_8:
            __CLU_END_LABEL;
            break;
        }
        }
        } /* end qtagcase */
        break;
    }
    default: {

  LINE(766);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = 990;
        err = intOPunparse(handlersOPlineno, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(STR_handlers_040not_040dealing_040with_040some_040expr_040, T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        err = compiler_logit(T_2_1, T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(768);
        {
        CLUREF T_2_1;
        T_2_1.num = 55;
        err = expr_print(ex, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE new_signals ****/


/**** BEGIN PROCEDURE add_signal ****/


errcode
handlersOPadd_signal(CLUREF sig, CLUREF procname)
{
    errcode err;
    if (handlers_own_init == 0) {
        err = handlers_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(771);

  LINE(773);
    {
    CLUREF T_1_1;
    RecordAlloc(3, T_1_1);
    T_1_1.vec->data[2] = sig.num;
    T_1_1.vec->data[1] = procname.num;
    T_1_1.vec->data[0] = handlersOPlineno.num;
    {
    if ((handlersOPcurrent_scope.array->int_low + handlersOPcurrent_scope.array->ext_size + 1) < handlersOPcurrent_scope.array->int_size) {
        handlersOPcurrent_scope.array->store->data[handlersOPcurrent_scope.array->int_low + handlersOPcurrent_scope.array->ext_size] = T_1_1.num;
        handlersOPcurrent_scope.array->ext_size++;
        handlersOPcurrent_scope.array->ext_high++;
    }
    else {
        err = arrayOPaddh(handlersOPcurrent_scope, T_1_1);
        if (err != ERR_ok)
            goto ex_0;
    }
    }
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE add_signal ****/

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[8];
} handlers_OPS;

static CLU_proc handlers_oe_add_signal = { .proc = handlersOPadd_signal };
static CLU_proc handlers_oe_done = { .proc = handlersOPdone };
static CLU_proc handlers_oe_enter = { .proc = handlersOPenter };
static CLU_proc handlers_oe_init = { .proc = handlersOPinit };
static CLU_proc handlers_oe_leave_except = { .proc = handlersOPleave_except };
static CLU_proc handlers_oe_leave_resig = { .proc = handlersOPleave_resig };
static CLU_proc handlers_oe_new_signals = { .proc = handlersOPnew_signals };
static CLU_proc handlers_oe_set_lineno = { .proc = handlersOPset_lineno };

static handlers_OPS handlers_ops_actual = {8, (OWNPTR)&handlers_own_init, (OWNPTR)&handlers_own_init, {
    {&handlers_oe_add_signal, "add_signal"},
    {&handlers_oe_done, "done"},
    {&handlers_oe_enter, "enter"},
    {&handlers_oe_init, "init"},
    {&handlers_oe_leave_except, "leave_except"},
    {&handlers_oe_leave_resig, "leave_resig"},
    {&handlers_oe_new_signals, "new_signals"},
    {&handlers_oe_set_lineno, "set_lineno"}}};

struct OPS *handlers_ops = (struct OPS *)&handlers_ops_actual;

/**** END CLUSTER handlers ****/


/**** BEGIN PROCEDURE alt_tinfo_op_sigs ****/

extern errcode current_typeOPget();
extern errcode recordOPget_5();
extern errcode recordOPget_9();

errcode
alt_tinfo_op_sigs(CLUREF op, CLUREF *ret_1)
{
    errcode err;
    CLUREF ct;
    CLUREF each_ap;
    enter_proc(779);

  LINE(783);
    { /* if */
    CLUREF T_1_1;
    err = current_typeOPexists(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_1.num == true) { /* if */

  LINE(784);
        {
        CLUREF T_2_1;
        err = current_typeOPget(&T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ct.num = T_2_1.num;
        }

  LINE(785);
        { /* for sequence$elements */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.num = ct.vec->data[0];
        T_2_3.num = T_2_1.vec->size;
        T_2_4 = T_2_1;
        for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
            each_ap.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(788);
            { /* if */
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = each_ap.vec->data[4];
            err = idnOPget_str(T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            T_3_3.num = ((T_3_2.str->size != op.str->size)? false :
                !(memcmp(T_3_2.str->data, op.str->data, T_3_2.str->size)));
            if (T_3_3.num == true) { /* if */

  LINE(789);
                { /* return */
                {
                CLUREF T_4_1;
                T_4_1.num = each_ap.vec->data[8];
                ret_1->num = T_4_1.num;
                }
                signal (ERR_ok);
                }
            }
            } /* end if */
        }
        }
        end_inline_for_1:
        __CLU_END_LABEL;
    }
    } /* end if */

  LINE(792);
    { /* signal */
        signal(ERR_not_found);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE alt_tinfo_op_sigs ****/



/**** BEGIN PROCEDURE tinfo_op_sigs ****/

extern errcode alt_tinfo_op_sigs();
static CLUREF STR_tinfo_137op_137sigs_040not_040dealing_040with_040some_040typespec;
static int tinfo_op_sigs_own_init = 0;

errcode
tinfo_op_sigs(CLUREF t, CLUREF op, CLUREF *ret_1)
{
    errcode err;
    CLUREF each_op;
    CLUREF info;
    CLUREF ty;
    CLUREF ap;
    if (tinfo_op_sigs_own_init == 0) {
        stringOPcons("tinfo_op_sigs not dealing with some typespec", CLU_1, CLUREF_make_num(44), &STR_tinfo_137op_137sigs_040not_040dealing_040with_040some_040typespec);
        tinfo_op_sigs_own_init = 1;
    }
    enter_proc(795);

  LINE(798);
    { /* if */
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    err = stringOPfetch(op, CLU_1, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    T_2_2.ch = '%';
    T_2_3.num = (T_2_1.ch == T_2_2.ch);
    if (T_2_3.num == true) { /* if */

  LINE(799);
        { /* return */
        {
        CLUREF T_3_1;
        err = alt_tinfo_op_sigs(op, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        ret_1->num = T_3_1.num;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_found)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(802);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = t.vec->data[0];
    T_1_3.num = T_1_1.vec->size;
    T_1_4 = T_1_1;
    for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
        each_op.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(805);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = each_op.vec->data[1];
        T_2_2.num = ((op.str->size != T_2_1.str->size)? false :
            !(memcmp(op.str->data, T_2_1.str->data, op.str->size)));
        T_2_3.num = !T_2_2.num;
        if (T_2_3.num == true) { /* if */
            continue;
        }
        } /* end if */

  LINE(806);
        {
        CLUREF T_2_1;
        T_2_1.num = each_op.vec->data[0];
        info.num = T_2_1.num;
        }

  LINE(807);
        {
        CLUREF T_2_1;
        T_2_1.num = info.vec->data[1];
        ty.num = T_2_1.num;
        }

  LINE(808);
        { /* qtagcase */
        CLUREF T_2_1;
        err = typespecOPget_abs(ty, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_1.cell->tag) {
        case 2: /* apply */ {
            CLUREF T_2_2;
            T_2_2.num = T_2_1.cell->value;
            ap.num = T_2_2.num;

  LINE(810);
            { /* return */
            {
            CLUREF T_3_1;
            T_3_1.num = ap.vec->data[2];
            ret_1->num = T_3_1.num;
            }
            signal (ERR_ok);
            }
            break;
        }
        default: {

  LINE(812);
            {
            CLUREF T_3_1;
            T_3_1.num = 995;
            err = compiler_logit(T_3_1, STR_tinfo_137op_137sigs_040not_040dealing_040with_040some_040typespec);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(813);
            {
            err = typespec_print(ty);
            if (err != ERR_ok)
                goto ex_0;
            }
            break;
        }
        }
        } /* end qtagcase */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(816);
    { /* signal */
        signal(ERR_not_found);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE tinfo_op_sigs ****/

