
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER ib ****/

extern errcode sequenceOPnew();
extern errcode intOPequal();
extern errcode sequenceOPsize();
extern errcode sequenceOPaddh();
extern errcode intOPadd();
extern errcode stringOPconcat();
extern errcode current_applyOPget_name();
extern errcode intOPunparse();
extern errcode boolOPnot();
extern errcode sequenceOPempty();
extern errcode g_envOPblankline();
extern errcode g_envOPputs();
extern errcode g_idnlit();
extern errcode sequenceOPelements();
extern errcode ibOPgen_body();
extern errcode exOPinit();
extern errcode loop_contextOPenter_for();
extern errcode current_applyOPis_iter();
extern errcode g_envOPnewline();
extern errcode recordOPget_4();
extern errcode recordOPget_1();
extern errcode intOPfrom_to();
extern errcode g_envOPputl();
extern errcode ibOPgen_locals();
extern errcode g_envOPindent();
extern errcode g_idn();
extern errcode sequenceOPfetch();
extern errcode stmtOPget_line();
extern errcode recordOPget_2();
extern errcode g_stmt();
extern errcode exOPget_current_ex_label();
extern errcode g_err();
extern errcode g_locals();
extern errcode g_envOPoutdent();
extern errcode exOPget_current_end_label();
extern errcode g_envOPensure_newline();
extern errcode loop_contextOPleave();
extern errcode current_localsOPget();
extern errcode current_applyOPget();
extern errcode parmOPget_base();
extern errcode dbg_infoOPactive();
extern errcode current_typeOPexists();
extern errcode current_typeOPparmd();
extern errcode current_typeOPget_name();
extern errcode current_applyOPparmd();
extern errcode op_own_name();
extern errcode arrayOPelements();
extern errcode g_decl_typespec();
extern errcode idnlit();
CLUREF STR__137IB_137;
CLUREF STR__057_052_052_052_052_040BEGIN_040ITERATOR_040BODIES_040for_040;
CLUREF STR__040_052_052_052_052_057;
CLUREF STR__057_052_052_052_052_040END_040ITERATOR_040BODIES_040for_040;
CLUREF STR_errcode_040;
CLUREF STR__050;
CLUREF STR_iv_137;
CLUREF STR__054_040;
CLUREF STR_locals_054_040iecode_051;
CLUREF STR_errcode_040_052iecode_073;
CLUREF STR_CLUREF_040iv_137;
CLUREF STR__073;
CLUREF STR__173;
CLUREF STR__040_075_040iv_137;
CLUREF STR__056num_073;
CLUREF STR_enter_137iter_137body_137proc_050;
CLUREF STR__051_073;
CLUREF STR_enter_137iter_137body_137proc_050_0551_051_073;
CLUREF STR__173signal_050ERR_137ok_051_073_175;
CLUREF STR__072;
CLUREF STR__052iecode_040_075_040;
CLUREF STR_body_137ctrl_137req_040_075_040true_073;
CLUREF STR__173signal_050ERR_137iteriterbodyexit_051_073_175;
CLUREF STR__173signal_050ERR_137iterbodyexit_051_073_175;
CLUREF STR__175;
CLUREF STR__072_040_173signal_050ERR_137ok_051_073_175;
CLUREF STR__057_052_040end_040;
CLUREF STR__040_052_057;
CLUREF STR_struct_040_173;
CLUREF STR__040_040_040_040struct_040dbg_137info_040_052DBG_137INFO_073;
CLUREF STR__040_040_040_040int_040DBG_137LINE_073;
CLUREF STR__040_040_040_040char_040_052_052user_137locals_073;
CLUREF STR__040_040_040_040errcode_040_050_052proc_051_050_051_073;
CLUREF STR__040_040_040_040errcode_040err_073;
CLUREF STR__040_040_040_040errcode_040ecode2_073;
CLUREF STR__040_040_040_040bool_040body_137ctrl_137req_073;
CLUREF STR__137OWN_137DEFN_040_052type_137own_137ptr_073;
CLUREF STR__137OWN_137DEFN_040_052op_137own_137ptr_073;
CLUREF STR__040_040_040_040;
CLUREF STR__040_040_040_040_175_040_052locals_073;
static int ib_own_init = 0;
OWN_req ib_ownreqs = {0,0};
CLUREF ibOPiblist;
CLUREF ibOPcount;
CLUREF ibOPold_count;
CLUREF ibOPgenerating_bodies;
errcode ib_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (ib_own_init == 0) {
        stringOPcons("_IB_", CLU_1, CLU_4, &STR__137IB_137);
        stringOPcons("/**** BEGIN ITERATOR BODIES for ", CLU_1, CLU_32, &STR__057_052_052_052_052_040BEGIN_040ITERATOR_040BODIES_040for_040);
        stringOPcons(" ****/", CLU_1, CLU_6, &STR__040_052_052_052_052_057);
        stringOPcons("/**** END ITERATOR BODIES for ", CLU_1, CLU_30, &STR__057_052_052_052_052_040END_040ITERATOR_040BODIES_040for_040);
        stringOPcons("errcode ", CLU_1, CLU_8, &STR_errcode_040);
        stringOPcons("(", CLU_1, CLU_1, &STR__050);
        stringOPcons("iv_", CLU_1, CLU_3, &STR_iv_137);
        stringOPcons(", ", CLU_1, CLU_2, &STR__054_040);
        stringOPcons("locals, iecode)", CLU_1, CLU_15, &STR_locals_054_040iecode_051);
        stringOPcons("errcode *iecode;", CLU_1, CLU_16, &STR_errcode_040_052iecode_073);
        stringOPcons("CLUREF iv_", CLU_1, CLU_10, &STR_CLUREF_040iv_137);
        stringOPcons(";", CLU_1, CLU_1, &STR__073);
        stringOPcons("{", CLU_1, CLU_1, &STR__173);
        stringOPcons(" = iv_", CLU_1, CLU_6, &STR__040_075_040iv_137);
        stringOPcons(".num;", CLU_1, CLU_5, &STR__056num_073);
        stringOPcons("enter_iter_body_proc(", CLU_1, CLU_21, &STR_enter_137iter_137body_137proc_050);
        stringOPcons(");", CLU_1, CLU_2, &STR__051_073);
        stringOPcons("enter_iter_body_proc(-1);", CLU_1, CLU_25, &STR_enter_137iter_137body_137proc_050_0551_051_073);
        stringOPcons("{signal(ERR_ok);}", CLU_1, CLU_17, &STR__173signal_050ERR_137ok_051_073_175);
        stringOPcons(":", CLU_1, CLU_1, &STR__072);
        stringOPcons("*iecode = ", CLU_1, CLU_10, &STR__052iecode_040_075_040);
        stringOPcons("body_ctrl_req = true;", CLU_1, CLU_21, &STR_body_137ctrl_137req_040_075_040true_073);
        stringOPcons("{signal(ERR_iteriterbodyexit);}", CLU_1, CLU_31, &STR__173signal_050ERR_137iteriterbodyexit_051_073_175);
        stringOPcons("{signal(ERR_iterbodyexit);}", CLU_1, CLU_27, &STR__173signal_050ERR_137iterbodyexit_051_073_175);
        stringOPcons("}", CLU_1, CLU_1, &STR__175);
        stringOPcons(": {signal(ERR_ok);}", CLU_1, CLU_19, &STR__072_040_173signal_050ERR_137ok_051_073_175);
        stringOPcons("/* end ", CLU_1, CLU_7, &STR__057_052_040end_040);
        stringOPcons(" */", CLU_1, CLU_3, &STR__040_052_057);
        stringOPcons("struct {", CLU_1, CLU_8, &STR_struct_040_173);
        stringOPcons("    struct dbg_info *DBG_INFO;", CLU_1, CLU_30, &STR__040_040_040_040struct_040dbg_137info_040_052DBG_137INFO_073);
        stringOPcons("    int DBG_LINE;", CLU_1, CLU_17, &STR__040_040_040_040int_040DBG_137LINE_073);
        stringOPcons("    char **user_locals;", CLU_1, CLU_23, &STR__040_040_040_040char_040_052_052user_137locals_073);
        stringOPcons("    errcode (*proc)();", CLU_1, CLU_22, &STR__040_040_040_040errcode_040_050_052proc_051_050_051_073);
        stringOPcons("    errcode err;", CLU_1, CLU_16, &STR__040_040_040_040errcode_040err_073);
        stringOPcons("    errcode ecode2;", CLU_1, CLU_19, &STR__040_040_040_040errcode_040ecode2_073);
        stringOPcons("    bool body_ctrl_req;", CLU_1, CLU_23, &STR__040_040_040_040bool_040body_137ctrl_137req_073);
        stringOPcons("_OWN_DEFN *type_own_ptr;", CLU_1, CLU_24, &STR__137OWN_137DEFN_040_052type_137own_137ptr_073);
        stringOPcons("_OWN_DEFN *op_own_ptr;", CLU_1, CLU_22, &STR__137OWN_137DEFN_040_052op_137own_137ptr_073);
        stringOPcons("    ", CLU_1, CLU_4, &STR__040_040_040_040);
        stringOPcons("    } *locals;", CLU_1, CLU_14, &STR__040_040_040_040_175_040_052locals_073);
        ib_own_init = 1;
        {
            {CLUREF T_0_1;
            err = sequenceOPnew(&T_0_1);
            if (err != ERR_ok) goto ex_0;
            ibOPiblist.num = T_0_1.num;
            }
            }
        {
            {ibOPcount.num = 0;
            }
            }
        {
            {ibOPold_count.num = 0;
            }
            }
        {
            {ibOPgenerating_bodies.tf = false;
            }
            }
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE init ****/

errcode ibOPinit()
    {
    errcode err;
    errcode ecode2;
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(19);

  LINE(20);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    ibOPiblist.num = T_1_1.num;
    }

  LINE(21);
    {
    ibOPcount.num = 0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE init ****/


/**** BEGIN PROCEDURE reset ****/

errcode ibOPreset()
    {
    errcode err;
    errcode ecode2;
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(24);

  LINE(25);
    {
    ibOPcount.num = 0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE reset ****/


/**** BEGIN PROCEDURE bodies ****/

errcode ibOPbodies(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(31);

  LINE(32);
    {
    {
    ret_1->num = ibOPgenerating_bodies.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE bodies ****/


/**** BEGIN PROCEDURE exist ****/

errcode ibOPexist(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(38);

  LINE(39);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ibOPiblist.vec->size;
    T_1_2.num = (T_1_1.num == 0)? true : false;
    if (T_1_2.num == true) {

  LINE(41);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(43);
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE exist ****/


/**** BEGIN PROCEDURE add_body ****/

errcode ibOPadd_body(bod)
CLUREF bod;
    {
    errcode err;
    errcode ecode2;
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(47);

  LINE(48);
    {
    CLUREF T_1_1;
    err = sequenceOPaddh(ibOPiblist, bod, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ibOPiblist.num = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE add_body ****/

static int ibOPnext_name_own_init = 0;

/**** BEGIN PROCEDURE next_name ****/

errcode ibOPnext_name(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (ibOPnext_name_own_init == 0) {
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ibOPnext_name_own_init = 1;
    }
    enter_proc(51);

  LINE(53);
    {
    CLUREF T_1_1;
    T_1_1.num = ibOPcount.num + 1;
     if ((T_1_1.num > 0 && ibOPcount.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && ibOPcount.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    ibOPcount.num = T_1_1.num;
    }

  LINE(55);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    err = current_applyOPget_name(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_1, STR__137IB_137, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = intOPunparse(ibOPcount, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_2, T_1_3, &T_1_4);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_4.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE next_name ****/


/**** BEGIN PROCEDURE save_name ****/

errcode ibOPsave_name()
    {
    errcode err;
    errcode ecode2;
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(59);

  LINE(60);
    {
    ibOPold_count.num = ibOPcount.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE save_name ****/


/**** BEGIN PROCEDURE restore_name ****/

errcode ibOPrestore_name()
    {
    errcode err;
    errcode ecode2;
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(63);

  LINE(64);
    {
    ibOPcount.num = ibOPold_count.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE restore_name ****/

static int ibOPgen_bodies_own_init = 0;

/**** BEGIN PROCEDURE gen_bodies ****/

errcode ibOPgen_bodies(e, id)
CLUREF e;
CLUREF id;
    {
    errcode err;
    errcode ecode2;
    CLUREF index;
    CLUREF each_bod;
        if (ibOPgen_bodies_own_init == 0) {
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ibOPgen_bodies_own_init = 1;
    }
    enter_proc(67);

  LINE(69);
    {
    ibOPgenerating_bodies.tf = true;
    }

  LINE(70);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = sequenceOPempty(ibOPiblist, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(71);
        {
        err = g_envOPblankline(e);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(72);
        {
        err = g_envOPputs(e, STR__057_052_052_052_052_040BEGIN_040ITERATOR_040BODIES_040for_040);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(73);
        {
        err = g_idnlit(e, id);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(74);
        {
        err = g_envOPputs(e, STR__040_052_052_052_052_057);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(75);
        {
        err = g_envOPblankline(e);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(76);
        {
            {index.num = 1;
            }
            }

  LINE(77);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
            T_2_2.num = ibOPiblist.vec->size; 
            T_2_3 = ibOPiblist;
            for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                each_bod.num = T_2_3.vec->data[T_2_1.num - 1];

  LINE(78);
                {
                err = ibOPgen_body(e, each_bod, index);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(79);
                {
                CLUREF T_3_1;
                T_3_1.num = index.num + 1;
                 if ((T_3_1.num > 0 && index.num < 0 && 1 < 0) || 
                     (T_3_1.num < 0 && index.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                index.num = T_3_1.num;
                }
            }
        }
        end_inline_for_1:;

  LINE(81);
        {
        err = g_envOPblankline(e);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(82);
        {
        err = g_envOPputs(e, STR__057_052_052_052_052_040END_040ITERATOR_040BODIES_040for_040);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(83);
        {
        err = g_idnlit(e, id);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(84);
        {
        err = g_envOPputs(e, STR__040_052_052_052_052_057);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(85);
        {
        err = g_envOPblankline(e);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(87);
    {
    ibOPgenerating_bodies.tf = false;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE gen_bodies ****/

static int ibOPgen_body_own_init = 0;

/**** BEGIN PROCEDURE gen_body ****/

errcode ibOPgen_body(e, f, index)
CLUREF e;
CLUREF f;
CLUREF index;
    {
    errcode err;
    errcode ecode2;
    CLUREF iterp;
    CLUREF ibname;
    CLUREF iv_count;
    CLUREF o;
    CLUREF n;
    CLUREF this_d;
    CLUREF each_i;
    CLUREF idns;
    CLUREF d;
    CLUREF i;
    CLUREF each_d;
    CLUREF each_idn;
    CLUREF s;
        if (ibOPgen_body_own_init == 0) {
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ibOPgen_body_own_init = 1;
    }
    enter_proc(90);

  LINE(92);
    {
    err = exOPinit();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(96);
    {
    err = loop_contextOPenter_for();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(100);
    {
        {CLUREF T_1_1;
        err = current_applyOPis_iter(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        iterp.num = T_1_1.num;
        }
        }

  LINE(102);
    {
    err = g_envOPnewline(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(105);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        err = current_applyOPget_name(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_1_1, STR__137IB_137, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        err = intOPunparse(index, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_1_2, T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        ibname.num = T_1_4.num;
        }
        }

  LINE(107);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = stringOPconcat(STR_errcode_040, ibname, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_1, STR__050, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = g_envOPputs(e, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(108);
    {
        {iv_count.num = 0;
        }
        }

  LINE(109);
    {
    CLUREF T_1_1;
    T_1_1.num = f.vec->data[3];
    switch (T_1_1.cell->tag) {
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        o.num = T_1_2.num;

  LINE(111);
            {
            CLUREF T_2_1;
            T_2_1.num = o.vec->size;
            iv_count.num = T_2_1.num;
            }
            break;
            }
    case 1: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        n.num = T_1_3.num;

  LINE(113);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
                T_2_2.num = n.vec->size; 
                T_2_3 = n;
                for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                    this_d.num = T_2_3.vec->data[T_2_1.num - 1];

  LINE(114);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    T_3_1.num = this_d.vec->data[0];
                    T_3_2.num = T_3_1.vec->size;
                    T_3_3.num = iv_count.num + T_3_2.num;
                     if ((T_3_3.num > 0 && iv_count.num < 0 && T_3_2.num < 0) || 
                         (T_3_3.num < 0 && iv_count.num > 0 && T_3_2.num > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    iv_count.num = T_3_3.num;
                    }
                }
            }
            end_inline_for_1:;
            break;
            }
    }
    }

  LINE(117);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = iv_count.num;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            each_i.num = T_1_1.num;

  LINE(118);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            err = intOPunparse(each_i, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(STR_iv_137, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_2, STR__054_040, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            err = g_envOPputs(e, T_2_3);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_2:;

  LINE(120);
    {
    err = g_envOPputl(e, STR_locals_054_040iecode_051);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(121);
    {
    err = g_envOPputl(e, STR_errcode_040_052iecode_073);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(122);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = iv_count.num;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            each_i.num = T_1_1.num;

  LINE(123);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            err = intOPunparse(each_i, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(STR_CLUREF_040iv_137, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_2, STR__073, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            err = g_envOPputl(e, T_2_3);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_3:;

  LINE(125);
    {
    err = ibOPgen_locals(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(128);
    {
    err = g_envOPputl(e, STR__173);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(129);
    {
    err = g_envOPindent(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(131);
    {
    CLUREF T_1_1;
    T_1_1.num = f.vec->data[3];
    switch (T_1_1.cell->tag) {
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        idns.num = T_1_2.num;

  LINE(133);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
                T_2_2.num = iv_count.num;
                for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                    each_i.num = T_2_1.num;

  LINE(134);
                    {
                    CLUREF T_3_1;
                    if (each_i.num < 1 || each_i.num > idns.vec->size ) {
                        err = ERR_bounds;
                        goto ex_0;}
                    T_3_1.num = idns.vec->data[each_i.num - 1];
                    err = g_idn(e, T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(135);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    err = intOPunparse(each_i, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(STR__040_075_040iv_137, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(T_3_2, STR__056num_073, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    err = g_envOPputl(e, T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    }
                }
            }
            end_inline_for_4:;
            break;
            }
    case 1: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        d.num = T_1_3.num;

  LINE(138);
            {
                {i.num = 1;
                }
                }

  LINE(139);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
                T_2_2.num = d.vec->size; 
                T_2_3 = d;
                for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                    each_d.num = T_2_3.vec->data[T_2_1.num - 1];

  LINE(140);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = each_d.vec->data[0];
                        T_3_3.num = T_3_1.vec->size; 
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            each_idn.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(141);
                            {
                            err = g_idn(e, each_idn);
                            if (err != ERR_ok) goto ex_0;
                            }

  LINE(142);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            err = intOPunparse(i, &T_4_1);
                            if (err != ERR_ok) goto ex_0;
                            err = stringOPconcat(STR__040_075_040iv_137, T_4_1, &T_4_2);
                            if (err != ERR_ok) goto ex_0;
                            err = stringOPconcat(T_4_2, STR__056num_073, &T_4_3);
                            if (err != ERR_ok) goto ex_0;
                            err = g_envOPputl(e, T_4_3);
                            if (err != ERR_ok) goto ex_0;
                            }

  LINE(143);
                            {
                            CLUREF T_4_1;
                            T_4_1.num = i.num + 1;
                             if ((T_4_1.num > 0 && i.num < 0 && 1 < 0) || 
                                 (T_4_1.num < 0 && i.num > 0 && 1 > 0)) {
                                err = ERR_overflow;
                                goto ex_0;}
                            i.num = T_4_1.num;
                            }
                        }
                    }
                    end_inline_for_6:;
                }
            }
            end_inline_for_5:;
            break;
            }
    }
    }

  LINE(147);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    CLUREF T_2_4;
    CLUREF T_2_5;
    CLUREF T_2_6;
    CLUREF T_2_7;
    T_2_1.num = f.vec->data[1];
    T_2_2.num = T_2_1.vec->data[1];
    if (1 < 1 || 1 > T_2_2.vec->size ) {
        err = ERR_bounds;
        goto ex_1;}
    T_2_3.num = T_2_2.vec->data[1 - 1];
    err = stmtOPget_line(T_2_3, &T_2_4);
    if (err != ERR_ok) goto ex_1;
    err = intOPunparse(T_2_4, &T_2_5);
    if (err != ERR_ok) goto ex_1;
    err = stringOPconcat(STR_enter_137iter_137body_137proc_050, T_2_5, &T_2_6);
    if (err != ERR_ok) goto ex_1;
    err = stringOPconcat(T_2_6, STR__051_073, &T_2_7);
    if (err != ERR_ok) goto ex_1;
    err = g_envOPputl(e, T_2_7);
    if (err != ERR_ok) goto ex_1;
    }
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {

  LINE(149);
                {
                err = g_envOPputl(e, STR_enter_137iter_137body_137proc_050_0551_051_073);
                if (err != ERR_ok) goto ex_0;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(151);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
        T_1_1.num = f.vec->data[1];
        T_1_2.num = T_1_1.vec->data[1];
        T_1_4.num = T_1_2.vec->size; 
        T_1_5 = T_1_2;
        for (T_1_3.num = 1; T_1_3.num <= T_1_4.num; T_1_3.num++) {
            s.num = T_1_5.vec->data[T_1_3.num - 1];

  LINE(152);
            {
            err = g_stmt(e, s);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_7:;

  LINE(156);
    {
    err = g_envOPputl(e, STR__173signal_050ERR_137ok_051_073_175);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(159);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = exOPget_current_ex_label(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_1, STR__072, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = g_envOPputl(e, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(160);
    {
    err = g_envOPindent(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(161);
    {
    err = g_envOPputl(e, STR__173);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(162);
    {
    err = g_envOPindent(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(163);
    {
    err = g_envOPputs(e, STR__052iecode_040_075_040);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(164);
    {
    err = g_err(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(165);
    {
    err = g_envOPputl(e, STR__073);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(166);
    {
    CLUREF T_1_1;
    err = current_applyOPis_iter(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(168);
        {
        err = g_locals(e);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(169);
        {
        err = g_envOPputl(e, STR_body_137ctrl_137req_040_075_040true_073);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(170);
        {
        err = g_envOPputs(e, STR__173signal_050ERR_137iteriterbodyexit_051_073_175);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(172);
        {
        err = g_envOPputs(e, STR__173signal_050ERR_137iterbodyexit_051_073_175);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(174);
    {
    err = g_envOPoutdent(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(175);
    {
    err = g_envOPoutdent(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(176);
    {
    err = g_envOPputl(e, STR__175);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(177);
    {
    err = g_envOPnewline(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(178);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = exOPget_current_end_label(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_1, STR__072_040_173signal_050ERR_137ok_051_073_175, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = g_envOPputs(e, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(179);
    {
    err = g_envOPensure_newline(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(182);
    {
    err = g_envOPputs(e, STR__175);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(183);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = stringOPconcat(STR__057_052_040end_040, ibname, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_1, STR__040_052_057, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = g_envOPputl(e, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(184);
    {
    err = g_envOPoutdent(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(185);
    {
    err = loop_contextOPleave();
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE gen_body ****/

static int ibOPgen_locals_own_init = 0;

/**** BEGIN PROCEDURE gen_locals ****/

errcode ibOPgen_locals(e)
CLUREF e;
    {
    errcode err;
    errcode ecode2;
    CLUREF iterp;
    CLUREF locals_UNIQ;
    CLUREF args;
    CLUREF ap;
    CLUREF parms;
    CLUREF defn_name;
    CLUREF lv;
    CLUREF ts;
    CLUREF id;
    CLUREF a;
        if (ibOPgen_locals_own_init == 0) {
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        ibOPgen_locals_own_init = 1;
    }
    enter_proc(190);

  LINE(192);
    {
        {CLUREF T_1_1;
        err = current_applyOPis_iter(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        iterp.num = T_1_1.num;
        }
        }

  LINE(194);
    {
        {CLUREF T_1_1;
        err = current_localsOPget(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        locals_UNIQ.num = T_1_1.num;
        }
        }

  LINE(195);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = current_applyOPget(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = T_1_1.vec->data[0];
        args.num = T_1_2.num;
        }
        }

  LINE(196);
    {
        {CLUREF T_1_1;
        err = current_applyOPget(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        ap.num = T_1_1.num;
        }
        }

  LINE(197);
    {
        {CLUREF T_1_1;
        err = parmOPget_base(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        parms.num = T_1_1.num;
        }
        }

  LINE(199);
    {
    err = g_envOPnewline(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(203);
    {
    err = g_envOPputl(e, STR_struct_040_173);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(204);
    {
    CLUREF T_1_1;
    err = dbg_infoOPactive(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(205);
        {
        err = g_envOPputl(e, STR__040_040_040_040struct_040dbg_137info_040_052DBG_137INFO_073);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(206);
        {
        err = g_envOPputl(e, STR__040_040_040_040int_040DBG_137LINE_073);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(208);
    {
    if (iterp.num == true) {

  LINE(209);
        {
        err = g_envOPputl(e, STR__040_040_040_040char_040_052_052user_137locals_073);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(210);
        {
        err = g_envOPputl(e, STR__040_040_040_040errcode_040_050_052proc_051_050_051_073);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(212);
    {
    err = g_envOPputl(e, STR__040_040_040_040errcode_040err_073);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(213);
    {
    err = g_envOPputl(e, STR__040_040_040_040errcode_040ecode2_073);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(214);
    {
    if (iterp.num == true) {
        {
        err = g_envOPputl(e, STR__040_040_040_040bool_040body_137ctrl_137req_073);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(216);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = current_typeOPexists(&T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        err = current_typeOPparmd(&T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_1.num = T_1_3.num;
    }
    if (T_1_1.num == true) {

  LINE(217);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = current_typeOPget_name(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_1, STR__137OWN_137DEFN_040_052type_137own_137ptr_073, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        err = g_envOPputl(e, T_2_2);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(219);
    {
    CLUREF T_1_1;
    err = current_applyOPparmd(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(220);
        {
            {CLUREF T_2_1;
            err = op_own_name(&T_2_1);
            if (err != ERR_ok) goto ex_0;
            defn_name.num = T_2_1.num;
            }
            }

  LINE(221);
        {
        CLUREF T_2_1;
        err = stringOPconcat(defn_name, STR__137OWN_137DEFN_040_052op_137own_137ptr_073, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = g_envOPputl(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(223);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = locals_UNIQ.array->ext_high; 
        T_1_3 = locals_UNIQ;
        for (T_1_1.num = locals_UNIQ.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            lv.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(224);
            {
                {CLUREF T_2_1;
                T_2_1.num = lv.vec->data[1];
                ts.num = T_2_1.num;
                }
                }

  LINE(225);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = lv.vec->data[0];
                T_2_3.num = T_2_1.vec->size; 
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    id.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(226);
                    {
                    err = g_envOPputs(e, STR__040_040_040_040);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(227);
                    {
                    CLUREF T_3_1;
                    err = idnlit(id, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = g_decl_typespec(e, ts, T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(230);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = dbg_infoOPactive(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(231);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
            T_2_2.num = args.vec->size; 
            T_2_3 = args;
            for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                a.num = T_2_3.vec->data[T_2_1.num - 1];

  LINE(232);
                {
                    {CLUREF T_3_1;
                    T_3_1.num = a.vec->data[1];
                    ts.num = T_3_1.num;
                    }
                    }

  LINE(233);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CLUREF T_3_4;
                    T_3_1.num = a.vec->data[0];
                    T_3_3.num = T_3_1.vec->size; 
                    T_3_4 = T_3_1;
                    for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                        id.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(234);
                        {
                        err = g_envOPputs(e, STR__040_040_040_040);
                        if (err != ERR_ok) goto ex_0;
                        }

  LINE(235);
                        {
                        CLUREF T_4_1;
                        err = idnlit(id, &T_4_1);
                        if (err != ERR_ok) goto ex_0;
                        err = g_decl_typespec(e, ts, T_4_1);
                        if (err != ERR_ok) goto ex_0;
                        }
                    }
                }
                end_inline_for_4:;
            }
        }
        end_inline_for_3:;
        }
        }/* end if */

  LINE(256);
    {
    err = g_envOPputl(e, STR__040_040_040_040_175_040_052locals_073);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE gen_locals ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[9];
} ib_OPS;

CLU_proc ib_oe_add_body = {{0,0,0,0}, ibOPadd_body, 0};
CLU_proc ib_oe_bodies = {{0,0,0,0}, ibOPbodies, 0};
CLU_proc ib_oe_exist = {{0,0,0,0}, ibOPexist, 0};
CLU_proc ib_oe_gen_bodies = {{0,0,0,0}, ibOPgen_bodies, 0};
CLU_proc ib_oe_init = {{0,0,0,0}, ibOPinit, 0};
CLU_proc ib_oe_next_name = {{0,0,0,0}, ibOPnext_name, 0};
CLU_proc ib_oe_reset = {{0,0,0,0}, ibOPreset, 0};
CLU_proc ib_oe_restore_name = {{0,0,0,0}, ibOPrestore_name, 0};
CLU_proc ib_oe_save_name = {{0,0,0,0}, ibOPsave_name, 0};

ib_OPS ib_ops_actual = {9, (OWNPTR)&ib_own_init, (OWNPTR)&ib_own_init, {
    {&ib_oe_add_body, "add_body"},
    {&ib_oe_bodies, "bodies"},
    {&ib_oe_exist, "exist"},
    {&ib_oe_gen_bodies, "gen_bodies"},
    {&ib_oe_init, "init"},
    {&ib_oe_next_name, "next_name"},
    {&ib_oe_reset, "reset"},
    {&ib_oe_restore_name, "restore_name"},
    {&ib_oe_save_name, "save_name"}}};

struct OPS *ib_ops = (struct OPS *)&ib_ops_actual;

/**** END CLUSTER ib ****/

extern errcode arrayOPnew();
extern errcode g_iterbody_names_asst();
extern errcode arrayOPempty();

/**** BEGIN PROCEDURE g_iterbody_names ****/

errcode g_iterbody_names(arr, bod)
CLUREF arr;
CLUREF bod;
    {
    errcode err;
    errcode ecode2;
    CLUREF next_bodies;
    CLUREF current_bodies;
    CLUREF each_for;
    enter_proc(265);

  LINE(270);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    next_bodies.num = T_1_1.num;
    }

  LINE(271);
    {
    CLUREF T_1_1;
    err = g_iterbody_names_asst(next_bodies, arr, bod, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(273);
    for (;;) {
        if (true != true) { break; }

  LINE(275);
        {
        current_bodies.num = next_bodies.num;
        }

  LINE(276);
        {
        CLUREF T_2_1;
        err = arrayOPnew(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        next_bodies.num = T_2_1.num;
        }

  LINE(278);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
            T_2_2.num = current_bodies.array->ext_high; 
            T_2_3 = current_bodies;
            for (T_2_1.num = current_bodies.array->ext_low; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                if (T_2_1.num > T_2_3.array->ext_high || T_2_1.num < T_2_3.array->ext_low) {
                    err = ERR_failure;
                    elist[0].str = array_bounds_exception_STRING;
                    goto ex_0;}
                each_for.num = T_2_3.array->store->data[T_2_1.num - T_2_3.array->ext_low + T_2_3.array->int_low];

  LINE(279);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                T_3_1.num = each_for.vec->data[1];
                T_3_2.num = T_3_1.vec->data[1];
                err = g_iterbody_names_asst(next_bodies, arr, T_3_2, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                }
            }
        }
        end_inline_for_1:;

  LINE(282);
        {
        CLUREF T_2_1;
        T_2_1.num = (next_bodies.array->ext_size == 0)? true : false;
        if (T_2_1.num == true) {
            goto end_while_1;
            }
            }/* end if */
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE g_iterbody_names ****/


extern errcode stmtOPget_abs();
extern errcode g_inline_iter_test();
extern errcode recordOPget_3();
extern errcode arrayOPaddh();
extern errcode ibOPnext_name();
extern errcode ibOPadd_body();
extern errcode sequenceOPfill();

/**** BEGIN PROCEDURE g_iterbody_names_asst ****/

errcode g_iterbody_names_asst(out, arr, bod, ret_1)
CLUREF out;
CLUREF arr;
CLUREF bod;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
    CLUREF d;
    CLUREF di;
    CLUREF f;
    CLUREF b;
    CLUREF w;
    CLUREF i;
    CLUREF arm;
    CLUREF t;
    CLUREF e;
    CLUREF a;
    CLUREF rs;
    enter_proc(288);

  LINE(290);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = bod.vec->size; 
        T_1_3 = bod;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            s.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(291);
            {
            CLUREF T_2_1;
            err = stmtOPget_abs(s, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_1.cell->tag) {
            case 6: 
                 {CLUREF T_2_2;
                T_2_2.num = T_2_1.cell->value;
                d.num = T_2_2.num;
                    break;
                    }
            case 7: 
                 {CLUREF T_2_3;
                T_2_3.num = T_2_1.cell->value;
                di.num = T_2_3.num;
                    break;
                    }
            case 10: 
                 {CLUREF T_2_4;
                T_2_4.num = T_2_1.cell->value;
                f.num = T_2_4.num;

  LINE(295);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    T_3_1.num = f.vec->data[2];
                    T_3_2.num = T_3_1.vec->data[0];
                    err = g_inline_iter_test(T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    if (T_3_3.num == true) {

  LINE(296);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        CLUREF T_4_3;
                        T_4_1.num = f.vec->data[1];
                        T_4_2.num = T_4_1.vec->data[1];
                        err = g_iterbody_names_asst(out, arr, T_4_2, &T_4_3);
                        if (err != ERR_ok) goto ex_0;
                        }
                        }
                    else {

  LINE(298);
                        {
                        CLUREF T_4_1;
                        err = ibOPnext_name(&T_4_1);
                        if (err != ERR_ok) goto ex_0;
                        {
                        if ((arr.array->int_low + arr.array->ext_size + 1) < arr.array->int_size) {
                            arr.array->store->data[arr.array->int_low + arr.array->ext_size] = T_4_1.num;
                            arr.array->ext_size++; arr.array->ext_high++;}
                        else {
                            err = arrayOPaddh(arr, T_4_1);
                            if (err != ERR_ok) goto ex_0;}
                        }
                        }

  LINE(299);
                        {
                        err = ibOPadd_body(f);
                        if (err != ERR_ok) goto ex_0;
                        }

  LINE(300);
                        {
                        {
                        if ((out.array->int_low + out.array->ext_size + 1) < out.array->int_size) {
                            out.array->store->data[out.array->int_low + out.array->ext_size] = f.num;
                            out.array->ext_size++; out.array->ext_high++;}
                        else {
                            err = arrayOPaddh(out, f);
                            if (err != ERR_ok) goto ex_0;}
                        }
                        }
                        }}/* end if */
                    break;
                    }
            case 3: 
                 {CLUREF T_2_5;
                T_2_5.num = T_2_1.cell->value;
                b.num = T_2_5.num;

  LINE(303);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    T_3_1.num = b.vec->data[1];
                    err = g_iterbody_names_asst(out, arr, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    }
                    break;
                    }
            case 19: 
                 {CLUREF T_2_6;
                T_2_6.num = T_2_1.cell->value;
                w.num = T_2_6.num;

  LINE(305);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    T_3_1.num = w.vec->data[0];
                    T_3_2.num = T_3_1.vec->data[1];
                    err = g_iterbody_names_asst(out, arr, T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    }
                    break;
                    }
            case 12: 
                 {CLUREF T_2_7;
                T_2_7.num = T_2_1.cell->value;
                i.num = T_2_7.num;

  LINE(307);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = i.vec->data[0];
                        T_3_3.num = T_3_1.vec->size; 
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            arm.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(308);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            T_4_1.num = arm.vec->data[0];
                            T_4_2.num = T_4_1.vec->data[1];
                            err = g_iterbody_names_asst(out, arr, T_4_2, &T_4_3);
                            if (err != ERR_ok) goto ex_0;
                            }
                        }
                    }
                    end_inline_for_2:;

  LINE(310);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = i.vec->data[1];
                    switch (T_3_1.cell->tag) {
                    case 1: 
                         {CLUREF T_3_2;
                        T_3_2.num = T_3_1.cell->value;
                        b.num = T_3_2.num;

  LINE(312);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            T_4_1.num = b.vec->data[1];
                            err = g_iterbody_names_asst(out, arr, T_4_1, &T_4_2);
                            if (err != ERR_ok) goto ex_0;
                            }
                            break;
                            }
                    default: {
                    }
                    }
                    }
                    break;
                    }
            case 18: 
                 {CLUREF T_2_8;
                T_2_8.num = T_2_1.cell->value;
                t.num = T_2_8.num;

  LINE(316);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = t.vec->data[0];
                        T_3_3.num = T_3_1.vec->size; 
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            arm.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(317);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            T_4_1.num = arm.vec->data[0];
                            T_4_2.num = T_4_1.vec->data[1];
                            err = g_iterbody_names_asst(out, arr, T_4_2, &T_4_3);
                            if (err != ERR_ok) goto ex_0;
                            }
                        }
                    }
                    end_inline_for_3:;

  LINE(319);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = t.vec->data[2];
                    switch (T_3_1.cell->tag) {
                    case 1: 
                         {CLUREF T_3_2;
                        T_3_2.num = T_3_1.cell->value;
                        b.num = T_3_2.num;

  LINE(321);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            T_4_1.num = b.vec->data[1];
                            err = g_iterbody_names_asst(out, arr, T_4_1, &T_4_2);
                            if (err != ERR_ok) goto ex_0;
                            }
                            break;
                            }
                    default: {
                    }
                    }
                    }
                    break;
                    }
            case 8: 
                 {CLUREF T_2_9;
                T_2_9.num = T_2_1.cell->value;
                e.num = T_2_9.num;

  LINE(325);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    T_3_1.num = e.vec->data[2];
                    err = sequenceOPfill(CLU_1, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    err = g_iterbody_names_asst(out, arr, T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(326);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = e.vec->data[0];
                        T_3_3.num = T_3_1.vec->size; 
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            a.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(327);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            T_4_1.num = a.vec->data[0];
                            T_4_2.num = T_4_1.vec->data[1];
                            err = g_iterbody_names_asst(out, arr, T_4_2, &T_4_3);
                            if (err != ERR_ok) goto ex_0;
                            }
                        }
                    }
                    end_inline_for_4:;

  LINE(329);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = e.vec->data[1];
                    switch (T_3_1.cell->tag) {
                    case 1: 
                         {CLUREF T_3_2;
                        T_3_2.num = T_3_1.cell->value;
                        a.num = T_3_2.num;

  LINE(331);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            T_4_1.num = a.vec->data[0];
                            T_4_2.num = T_4_1.vec->data[1];
                            err = g_iterbody_names_asst(out, arr, T_4_2, &T_4_3);
                            if (err != ERR_ok) goto ex_0;
                            }
                            break;
                            }
                    default: {
                    }
                    }
                    }
                    break;
                    }
            case 14: 
                 {CLUREF T_2_10;
                T_2_10.num = T_2_1.cell->value;
                rs.num = T_2_10.num;

  LINE(335);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    T_3_1.num = rs.vec->data[1];
                    err = sequenceOPfill(CLU_1, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    err = g_iterbody_names_asst(out, arr, T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    }
                    break;
                    }
            default: {
            }
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(339);
    {
    {
    ret_1->num = out.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE g_iterbody_names_asst ****/


/**** BEGIN CLUSTER loop_context ****/

extern errcode oneofOPmake_3();
extern errcode oneofOPmake_4();
extern errcode oneofOPmake_2();
extern errcode oneofOPmake_1();
extern errcode oneofOPis_4();
extern errcode arrayOPremh();
extern errcode oneofOPis_2();
extern errcode arrayOPtop();
static int loop_context_own_init = 0;
OWN_req loop_context_ownreqs = {0,0};
CLUREF loop_contextOPstate;
CLUREF loop_contextOPstack;
CLUREF loop_contextOPwhile_count;
CLUREF loop_contextOPwhile_count_stack;
CLUREF loop_contextOPinline_for_count;
CLUREF loop_contextOPinline_for_count_stack;
errcode loop_context_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (loop_context_own_init == 0) {
        loop_context_own_init = 1;
        {
            {CLUREF T_0_1;
            CellAlloc(3, nil, T_0_1);
            loop_contextOPstate.num = T_0_1.num;
            }
            }
        {
            {CLUREF T_0_2;
            err = arrayOPnew(&T_0_2);
            if (err != ERR_ok) goto ex_0;
            loop_contextOPstack.num = T_0_2.num;
            }
            }
        {
            {loop_contextOPwhile_count.num = 0;
            }
            }
        {
            {CLUREF T_0_3;
            err = arrayOPnew(&T_0_3);
            if (err != ERR_ok) goto ex_0;
            loop_contextOPwhile_count_stack.num = T_0_3.num;
            }
            }
        {
            {loop_contextOPinline_for_count.num = 0;
            }
            }
        {
            {CLUREF T_0_4;
            err = arrayOPnew(&T_0_4);
            if (err != ERR_ok) goto ex_0;
            loop_contextOPinline_for_count_stack.num = T_0_4.num;
            }
            }
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE init ****/

errcode loop_contextOPinit()
    {
    errcode err;
    errcode ecode2;
        if (loop_context_own_init == 0) {
            err = loop_context_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(364);

  LINE(366);
    {
    CLUREF T_1_1;
    CellAlloc(3, nil, T_1_1);
    loop_contextOPstate.num = T_1_1.num;
    }

  LINE(367);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    loop_contextOPstack.num = T_1_1.num;
    }

  LINE(368);
    {
    loop_contextOPwhile_count.num = 0;
    }

  LINE(369);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    loop_contextOPwhile_count_stack.num = T_1_1.num;
    }

  LINE(370);
    {
    loop_contextOPinline_for_count.num = 0;
    }

  LINE(371);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    loop_contextOPinline_for_count_stack.num = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE init ****/


/**** BEGIN PROCEDURE enter_while ****/

errcode loop_contextOPenter_while()
    {
    errcode err;
    errcode ecode2;
        if (loop_context_own_init == 0) {
            err = loop_context_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(375);

  LINE(377);
    {
    {
    if ((loop_contextOPstack.array->int_low + loop_contextOPstack.array->ext_size + 1) < loop_contextOPstack.array->int_size) {
        loop_contextOPstack.array->store->data[loop_contextOPstack.array->int_low + loop_contextOPstack.array->ext_size] = loop_contextOPstate.num;
        loop_contextOPstack.array->ext_size++; loop_contextOPstack.array->ext_high++;}
    else {
        err = arrayOPaddh(loop_contextOPstack, loop_contextOPstate);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(378);
    {
    CLUREF T_1_1;
    CellAlloc(4, nil, T_1_1);
    loop_contextOPstate.num = T_1_1.num;
    }

  LINE(379);
    {
    CLUREF T_1_1;
    T_1_1.num = loop_contextOPwhile_count.num + 1;
     if ((T_1_1.num > 0 && loop_contextOPwhile_count.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && loop_contextOPwhile_count.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    loop_contextOPwhile_count.num = T_1_1.num;
    }

  LINE(380);
    {
    {
    if ((loop_contextOPwhile_count_stack.array->int_low + loop_contextOPwhile_count_stack.array->ext_size + 1) < loop_contextOPwhile_count_stack.array->int_size) {
        loop_contextOPwhile_count_stack.array->store->data[loop_contextOPwhile_count_stack.array->int_low + loop_contextOPwhile_count_stack.array->ext_size] = loop_contextOPwhile_count.num;
        loop_contextOPwhile_count_stack.array->ext_size++; loop_contextOPwhile_count_stack.array->ext_high++;}
    else {
        err = arrayOPaddh(loop_contextOPwhile_count_stack, loop_contextOPwhile_count);
        if (err != ERR_ok) goto ex_0;}
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE enter_while ****/


/**** BEGIN PROCEDURE enter_inline_for ****/

errcode loop_contextOPenter_inline_for()
    {
    errcode err;
    errcode ecode2;
        if (loop_context_own_init == 0) {
            err = loop_context_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(384);

  LINE(386);
    {
    {
    if ((loop_contextOPstack.array->int_low + loop_contextOPstack.array->ext_size + 1) < loop_contextOPstack.array->int_size) {
        loop_contextOPstack.array->store->data[loop_contextOPstack.array->int_low + loop_contextOPstack.array->ext_size] = loop_contextOPstate.num;
        loop_contextOPstack.array->ext_size++; loop_contextOPstack.array->ext_high++;}
    else {
        err = arrayOPaddh(loop_contextOPstack, loop_contextOPstate);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(387);
    {
    CLUREF T_1_1;
    CellAlloc(2, nil, T_1_1);
    loop_contextOPstate.num = T_1_1.num;
    }

  LINE(388);
    {
    CLUREF T_1_1;
    T_1_1.num = loop_contextOPinline_for_count.num + 1;
     if ((T_1_1.num > 0 && loop_contextOPinline_for_count.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && loop_contextOPinline_for_count.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    loop_contextOPinline_for_count.num = T_1_1.num;
    }

  LINE(389);
    {
    {
    if ((loop_contextOPinline_for_count_stack.array->int_low + loop_contextOPinline_for_count_stack.array->ext_size + 1) < loop_contextOPinline_for_count_stack.array->int_size) {
        loop_contextOPinline_for_count_stack.array->store->data[loop_contextOPinline_for_count_stack.array->int_low + loop_contextOPinline_for_count_stack.array->ext_size] = loop_contextOPinline_for_count.num;
        loop_contextOPinline_for_count_stack.array->ext_size++; loop_contextOPinline_for_count_stack.array->ext_high++;}
    else {
        err = arrayOPaddh(loop_contextOPinline_for_count_stack, loop_contextOPinline_for_count);
        if (err != ERR_ok) goto ex_0;}
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE enter_inline_for ****/


/**** BEGIN PROCEDURE enter_for ****/

errcode loop_contextOPenter_for()
    {
    errcode err;
    errcode ecode2;
        if (loop_context_own_init == 0) {
            err = loop_context_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(393);

  LINE(395);
    {
    {
    if ((loop_contextOPstack.array->int_low + loop_contextOPstack.array->ext_size + 1) < loop_contextOPstack.array->int_size) {
        loop_contextOPstack.array->store->data[loop_contextOPstack.array->int_low + loop_contextOPstack.array->ext_size] = loop_contextOPstate.num;
        loop_contextOPstack.array->ext_size++; loop_contextOPstack.array->ext_high++;}
    else {
        err = arrayOPaddh(loop_contextOPstack, loop_contextOPstate);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(396);
    {
    CLUREF T_1_1;
    CellAlloc(1, nil, T_1_1);
    loop_contextOPstate.num = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE enter_for ****/


/**** BEGIN PROCEDURE leave ****/

errcode loop_contextOPleave()
    {
    errcode err;
    errcode ecode2;
        if (loop_context_own_init == 0) {
            err = loop_context_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(400);

  LINE(402);
    {
    CLUREF T_1_1;
    if (loop_contextOPstate.cell->tag == 4) T_1_1.num = true; else T_1_1.num = false;
    if (T_1_1.num == true) {

  LINE(404);
        {
        CLUREF T_2_1;
        err = arrayOPremh(loop_contextOPwhile_count_stack, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(406);
    {
    CLUREF T_1_1;
    if (loop_contextOPstate.cell->tag == 2) T_1_1.num = true; else T_1_1.num = false;
    if (T_1_1.num == true) {

  LINE(408);
        {
        CLUREF T_2_1;
        err = arrayOPremh(loop_contextOPinline_for_count_stack, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(410);
    {
    CLUREF T_1_1;
    err = arrayOPremh(loop_contextOPstack, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    loop_contextOPstate.num = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE leave ****/


/**** BEGIN PROCEDURE is_for ****/

errcode loop_contextOPis_for(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (loop_context_own_init == 0) {
            err = loop_context_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(414);

  LINE(415);
    {
    switch (loop_contextOPstate.cell->tag) {
    case 1: 
         {

  LINE(417);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(419);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE is_for ****/


/**** BEGIN PROCEDURE is_while ****/

errcode loop_contextOPis_while(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (loop_context_own_init == 0) {
            err = loop_context_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(423);

  LINE(424);
    {
    switch (loop_contextOPstate.cell->tag) {
    case 4: 
         {

  LINE(426);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(428);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE is_while ****/


/**** BEGIN PROCEDURE is_inline_for ****/

errcode loop_contextOPis_inline_for(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (loop_context_own_init == 0) {
            err = loop_context_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(432);

  LINE(433);
    {
    switch (loop_contextOPstate.cell->tag) {
    case 2: 
         {

  LINE(435);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(437);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE is_inline_for ****/


/**** BEGIN PROCEDURE get_current_while_count ****/

errcode loop_contextOPget_current_while_count(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (loop_context_own_init == 0) {
            err = loop_context_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(441);

  LINE(442);
    {
    {
    CLUREF T_1_1;
    err = arrayOPtop(loop_contextOPwhile_count_stack, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_current_while_count ****/


/**** BEGIN PROCEDURE get_current_inline_for_count ****/

errcode loop_contextOPget_current_inline_for_count(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (loop_context_own_init == 0) {
            err = loop_context_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(445);

  LINE(446);
    {
    {
    CLUREF T_1_1;
    err = arrayOPtop(loop_contextOPinline_for_count_stack, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_current_inline_for_count ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[10];
} loop_context_OPS;

CLU_proc loop_context_oe_enter_for = {{0,0,0,0}, loop_contextOPenter_for, 0};
CLU_proc loop_context_oe_enter_inline_for = {{0,0,0,0}, loop_contextOPenter_inline_for, 0};
CLU_proc loop_context_oe_enter_while = {{0,0,0,0}, loop_contextOPenter_while, 0};
CLU_proc loop_context_oe_get_current_inline_for_count = {{0,0,0,0}, loop_contextOPget_current_inline_for_count, 0};
CLU_proc loop_context_oe_get_current_while_count = {{0,0,0,0}, loop_contextOPget_current_while_count, 0};
CLU_proc loop_context_oe_init = {{0,0,0,0}, loop_contextOPinit, 0};
CLU_proc loop_context_oe_is_for = {{0,0,0,0}, loop_contextOPis_for, 0};
CLU_proc loop_context_oe_is_inline_for = {{0,0,0,0}, loop_contextOPis_inline_for, 0};
CLU_proc loop_context_oe_is_while = {{0,0,0,0}, loop_contextOPis_while, 0};
CLU_proc loop_context_oe_leave = {{0,0,0,0}, loop_contextOPleave, 0};

loop_context_OPS loop_context_ops_actual = {10, (OWNPTR)&loop_context_own_init, (OWNPTR)&loop_context_own_init, {
    {&loop_context_oe_enter_for, "enter_for"},
    {&loop_context_oe_enter_inline_for, "enter_inline_for"},
    {&loop_context_oe_enter_while, "enter_while"},
    {&loop_context_oe_get_current_inline_for_count, "get_current_inline_for_count"},
    {&loop_context_oe_get_current_while_count, "get_current_while_count"},
    {&loop_context_oe_init, "init"},
    {&loop_context_oe_is_for, "is_for"},
    {&loop_context_oe_is_inline_for, "is_inline_for"},
    {&loop_context_oe_is_while, "is_while"},
    {&loop_context_oe_leave, "leave"}}};

struct OPS *loop_context_ops = (struct OPS *)&loop_context_ops_actual;

/**** END CLUSTER loop_context ****/

/**** BEGIN CLUSTER current_locals ****/

static int current_locals_own_init = 0;
OWN_req current_locals_ownreqs = {0,0};
CLUREF current_localsOPcurr_lvs;
errcode current_locals_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (current_locals_own_init == 0) {
        current_locals_own_init = 1;
        {
            {CLUREF T_0_1;
            err = arrayOPnew(&T_0_1);
            if (err != ERR_ok) goto ex_0;
            current_localsOPcurr_lvs.num = T_0_1.num;
            }
            }
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE set ****/

errcode current_localsOPset(lvs)
CLUREF lvs;
    {
    errcode err;
    errcode ecode2;
        if (current_locals_own_init == 0) {
            err = current_locals_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(461);

  LINE(462);
    {
    current_localsOPcurr_lvs.num = lvs.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set ****/


/**** BEGIN PROCEDURE get ****/

errcode current_localsOPget(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (current_locals_own_init == 0) {
            err = current_locals_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(465);

  LINE(466);
    {
    {
    ret_1->num = current_localsOPcurr_lvs.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[2];
} current_locals_OPS;

CLU_proc current_locals_oe_get = {{0,0,0,0}, current_localsOPget, 0};
CLU_proc current_locals_oe_set = {{0,0,0,0}, current_localsOPset, 0};

current_locals_OPS current_locals_ops_actual = {2, (OWNPTR)&current_locals_own_init, (OWNPTR)&current_locals_own_init, {
    {&current_locals_oe_get, "get"},
    {&current_locals_oe_set, "set"}}};

struct OPS *current_locals_ops = (struct OPS *)&current_locals_ops_actual;

/**** END CLUSTER current_locals ****/

/**** BEGIN CLUSTER current_apply ****/

extern errcode idnOPget_str();
extern errcode recordOPget_5();
extern errcode charOPequal();
extern errcode stringOPfetch();
extern errcode stringOPrest();
extern errcode stringOPequal();
extern errcode duOPget_unique();
extern errcode recordOPget_11();
extern errcode stringOPempty();
extern errcode recordOPget_8();
extern errcode arrayOPpredict();
CLUREF STR_;
CLUREF STR_itertype;
CLUREF STR_OP;
CLUREF STR__137;
static int current_apply_own_init = 0;
OWN_req current_apply_ownreqs = {0,0};
CLUREF current_applyOPcurr_app;
CLUREF current_applyOPcurr_app_name;
CLUREF current_applyOPiterp;
errcode current_apply_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (current_apply_own_init == 0) {
        stringOPcons("", CLU_1, CLU_0, &STR_);
        stringOPcons("itertype", CLU_1, CLU_8, &STR_itertype);
        stringOPcons("OP", CLU_1, CLU_2, &STR_OP);
        stringOPcons("_", CLU_1, CLU_1, &STR__137);
        current_apply_own_init = 1;
        {
            {current_applyOPcurr_app_name = STR_;
            }
            }
        {
            {current_applyOPiterp.tf = false;
            }
            }
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }

static int current_applyOPset_own_init = 0;

/**** BEGIN PROCEDURE set ****/

errcode current_applyOPset(app)
CLUREF app;
    {
    errcode err;
    errcode ecode2;
        if (current_applyOPset_own_init == 0) {
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        current_applyOPset_own_init = 1;
    }
    enter_proc(485);

  LINE(486);
    {
    current_applyOPcurr_app.num = app.num;
    }

  LINE(487);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = current_applyOPcurr_app.vec->data[4];
    err = idnOPget_str(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    current_applyOPcurr_app_name.num = T_1_2.num;
    }

  LINE(488);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = stringOPfetch(current_applyOPcurr_app_name, CLU_1, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.ch = '%';
    T_1_3.num = (T_1_1.ch == T_1_2.ch)? true : false;
    if (T_1_3.num == true) {

  LINE(489);
        {
        CLUREF T_2_1;
        err = stringOPrest(current_applyOPcurr_app_name, CLU_2, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        current_applyOPcurr_app_name.num = T_2_1.num;
        }
        }
        }/* end if */

  LINE(491);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = current_applyOPcurr_app.vec->data[3];
    err = duOPget_unique(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_3.num = ((T_1_2.str->size != STR_itertype.str->size)? false :
        !(bcmp(T_1_2.str->data, STR_itertype.str->data, T_1_2.str->size)));
    if (T_1_3.num == true) {
        {
        current_applyOPiterp.tf = true;
        }
        }
    else {

  LINE(492);
        {
        current_applyOPiterp.tf = false;
        }
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set ****/


/**** BEGIN PROCEDURE get ****/

errcode current_applyOPget(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(495);

  LINE(496);
    {
    {
    ret_1->num = current_applyOPcurr_app.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get ****/


/**** BEGIN PROCEDURE get_val_count ****/

errcode current_applyOPget_val_count(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(499);

  LINE(500);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = current_applyOPcurr_app.vec->data[10];
    T_1_2.num = T_1_1.vec->size;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_val_count ****/


/**** BEGIN PROCEDURE get_apply_name ****/

errcode current_applyOPget_apply_name(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(503);

  LINE(504);
    {
    {
    ret_1->num = current_applyOPcurr_app_name.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_apply_name ****/

static int current_applyOPget_name_own_init = 0;

/**** BEGIN PROCEDURE get_name ****/

errcode current_applyOPget_name(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF tname;
        if (current_applyOPget_name_own_init == 0) {
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        current_applyOPget_name_own_init = 1;
    }
    enter_proc(507);

  LINE(508);
    {
        {CLUREF T_1_1;
        err = current_typeOPget_name(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        tname.num = T_1_1.num;
        }
        }

  LINE(509);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    err = stringOPempty(tname, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_3.num = T_1_2.num ^ 1;
    T_1_1.num = T_1_3.num;
    if (T_1_3.num) {
        err = stringOPempty(current_applyOPcurr_app_name, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        T_1_5.num = T_1_4.num ^ 1;
        T_1_1.num = T_1_5.num;
    }
    if (T_1_1.num == true) {

  LINE(511);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = current_typeOPget_name(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_1, STR_OP, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_2, current_applyOPcurr_app_name, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_3.num;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(512);
        {
        {
        CLUREF T_2_1;
        err = stringOPconcat(tname, current_applyOPcurr_app_name, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_name ****/


/**** BEGIN PROCEDURE get_short_name ****/

errcode current_applyOPget_short_name(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(516);

  LINE(517);
    {
    {
    ret_1->num = current_applyOPcurr_app_name.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_short_name ****/


/**** BEGIN PROCEDURE is_iter ****/

errcode current_applyOPis_iter(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(520);

  LINE(521);
    {
    {
    ret_1->num = current_applyOPiterp.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE is_iter ****/

static int current_applyOPparmd_own_init = 0;

/**** BEGIN PROCEDURE parmd ****/

errcode current_applyOPparmd(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (current_applyOPparmd_own_init == 0) {
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        current_applyOPparmd_own_init = 1;
    }
    enter_proc(524);

  LINE(525);
    {
    CLUREF T_1_1;
    T_1_1.num = ((current_applyOPcurr_app_name.str->size != STR_.str->size)? false :
        !(bcmp(current_applyOPcurr_app_name.str->data, STR_.str->data, current_applyOPcurr_app_name.str->size)));
    if (T_1_1.num == true) {
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(526);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = current_applyOPcurr_app.vec->data[7];
    T_1_2.num = T_1_1.vec->size;
    T_1_3.num = (T_1_2.num == 0)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(527);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE parmd ****/

static int current_applyOPget_formals_string_own_init = 0;

/**** BEGIN PROCEDURE get_formals_string ****/

errcode current_applyOPget_formals_string(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF result;
    CLUREF each_d;
    CLUREF each_i;
        if (current_applyOPget_formals_string_own_init == 0) {
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        current_applyOPget_formals_string_own_init = 1;
    }
    enter_proc(530);

  LINE(531);
    {
        {result = STR_;
        }
        }

  LINE(532);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = current_applyOPcurr_app.vec->data[7];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            each_d.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(533);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = each_d.vec->data[0];
                T_2_3.num = T_2_1.vec->size; 
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    each_i.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(534);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    err = stringOPconcat(result, STR__137, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = idnOPget_str(each_i, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(T_3_1, T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    result.num = T_3_3.num;
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(537);
    {
    {
    ret_1->num = result.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_formals_string ****/


/**** BEGIN PROCEDURE get_formals ****/

errcode current_applyOPget_formals(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF result;
    CLUREF each_d;
    CLUREF each_i;
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(540);

  LINE(541);
    {
        {CLUREF T_1_1;
        err = arrayOPpredict(CLU_1, CLU_10, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        result.num = T_1_1.num;
        }
        }

  LINE(542);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = current_applyOPcurr_app.vec->data[7];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            each_d.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(543);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = each_d.vec->data[0];
                T_2_3.num = T_2_1.vec->size; 
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    each_i.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(544);
                    {
                    CLUREF T_3_1;
                    err = idnOPget_str(each_i, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    {
                    if ((result.array->int_low + result.array->ext_size + 1) < result.array->int_size) {
                        result.array->store->data[result.array->int_low + result.array->ext_size] = T_3_1.num;
                        result.array->ext_size++; result.array->ext_high++;}
                    else {
                        err = arrayOPaddh(result, T_3_1);
                        if (err != ERR_ok) goto ex_0;}
                    }
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(547);
    {
    {
    ret_1->num = result.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_formals ****/

static int current_applyOPreset_own_init = 0;

/**** BEGIN PROCEDURE reset ****/

errcode current_applyOPreset()
    {
    errcode err;
    errcode ecode2;
        if (current_applyOPreset_own_init == 0) {
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        current_applyOPreset_own_init = 1;
    }
    enter_proc(550);

  LINE(551);
    {
    current_applyOPcurr_app_name = STR_;
    }

  LINE(552);
    {
    current_applyOPiterp.tf = false;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE reset ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[11];
} current_apply_OPS;

CLU_proc current_apply_oe_get = {{0,0,0,0}, current_applyOPget, 0};
CLU_proc current_apply_oe_get_apply_name = {{0,0,0,0}, current_applyOPget_apply_name, 0};
CLU_proc current_apply_oe_get_formals = {{0,0,0,0}, current_applyOPget_formals, 0};
CLU_proc current_apply_oe_get_formals_string = {{0,0,0,0}, current_applyOPget_formals_string, 0};
CLU_proc current_apply_oe_get_name = {{0,0,0,0}, current_applyOPget_name, 0};
CLU_proc current_apply_oe_get_short_name = {{0,0,0,0}, current_applyOPget_short_name, 0};
CLU_proc current_apply_oe_get_val_count = {{0,0,0,0}, current_applyOPget_val_count, 0};
CLU_proc current_apply_oe_is_iter = {{0,0,0,0}, current_applyOPis_iter, 0};
CLU_proc current_apply_oe_parmd = {{0,0,0,0}, current_applyOPparmd, 0};
CLU_proc current_apply_oe_reset = {{0,0,0,0}, current_applyOPreset, 0};
CLU_proc current_apply_oe_set = {{0,0,0,0}, current_applyOPset, 0};

current_apply_OPS current_apply_ops_actual = {11, (OWNPTR)&current_apply_own_init, (OWNPTR)&current_apply_own_init, {
    {&current_apply_oe_get, "get"},
    {&current_apply_oe_get_apply_name, "get_apply_name"},
    {&current_apply_oe_get_formals, "get_formals"},
    {&current_apply_oe_get_formals_string, "get_formals_string"},
    {&current_apply_oe_get_name, "get_name"},
    {&current_apply_oe_get_short_name, "get_short_name"},
    {&current_apply_oe_get_val_count, "get_val_count"},
    {&current_apply_oe_is_iter, "is_iter"},
    {&current_apply_oe_parmd, "parmd"},
    {&current_apply_oe_reset, "reset"},
    {&current_apply_oe_set, "set"}}};

struct OPS *current_apply_ops = (struct OPS *)&current_apply_ops_actual;

/**** END CLUSTER current_apply ****/

/**** BEGIN CLUSTER current_type ****/

static int current_type_own_init = 0;
OWN_req current_type_ownreqs = {0,0};
CLUREF current_typeOPcurr_typ;
CLUREF current_typeOPcurr_typ_name;
CLUREF current_typeOPown_init_proc;
errcode current_type_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (current_type_own_init == 0) {
        stringOPcons("", CLU_1, CLU_0, &STR_);
        stringOPcons("_", CLU_1, CLU_1, &STR__137);
        current_type_own_init = 1;
        {
            {current_typeOPcurr_typ_name = STR_;
            }
            }
        {
            {current_typeOPown_init_proc.tf = false;
            }
            }
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE set ****/

errcode current_typeOPset(typ)
CLUREF typ;
    {
    errcode err;
    errcode ecode2;
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(571);

  LINE(572);
    {
    current_typeOPcurr_typ.num = typ.num;
    }

  LINE(573);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = current_typeOPcurr_typ.vec->data[3];
    err = idnOPget_str(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    current_typeOPcurr_typ_name.num = T_1_2.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set ****/


/**** BEGIN PROCEDURE get ****/

errcode current_typeOPget(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(576);

  LINE(577);
    {
    {
    ret_1->num = current_typeOPcurr_typ.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get ****/

static int current_typeOPexists_own_init = 0;

/**** BEGIN PROCEDURE exists ****/

errcode current_typeOPexists(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (current_typeOPexists_own_init == 0) {
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        current_typeOPexists_own_init = 1;
    }
    enter_proc(580);

  LINE(581);
    {
    CLUREF T_1_1;
    T_1_1.num = ((current_typeOPcurr_typ_name.str->size != STR_.str->size)? false :
        !(bcmp(current_typeOPcurr_typ_name.str->data, STR_.str->data, current_typeOPcurr_typ_name.str->size)));
    if (T_1_1.num == true) {
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(582);
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE exists ****/


/**** BEGIN PROCEDURE parmd ****/

errcode current_typeOPparmd(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(585);

  LINE(586);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = current_typeOPcurr_typ.vec->data[7];
    T_1_2.num = T_1_1.vec->size;
    T_1_3.num = (T_1_2.num == 0)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(587);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE parmd ****/

static int current_typeOPget_formals_string_own_init = 0;

/**** BEGIN PROCEDURE get_formals_string ****/

errcode current_typeOPget_formals_string(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF result;
    CLUREF each_d;
    CLUREF each_i;
        if (current_typeOPget_formals_string_own_init == 0) {
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        current_typeOPget_formals_string_own_init = 1;
    }
    enter_proc(590);

  LINE(591);
    {
        {result = STR_;
        }
        }

  LINE(592);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = current_typeOPcurr_typ.vec->data[7];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            each_d.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(593);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = each_d.vec->data[0];
                T_2_3.num = T_2_1.vec->size; 
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    each_i.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(594);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    err = stringOPconcat(result, STR__137, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = idnOPget_str(each_i, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(T_3_1, T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    result.num = T_3_3.num;
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(597);
    {
    {
    ret_1->num = result.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_formals_string ****/


/**** BEGIN PROCEDURE get_formals ****/

errcode current_typeOPget_formals(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF result;
    CLUREF each_d;
    CLUREF each_i;
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(600);

  LINE(601);
    {
        {CLUREF T_1_1;
        err = arrayOPpredict(CLU_1, CLU_10, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        result.num = T_1_1.num;
        }
        }

  LINE(602);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = current_typeOPcurr_typ.vec->data[7];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            each_d.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(603);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = each_d.vec->data[0];
                T_2_3.num = T_2_1.vec->size; 
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    each_i.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(604);
                    {
                    CLUREF T_3_1;
                    err = idnOPget_str(each_i, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    {
                    if ((result.array->int_low + result.array->ext_size + 1) < result.array->int_size) {
                        result.array->store->data[result.array->int_low + result.array->ext_size] = T_3_1.num;
                        result.array->ext_size++; result.array->ext_high++;}
                    else {
                        err = arrayOPaddh(result, T_3_1);
                        if (err != ERR_ok) goto ex_0;}
                    }
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(607);
    {
    {
    ret_1->num = result.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_formals ****/


/**** BEGIN PROCEDURE get_name ****/

errcode current_typeOPget_name(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(610);

  LINE(611);
    {
    {
    ret_1->num = current_typeOPcurr_typ_name.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_name ****/


/**** BEGIN PROCEDURE set_own_init_proc ****/

errcode current_typeOPset_own_init_proc(generated)
CLUREF generated;
    {
    errcode err;
    errcode ecode2;
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(614);

  LINE(615);
    {
    current_typeOPown_init_proc.num = generated.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_own_init_proc ****/

static int current_typeOPown_init_proc_exists_own_init = 0;

/**** BEGIN PROCEDURE own_init_proc_exists ****/

errcode current_typeOPown_init_proc_exists(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (current_typeOPown_init_proc_exists_own_init == 0) {
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        current_typeOPown_init_proc_exists_own_init = 1;
    }
    enter_proc(618);

  LINE(619);
    {
    CLUREF T_1_1;
    T_1_1.num = ((current_typeOPcurr_typ_name.str->size != STR_.str->size)? false :
        !(bcmp(current_typeOPcurr_typ_name.str->data, STR_.str->data, current_typeOPcurr_typ_name.str->size)));
    if (T_1_1.num == true) {
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(620);
    {
    {
    ret_1->num = current_typeOPown_init_proc.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE own_init_proc_exists ****/

static int current_typeOPreset_own_init = 0;

/**** BEGIN PROCEDURE reset ****/

errcode current_typeOPreset()
    {
    errcode err;
    errcode ecode2;
        if (current_typeOPreset_own_init == 0) {
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        current_typeOPreset_own_init = 1;
    }
    enter_proc(623);

  LINE(624);
    {
    current_typeOPcurr_typ_name = STR_;
    }

  LINE(625);
    {
    current_typeOPown_init_proc.tf = false;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE reset ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[10];
} current_type_OPS;

CLU_proc current_type_oe_exists = {{0,0,0,0}, current_typeOPexists, 0};
CLU_proc current_type_oe_get = {{0,0,0,0}, current_typeOPget, 0};
CLU_proc current_type_oe_get_formals = {{0,0,0,0}, current_typeOPget_formals, 0};
CLU_proc current_type_oe_get_formals_string = {{0,0,0,0}, current_typeOPget_formals_string, 0};
CLU_proc current_type_oe_get_name = {{0,0,0,0}, current_typeOPget_name, 0};
CLU_proc current_type_oe_own_init_proc_exists = {{0,0,0,0}, current_typeOPown_init_proc_exists, 0};
CLU_proc current_type_oe_parmd = {{0,0,0,0}, current_typeOPparmd, 0};
CLU_proc current_type_oe_reset = {{0,0,0,0}, current_typeOPreset, 0};
CLU_proc current_type_oe_set = {{0,0,0,0}, current_typeOPset, 0};
CLU_proc current_type_oe_set_own_init_proc = {{0,0,0,0}, current_typeOPset_own_init_proc, 0};

current_type_OPS current_type_ops_actual = {10, (OWNPTR)&current_type_own_init, (OWNPTR)&current_type_own_init, {
    {&current_type_oe_exists, "exists"},
    {&current_type_oe_get, "get"},
    {&current_type_oe_get_formals, "get_formals"},
    {&current_type_oe_get_formals_string, "get_formals_string"},
    {&current_type_oe_get_name, "get_name"},
    {&current_type_oe_own_init_proc_exists, "own_init_proc_exists"},
    {&current_type_oe_parmd, "parmd"},
    {&current_type_oe_reset, "reset"},
    {&current_type_oe_set, "set"},
    {&current_type_oe_set_own_init_proc, "set_own_init_proc"}}};

struct OPS *current_type_ops = (struct OPS *)&current_type_ops_actual;

/**** END CLUSTER current_type ****/

/**** BEGIN CLUSTER owns ****/

extern errcode idnOPequal();
static int owns_own_init = 0;
OWN_req owns_ownreqs = {0,0};
CLUREF ownsOPcurrent_owns;
errcode owns_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (owns_own_init == 0) {
        owns_own_init = 1;
        {
            {CLUREF T_0_1;
            err = sequenceOPnew(&T_0_1);
            if (err != ERR_ok) goto ex_0;
            ownsOPcurrent_owns.num = T_0_1.num;
            }
            }
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE save ****/

errcode ownsOPsave(ilist)
CLUREF ilist;
    {
    errcode err;
    errcode ecode2;
    CLUREF each_i;
        if (owns_own_init == 0) {
            err = owns_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(635);

  LINE(637);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = ilist.vec->size; 
        T_1_3 = ilist;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            each_i.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(638);
            {
            CLUREF T_2_1;
            err = sequenceOPaddh(ownsOPcurrent_owns, each_i, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ownsOPcurrent_owns.num = T_2_1.num;
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE save ****/


/**** BEGIN PROCEDURE forget ****/

errcode ownsOPforget()
    {
    errcode err;
    errcode ecode2;
        if (owns_own_init == 0) {
            err = owns_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(643);

  LINE(645);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    ownsOPcurrent_owns.num = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE forget ****/


/**** BEGIN PROCEDURE member ****/

errcode ownsOPmember(i, ret_1)
CLUREF i;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF this_init;
    CLUREF d;
    CLUREF this_idn;
    CLUREF di;
    CLUREF this_decl;
        if (owns_own_init == 0) {
            err = owns_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(649);

  LINE(650);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = ownsOPcurrent_owns.vec->size; 
        T_1_3 = ownsOPcurrent_owns;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            this_init.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(651);
            {
            CLUREF T_2_1;
            T_2_1.num = this_init.vec->data[1];
            switch (T_2_1.cell->tag) {
            case 1: 
                 {CLUREF T_2_2;
                T_2_2.num = T_2_1.cell->value;
                d.num = T_2_2.num;

  LINE(653);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = d.vec->data[0];
                        T_3_3.num = T_3_1.vec->size; 
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            this_idn.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(654);
                            {
                            CLUREF T_4_1;
                            err = idnOPequal(this_idn, i, &T_4_1);
                            if (err != ERR_ok) goto ex_0;
                            if (T_4_1.num == true) {
                                {
                                {
                                ret_1->tf = true;
                                }
                                {signal (ERR_ok);}}
                                }
                                }/* end if */
                        }
                    }
                    end_inline_for_2:;
                    break;
                    }
            case 2: 
                 {CLUREF T_2_3;
                T_2_3.num = T_2_1.cell->value;
                di.num = T_2_3.num;

  LINE(657);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = di.vec->data[1];
                        T_3_3.num = T_3_1.vec->size; 
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            this_decl.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(658);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            CLUREF T_4_4;
                                T_4_1.num = this_decl.vec->data[0];
                                T_4_3.num = T_4_1.vec->size; 
                                T_4_4 = T_4_1;
                                for (T_4_2.num = 1; T_4_2.num <= T_4_3.num; T_4_2.num++) {
                                    this_idn.num = T_4_4.vec->data[T_4_2.num - 1];

  LINE(659);
                                    {
                                    CLUREF T_5_1;
                                    err = idnOPequal(this_idn, i, &T_5_1);
                                    if (err != ERR_ok) goto ex_0;
                                    if (T_5_1.num == true) {
                                        {
                                        {
                                        ret_1->tf = true;
                                        }
                                        {signal (ERR_ok);}}
                                        }
                                        }/* end if */
                                }
                            }
                            end_inline_for_4:;
                        }
                    }
                    end_inline_for_3:;
                    break;
                    }
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(664);
    {
    {
    ret_1->tf = false;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE member ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[3];
} owns_OPS;

CLU_proc owns_oe_forget = {{0,0,0,0}, ownsOPforget, 0};
CLU_proc owns_oe_member = {{0,0,0,0}, ownsOPmember, 0};
CLU_proc owns_oe_save = {{0,0,0,0}, ownsOPsave, 0};

owns_OPS owns_ops_actual = {3, (OWNPTR)&owns_own_init, (OWNPTR)&owns_own_init, {
    {&owns_oe_forget, "forget"},
    {&owns_oe_member, "member"},
    {&owns_oe_save, "save"}}};

struct OPS *owns_ops = (struct OPS *)&owns_ops_actual;

/**** END CLUSTER owns ****/
