
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER ib ****/

extern errcode sequenceOPnew();
extern errcode intOPequal();
extern errcode sequenceOPsize();
extern errcode sequenceOPaddh();
extern errcode intOPadd();
extern errcode stringOPconcat();
extern errcode current_applyOPget_name();
extern errcode intOPunparse();
extern errcode boolOPnot();
extern errcode sequenceOPempty();
extern errcode g_envOPblankline();
extern errcode g_envOPputs();
extern errcode g_idnlit();
extern errcode sequenceOPelements();
extern errcode ibOPgen_body();
extern errcode exOPinit();
extern errcode loop_contextOPenter_for();
extern errcode g_envOPputl();
extern errcode recordOPget_4();
extern errcode recordOPget_1();
extern errcode intOPfrom_to();
extern errcode g_envOPindent();
extern errcode g_idn();
extern errcode sequenceOPfetch();
extern errcode stmtOPget_line();
extern errcode recordOPget_2();
extern errcode g_stmt();
extern errcode g_envOPoutdent();
extern errcode exOPget_current_ex_label();
extern errcode g_err();
extern errcode current_applyOPis_iter();
extern errcode g_locals();
extern errcode exOPget_current_end_label();
extern errcode loop_contextOPleave();
static CLUREF STR__137IB_137;
static CLUREF STR__057_052_052_052_052_040BEGIN_040ITERATOR_040BODIES_040for_040;
static CLUREF STR__040_052_052_052_052_057;
static CLUREF STR__057_052_052_052_052_040END_040ITERATOR_040BODIES_040for_040;
static CLUREF STR_static_040errcode;
static CLUREF STR__050;
static CLUREF STR_CLUREF_040iv_137;
static CLUREF STR__054_040;
static CLUREF STR__137LOCALS_137t_040_052locals_054_040;
static CLUREF STR_errcode_040_052iecode_051;
static CLUREF STR__173;
static CLUREF STR__040_075_040iv_137;
static CLUREF STR__056num_073;
static CLUREF STR_enter_137iter_137body_137proc_050;
static CLUREF STR__051_073;
static CLUREF STR_enter_137iter_137body_137proc_050_0551_051_073;
static CLUREF STR_signal_050ERR_137ok_051_073;
static CLUREF STR__040_040;
static CLUREF STR__072;
static CLUREF STR__052iecode_040_075_040;
static CLUREF STR__073;
static CLUREF STR_body_137ctrl_137req_040_075_040true_073;
static CLUREF STR_signal_050ERR_137iteriterbodyexit_051_073;
static CLUREF STR_signal_050ERR_137iterbodyexit_051_073;
static CLUREF STR__175;
static int ib_own_init = 0;
const OWN_req ib_ownreqs = { 0, 0 };
CLUREF ibOPiblist;
CLUREF ibOPcount;
CLUREF ibOPold_count;
CLUREF ibOPgenerating_bodies;

errcode
ib_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (ib_own_init == 0) {
        stringOPcons("_IB_", CLU_1, CLUREF_make_num(4), &STR__137IB_137);
        stringOPcons("/**** BEGIN ITERATOR BODIES for ", CLU_1, CLUREF_make_num(32), &STR__057_052_052_052_052_040BEGIN_040ITERATOR_040BODIES_040for_040);
        stringOPcons(" ****/", CLU_1, CLUREF_make_num(6), &STR__040_052_052_052_052_057);
        stringOPcons("/**** END ITERATOR BODIES for ", CLU_1, CLUREF_make_num(30), &STR__057_052_052_052_052_040END_040ITERATOR_040BODIES_040for_040);
        stringOPcons("static errcode", CLU_1, CLUREF_make_num(14), &STR_static_040errcode);
        stringOPcons("(", CLU_1, CLUREF_make_num(1), &STR__050);
        stringOPcons("CLUREF iv_", CLU_1, CLUREF_make_num(10), &STR_CLUREF_040iv_137);
        stringOPcons(", ", CLU_1, CLUREF_make_num(2), &STR__054_040);
        stringOPcons("_LOCALS_t *locals, ", CLU_1, CLUREF_make_num(19), &STR__137LOCALS_137t_040_052locals_054_040);
        stringOPcons("errcode *iecode)", CLU_1, CLUREF_make_num(16), &STR_errcode_040_052iecode_051);
        stringOPcons("{", CLU_1, CLUREF_make_num(1), &STR__173);
        stringOPcons(" = iv_", CLU_1, CLUREF_make_num(6), &STR__040_075_040iv_137);
        stringOPcons(".num;", CLU_1, CLUREF_make_num(5), &STR__056num_073);
        stringOPcons("enter_iter_body_proc(", CLU_1, CLUREF_make_num(21), &STR_enter_137iter_137body_137proc_050);
        stringOPcons(");", CLU_1, CLUREF_make_num(2), &STR__051_073);
        stringOPcons("enter_iter_body_proc(-1);", CLU_1, CLUREF_make_num(25), &STR_enter_137iter_137body_137proc_050_0551_051_073);
        stringOPcons("signal(ERR_ok);", CLU_1, CLUREF_make_num(15), &STR_signal_050ERR_137ok_051_073);
        stringOPcons("  ", CLU_1, CLUREF_make_num(2), &STR__040_040);
        stringOPcons(":", CLU_1, CLUREF_make_num(1), &STR__072);
        stringOPcons("*iecode = ", CLU_1, CLUREF_make_num(10), &STR__052iecode_040_075_040);
        stringOPcons(";", CLU_1, CLUREF_make_num(1), &STR__073);
        stringOPcons("body_ctrl_req = true;", CLU_1, CLUREF_make_num(21), &STR_body_137ctrl_137req_040_075_040true_073);
        stringOPcons("signal(ERR_iteriterbodyexit);", CLU_1, CLUREF_make_num(29), &STR_signal_050ERR_137iteriterbodyexit_051_073);
        stringOPcons("signal(ERR_iterbodyexit);", CLU_1, CLUREF_make_num(25), &STR_signal_050ERR_137iterbodyexit_051_073);
        stringOPcons("}", CLU_1, CLUREF_make_num(1), &STR__175);
        ib_own_init = 1;
        {
            {CLUREF T_0_1;
            err = sequenceOPnew(&T_0_1);
            if (err != ERR_ok) goto ex_0;
            ibOPiblist.num = T_0_1.num;
            }
            }
        {
            {ibOPcount.num = 0;
            }
            }
        {
            {ibOPold_count.num = 0;
            }
            }
        {
            {ibOPgenerating_bodies.tf = false;
            }
            }
        signal(ERR_ok);
      ex_0:
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE init ****/


errcode
ibOPinit()
{
    errcode err;
    if (ib_own_init == 0) {
        err = ib_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(19);

  LINE(20);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    ibOPiblist.num = T_1_1.num;
    }

  LINE(21);
    {
    ibOPcount.num = 0;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE init ****/


/**** BEGIN PROCEDURE reset ****/


errcode
ibOPreset()
{
    errcode err;
    if (ib_own_init == 0) {
        err = ib_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(24);

  LINE(25);
    {
    ibOPcount.num = 0;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE reset ****/


/**** BEGIN PROCEDURE bodies ****/


errcode
ibOPbodies(CLUREF *ret_1)
{
    errcode err;
    if (ib_own_init == 0) {
        err = ib_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(31);

  LINE(32);
    {
    {
    ret_1->num = ibOPgenerating_bodies.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE bodies ****/


/**** BEGIN PROCEDURE exist ****/


errcode
ibOPexist(CLUREF *ret_1)
{
    errcode err;
    if (ib_own_init == 0) {
        err = ib_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(38);

  LINE(39);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ibOPiblist.vec->size;
    T_1_2.num = (T_1_1.num == 0)? true : false;
    if (T_1_2.num == true) {

  LINE(41);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(43);
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }}/* end if */

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE exist ****/


/**** BEGIN PROCEDURE add_body ****/


errcode
ibOPadd_body(CLUREF bod)
{
    errcode err;
    if (ib_own_init == 0) {
        err = ib_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(47);

  LINE(48);
    {
    CLUREF T_1_1;
    err = sequenceOPaddh(ibOPiblist, bod, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ibOPiblist.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE add_body ****/


/**** BEGIN PROCEDURE next_name ****/

static int ibOPnext_name_own_init = 0;

errcode
ibOPnext_name(CLUREF *ret_1)
{
    errcode err;
    if (ibOPnext_name_own_init == 0) {
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        ibOPnext_name_own_init = 1;
    }
    enter_proc(51);

  LINE(53);
    {
    CLUREF T_1_1;
    T_1_1.num = ibOPcount.num + 1;
     if ((T_1_1.num > 0 && ibOPcount.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && ibOPcount.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    ibOPcount.num = T_1_1.num;
    }

  LINE(55);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    err = current_applyOPget_name(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_1, STR__137IB_137, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = intOPunparse(ibOPcount, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_2, T_1_3, &T_1_4);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_4.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE next_name ****/


/**** BEGIN PROCEDURE save_name ****/


errcode
ibOPsave_name()
{
    errcode err;
    if (ib_own_init == 0) {
        err = ib_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(59);

  LINE(60);
    {
    ibOPold_count.num = ibOPcount.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE save_name ****/


/**** BEGIN PROCEDURE restore_name ****/


errcode
ibOPrestore_name()
{
    errcode err;
    if (ib_own_init == 0) {
        err = ib_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(63);

  LINE(64);
    {
    ibOPcount.num = ibOPold_count.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE restore_name ****/


/**** BEGIN PROCEDURE gen_bodies ****/

static int ibOPgen_bodies_own_init = 0;

errcode
ibOPgen_bodies(CLUREF e, CLUREF id)
{
    errcode err;
    CLUREF index;
    CLUREF each_bod;
    if (ibOPgen_bodies_own_init == 0) {
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        ibOPgen_bodies_own_init = 1;
    }
    enter_proc(67);

  LINE(69);
    {
    ibOPgenerating_bodies.tf = true;
    }

  LINE(70);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = sequenceOPempty(ibOPiblist, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(71);
        {
        err = g_envOPblankline(e);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(72);
        {
        err = g_envOPputs(e, STR__057_052_052_052_052_040BEGIN_040ITERATOR_040BODIES_040for_040);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(73);
        {
        err = g_idnlit(e, id);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(74);
        {
        err = g_envOPputs(e, STR__040_052_052_052_052_057);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(75);
        {
            {index.num = 1;
            }
            }

  LINE(76);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
            T_2_2.num = ibOPiblist.vec->size;
            T_2_3 = ibOPiblist;
            for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                each_bod.num = T_2_3.vec->data[T_2_1.num - 1];

  LINE(77);
                {
                err = ibOPgen_body(e, each_bod, index);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(78);
                {
                CLUREF T_3_1;
                T_3_1.num = index.num + 1;
                 if ((T_3_1.num > 0 && index.num < 0 && 1 < 0) ||
                     (T_3_1.num < 0 && index.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                index.num = T_3_1.num;
                }
            }
        }
        end_inline_for_1:;

  LINE(80);
        {
        err = g_envOPblankline(e);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(81);
        {
        err = g_envOPputs(e, STR__057_052_052_052_052_040END_040ITERATOR_040BODIES_040for_040);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(82);
        {
        err = g_idnlit(e, id);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(83);
        {
        err = g_envOPputs(e, STR__040_052_052_052_052_057);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(84);
        {
        err = g_envOPblankline(e);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(86);
    {
    ibOPgenerating_bodies.tf = false;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE gen_bodies ****/


/**** BEGIN PROCEDURE gen_body ****/

static int ibOPgen_body_own_init = 0;

errcode
ibOPgen_body(CLUREF e, CLUREF f, CLUREF index)
{
    errcode err;
    CLUREF ibname;
    CLUREF iv_count;
    CLUREF o;
    CLUREF n;
    CLUREF this_d;
    CLUREF each_i;
    CLUREF idns;
    CLUREF d;
    CLUREF i;
    CLUREF each_d;
    CLUREF each_idn;
    CLUREF s;
    if (ibOPgen_body_own_init == 0) {
        if (ib_own_init == 0) {
            err = ib_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        ibOPgen_body_own_init = 1;
    }
    enter_proc(89);

  LINE(91);
    {
    err = exOPinit();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(94);
    {
    err = loop_contextOPenter_for();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(96);
    {
    err = g_envOPblankline(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(99);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        err = current_applyOPget_name(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_1_1, STR__137IB_137, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        err = intOPunparse(index, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_1_2, T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        ibname.num = T_1_4.num;
        }
        }

  LINE(102);
    {
    err = g_envOPputl(e, STR_static_040errcode);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(103);
    {
    err = g_envOPputs(e, ibname);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(104);
    {
    err = g_envOPputs(e, STR__050);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(106);
    {
        {iv_count.num = 0;
        }
        }

  LINE(107);
    {
    CLUREF T_1_1;
    T_1_1.num = f.vec->data[3];
    switch (T_1_1.cell->tag) {
    case 2:
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        o.num = T_1_2.num;

  LINE(109);
            {
            CLUREF T_2_1;
            T_2_1.num = o.vec->size;
            iv_count.num = T_2_1.num;
            }
            break;
            }
    case 1:
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        n.num = T_1_3.num;

  LINE(111);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
                T_2_2.num = n.vec->size;
                T_2_3 = n;
                for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                    this_d.num = T_2_3.vec->data[T_2_1.num - 1];

  LINE(112);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    T_3_1.num = this_d.vec->data[0];
                    T_3_2.num = T_3_1.vec->size;
                    T_3_3.num = iv_count.num + T_3_2.num;
                     if ((T_3_3.num > 0 && iv_count.num < 0 && T_3_2.num < 0) ||
                         (T_3_3.num < 0 && iv_count.num > 0 && T_3_2.num > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    iv_count.num = T_3_3.num;
                    }
                }
            }
            end_inline_for_1:;
            break;
            }
    }
    }

  LINE(116);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = iv_count.num;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            each_i.num = T_1_1.num;

  LINE(117);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            err = intOPunparse(each_i, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(STR_CLUREF_040iv_137, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_2, STR__054_040, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            err = g_envOPputs(e, T_2_3);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_2:;

  LINE(120);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = current_applyOPget_name(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_1, STR__137LOCALS_137t_040_052locals_054_040, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = g_envOPputs(e, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(121);
    {
    err = g_envOPputl(e, STR_errcode_040_052iecode_051);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(124);
    {
    err = g_envOPputl(e, STR__173);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(125);
    {
    err = g_envOPindent(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(127);
    {
    CLUREF T_1_1;
    T_1_1.num = f.vec->data[3];
    switch (T_1_1.cell->tag) {
    case 2:
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        idns.num = T_1_2.num;

  LINE(129);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
                T_2_2.num = iv_count.num;
                for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                    each_i.num = T_2_1.num;

  LINE(130);
                    {
                    CLUREF T_3_1;
                    if (each_i.num < 1 || each_i.num > idns.vec->size ) {
                        err = ERR_bounds;
                        goto ex_0;}
                    T_3_1.num = idns.vec->data[each_i.num - 1];
                    err = g_idn(e, T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(131);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    err = intOPunparse(each_i, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(STR__040_075_040iv_137, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(T_3_2, STR__056num_073, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    err = g_envOPputl(e, T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    }
                }
            }
            end_inline_for_3:;
            break;
            }
    case 1:
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        d.num = T_1_3.num;

  LINE(134);
            {
                {i.num = 1;
                }
                }

  LINE(135);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
                T_2_2.num = d.vec->size;
                T_2_3 = d;
                for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                    each_d.num = T_2_3.vec->data[T_2_1.num - 1];

  LINE(136);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = each_d.vec->data[0];
                        T_3_3.num = T_3_1.vec->size;
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            each_idn.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(137);
                            {
                            err = g_idn(e, each_idn);
                            if (err != ERR_ok) goto ex_0;
                            }

  LINE(138);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            err = intOPunparse(i, &T_4_1);
                            if (err != ERR_ok) goto ex_0;
                            err = stringOPconcat(STR__040_075_040iv_137, T_4_1, &T_4_2);
                            if (err != ERR_ok) goto ex_0;
                            err = stringOPconcat(T_4_2, STR__056num_073, &T_4_3);
                            if (err != ERR_ok) goto ex_0;
                            err = g_envOPputl(e, T_4_3);
                            if (err != ERR_ok) goto ex_0;
                            }

  LINE(139);
                            {
                            CLUREF T_4_1;
                            T_4_1.num = i.num + 1;
                             if ((T_4_1.num > 0 && i.num < 0 && 1 < 0) ||
                                 (T_4_1.num < 0 && i.num > 0 && 1 > 0)) {
                                err = ERR_overflow;
                                goto ex_0;}
                            i.num = T_4_1.num;
                            }
                        }
                    }
                    end_inline_for_5:;
                }
            }
            end_inline_for_4:;
            break;
            }
    }
    }

  LINE(143);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    CLUREF T_2_4;
    CLUREF T_2_5;
    CLUREF T_2_6;
    CLUREF T_2_7;
    T_2_1.num = f.vec->data[1];
    T_2_2.num = T_2_1.vec->data[1];
    if (1 < 1 || 1 > T_2_2.vec->size ) {
        err = ERR_bounds;
        goto ex_1;}
    T_2_3.num = T_2_2.vec->data[1 - 1];
    err = stmtOPget_line(T_2_3, &T_2_4);
    if (err != ERR_ok) goto ex_1;
    err = intOPunparse(T_2_4, &T_2_5);
    if (err != ERR_ok) goto ex_1;
    err = stringOPconcat(STR_enter_137iter_137body_137proc_050, T_2_5, &T_2_6);
    if (err != ERR_ok) goto ex_1;
    err = stringOPconcat(T_2_6, STR__051_073, &T_2_7);
    if (err != ERR_ok) goto ex_1;
    err = g_envOPputl(e, T_2_7);
    if (err != ERR_ok) goto ex_1;
    }
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {

  LINE(145);
                {
                err = g_envOPputl(e, STR_enter_137iter_137body_137proc_050_0551_051_073);
                if (err != ERR_ok) goto ex_0;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(147);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
        T_1_1.num = f.vec->data[1];
        T_1_2.num = T_1_1.vec->data[1];
        T_1_4.num = T_1_2.vec->size;
        T_1_5 = T_1_2;
        for (T_1_3.num = 1; T_1_3.num <= T_1_4.num; T_1_3.num++) {
            s.num = T_1_5.vec->data[T_1_3.num - 1];

  LINE(148);
            {
            err = g_stmt(e, s);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_6:;

  LINE(152);
    {
    err = g_envOPblankline(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(153);
    {
    err = g_envOPputl(e, STR_signal_050ERR_137ok_051_073);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(156);
    {
    err = g_envOPoutdent(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(157);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = exOPget_current_ex_label(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(STR__040_040, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_2, STR__072, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    err = g_envOPputl(e, T_1_3);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(158);
    {
    err = g_envOPindent(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(159);
    {
    err = g_envOPputs(e, STR__052iecode_040_075_040);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(160);
    {
    err = g_err(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(161);
    {
    err = g_envOPputl(e, STR__073);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(162);
    {
    CLUREF T_1_1;
    err = current_applyOPis_iter(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(164);
        {
        err = g_locals(e);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(165);
        {
        err = g_envOPputl(e, STR_body_137ctrl_137req_040_075_040true_073);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(166);
        {
        err = g_envOPputl(e, STR_signal_050ERR_137iteriterbodyexit_051_073);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(168);
        {
        err = g_envOPputl(e, STR_signal_050ERR_137iterbodyexit_051_073);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(171);
    {
    err = g_envOPoutdent(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(172);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = exOPget_current_end_label(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(STR__040_040, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_2, STR__072, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    err = g_envOPputl(e, T_1_3);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(173);
    {
    err = g_envOPindent(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(174);
    {
    err = g_envOPputl(e, STR_signal_050ERR_137ok_051_073);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(177);
    {
    err = g_envOPoutdent(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(178);
    {
    err = g_envOPputl(e, STR__175);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(180);
    {
    err = loop_contextOPleave();
    if (err != ERR_ok) goto ex_0;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE gen_body ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[9];
} ib_OPS;

static CLU_proc ib_oe_add_body = { .proc = ibOPadd_body };
static CLU_proc ib_oe_bodies = { .proc = ibOPbodies };
static CLU_proc ib_oe_exist = { .proc = ibOPexist };
static CLU_proc ib_oe_gen_bodies = { .proc = ibOPgen_bodies };
static CLU_proc ib_oe_init = { .proc = ibOPinit };
static CLU_proc ib_oe_next_name = { .proc = ibOPnext_name };
static CLU_proc ib_oe_reset = { .proc = ibOPreset };
static CLU_proc ib_oe_restore_name = { .proc = ibOPrestore_name };
static CLU_proc ib_oe_save_name = { .proc = ibOPsave_name };

static ib_OPS ib_ops_actual = {9, (OWNPTR)&ib_own_init, (OWNPTR)&ib_own_init, {
    {&ib_oe_add_body, "add_body"},
    {&ib_oe_bodies, "bodies"},
    {&ib_oe_exist, "exist"},
    {&ib_oe_gen_bodies, "gen_bodies"},
    {&ib_oe_init, "init"},
    {&ib_oe_next_name, "next_name"},
    {&ib_oe_reset, "reset"},
    {&ib_oe_restore_name, "restore_name"},
    {&ib_oe_save_name, "save_name"}}};

struct OPS *ib_ops = (struct OPS *)&ib_ops_actual;

/**** END CLUSTER ib ****/


/**** BEGIN PROCEDURE g_iterbody_names ****/

extern errcode enumerate_iterbodies();
extern errcode arrayOPaddh();
extern errcode ibOPnext_name();
extern errcode ibOPadd_body();
static errcode g_iterbody_names_IB_1();
typedef struct {
    errcode ecode2;
    errcode err;
    CLUREF f;
    CLUREF names;
    CLUREF bod;
} g_iterbody_names_LOCALS_t;

errcode
g_iterbody_names(CLUREF names, CLUREF bod)
{
    g_iterbody_names_LOCALS_t locals;
    locals.names = names;
    locals.bod = bod;
    enter_proc(191);

  LINE(192);
    {
        locals.err = enumerate_iterbodies(locals.bod, g_iterbody_names_IB_1, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {
            signal(ERR_ok);
        }
        if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
        if (locals.err == ERR_break) locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
        if (locals.err != ERR_ok) goto ex_0;
        }

    goto end_0;
  ex_0:
    if (locals.err != ERR_failure)
        elist[0] = _pclu_erstr(locals.err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE g_iterbody_names ****/


/**** BEGIN ITERATOR BODIES for g_iterbody_names ****/

static errcode
g_iterbody_names_IB_1(CLUREF iv_1, g_iterbody_names_LOCALS_t *locals, errcode *iecode)
{
    locals->f.num = iv_1.num;
    enter_iter_body_proc(193);

  FB_LINE(193);
    {
    CLUREF T_1_1;
    locals->err = ibOPnext_name(&T_1_1);
    if (locals->err != ERR_ok) goto ex_0;
    {
    if ((locals->names.array->int_low + locals->names.array->ext_size + 1) < locals->names.array->int_size) {
        locals->names.array->store->data[locals->names.array->int_low + locals->names.array->ext_size] = T_1_1.num;
        locals->names.array->ext_size++; locals->names.array->ext_high++;}
    else {
        locals->err = arrayOPaddh(locals->names, T_1_1);
        if (locals->err != ERR_ok) goto ex_0;}
    }
    }

  FB_LINE(194);
    {
    locals->err = ibOPadd_body(locals->f);
    if (locals->err != ERR_ok) goto ex_0;
    }

    signal(ERR_ok);
  ex_0:
    *iecode = locals->err;
    signal(ERR_iterbodyexit);
  end_0:
    signal(ERR_ok);
}

/**** END ITERATOR BODIES for g_iterbody_names ****/



/**** BEGIN ITERATOR enumerate_iterbodies ****/

extern errcode arrayOPnew();
extern errcode g_iterbody_names_asst();
extern errcode arrayOPelements();
extern errcode arrayOPempty();

errcode
enumerate_iterbodies(CLUREF bod, errcode (*proc)(), void *user_locals, errcode *iecode)
{
    errcode ecode;
    errcode err;
    bool body_ctrl_req;
    CLUREF next_bodies;
    CLUREF current_bodies;
    CLUREF each_for;
    enter_proc(199);

  LINE(204);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    next_bodies.num = T_1_1.num;
    }

  LINE(205);
    {
    CLUREF T_1_1;
    err = g_iterbody_names_asst(next_bodies, bod, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(207);
    for (;;) {
        if (true != true) { break; }

  LINE(209);
        {
        current_bodies.num = next_bodies.num;
        }

  LINE(210);
        {
        CLUREF T_2_1;
        err = arrayOPnew(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        next_bodies.num = T_2_1.num;
        }

  LINE(212);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
            T_2_2.num = current_bodies.array->ext_high;
            T_2_3 = current_bodies;
            for (T_2_1.num = current_bodies.array->ext_low; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                if (T_2_1.num > T_2_3.array->ext_high || T_2_1.num < T_2_3.array->ext_low) {
                    err = ERR_failure;
                    elist[0] = array_bounds_exception_STRING;
                    goto ex_0;}
                each_for.num = T_2_3.array->store->data[T_2_1.num - T_2_3.array->ext_low + T_2_3.array->int_low];

  LINE(213);
                {
                err = proc(each_for, user_locals, iecode);
                if (err != ERR_ok) {
                if (err == ERR_break) {signal(ERR_break);}
                if (err == ERR_iterbodyreturn) {signal(ERR_iterbodyreturn);}
                if (err == ERR_iterbodyexit) {signal(ERR_iterbodyexit);}
                if (err == ERR_iterbodysignal) {signal(ERR_iterbodysignal);}
                {signal(err);
                    }}
                }
            }
        }
        end_inline_for_1:;

  LINE(216);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
            T_2_2.num = current_bodies.array->ext_high;
            T_2_3 = current_bodies;
            for (T_2_1.num = current_bodies.array->ext_low; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                if (T_2_1.num > T_2_3.array->ext_high || T_2_1.num < T_2_3.array->ext_low) {
                    err = ERR_failure;
                    elist[0] = array_bounds_exception_STRING;
                    goto ex_0;}
                each_for.num = T_2_3.array->store->data[T_2_1.num - T_2_3.array->ext_low + T_2_3.array->int_low];

  LINE(217);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                T_3_1.num = each_for.vec->data[1];
                T_3_2.num = T_3_1.vec->data[1];
                err = g_iterbody_names_asst(next_bodies, T_3_2, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                }
            }
        }
        end_inline_for_2:;

  LINE(220);
        {
        CLUREF T_2_1;
        T_2_1.num = (next_bodies.array->ext_size == 0)? true : false;
        if (T_2_1.num == true) {
            goto end_while_1;
            }
            }/* end if */
        }
        end_while_1:;

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END ITERATOR enumerate_iterbodies ****/



/**** BEGIN PROCEDURE g_iterbody_names_asst ****/

extern errcode stmtOPget_abs();
extern errcode g_inline_iter_test();
extern errcode recordOPget_3();

errcode
g_iterbody_names_asst(CLUREF fors, CLUREF bod, CLUREF *ret_1)
{
    errcode err;
    CLUREF s;
    CLUREF f;
    CLUREF b;
    CLUREF w;
    CLUREF i;
    CLUREF arm;
    CLUREF t;
    CLUREF e;
    CLUREF a;
    CLUREF rs;
    enter_proc(226);

  LINE(228);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = bod.vec->size;
        T_1_3 = bod;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            s.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(229);
            {
            CLUREF T_2_1;
            err = stmtOPget_abs(s, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_1.cell->tag) {
            case 10:
                 {CLUREF T_2_2;
                T_2_2.num = T_2_1.cell->value;
                f.num = T_2_2.num;

  LINE(232);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    T_3_1.num = f.vec->data[2];
                    T_3_2.num = T_3_1.vec->data[0];
                    err = g_inline_iter_test(T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    if (T_3_3.num == true) {

  LINE(233);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        CLUREF T_4_3;
                        T_4_1.num = f.vec->data[1];
                        T_4_2.num = T_4_1.vec->data[1];
                        err = g_iterbody_names_asst(fors, T_4_2, &T_4_3);
                        if (err != ERR_ok) goto ex_0;
                        }
                        }
                    else {

  LINE(236);
                        {
                        {
                        if ((fors.array->int_low + fors.array->ext_size + 1) < fors.array->int_size) {
                            fors.array->store->data[fors.array->int_low + fors.array->ext_size] = f.num;
                            fors.array->ext_size++; fors.array->ext_high++;}
                        else {
                            err = arrayOPaddh(fors, f);
                            if (err != ERR_ok) goto ex_0;}
                        }
                        }
                        }}/* end if */
                    break;
                    }
            case 3:
                 {CLUREF T_2_3;
                T_2_3.num = T_2_1.cell->value;
                b.num = T_2_3.num;

  LINE(240);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    T_3_1.num = b.vec->data[1];
                    err = g_iterbody_names_asst(fors, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    }
                    break;
                    }
            case 19:
                 {CLUREF T_2_4;
                T_2_4.num = T_2_1.cell->value;
                w.num = T_2_4.num;

  LINE(242);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    T_3_1.num = w.vec->data[0];
                    T_3_2.num = T_3_1.vec->data[1];
                    err = g_iterbody_names_asst(fors, T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    }
                    break;
                    }
            case 12:
                 {CLUREF T_2_5;
                T_2_5.num = T_2_1.cell->value;
                i.num = T_2_5.num;

  LINE(244);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = i.vec->data[0];
                        T_3_3.num = T_3_1.vec->size;
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            arm.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(245);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            T_4_1.num = arm.vec->data[0];
                            T_4_2.num = T_4_1.vec->data[1];
                            err = g_iterbody_names_asst(fors, T_4_2, &T_4_3);
                            if (err != ERR_ok) goto ex_0;
                            }
                        }
                    }
                    end_inline_for_2:;

  LINE(247);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = i.vec->data[1];
                    switch (T_3_1.cell->tag) {
                    case 1:
                         {CLUREF T_3_2;
                        T_3_2.num = T_3_1.cell->value;
                        b.num = T_3_2.num;

  LINE(249);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            T_4_1.num = b.vec->data[1];
                            err = g_iterbody_names_asst(fors, T_4_1, &T_4_2);
                            if (err != ERR_ok) goto ex_0;
                            }
                            break;
                            }
                    default: {
                    }
                    }
                    }
                    break;
                    }
            case 18:
                 {CLUREF T_2_6;
                T_2_6.num = T_2_1.cell->value;
                t.num = T_2_6.num;

  LINE(253);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = t.vec->data[0];
                        T_3_3.num = T_3_1.vec->size;
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            arm.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(254);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            T_4_1.num = arm.vec->data[0];
                            T_4_2.num = T_4_1.vec->data[1];
                            err = g_iterbody_names_asst(fors, T_4_2, &T_4_3);
                            if (err != ERR_ok) goto ex_0;
                            }
                        }
                    }
                    end_inline_for_3:;

  LINE(256);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = t.vec->data[2];
                    switch (T_3_1.cell->tag) {
                    case 1:
                         {CLUREF T_3_2;
                        T_3_2.num = T_3_1.cell->value;
                        b.num = T_3_2.num;

  LINE(258);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            T_4_1.num = b.vec->data[1];
                            err = g_iterbody_names_asst(fors, T_4_1, &T_4_2);
                            if (err != ERR_ok) goto ex_0;
                            }
                            break;
                            }
                    default: {
                    }
                    }
                    }
                    break;
                    }
            case 8:
                 {CLUREF T_2_7;
                T_2_7.num = T_2_1.cell->value;
                e.num = T_2_7.num;

  LINE(262);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    sequenceOPnew2(CLU_1, &T_3_1);
                    T_3_2.num = e.vec->data[2];
                    T_3_1.vec->data[0] = T_3_2.num;
                    err = g_iterbody_names_asst(fors, T_3_1, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(263);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = e.vec->data[0];
                        T_3_3.num = T_3_1.vec->size;
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            a.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(264);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            T_4_1.num = a.vec->data[0];
                            T_4_2.num = T_4_1.vec->data[1];
                            err = g_iterbody_names_asst(fors, T_4_2, &T_4_3);
                            if (err != ERR_ok) goto ex_0;
                            }
                        }
                    }
                    end_inline_for_4:;

  LINE(266);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = e.vec->data[1];
                    switch (T_3_1.cell->tag) {
                    case 1:
                         {CLUREF T_3_2;
                        T_3_2.num = T_3_1.cell->value;
                        a.num = T_3_2.num;

  LINE(268);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            T_4_1.num = a.vec->data[0];
                            T_4_2.num = T_4_1.vec->data[1];
                            err = g_iterbody_names_asst(fors, T_4_2, &T_4_3);
                            if (err != ERR_ok) goto ex_0;
                            }
                            break;
                            }
                    default: {
                    }
                    }
                    }
                    break;
                    }
            case 14:
                 {CLUREF T_2_8;
                T_2_8.num = T_2_1.cell->value;
                rs.num = T_2_8.num;

  LINE(272);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    sequenceOPnew2(CLU_1, &T_3_1);
                    T_3_2.num = rs.vec->data[1];
                    T_3_1.vec->data[0] = T_3_2.num;
                    err = g_iterbody_names_asst(fors, T_3_1, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    }
                    break;
                    }
            default: {
            }
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(276);
    {
    {
    ret_1->num = fors.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE g_iterbody_names_asst ****/


/**** BEGIN CLUSTER loop_context ****/

extern errcode oneofOPmake_3();
extern errcode oneofOPmake_4();
extern errcode oneofOPmake_2();
extern errcode oneofOPmake_1();
extern errcode oneofOPis_4();
extern errcode arrayOPremh();
extern errcode oneofOPis_2();
extern errcode arrayOPtop();
static int loop_context_own_init = 0;
const OWN_req loop_context_ownreqs = { 0, 0 };
CLUREF loop_contextOPstate;
CLUREF loop_contextOPstack;
CLUREF loop_contextOPwhile_count;
CLUREF loop_contextOPwhile_count_stack;
CLUREF loop_contextOPinline_for_count;
CLUREF loop_contextOPinline_for_count_stack;

errcode
loop_context_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (loop_context_own_init == 0) {
        loop_context_own_init = 1;
        {
            {CLUREF T_0_1;
            CellAlloc(3, nil, T_0_1);
            loop_contextOPstate.num = T_0_1.num;
            }
            }
        {
            {CLUREF T_0_2;
            err = arrayOPnew(&T_0_2);
            if (err != ERR_ok) goto ex_0;
            loop_contextOPstack.num = T_0_2.num;
            }
            }
        {
            {loop_contextOPwhile_count.num = 0;
            }
            }
        {
            {CLUREF T_0_3;
            err = arrayOPnew(&T_0_3);
            if (err != ERR_ok) goto ex_0;
            loop_contextOPwhile_count_stack.num = T_0_3.num;
            }
            }
        {
            {loop_contextOPinline_for_count.num = 0;
            }
            }
        {
            {CLUREF T_0_4;
            err = arrayOPnew(&T_0_4);
            if (err != ERR_ok) goto ex_0;
            loop_contextOPinline_for_count_stack.num = T_0_4.num;
            }
            }
        signal(ERR_ok);
      ex_0:
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE init ****/


errcode
loop_contextOPinit()
{
    errcode err;
    if (loop_context_own_init == 0) {
        err = loop_context_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(303);

  LINE(305);
    {
    CLUREF T_1_1;
    CellAlloc(3, nil, T_1_1);
    loop_contextOPstate.num = T_1_1.num;
    }

  LINE(306);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    loop_contextOPstack.num = T_1_1.num;
    }

  LINE(307);
    {
    loop_contextOPwhile_count.num = 0;
    }

  LINE(308);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    loop_contextOPwhile_count_stack.num = T_1_1.num;
    }

  LINE(309);
    {
    loop_contextOPinline_for_count.num = 0;
    }

  LINE(310);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    loop_contextOPinline_for_count_stack.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE init ****/


/**** BEGIN PROCEDURE enter_while ****/


errcode
loop_contextOPenter_while()
{
    errcode err;
    if (loop_context_own_init == 0) {
        err = loop_context_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(314);

  LINE(316);
    {
    {
    if ((loop_contextOPstack.array->int_low + loop_contextOPstack.array->ext_size + 1) < loop_contextOPstack.array->int_size) {
        loop_contextOPstack.array->store->data[loop_contextOPstack.array->int_low + loop_contextOPstack.array->ext_size] = loop_contextOPstate.num;
        loop_contextOPstack.array->ext_size++; loop_contextOPstack.array->ext_high++;}
    else {
        err = arrayOPaddh(loop_contextOPstack, loop_contextOPstate);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(317);
    {
    CLUREF T_1_1;
    CellAlloc(4, nil, T_1_1);
    loop_contextOPstate.num = T_1_1.num;
    }

  LINE(318);
    {
    CLUREF T_1_1;
    T_1_1.num = loop_contextOPwhile_count.num + 1;
     if ((T_1_1.num > 0 && loop_contextOPwhile_count.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && loop_contextOPwhile_count.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    loop_contextOPwhile_count.num = T_1_1.num;
    }

  LINE(319);
    {
    {
    if ((loop_contextOPwhile_count_stack.array->int_low + loop_contextOPwhile_count_stack.array->ext_size + 1) < loop_contextOPwhile_count_stack.array->int_size) {
        loop_contextOPwhile_count_stack.array->store->data[loop_contextOPwhile_count_stack.array->int_low + loop_contextOPwhile_count_stack.array->ext_size] = loop_contextOPwhile_count.num;
        loop_contextOPwhile_count_stack.array->ext_size++; loop_contextOPwhile_count_stack.array->ext_high++;}
    else {
        err = arrayOPaddh(loop_contextOPwhile_count_stack, loop_contextOPwhile_count);
        if (err != ERR_ok) goto ex_0;}
    }
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE enter_while ****/


/**** BEGIN PROCEDURE enter_inline_for ****/


errcode
loop_contextOPenter_inline_for()
{
    errcode err;
    if (loop_context_own_init == 0) {
        err = loop_context_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(323);

  LINE(325);
    {
    {
    if ((loop_contextOPstack.array->int_low + loop_contextOPstack.array->ext_size + 1) < loop_contextOPstack.array->int_size) {
        loop_contextOPstack.array->store->data[loop_contextOPstack.array->int_low + loop_contextOPstack.array->ext_size] = loop_contextOPstate.num;
        loop_contextOPstack.array->ext_size++; loop_contextOPstack.array->ext_high++;}
    else {
        err = arrayOPaddh(loop_contextOPstack, loop_contextOPstate);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(326);
    {
    CLUREF T_1_1;
    CellAlloc(2, nil, T_1_1);
    loop_contextOPstate.num = T_1_1.num;
    }

  LINE(327);
    {
    CLUREF T_1_1;
    T_1_1.num = loop_contextOPinline_for_count.num + 1;
     if ((T_1_1.num > 0 && loop_contextOPinline_for_count.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && loop_contextOPinline_for_count.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    loop_contextOPinline_for_count.num = T_1_1.num;
    }

  LINE(328);
    {
    {
    if ((loop_contextOPinline_for_count_stack.array->int_low + loop_contextOPinline_for_count_stack.array->ext_size + 1) < loop_contextOPinline_for_count_stack.array->int_size) {
        loop_contextOPinline_for_count_stack.array->store->data[loop_contextOPinline_for_count_stack.array->int_low + loop_contextOPinline_for_count_stack.array->ext_size] = loop_contextOPinline_for_count.num;
        loop_contextOPinline_for_count_stack.array->ext_size++; loop_contextOPinline_for_count_stack.array->ext_high++;}
    else {
        err = arrayOPaddh(loop_contextOPinline_for_count_stack, loop_contextOPinline_for_count);
        if (err != ERR_ok) goto ex_0;}
    }
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE enter_inline_for ****/


/**** BEGIN PROCEDURE enter_for ****/


errcode
loop_contextOPenter_for()
{
    errcode err;
    if (loop_context_own_init == 0) {
        err = loop_context_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(332);

  LINE(334);
    {
    {
    if ((loop_contextOPstack.array->int_low + loop_contextOPstack.array->ext_size + 1) < loop_contextOPstack.array->int_size) {
        loop_contextOPstack.array->store->data[loop_contextOPstack.array->int_low + loop_contextOPstack.array->ext_size] = loop_contextOPstate.num;
        loop_contextOPstack.array->ext_size++; loop_contextOPstack.array->ext_high++;}
    else {
        err = arrayOPaddh(loop_contextOPstack, loop_contextOPstate);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(335);
    {
    CLUREF T_1_1;
    CellAlloc(1, nil, T_1_1);
    loop_contextOPstate.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE enter_for ****/


/**** BEGIN PROCEDURE leave ****/


errcode
loop_contextOPleave()
{
    errcode err;
    if (loop_context_own_init == 0) {
        err = loop_context_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(339);

  LINE(341);
    {
    CLUREF T_1_1;
    if (loop_contextOPstate.cell->tag == 4) T_1_1.num = true; else T_1_1.num = false;
    if (T_1_1.num == true) {

  LINE(343);
        {
        CLUREF T_2_1;
        err = arrayOPremh(loop_contextOPwhile_count_stack, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(345);
    {
    CLUREF T_1_1;
    if (loop_contextOPstate.cell->tag == 2) T_1_1.num = true; else T_1_1.num = false;
    if (T_1_1.num == true) {

  LINE(347);
        {
        CLUREF T_2_1;
        err = arrayOPremh(loop_contextOPinline_for_count_stack, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(349);
    {
    CLUREF T_1_1;
    err = arrayOPremh(loop_contextOPstack, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    loop_contextOPstate.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE leave ****/


/**** BEGIN PROCEDURE is_for ****/


errcode
loop_contextOPis_for(CLUREF *ret_1)
{
    errcode err;
    if (loop_context_own_init == 0) {
        err = loop_context_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(353);

  LINE(354);
    {
    switch (loop_contextOPstate.cell->tag) {
    case 1:
         {

  LINE(356);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(358);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
    }
    }
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE is_for ****/


/**** BEGIN PROCEDURE is_while ****/


errcode
loop_contextOPis_while(CLUREF *ret_1)
{
    errcode err;
    if (loop_context_own_init == 0) {
        err = loop_context_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(362);

  LINE(363);
    {
    switch (loop_contextOPstate.cell->tag) {
    case 4:
         {

  LINE(365);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(367);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
    }
    }
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE is_while ****/


/**** BEGIN PROCEDURE is_inline_for ****/


errcode
loop_contextOPis_inline_for(CLUREF *ret_1)
{
    errcode err;
    if (loop_context_own_init == 0) {
        err = loop_context_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(371);

  LINE(372);
    {
    switch (loop_contextOPstate.cell->tag) {
    case 2:
         {

  LINE(374);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(376);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
    }
    }
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE is_inline_for ****/


/**** BEGIN PROCEDURE get_current_while_count ****/


errcode
loop_contextOPget_current_while_count(CLUREF *ret_1)
{
    errcode err;
    if (loop_context_own_init == 0) {
        err = loop_context_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(380);

  LINE(381);
    {
    {
    CLUREF T_1_1;
    err = arrayOPtop(loop_contextOPwhile_count_stack, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_current_while_count ****/


/**** BEGIN PROCEDURE get_current_inline_for_count ****/


errcode
loop_contextOPget_current_inline_for_count(CLUREF *ret_1)
{
    errcode err;
    if (loop_context_own_init == 0) {
        err = loop_context_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(384);

  LINE(385);
    {
    {
    CLUREF T_1_1;
    err = arrayOPtop(loop_contextOPinline_for_count_stack, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_current_inline_for_count ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[10];
} loop_context_OPS;

static CLU_proc loop_context_oe_enter_for = { .proc = loop_contextOPenter_for };
static CLU_proc loop_context_oe_enter_inline_for = { .proc = loop_contextOPenter_inline_for };
static CLU_proc loop_context_oe_enter_while = { .proc = loop_contextOPenter_while };
static CLU_proc loop_context_oe_get_current_inline_for_count = { .proc = loop_contextOPget_current_inline_for_count };
static CLU_proc loop_context_oe_get_current_while_count = { .proc = loop_contextOPget_current_while_count };
static CLU_proc loop_context_oe_init = { .proc = loop_contextOPinit };
static CLU_proc loop_context_oe_is_for = { .proc = loop_contextOPis_for };
static CLU_proc loop_context_oe_is_inline_for = { .proc = loop_contextOPis_inline_for };
static CLU_proc loop_context_oe_is_while = { .proc = loop_contextOPis_while };
static CLU_proc loop_context_oe_leave = { .proc = loop_contextOPleave };

static loop_context_OPS loop_context_ops_actual = {10, (OWNPTR)&loop_context_own_init, (OWNPTR)&loop_context_own_init, {
    {&loop_context_oe_enter_for, "enter_for"},
    {&loop_context_oe_enter_inline_for, "enter_inline_for"},
    {&loop_context_oe_enter_while, "enter_while"},
    {&loop_context_oe_get_current_inline_for_count, "get_current_inline_for_count"},
    {&loop_context_oe_get_current_while_count, "get_current_while_count"},
    {&loop_context_oe_init, "init"},
    {&loop_context_oe_is_for, "is_for"},
    {&loop_context_oe_is_inline_for, "is_inline_for"},
    {&loop_context_oe_is_while, "is_while"},
    {&loop_context_oe_leave, "leave"}}};

struct OPS *loop_context_ops = (struct OPS *)&loop_context_ops_actual;

/**** END CLUSTER loop_context ****/

/**** BEGIN CLUSTER current_apply ****/

extern errcode c_fixup_opname();
extern errcode idnOPget_str();
extern errcode recordOPget_5();
extern errcode stringOPequal();
extern errcode duOPget_unique();
extern errcode recordOPget_11();
extern errcode current_typeOPget_name();
extern errcode stringOPempty();
extern errcode current_typeOPexists();
extern errcode recordOPget_8();
extern errcode arrayOPpredict();
static CLUREF STR_itertype;
static CLUREF STR_OP;
static CLUREF STR__137;
static int current_apply_own_init = 0;
const OWN_req current_apply_ownreqs = { 0, 0 };
CLUREF current_applyOPcurr_app;
CLUREF current_applyOPcurr_app_name;
CLUREF current_applyOPiterp;

errcode
current_apply_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (current_apply_own_init == 0) {
        stringOPcons("itertype", CLU_1, CLUREF_make_num(8), &STR_itertype);
        stringOPcons("OP", CLU_1, CLUREF_make_num(2), &STR_OP);
        stringOPcons("_", CLU_1, CLUREF_make_num(1), &STR__137);
        current_apply_own_init = 1;
        {
            {current_applyOPcurr_app_name = CLU_empty_string;
            }
            }
        {
            {current_applyOPiterp.tf = false;
            }
            }
        signal(ERR_ok);
      ex_0:
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE set ****/

static int current_applyOPset_own_init = 0;

errcode
current_applyOPset(CLUREF app)
{
    errcode err;
    if (current_applyOPset_own_init == 0) {
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        current_applyOPset_own_init = 1;
    }
    enter_proc(406);

  LINE(407);
    {
    current_applyOPcurr_app.num = app.num;
    }

  LINE(408);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = current_applyOPcurr_app.vec->data[4];
    err = idnOPget_str(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = c_fixup_opname(T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    current_applyOPcurr_app_name.num = T_1_3.num;
    }

  LINE(409);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = current_applyOPcurr_app.vec->data[3];
    err = duOPget_unique(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_3.num = ((T_1_2.str->size != STR_itertype.str->size)? false :
        !(memcmp(T_1_2.str->data, STR_itertype.str->data, T_1_2.str->size)));
    if (T_1_3.num == true) {
        {
        current_applyOPiterp.tf = true;
        }
        }
    else {

  LINE(410);
        {
        current_applyOPiterp.tf = false;
        }
        }}/* end if */

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set ****/


/**** BEGIN PROCEDURE get ****/


errcode
current_applyOPget(CLUREF *ret_1)
{
    errcode err;
    if (current_apply_own_init == 0) {
        err = current_apply_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(413);

  LINE(414);
    {
    {
    ret_1->num = current_applyOPcurr_app.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get ****/


/**** BEGIN PROCEDURE get_val_count ****/


errcode
current_applyOPget_val_count(CLUREF *ret_1)
{
    errcode err;
    if (current_apply_own_init == 0) {
        err = current_apply_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(417);

  LINE(418);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = current_applyOPcurr_app.vec->data[10];
    T_1_2.num = T_1_1.vec->size;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_val_count ****/


/**** BEGIN PROCEDURE get_apply_name ****/


errcode
current_applyOPget_apply_name(CLUREF *ret_1)
{
    errcode err;
    if (current_apply_own_init == 0) {
        err = current_apply_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(421);

  LINE(422);
    {
    {
    ret_1->num = current_applyOPcurr_app_name.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_apply_name ****/


/**** BEGIN PROCEDURE get_name ****/

static int current_applyOPget_name_own_init = 0;

errcode
current_applyOPget_name(CLUREF *ret_1)
{
    errcode err;
    CLUREF tname;
    if (current_applyOPget_name_own_init == 0) {
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        current_applyOPget_name_own_init = 1;
    }
    enter_proc(425);

  LINE(426);
    {
        {CLUREF T_1_1;
        err = current_typeOPget_name(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        tname.num = T_1_1.num;
        }
        }

  LINE(427);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    err = stringOPempty(tname, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_3.num = T_1_2.num ^ 1;
    T_1_1.num = T_1_3.num;
    if (T_1_3.num) {
        err = stringOPempty(current_applyOPcurr_app_name, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        T_1_5.num = T_1_4.num ^ 1;
        T_1_1.num = T_1_5.num;
    }
    if (T_1_1.num == true) {

  LINE(429);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = current_typeOPget_name(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_1, STR_OP, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_2, current_applyOPcurr_app_name, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_3.num;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(430);
        {
        {
        CLUREF T_2_1;
        err = stringOPconcat(tname, current_applyOPcurr_app_name, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
        }}/* end if */

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_name ****/


/**** BEGIN PROCEDURE is_type_own_init ****/


errcode
current_applyOPis_type_own_init(CLUREF *ret_1)
{
    errcode err;
    if (current_apply_own_init == 0) {
        err = current_apply_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(444);

  LINE(445);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = stringOPempty(current_applyOPcurr_app_name, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        err = current_typeOPexists(&T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_1.num = T_1_3.num;
    }
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE is_type_own_init ****/


/**** BEGIN PROCEDURE get_short_name ****/


errcode
current_applyOPget_short_name(CLUREF *ret_1)
{
    errcode err;
    if (current_apply_own_init == 0) {
        err = current_apply_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(448);

  LINE(449);
    {
    {
    ret_1->num = current_applyOPcurr_app_name.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_short_name ****/


/**** BEGIN PROCEDURE is_iter ****/


errcode
current_applyOPis_iter(CLUREF *ret_1)
{
    errcode err;
    if (current_apply_own_init == 0) {
        err = current_apply_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(452);

  LINE(453);
    {
    {
    ret_1->num = current_applyOPiterp.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE is_iter ****/


/**** BEGIN PROCEDURE parmd ****/

static int current_applyOPparmd_own_init = 0;

errcode
current_applyOPparmd(CLUREF *ret_1)
{
    errcode err;
    if (current_applyOPparmd_own_init == 0) {
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        current_applyOPparmd_own_init = 1;
    }
    enter_proc(456);

  LINE(457);
    {
    CLUREF T_1_1;
    T_1_1.num = ((current_applyOPcurr_app_name.str->size != CLU_empty_string.str->size)? false :
        !(memcmp(current_applyOPcurr_app_name.str->data, CLU_empty_string.str->data, current_applyOPcurr_app_name.str->size)));
    if (T_1_1.num == true) {
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(458);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = current_applyOPcurr_app.vec->data[7];
    T_1_2.num = T_1_1.vec->size;
    T_1_3.num = (T_1_2.num == 0)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(459);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }}/* end if */

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE parmd ****/


/**** BEGIN PROCEDURE get_formals_string ****/

static int current_applyOPget_formals_string_own_init = 0;

errcode
current_applyOPget_formals_string(CLUREF *ret_1)
{
    errcode err;
    CLUREF result;
    CLUREF each_d;
    CLUREF each_i;
    if (current_applyOPget_formals_string_own_init == 0) {
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        current_applyOPget_formals_string_own_init = 1;
    }
    enter_proc(462);

  LINE(463);
    {
        {result = CLU_empty_string;
        }
        }

  LINE(464);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = current_applyOPcurr_app.vec->data[7];
        T_1_3.num = T_1_1.vec->size;
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            each_d.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(465);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = each_d.vec->data[0];
                T_2_3.num = T_2_1.vec->size;
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    each_i.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(466);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    err = stringOPconcat(result, STR__137, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = idnOPget_str(each_i, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(T_3_1, T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    result.num = T_3_3.num;
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(469);
    {
    {
    ret_1->num = result.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_formals_string ****/


/**** BEGIN PROCEDURE get_formals ****/


errcode
current_applyOPget_formals(CLUREF *ret_1)
{
    errcode err;
    CLUREF result;
    CLUREF each_d;
    CLUREF each_i;
    if (current_apply_own_init == 0) {
        err = current_apply_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(472);

  LINE(473);
    {
        {CLUREF T_1_1;
        err = arrayOPpredict(CLU_1, CLU_10, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        result.num = T_1_1.num;
        }
        }

  LINE(474);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = current_applyOPcurr_app.vec->data[7];
        T_1_3.num = T_1_1.vec->size;
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            each_d.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(475);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = each_d.vec->data[0];
                T_2_3.num = T_2_1.vec->size;
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    each_i.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(476);
                    {
                    CLUREF T_3_1;
                    err = idnOPget_str(each_i, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    {
                    if ((result.array->int_low + result.array->ext_size + 1) < result.array->int_size) {
                        result.array->store->data[result.array->int_low + result.array->ext_size] = T_3_1.num;
                        result.array->ext_size++; result.array->ext_high++;}
                    else {
                        err = arrayOPaddh(result, T_3_1);
                        if (err != ERR_ok) goto ex_0;}
                    }
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(479);
    {
    {
    ret_1->num = result.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_formals ****/


/**** BEGIN PROCEDURE reset ****/

static int current_applyOPreset_own_init = 0;

errcode
current_applyOPreset()
{
    errcode err;
    if (current_applyOPreset_own_init == 0) {
        if (current_apply_own_init == 0) {
            err = current_apply_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        current_applyOPreset_own_init = 1;
    }
    enter_proc(482);

  LINE(483);
    {
    current_applyOPcurr_app_name = CLU_empty_string;
    }

  LINE(484);
    {
    current_applyOPiterp.tf = false;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE reset ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[12];
} current_apply_OPS;

static CLU_proc current_apply_oe_get = { .proc = current_applyOPget };
static CLU_proc current_apply_oe_get_apply_name = { .proc = current_applyOPget_apply_name };
static CLU_proc current_apply_oe_get_formals = { .proc = current_applyOPget_formals };
static CLU_proc current_apply_oe_get_formals_string = { .proc = current_applyOPget_formals_string };
static CLU_proc current_apply_oe_get_name = { .proc = current_applyOPget_name };
static CLU_proc current_apply_oe_get_short_name = { .proc = current_applyOPget_short_name };
static CLU_proc current_apply_oe_get_val_count = { .proc = current_applyOPget_val_count };
static CLU_proc current_apply_oe_is_iter = { .proc = current_applyOPis_iter };
static CLU_proc current_apply_oe_is_type_own_init = { .proc = current_applyOPis_type_own_init };
static CLU_proc current_apply_oe_parmd = { .proc = current_applyOPparmd };
static CLU_proc current_apply_oe_reset = { .proc = current_applyOPreset };
static CLU_proc current_apply_oe_set = { .proc = current_applyOPset };

static current_apply_OPS current_apply_ops_actual = {12, (OWNPTR)&current_apply_own_init, (OWNPTR)&current_apply_own_init, {
    {&current_apply_oe_get, "get"},
    {&current_apply_oe_get_apply_name, "get_apply_name"},
    {&current_apply_oe_get_formals, "get_formals"},
    {&current_apply_oe_get_formals_string, "get_formals_string"},
    {&current_apply_oe_get_name, "get_name"},
    {&current_apply_oe_get_short_name, "get_short_name"},
    {&current_apply_oe_get_val_count, "get_val_count"},
    {&current_apply_oe_is_iter, "is_iter"},
    {&current_apply_oe_is_type_own_init, "is_type_own_init"},
    {&current_apply_oe_parmd, "parmd"},
    {&current_apply_oe_reset, "reset"},
    {&current_apply_oe_set, "set"}}};

struct OPS *current_apply_ops = (struct OPS *)&current_apply_ops_actual;

/**** END CLUSTER current_apply ****/

/**** BEGIN CLUSTER current_type ****/

static int current_type_own_init = 0;
const OWN_req current_type_ownreqs = { 0, 0 };
CLUREF current_typeOPcurr_typ;
CLUREF current_typeOPcurr_typ_name;
CLUREF current_typeOPown_init_proc;

errcode
current_type_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (current_type_own_init == 0) {
        stringOPcons("_", CLU_1, CLUREF_make_num(1), &STR__137);
        current_type_own_init = 1;
        {
            {current_typeOPcurr_typ_name = CLU_empty_string;
            }
            }
        {
            {current_typeOPown_init_proc.tf = false;
            }
            }
        signal(ERR_ok);
      ex_0:
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE set ****/


errcode
current_typeOPset(CLUREF typ)
{
    errcode err;
    if (current_type_own_init == 0) {
        err = current_type_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(503);

  LINE(504);
    {
    current_typeOPcurr_typ.num = typ.num;
    }

  LINE(505);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = current_typeOPcurr_typ.vec->data[3];
    err = idnOPget_str(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    current_typeOPcurr_typ_name.num = T_1_2.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set ****/


/**** BEGIN PROCEDURE get ****/


errcode
current_typeOPget(CLUREF *ret_1)
{
    errcode err;
    if (current_type_own_init == 0) {
        err = current_type_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(508);

  LINE(509);
    {
    {
    ret_1->num = current_typeOPcurr_typ.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get ****/


/**** BEGIN PROCEDURE exists ****/

static int current_typeOPexists_own_init = 0;

errcode
current_typeOPexists(CLUREF *ret_1)
{
    errcode err;
    if (current_typeOPexists_own_init == 0) {
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        current_typeOPexists_own_init = 1;
    }
    enter_proc(512);

  LINE(513);
    {
    CLUREF T_1_1;
    T_1_1.num = ((current_typeOPcurr_typ_name.str->size != CLU_empty_string.str->size)? false :
        !(memcmp(current_typeOPcurr_typ_name.str->data, CLU_empty_string.str->data, current_typeOPcurr_typ_name.str->size)));
    if (T_1_1.num == true) {
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(514);
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }}/* end if */

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE exists ****/


/**** BEGIN PROCEDURE parmd ****/


errcode
current_typeOPparmd(CLUREF *ret_1)
{
    errcode err;
    if (current_type_own_init == 0) {
        err = current_type_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(517);

  LINE(518);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = current_typeOPcurr_typ.vec->data[7];
    T_1_2.num = T_1_1.vec->size;
    T_1_3.num = (T_1_2.num == 0)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(519);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }}/* end if */

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE parmd ****/


/**** BEGIN PROCEDURE get_formals_string ****/

static int current_typeOPget_formals_string_own_init = 0;

errcode
current_typeOPget_formals_string(CLUREF *ret_1)
{
    errcode err;
    CLUREF result;
    CLUREF each_d;
    CLUREF each_i;
    if (current_typeOPget_formals_string_own_init == 0) {
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        current_typeOPget_formals_string_own_init = 1;
    }
    enter_proc(522);

  LINE(523);
    {
        {result = CLU_empty_string;
        }
        }

  LINE(524);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = current_typeOPcurr_typ.vec->data[7];
        T_1_3.num = T_1_1.vec->size;
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            each_d.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(525);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = each_d.vec->data[0];
                T_2_3.num = T_2_1.vec->size;
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    each_i.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(526);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    err = stringOPconcat(result, STR__137, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = idnOPget_str(each_i, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(T_3_1, T_3_2, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    result.num = T_3_3.num;
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(529);
    {
    {
    ret_1->num = result.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_formals_string ****/


/**** BEGIN PROCEDURE get_formals ****/


errcode
current_typeOPget_formals(CLUREF *ret_1)
{
    errcode err;
    CLUREF result;
    CLUREF each_d;
    CLUREF each_i;
    if (current_type_own_init == 0) {
        err = current_type_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(532);

  LINE(533);
    {
        {CLUREF T_1_1;
        err = arrayOPpredict(CLU_1, CLU_10, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        result.num = T_1_1.num;
        }
        }

  LINE(534);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = current_typeOPcurr_typ.vec->data[7];
        T_1_3.num = T_1_1.vec->size;
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            each_d.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(535);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = each_d.vec->data[0];
                T_2_3.num = T_2_1.vec->size;
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    each_i.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(536);
                    {
                    CLUREF T_3_1;
                    err = idnOPget_str(each_i, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    {
                    if ((result.array->int_low + result.array->ext_size + 1) < result.array->int_size) {
                        result.array->store->data[result.array->int_low + result.array->ext_size] = T_3_1.num;
                        result.array->ext_size++; result.array->ext_high++;}
                    else {
                        err = arrayOPaddh(result, T_3_1);
                        if (err != ERR_ok) goto ex_0;}
                    }
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(539);
    {
    {
    ret_1->num = result.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_formals ****/


/**** BEGIN PROCEDURE get_name ****/


errcode
current_typeOPget_name(CLUREF *ret_1)
{
    errcode err;
    if (current_type_own_init == 0) {
        err = current_type_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(542);

  LINE(543);
    {
    {
    ret_1->num = current_typeOPcurr_typ_name.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_name ****/


/**** BEGIN PROCEDURE set_own_init_proc ****/


errcode
current_typeOPset_own_init_proc(CLUREF generated)
{
    errcode err;
    if (current_type_own_init == 0) {
        err = current_type_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(546);

  LINE(547);
    {
    current_typeOPown_init_proc.num = generated.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_own_init_proc ****/


/**** BEGIN PROCEDURE own_init_proc_exists ****/

static int current_typeOPown_init_proc_exists_own_init = 0;

errcode
current_typeOPown_init_proc_exists(CLUREF *ret_1)
{
    errcode err;
    if (current_typeOPown_init_proc_exists_own_init == 0) {
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        current_typeOPown_init_proc_exists_own_init = 1;
    }
    enter_proc(550);

  LINE(551);
    {
    CLUREF T_1_1;
    T_1_1.num = ((current_typeOPcurr_typ_name.str->size != CLU_empty_string.str->size)? false :
        !(memcmp(current_typeOPcurr_typ_name.str->data, CLU_empty_string.str->data, current_typeOPcurr_typ_name.str->size)));
    if (T_1_1.num == true) {
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(552);
    {
    {
    ret_1->num = current_typeOPown_init_proc.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE own_init_proc_exists ****/


/**** BEGIN PROCEDURE reset ****/

static int current_typeOPreset_own_init = 0;

errcode
current_typeOPreset()
{
    errcode err;
    if (current_typeOPreset_own_init == 0) {
        if (current_type_own_init == 0) {
            err = current_type_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        current_typeOPreset_own_init = 1;
    }
    enter_proc(555);

  LINE(556);
    {
    current_typeOPcurr_typ_name = CLU_empty_string;
    }

  LINE(557);
    {
    current_typeOPown_init_proc.tf = false;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE reset ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[10];
} current_type_OPS;

static CLU_proc current_type_oe_exists = { .proc = current_typeOPexists };
static CLU_proc current_type_oe_get = { .proc = current_typeOPget };
static CLU_proc current_type_oe_get_formals = { .proc = current_typeOPget_formals };
static CLU_proc current_type_oe_get_formals_string = { .proc = current_typeOPget_formals_string };
static CLU_proc current_type_oe_get_name = { .proc = current_typeOPget_name };
static CLU_proc current_type_oe_own_init_proc_exists = { .proc = current_typeOPown_init_proc_exists };
static CLU_proc current_type_oe_parmd = { .proc = current_typeOPparmd };
static CLU_proc current_type_oe_reset = { .proc = current_typeOPreset };
static CLU_proc current_type_oe_set = { .proc = current_typeOPset };
static CLU_proc current_type_oe_set_own_init_proc = { .proc = current_typeOPset_own_init_proc };

static current_type_OPS current_type_ops_actual = {10, (OWNPTR)&current_type_own_init, (OWNPTR)&current_type_own_init, {
    {&current_type_oe_exists, "exists"},
    {&current_type_oe_get, "get"},
    {&current_type_oe_get_formals, "get_formals"},
    {&current_type_oe_get_formals_string, "get_formals_string"},
    {&current_type_oe_get_name, "get_name"},
    {&current_type_oe_own_init_proc_exists, "own_init_proc_exists"},
    {&current_type_oe_parmd, "parmd"},
    {&current_type_oe_reset, "reset"},
    {&current_type_oe_set, "set"},
    {&current_type_oe_set_own_init_proc, "set_own_init_proc"}}};

struct OPS *current_type_ops = (struct OPS *)&current_type_ops_actual;

/**** END CLUSTER current_type ****/

/**** BEGIN CLUSTER owns ****/

extern errcode idnOPequal();
static int owns_own_init = 0;
const OWN_req owns_ownreqs = { 0, 0 };
CLUREF ownsOPcurrent_owns;

errcode
owns_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (owns_own_init == 0) {
        owns_own_init = 1;
        {
            {CLUREF T_0_1;
            err = sequenceOPnew(&T_0_1);
            if (err != ERR_ok) goto ex_0;
            ownsOPcurrent_owns.num = T_0_1.num;
            }
            }
        signal(ERR_ok);
      ex_0:
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE save ****/


errcode
ownsOPsave(CLUREF ilist)
{
    errcode err;
    CLUREF each_i;
    if (owns_own_init == 0) {
        err = owns_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(567);

  LINE(569);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = ilist.vec->size;
        T_1_3 = ilist;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            each_i.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(570);
            {
            CLUREF T_2_1;
            err = sequenceOPaddh(ownsOPcurrent_owns, each_i, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ownsOPcurrent_owns.num = T_2_1.num;
            }
        }
    }
    end_inline_for_1:;

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE save ****/


/**** BEGIN PROCEDURE forget ****/


errcode
ownsOPforget()
{
    errcode err;
    if (owns_own_init == 0) {
        err = owns_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(575);

  LINE(577);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    ownsOPcurrent_owns.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE forget ****/


/**** BEGIN PROCEDURE member ****/


errcode
ownsOPmember(CLUREF i, CLUREF *ret_1)
{
    errcode err;
    CLUREF this_init;
    CLUREF d;
    CLUREF this_idn;
    CLUREF di;
    CLUREF this_decl;
    if (owns_own_init == 0) {
        err = owns_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(581);

  LINE(582);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = ownsOPcurrent_owns.vec->size;
        T_1_3 = ownsOPcurrent_owns;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            this_init.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(583);
            {
            CLUREF T_2_1;
            T_2_1.num = this_init.vec->data[1];
            switch (T_2_1.cell->tag) {
            case 1:
                 {CLUREF T_2_2;
                T_2_2.num = T_2_1.cell->value;
                d.num = T_2_2.num;

  LINE(585);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = d.vec->data[0];
                        T_3_3.num = T_3_1.vec->size;
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            this_idn.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(586);
                            {
                            CLUREF T_4_1;
                            err = idnOPequal(this_idn, i, &T_4_1);
                            if (err != ERR_ok) goto ex_0;
                            if (T_4_1.num == true) {
                                {
                                {
                                ret_1->tf = true;
                                }
                                {signal (ERR_ok);}}
                                }
                                }/* end if */
                        }
                    }
                    end_inline_for_2:;
                    break;
                    }
            case 2:
                 {CLUREF T_2_3;
                T_2_3.num = T_2_1.cell->value;
                di.num = T_2_3.num;

  LINE(589);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                        T_3_1.num = di.vec->data[1];
                        T_3_3.num = T_3_1.vec->size;
                        T_3_4 = T_3_1;
                        for (T_3_2.num = 1; T_3_2.num <= T_3_3.num; T_3_2.num++) {
                            this_decl.num = T_3_4.vec->data[T_3_2.num - 1];

  LINE(590);
                            {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            CLUREF T_4_4;
                                T_4_1.num = this_decl.vec->data[0];
                                T_4_3.num = T_4_1.vec->size;
                                T_4_4 = T_4_1;
                                for (T_4_2.num = 1; T_4_2.num <= T_4_3.num; T_4_2.num++) {
                                    this_idn.num = T_4_4.vec->data[T_4_2.num - 1];

  LINE(591);
                                    {
                                    CLUREF T_5_1;
                                    err = idnOPequal(this_idn, i, &T_5_1);
                                    if (err != ERR_ok) goto ex_0;
                                    if (T_5_1.num == true) {
                                        {
                                        {
                                        ret_1->tf = true;
                                        }
                                        {signal (ERR_ok);}}
                                        }
                                        }/* end if */
                                }
                            }
                            end_inline_for_4:;
                        }
                    }
                    end_inline_for_3:;
                    break;
                    }
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(596);
    {
    {
    ret_1->tf = false;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE member ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[3];
} owns_OPS;

static CLU_proc owns_oe_forget = { .proc = ownsOPforget };
static CLU_proc owns_oe_member = { .proc = ownsOPmember };
static CLU_proc owns_oe_save = { .proc = ownsOPsave };

static owns_OPS owns_ops_actual = {3, (OWNPTR)&owns_own_init, (OWNPTR)&owns_own_init, {
    {&owns_oe_forget, "forget"},
    {&owns_oe_member, "member"},
    {&owns_oe_save, "save"}}};

struct OPS *owns_ops = (struct OPS *)&owns_ops_actual;

/**** END CLUSTER owns ****/
