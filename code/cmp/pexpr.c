
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


extern errcode p_expr0();
extern errcode p_envOPassume();
extern errcode p_envOPget_bad_expr();
CLUREF STR_expression;
static int p_expr1_own_init = 0;

/**** BEGIN PROCEDURE p_expr1 ****/

errcode p_expr1(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (p_expr1_own_init == 0) {
        stringOPcons("expression", CLU_1, CLU_10, &STR_expression);
        p_expr1_own_init = 1;
    }
    enter_proc(6);

  LINE(7);
    {
    {
    CLUREF T_2_1;
    err = p_expr0(e, CLU_0, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    ret_1->num = T_2_1.num;
    }
    {signal (ERR_ok);}}
        goto end_1;
        ex_1:
            if ((err == ERR_none)) {

  LINE(8);
                {
                err = p_envOPassume(e, STR_expression);
                if (err != ERR_ok) goto ex_0;
                }
            }
            else if ((err == ERR_bad)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(11);
    {
    {
    CLUREF T_1_1;
    err = p_envOPget_bad_expr(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_expr1 ****/



/**** BEGIN PROCEDURE p_expr ****/

errcode p_expr(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    enter_proc(14);

  LINE(15);
    {
    {
    CLUREF T_2_1;
    err = p_expr0(e, CLU_0, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    ret_1->num = T_2_1.num;
    }
    {signal (ERR_ok);}}
    goto end_1;
    ex_1:
        if (err == ERR_none) {signal(ERR_none);}
        else if (err == ERR_bad) {signal(ERR_bad);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_expr ****/


extern errcode p_prim();
extern errcode p_envOPget_peek1();
extern errcode structOPget_3();
extern errcode structOPget_2();
extern errcode structOPget_1();
extern errcode intOPgt();
extern errcode intOPequal();
extern errcode p_envOPnext_token();
extern errcode stringOPequal();
extern errcode oneofOPmake_6();
extern errcode oneofOPmake_8();
extern errcode oneofOPmake_14();
extern errcode exprOPcreate();
extern errcode p_envOPget_unknown_type();
CLUREF STR_expression_040after_040binary_040operator;
CLUREF STR_cand;
CLUREF STR_cor;
static int p_expr0_own_init = 0;

/**** BEGIN PROCEDURE p_expr0 ****/

errcode p_expr0(e, level, ret_1)
CLUREF e;
CLUREF level;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF left;
    CLUREF prec;
    CLUREF op;
    CLUREF neg;
    CLUREF k;
    CLUREF right;
    CLUREF abs;
        if (p_expr0_own_init == 0) {
        stringOPcons("expression after binary operator", CLU_1, CLU_32, &STR_expression_040after_040binary_040operator);
        stringOPcons("cand", CLU_1, CLU_4, &STR_cand);
        stringOPcons("cor", CLU_1, CLU_3, &STR_cor);
        p_expr0_own_init = 1;
    }
    enter_proc(23);

  LINE(24);
    {
        {CLUREF T_2_1;
        err = p_prim(e, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        left.num = T_2_1.num;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_none) {signal(ERR_none);}
        else {
            goto ex_0;}
    end_1:;

  LINE(26);
    for (;;) {
        if (true != true) { break; }

  LINE(30);
        {
        CLUREF T_2_1;
        err = p_envOPget_peek1(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_1.cell->tag) {
        case 23: 
        case 11: 
             {CLUREF T_2_2;
            T_2_2.num = T_2_1.cell->value;
            k.num = T_2_2.num;

  LINE(32);
                {
                CLUREF T_3_1;
                T_3_1.num = k.vec->data[2];
                prec.num = T_3_1.num;
                }

  LINE(33);
                {
                CLUREF T_3_1;
                T_3_1.num = k.vec->data[1];
                op.num = T_3_1.num;
                }

  LINE(34);
                {
                CLUREF T_3_1;
                T_3_1.num = k.vec->data[0];
                neg.num = T_3_1.num;
                }
                break;
                }
        default: {

  LINE(36);
            {
            {
            ret_1->num = left.num;
            }
            {signal (ERR_ok);}}
        }
        }
        }

  LINE(38);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_2.num = (prec.num > level.num)? true : false;
        T_2_1.num = T_2_2.num;
        if (!T_2_2.num) {
            T_2_3.num = (prec.num == 6)? true : false;
            T_2_1.num = T_2_3.num;
        }
        if (T_2_1.num == true) {

  LINE(39);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            }
            }
        else {

  LINE(40);
            {
            {
            ret_1->num = left.num;
            }
            {signal (ERR_ok);}}
            }}/* end if */

  LINE(42);
        {
            {CLUREF T_3_1;
            err = p_expr0(e, prec, &T_3_1);
            if (err != ERR_ok) goto ex_2;
            right.num = T_3_1.num;
            }
            }
            goto end_2;
            ex_2:
                if ((err == ERR_none)) {

  LINE(43);
                    {
                    err = p_envOPassume(e, STR_expression_040after_040binary_040operator);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(45);
                    {
                    CLUREF T_3_1;
                    err = p_envOPget_bad_expr(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    right.num = T_3_1.num;
                    }
                }
                else if ((err == ERR_bad)) {

  LINE(46);
                    {
                    CLUREF T_3_1;
                    err = p_envOPget_bad_expr(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    right.num = T_3_1.num;
                    }
                }
                else {
                    goto ex_0;
                }
            end_2:;

  LINE(49);
        {
        CLUREF T_2_1;
        T_2_1.num = ((op.str->size != STR_cand.str->size)? false :
            !(bcmp(op.str->data, STR_cand.str->data, op.str->size)));
        if (T_2_1.num == true) {

  LINE(50);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            RecordAlloc(2, T_3_1);
            T_3_1.vec->data[0]  = left.num;
            T_3_1.vec->data[1]  = right.num;
            CellAlloc(6, T_3_1.num, T_3_2);
            abs.num = T_3_2.num;
            }
            }
        else {
        CLUREF T_2_2;
        T_2_2.num = ((op.str->size != STR_cor.str->size)? false :
            !(bcmp(op.str->data, STR_cor.str->data, op.str->size)));
        if (T_2_2.num == true) {

  LINE(53);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            RecordAlloc(2, T_3_1);
            T_3_1.vec->data[0]  = left.num;
            T_3_1.vec->data[1]  = right.num;
            CellAlloc(8, T_3_1.num, T_3_2);
            abs.num = T_3_2.num;
            }
            }
        else {

  LINE(55);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            RecordAlloc(4, T_3_1);
            T_3_1.vec->data[0]  = left.num;
            T_3_1.vec->data[2]  = op.num;
            T_3_1.vec->data[1]  = neg.num;
            T_3_1.vec->data[3]  = right.num;
            CellAlloc(14, T_3_1.num, T_3_2);
            abs.num = T_3_2.num;
            }
            }}}/* end if */

  LINE(60);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = p_envOPget_unknown_type(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = exprOPcreate(abs, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        left.num = T_2_2.num;
        }
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_expr0 ****/


extern errcode p_idn_primary();
extern errcode p_type_primary();
extern errcode p_type();
extern errcode oneofOPmake_11();
extern errcode p_force();
extern errcode oneofOPmake_26();
extern errcode p_pexpr();
extern errcode oneofOPmake_27();
extern errcode oneofOPmake_9();
extern errcode oneofOPmake_18();
extern errcode boolOPnot();
extern errcode oneofOPmake_17();
extern errcode p_more_primary();
CLUREF STR_sub;
CLUREF STR_expression_040before_040binary_040operator;
CLUREF STR_expression_040after_040unary_040operator;
static int p_prim_own_init = 0;

/**** BEGIN PROCEDURE p_prim ****/

errcode p_prim(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF abs;
    CLUREF k;
        if (p_prim_own_init == 0) {
        stringOPcons("sub", CLU_1, CLU_3, &STR_sub);
        stringOPcons("expression before binary operator", CLU_1, CLU_33, &STR_expression_040before_040binary_040operator);
        stringOPcons("expression after unary operator", CLU_1, CLU_31, &STR_expression_040after_040unary_040operator);
        p_prim_own_init = 1;
    }
    enter_proc(70);

  LINE(72);
    {
    CLUREF T_2_1;
    err = p_envOPget_peek1(e, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    switch (T_2_1.cell->tag) {
    case 16: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        k.num = T_2_2.num;

  LINE(74);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(75);
            {
            CLUREF T_3_1;
            err = p_idn_primary(e, k, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            abs.num = T_3_1.num;
            }
            break;
            }
    case 37: 
    case 38: 
         {

  LINE(77);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = p_type(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            err = p_type_primary(e, T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            abs.num = T_3_2.num;
            }
            break;
            }
    case 13: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        k.num = T_2_3.num;

  LINE(79);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(80);
            {
            abs.num = k.num;
            }
            break;
            }
    case 14: 
         {CLUREF T_2_4;
        T_2_4.num = T_2_1.cell->value;
        k.num = T_2_4.num;

  LINE(82);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(83);
            {
            switch (k.cell->tag) {
            case 2: 
                 {

  LINE(84);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    err = p_force(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    CellAlloc(11, T_4_1.num, T_4_2);
                    abs.num = T_4_2.num;
                    }
                    break;
                    }
            case 3: 
                 {

  LINE(85);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    err = p_pexpr(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    CellAlloc(26, T_4_1.num, T_4_2);
                    abs.num = T_4_2.num;
                    }
                    break;
                    }
            case 4: 
                 {

  LINE(86);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    err = p_pexpr(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    CellAlloc(27, T_4_1.num, T_4_2);
                    abs.num = T_4_2.num;
                    }
                    break;
                    }
            case 1: 
                 {

  LINE(87);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    err = p_pexpr(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    CellAlloc(9, T_4_1.num, T_4_2);
                    abs.num = T_4_2.num;
                    }
                    break;
                    }
            }
            }
            break;
            }
    case 21: 
         {

  LINE(90);
            {
            {
            CLUREF T_3_1;
            err = p_pexpr(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 22: 
         {

  LINE(92);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(93);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            err = p_prim(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            CellAlloc(18, T_3_1.num, T_3_2);
            err = p_envOPget_unknown_type(e, &T_3_3);
            if (err != ERR_ok) goto ex_1;
            err = exprOPcreate(T_3_2, T_3_3, &T_3_4);
            if (err != ERR_ok) goto ex_1;
            ret_1->num = T_3_4.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 23: 
    case 11: 
         {CLUREF T_2_5;
        T_2_5.num = T_2_1.cell->value;
        k.num = T_2_5.num;

  LINE(95);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            T_3_2.num = k.vec->data[1];
            T_3_3.num = ((STR_sub.str->size != T_3_2.str->size)? false :
                !(bcmp(STR_sub.str->data, T_3_2.str->data, STR_sub.str->size)));
            T_3_4.num = T_3_3.num ^ 1;
            T_3_1.num = T_3_4.num;
            if (!T_3_4.num) {
                T_3_5.num = k.vec->data[0];
                T_3_1.num = T_3_5.num;
            }
            if (T_3_1.num == true) {

  LINE(96);
                {
                err = p_envOPassume(e, STR_expression_040before_040binary_040operator);
                if (err != ERR_ok) goto ex_1;
                }

  LINE(97);
                {
                {
                CLUREF T_4_1;
                err = p_envOPget_bad_expr(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                ret_1->num = T_4_1.num;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */

  LINE(99);
            {
            CLUREF T_3_1;
            err = p_envOPnext_token(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(100);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            err = p_prim(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            CellAlloc(17, T_3_1.num, T_3_2);
            err = p_envOPget_unknown_type(e, &T_3_3);
            if (err != ERR_ok) goto ex_1;
            err = exprOPcreate(T_3_2, T_3_3, &T_3_4);
            if (err != ERR_ok) goto ex_1;
            ret_1->num = T_3_4.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(102);
        {
        {signal (ERR_none);}}
    }
    }
    }
        goto end_1;
        ex_1:
            if ((err == ERR_none)) {

  LINE(104);
                {
                err = p_envOPassume(e, STR_expression_040after_040unary_040operator);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(105);
                {
                {
                CLUREF T_2_1;
                err = p_envOPget_bad_expr(e, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                ret_1->num = T_2_1.num;
                }
                {signal (ERR_ok);}}
            }
            else if ((err == ERR_bad)) {

  LINE(106);
                {
                {
                CLUREF T_2_1;
                err = p_envOPget_bad_expr(e, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                ret_1->num = T_2_1.num;
                }
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(108);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = p_envOPget_unknown_type(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = exprOPcreate(abs, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = p_more_primary(e, T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_3.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_prim ****/


extern errcode p_is_seltype();
extern errcode p_fieldspeclist();
extern errcode typespecOPcreate();
extern errcode p_blist();
extern errcode p_expr();
extern errcode oneofOPmake_10();
extern errcode oneofOPmake_22();
extern errcode oneofOPmake_5();
extern errcode oneofOPmake_13();
extern errcode oneofOPmake_4();
extern struct REQS *p_blist_of_t_reqs;
extern struct OPS *expr_ops;
extern OWN_req p_blist_ownreqs;
struct OPS *p_blist_of_expr_table;
struct OPS *p_blist_of_expr_ops;
struct OPS *p_blist_of_expr_ops;
OWNPTR p_blist_of_expr_owns;
CLUREF STR_constant;
static int p_idn_primary_own_init = 0;

/**** BEGIN PROCEDURE p_idn_primary ****/

errcode p_idn_primary(e, id, ret_1)
CLUREF e;
CLUREF id;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF parms;
    CLUREF ta;
        if (p_idn_primary_own_init == 0) {
        add_parm_info_type(0, expr_ops, p_blist_of_t_reqs);
        find_prociter_instance(p_blist, 1, &p_blist_ownreqs, &(p_blist_of_expr_ops));
        stringOPcons("constant", CLU_1, CLU_8, &STR_constant);
        p_idn_primary_own_init = 1;
    }
    enter_proc(111);

  LINE(112);
    {
    CLUREF T_2_1;
    err = p_envOPget_peek1(e, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    switch (T_2_1.cell->tag) {
    case 19: 
         {

  LINE(114);
            {
            CLUREF T_3_1;
            err = p_is_seltype(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            if (T_3_1.num == true) {

  LINE(115);
                {
                    {CLUREF T_4_1;
                    err = p_fieldspeclist(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    parms.num = T_4_1.num;
                    }
                    }

  LINE(116);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    RecordAlloc(2, T_4_1);
                    T_4_1.vec->data[0]  = id.num;
                    T_4_1.vec->data[1]  = parms.num;
                    CellAlloc(11, T_4_1.num, T_4_2);
                    ta.num = T_4_2.num;
                    }
                    }

  LINE(119);
                {
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                err = typespecOPcreate(ta, CLU_0, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                err = p_type_primary(e, T_4_1, &T_4_2);
                if (err != ERR_ok) goto ex_1;
                ret_1->num = T_4_2.num;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */

  LINE(121);
            {
                {CLUREF T_3_1;
                CLUREF T_3_2;
                err = proctypeOPnew(CLU_0, &T_3_1.proc);
                if (err!= ERR_ok) goto ex_1;
                T_3_1.proc->type_owns = 0;
                T_3_1.proc->op_owns = 0;
                T_3_1.proc->proc = p_expr;
                generic_CLU_proc.type_owns = 0;
                generic_CLU_proc.op_owns = (long)p_blist_of_expr_ops->op_owns;
                generic_CLU_proc.proc = p_blist;
                CUR_PROC_VAR.proc = &generic_CLU_proc;
                err = p_blist(e, T_3_1, CLU_1, STR_constant, &T_3_2);
                if (err != ERR_ok) goto ex_1;
                parms.num = T_3_2.num;
                }
                }

  LINE(123);
            {
            CLUREF T_3_1;
            err = p_envOPget_peek1(e, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            switch (T_3_1.cell->tag) {
            case 6: 
                 {

  LINE(125);
                    {
                        {CLUREF T_4_1;
                        CLUREF T_4_2;
                        RecordAlloc(2, T_4_1);
                        T_4_1.vec->data[0]  = id.num;
                        T_4_1.vec->data[1]  = parms.num;
                        CellAlloc(10, T_4_1.num, T_4_2);
                        ta.num = T_4_2.num;
                        }
                        }

  LINE(128);
                    {
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    err = typespecOPcreate(ta, CLU_0, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    err = p_type_primary(e, T_4_1, &T_4_2);
                    if (err != ERR_ok) goto ex_1;
                    ret_1->num = T_4_2.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            default: {

  LINE(130);
                {
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                RecordAlloc(2, T_4_1);
                T_4_1.vec->data[0]  = id.num;
                T_4_1.vec->data[1]  = parms.num;
                CellAlloc(22, T_4_1.num, T_4_2);
                ret_1->num = T_4_2.num;
                }
                {signal (ERR_ok);}}
            }
            }
            }
            break;
            }
    case 6: 
         {

  LINE(134);
            {
                {CLUREF T_3_1;
                CellAlloc(5, id.num, T_3_1);
                ta.num = T_3_1.num;
                }
                }

  LINE(135);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = typespecOPcreate(ta, CLU_0, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            err = p_type_primary(e, T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            ret_1->num = T_3_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(137);
        {
        {
        CLUREF T_3_1;
        CellAlloc(13, id.num, T_3_1);
        ret_1->num = T_3_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }
        goto end_1;
        ex_1:
            if ((err == ERR_bad)) {

  LINE(138);
                {
                {
                CLUREF T_2_1;
                CellAlloc(4, nil, T_2_1);
                ret_1->num = T_2_1.num;
                }
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_idn_primary ****/


extern errcode oneofOPmake_25();
extern errcode p_s_cons();
extern errcode p_a_cons();
extern errcode oneofOPmake_20();
extern errcode idnOPget_str();
struct OPS *p_blist_of_expr_table;
struct OPS *p_blist_of_expr_ops;
struct OPS *p_blist_of_expr_ops;
OWNPTR p_blist_of_expr_owns;
CLUREF STR_constructor_040or_040name_040after_040type_137spec_044;
static int p_type_primary_own_init = 0;

/**** BEGIN PROCEDURE p_type_primary ****/

errcode p_type_primary(e, t, ret_1)
CLUREF e;
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF k;
    CLUREF parms;
        if (p_type_primary_own_init == 0) {
        add_parm_info_type(0, expr_ops, p_blist_of_t_reqs);
        find_prociter_instance(p_blist, 1, &p_blist_ownreqs, &(p_blist_of_expr_ops));
        stringOPcons("constant", CLU_1, CLU_8, &STR_constant);
        stringOPcons("constructor or name after type_spec$", CLU_1, CLU_36, &STR_constructor_040or_040name_040after_040type_137spec_044);
        p_type_primary_own_init = 1;
    }
    enter_proc(144);

  LINE(145);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 6: 
         {

  LINE(146);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(147);
        {
        {
        CLUREF T_2_1;
        CellAlloc(25, t.num, T_2_1);
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(149);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 20: 
         {

  LINE(151);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(152);
            {
            {
            CLUREF T_2_1;
            err = p_s_cons(e, t, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 19: 
         {

  LINE(154);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(155);
            {
            {
            CLUREF T_2_1;
            err = p_a_cons(e, t, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 16: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(157);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(158);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                err = proctypeOPnew(CLU_0, &T_2_1.proc);
                if (err!= ERR_ok) goto ex_0;
                T_2_1.proc->type_owns = 0;
                T_2_1.proc->op_owns = 0;
                T_2_1.proc->proc = p_expr;
                generic_CLU_proc.type_owns = 0;
                generic_CLU_proc.op_owns = (long)p_blist_of_expr_ops->op_owns;
                generic_CLU_proc.proc = p_blist;
                CUR_PROC_VAR.proc = &generic_CLU_proc;
                err = p_blist(e, T_2_1, CLU_1, STR_constant, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                parms.num = T_2_2.num;
                }
                }

  LINE(160);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            RecordAlloc(3, T_2_1);
            T_2_1.vec->data[2]  = t.num;
            err = idnOPget_str(k, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            T_2_1.vec->data[0]  = T_2_2.num;
            T_2_1.vec->data[1]  = parms.num;
            CellAlloc(20, T_2_1.num, T_2_3);
            ret_1->num = T_2_3.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(164);
        {
        err = p_envOPassume(e, STR_constructor_040or_040name_040after_040type_137spec_044);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(165);
        {
        {signal (ERR_bad);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_type_primary ****/


extern errcode p_name();
extern errcode oneofOPmake_12();
extern errcode p_expr1();
extern errcode p_plist();
extern errcode oneofOPmake_16();
extern errcode p_envOPerr();
extern errcode exprOPget_abs();
extern struct REQS *p_plist_of_t_reqs;
extern OWN_req p_plist_ownreqs;
struct OPS *p_plist_of_expr_table;
struct OPS *p_plist_of_expr_ops;
struct OPS *p_plist_of_expr_ops;
OWNPTR p_plist_of_expr_owns;
CLUREF STR__135_040in_040primary_133expression_135;
CLUREF STR_missing_040name_040_055_040_047_056_047_040ignored;
static int p_more_primary_own_init = 0;

/**** BEGIN PROCEDURE p_more_primary ****/

errcode p_more_primary(e, x, ret_1)
CLUREF e;
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF abs;
    CLUREF n;
    CLUREF index;
    CLUREF args;
        if (p_more_primary_own_init == 0) {
        add_parm_info_type(0, expr_ops, p_plist_of_t_reqs);
        find_prociter_instance(p_plist, 1, &p_plist_ownreqs, &(p_plist_of_expr_ops));
        stringOPcons("] in primary[expression]", CLU_1, CLU_24, &STR__135_040in_040primary_133expression_135);
        stringOPcons("expression", CLU_1, CLU_10, &STR_expression);
        stringOPcons("missing name - \'.\' ignored", CLU_1, CLU_26, &STR_missing_040name_040_055_040_047_056_047_040ignored);
        p_more_primary_own_init = 1;
    }
    enter_proc(173);

  LINE(174);
    for (;;) {
        if (true != true) { break; }

  LINE(176);
        {
        CLUREF T_3_1;
        err = p_envOPget_peek1(e, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        switch (T_3_1.cell->tag) {
        case 25: 
             {

  LINE(178);
                {
                CLUREF T_4_1;
                err = p_envOPnext_token(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                }

  LINE(179);
                {
                    {CLUREF T_4_1;
                    err = p_name(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    n.num = T_4_1.num;
                    }
                    }

  LINE(180);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                RecordAlloc(2, T_4_1);
                T_4_1.vec->data[0]  = x.num;
                T_4_1.vec->data[1]  = n.num;
                CellAlloc(12, T_4_1.num, T_4_2);
                abs.num = T_4_2.num;
                }
                break;
                }
        case 19: 
             {

  LINE(183);
                {
                CLUREF T_4_1;
                err = p_envOPnext_token(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                }

  LINE(184);
                {
                    {CLUREF T_4_1;
                    err = p_expr1(e, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    index.num = T_4_1.num;
                    }
                    }

  LINE(185);
                {
                CLUREF T_4_1;
                err = p_envOPget_peek1(e, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                switch (T_4_1.cell->tag) {
                case 26: 
                     {

  LINE(186);
                        {
                        CLUREF T_5_1;
                        err = p_envOPnext_token(e, &T_5_1);
                        if (err != ERR_ok) goto ex_1;
                        }
                        break;
                        }
                default: {

  LINE(187);
                    {
                    err = p_envOPassume(e, STR__135_040in_040primary_133expression_135);
                    if (err != ERR_ok) goto ex_1;
                    }
                }
                }
                }

  LINE(189);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                RecordAlloc(2, T_4_1);
                T_4_1.vec->data[1]  = x.num;
                T_4_1.vec->data[0]  = index.num;
                CellAlloc(10, T_4_1.num, T_4_2);
                abs.num = T_4_2.num;
                }
                break;
                }
        case 21: 
             {

  LINE(192);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    err = proctypeOPnew(CLU_0, &T_4_1.proc);
                    if (err!= ERR_ok) goto ex_1;
                    T_4_1.proc->type_owns = 0;
                    T_4_1.proc->op_owns = 0;
                    T_4_1.proc->proc = p_expr;
                    generic_CLU_proc.type_owns = 0;
                    generic_CLU_proc.op_owns = (long)p_plist_of_expr_ops->op_owns;
                    generic_CLU_proc.proc = p_plist;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = p_plist(e, T_4_1, CLU_0, CLU_1, STR_expression, &T_4_2);
                    if (err != ERR_ok) goto ex_1;
                    args.num = T_4_2.num;
                    }
                    }

  LINE(194);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                RecordAlloc(2, T_4_1);
                T_4_1.vec->data[0]  = x.num;
                T_4_1.vec->data[1]  = args.num;
                CellAlloc(16, T_4_1.num, T_4_2);
                abs.num = T_4_2.num;
                }
                break;
                }
        default: {

  LINE(196);
            {
            {
            ret_1->num = x.num;
            }
            {signal (ERR_ok);}}
        }
        }
        }
            goto end_1;
            ex_1:
                if ((err == ERR_none)) {

  LINE(198);
                    {
                    err = p_envOPerr(e, STR_missing_040name_040_055_040_047_056_047_040ignored, CLU_1);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(200);
                    {
                    CLUREF T_3_1;
                    err = exprOPget_abs(x, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    abs.num = T_3_1.num;
                    }
                }
                else {
                    goto ex_0;
                }
            end_1:;

  LINE(202);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = p_envOPget_unknown_type(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = exprOPcreate(abs, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        x.num = T_2_2.num;
        }
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_more_primary ****/


extern errcode p_clist();
extern errcode p_field();
extern errcode oneofOPmake_23();
extern struct REQS *sequence_of_t_reqs;
extern struct OPS *string_ops;
extern OWN_req sequence_ownreqs;
extern struct OPS *sequence_ops;
struct OPS *sequence_of_string_table;
struct OPS *sequence_of_string_ops;
struct OPS *sequence_of_string_ops;
OWNPTR sequence_of_string_owns;
extern struct OPS *int_ops;
extern struct OPS *sequence_of_string_ops;
struct OPS  *record_line_sels_val_ops;
extern struct REQS *p_clist_of_t_reqs;
extern struct OPS *record_line_sels_val_ops;
extern OWN_req p_clist_ownreqs;
struct OPS *p_clist_of_record_line_sels_val_table;
struct OPS *p_clist_of_record_line_sels_val_ops;
struct OPS *p_clist_of_record_line_sels_val_ops;
OWNPTR p_clist_of_record_line_sels_val_owns;
CLUREF STR_field;
CLUREF STR__175_040in_040constructor;
static int p_s_cons_own_init = 0;

/**** BEGIN PROCEDURE p_s_cons ****/

errcode p_s_cons(e, t, ret_1)
CLUREF e;
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF fields;
    CLUREF abs;
        if (p_s_cons_own_init == 0) {
        add_parm_info_type(0, string_ops, sequence_of_t_reqs);
        find_type_instance(sequence_ops, 1, &sequence_ownreqs, &(sequence_of_string_ops));
        add_selector_info("line", 0, int_ops); 
        add_selector_info("sels", 1, sequence_of_string_ops); 
        add_selector_info("val", 2, expr_ops); 
        find_selector_ops("record", 3, &(record_line_sels_val_ops));
        add_parm_info_type(0, record_line_sels_val_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_record_line_sels_val_ops));
        stringOPcons("field", CLU_1, CLU_5, &STR_field);
        stringOPcons("} in constructor", CLU_1, CLU_16, &STR__175_040in_040constructor);
        p_s_cons_own_init = 1;
    }
    enter_proc(211);

  LINE(212);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_field;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_clist_of_record_line_sels_val_ops->op_owns;
        generic_CLU_proc.proc = p_clist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_clist(e, T_1_1, STR_field, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        fields.num = T_1_2.num;
        }
        }

  LINE(213);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        RecordAlloc(2, T_1_1);
        T_1_1.vec->data[1]  = t.num;
        T_1_1.vec->data[0]  = fields.num;
        CellAlloc(23, T_1_1.num, T_1_2);
        abs.num = T_1_2.num;
        }
        }

  LINE(215);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 27: 
         {

  LINE(216);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(217);
        {
        err = p_envOPassume(e, STR__175_040in_040constructor);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(219);
    {
    {
    ret_1->num = abs.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_s_cons ****/


extern errcode p_envOPget_line();
struct OPS *p_clist_of_string_table;
struct OPS *p_clist_of_string_ops;
struct OPS *p_clist_of_string_ops;
OWNPTR p_clist_of_string_owns;
CLUREF STR_name;
CLUREF STR__072_040expression_040in_040field_040of_040constructor;
static int p_field_own_init = 0;

/**** BEGIN PROCEDURE p_field ****/

errcode p_field(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF sels;
    CLUREF line;
    CLUREF val;
        if (p_field_own_init == 0) {
        add_parm_info_type(0, string_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_string_ops));
        stringOPcons("name", CLU_1, CLU_4, &STR_name);
        stringOPcons(": expression in field of constructor", CLU_1, CLU_36, &STR__072_040expression_040in_040field_040of_040constructor);
        p_field_own_init = 1;
    }
    enter_proc(222);

  LINE(223);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 16: 
         {
            break;
            }
    default: {

  LINE(225);
        {
        {signal (ERR_none);}}
    }
    }
    }

  LINE(227);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = proctypeOPnew(CLU_0, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->type_owns = 0;
        T_1_1.proc->op_owns = 0;
        T_1_1.proc->proc = p_name;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = (long)p_clist_of_string_ops->op_owns;
        generic_CLU_proc.proc = p_clist;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = p_clist(e, T_1_1, STR_name, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        sels.num = T_1_2.num;
        }
        }

  LINE(228);
    {
        {CLUREF T_1_1;
        err = p_envOPget_line(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        line.num = T_1_1.num;
        }
        }

  LINE(230);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: 
         {

  LINE(231);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(232);
            {
            CLUREF T_2_1;
            err = p_expr1(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            val.num = T_2_1.num;
            }
            break;
            }
    default: {

  LINE(233);
        {
        err = p_envOPassume(e, STR__072_040expression_040in_040field_040of_040constructor);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(234);
        {
        CLUREF T_2_1;
        err = p_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        val.num = T_2_1.num;
        }
    }
    }
    }

  LINE(236);
    {
    {
    CLUREF T_1_1;
    RecordAlloc(3, T_1_1);
    T_1_1.vec->data[1]  = sels.num;
    T_1_1.vec->data[2]  = val.num;
    T_1_1.vec->data[0]  = line.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_field ****/


extern errcode oneofOPmake_1();
extern errcode sequenceOPnew();
extern errcode oneofOPmake_2();
extern errcode sequenceOPaddl();
struct OPS *p_clist_of_expr_table;
struct OPS *p_clist_of_expr_ops;
struct OPS *p_clist_of_expr_ops;
OWNPTR p_clist_of_expr_owns;
CLUREF STR__135_040in_040constructor;
static int p_a_cons_own_init = 0;

/**** BEGIN PROCEDURE p_a_cons ****/

errcode p_a_cons(e, t, ret_1)
CLUREF e;
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF x;
    CLUREF low;
    CLUREF elts;
        if (p_a_cons_own_init == 0) {
        add_parm_info_type(0, expr_ops, p_clist_of_t_reqs);
        find_prociter_instance(p_clist, 1, &p_clist_ownreqs, &(p_clist_of_expr_ops));
        stringOPcons("expression", CLU_1, CLU_10, &STR_expression);
        stringOPcons("] in constructor", CLU_1, CLU_16, &STR__135_040in_040constructor);
        p_a_cons_own_init = 1;
    }
    enter_proc(245);

  LINE(249);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 26: 
         {

  LINE(251);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(252);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            RecordAlloc(3, T_2_1);
            T_2_1.vec->data[2]  = t.num;
            CellAlloc(1, nil, T_2_2);
            T_2_1.vec->data[1]  = T_2_2.num;
            err = sequenceOPnew(&T_2_3);
            if (err != ERR_ok) goto ex_0;
            T_2_1.vec->data[0]  = T_2_3.num;
            CellAlloc(1, T_2_1.num, T_2_4);
            ret_1->num = T_2_4.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(256);
        {
        CLUREF T_2_1;
        err = p_expr1(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        x.num = T_2_1.num;
        }
    }
    }
    }

  LINE(258);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: 
         {

  LINE(259);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(260);
            {
            CLUREF T_2_1;
            CellAlloc(2, x.num, T_2_1);
            low.num = T_2_1.num;
            }

  LINE(261);
            {
            CLUREF T_2_1;
            err = p_envOPget_peek1(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_1.cell->tag) {
            case 26: 
                 {

  LINE(262);
                    {
                    CLUREF T_3_1;
                    err = sequenceOPnew(&T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    elts.num = T_3_1.num;
                    }
                    break;
                    }
            default: {

  LINE(263);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                err = proctypeOPnew(CLU_0, &T_3_1.proc);
                if (err!= ERR_ok) goto ex_0;
                T_3_1.proc->type_owns = 0;
                T_3_1.proc->op_owns = 0;
                T_3_1.proc->proc = p_expr;
                generic_CLU_proc.type_owns = 0;
                generic_CLU_proc.op_owns = (long)p_clist_of_expr_ops->op_owns;
                generic_CLU_proc.proc = p_clist;
                CUR_PROC_VAR.proc = &generic_CLU_proc;
                err = p_clist(e, T_3_1, STR_expression, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                elts.num = T_3_2.num;
                }
            }
            }
            }
            break;
            }
    case 3: 
         {

  LINE(265);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(266);
            {
            CLUREF T_2_1;
            CellAlloc(1, nil, T_2_1);
            low.num = T_2_1.num;
            }

  LINE(267);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = proctypeOPnew(CLU_0, &T_2_1.proc);
            if (err!= ERR_ok) goto ex_0;
            T_2_1.proc->type_owns = 0;
            T_2_1.proc->op_owns = 0;
            T_2_1.proc->proc = p_expr;
            generic_CLU_proc.type_owns = 0;
            generic_CLU_proc.op_owns = (long)p_clist_of_expr_ops->op_owns;
            generic_CLU_proc.proc = p_clist;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = p_clist(e, T_2_1, STR_expression, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            elts.num = T_2_2.num;
            }

  LINE(268);
            {
            CLUREF T_2_1;
            err = sequenceOPaddl(elts, x, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            elts.num = T_2_1.num;
            }
            break;
            }
    default: {

  LINE(269);
        {
        CLUREF T_2_1;
        CellAlloc(1, nil, T_2_1);
        low.num = T_2_1.num;
        }

  LINE(270);
        {
        CLUREF T_2_1;
        sequenceOPnew2(CLU_1, &T_2_1);
        T_2_1.vec->data[0] = x.num;
        elts.num = T_2_1.num;
        }
    }
    }
    }

  LINE(272);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 26: 
         {

  LINE(273);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(274);
        {
        err = p_envOPassume(e, STR__135_040in_040constructor);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(276);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(3, T_1_1);
    T_1_1.vec->data[2]  = t.num;
    T_1_1.vec->data[1]  = low.num;
    T_1_1.vec->data[0]  = elts.num;
    CellAlloc(1, T_1_1.num, T_1_2);
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_a_cons ****/


extern errcode p_type1();
CLUREF STR__133type_137spec_135_040in_040FORCE_133type_137spec_135;
CLUREF STR__135_040in_040FORCE_133type_137spec_135;
static int p_force_own_init = 0;

/**** BEGIN PROCEDURE p_force ****/

errcode p_force(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF t;
        if (p_force_own_init == 0) {
        stringOPcons("[type_spec] in FORCE[type_spec]", CLU_1, CLU_31, &STR__133type_137spec_135_040in_040FORCE_133type_137spec_135);
        stringOPcons("] in FORCE[type_spec]", CLU_1, CLU_21, &STR__135_040in_040FORCE_133type_137spec_135);
        p_force_own_init = 1;
    }
    enter_proc(283);

  LINE(284);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 19: 
         {

  LINE(285);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(286);
        {
        err = p_envOPassume(e, STR__133type_137spec_135_040in_040FORCE_133type_137spec_135);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(287);
        {
        {
        CLUREF T_2_1;
        err = p_envOPget_unknown_type(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(289);
    {
        {CLUREF T_1_1;
        err = p_type1(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        t.num = T_1_1.num;
        }
        }

  LINE(290);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 26: 
         {

  LINE(291);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(292);
        {
        err = p_envOPassume(e, STR__135_040in_040FORCE_133type_137spec_135);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(294);
    {
    {
    ret_1->num = t.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_force ****/


CLUREF STR__050expression_051;
CLUREF STR__051_040in_040_050expression_051;
static int p_pexpr_own_init = 0;

/**** BEGIN PROCEDURE p_pexpr ****/

errcode p_pexpr(e, ret_1)
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF x;
        if (p_pexpr_own_init == 0) {
        stringOPcons("(expression)", CLU_1, CLU_12, &STR__050expression_051);
        stringOPcons(") in (expression)", CLU_1, CLU_17, &STR__051_040in_040_050expression_051);
        p_pexpr_own_init = 1;
    }
    enter_proc(299);

  LINE(300);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 21: 
         {

  LINE(301);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(302);
        {
        err = p_envOPassume(e, STR__050expression_051);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(303);
        {
        {
        CLUREF T_2_1;
        err = p_envOPget_bad_expr(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(305);
    {
        {CLUREF T_1_1;
        err = p_expr1(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        x.num = T_1_1.num;
        }
        }

  LINE(306);
    {
    CLUREF T_1_1;
    err = p_envOPget_peek1(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 28: 
         {

  LINE(307);
            {
            CLUREF T_2_1;
            err = p_envOPnext_token(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(308);
        {
        err = p_envOPassume(e, STR__051_040in_040_050expression_051);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(310);
    {
    {
    ret_1->num = x.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE p_pexpr ****/

