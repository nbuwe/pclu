
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER data_chan ****/

extern errcode stringOPequal();
extern errcode file_nameOPget_dir();
extern errcode file_nameOPget_name();
extern errcode _chanOPnul();
extern errcode _chanOPopen();
extern errcode _wordvecOPcreate();
extern errcode oneofOPmake_1();
extern errcode recordOPget_1();
extern errcode stringOPsize();
extern errcode recordOPset_1();
extern errcode intOPadd();
extern errcode intOPmul();
extern errcode intOPdiv();
extern errcode recordOPget_6();
extern errcode recordOPget_5();
extern errcode intOPequal();
extern errcode boolOPnot();
extern errcode recordOPget_4();
extern errcode _chanOPputw();
extern errcode recordOPget_2();
extern errcode recordOPset_4();
extern errcode recordOPset_7();
extern errcode _wordvecOPstore2();
extern errcode _cvt();
extern errcode intOPgt();
extern errcode intOPsub();
extern errcode _wordvecOPmove_b2w();
extern errcode intOPmod();
extern errcode _wordvecOPbstore();
extern errcode _wordvecOPwstore();
extern errcode recordOPset_5();
extern errcode sequenceOPempty();
extern errcode sequenceOPsize();
extern errcode _wordvecOPstore();
extern errcode sequenceOPelements();
extern errcode _wordvecOPxstore();
extern errcode arrayOPempty();
extern errcode arrayOPsize();
extern errcode arrayOPelements();
extern errcode data_chanOPstore_cell();
extern errcode oneofOPmake_2();
extern errcode recordOPget_3();
extern errcode code_chanOPsize();
extern errcode code_chanOPget_chan();
extern errcode _chanOPset_access();
extern errcode _chanOPgetw();
extern errcode _bin_id();
extern errcode _chanOPabort();
extern errcode _chanOPclose();
extern errcode recordOPget_7();
extern errcode recordOPset_3();
CLUREF STR__057dev;
CLUREF STR_null;
CLUREF STR_write;
CLUREF STR_;
CLUREF STR_channel_040is_040closed;
static int data_chan_own_init = 0;
OWN_req data_chan_ownreqs = {0,0};
CLUREF data_chanOPisfree;
CLUREF data_chanOPfree;
errcode data_chan_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (data_chan_own_init == 0) {
        stringOPcons("/dev", CLU_1, CLU_4, &STR__057dev);
        stringOPcons("null", CLU_1, CLU_4, &STR_null);
        stringOPcons("write", CLU_1, CLU_5, &STR_write);
        stringOPcons("", CLU_1, CLU_0, &STR_);
        stringOPcons("channel is closed", CLU_1, CLU_17, &STR_channel_040is_040closed);
        data_chan_own_init = 1;
        {
            {data_chanOPisfree.tf = false;
            }
            }
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }

static int data_chanOPopen_own_init = 0;

/**** BEGIN PROCEDURE open ****/

errcode data_chanOPopen(fn, ret_1, ret_2)
CLUREF fn;
CLUREF *ret_1;
CLUREF *ret_2;
    {
    errcode err;
    errcode ecode2;
    CLUREF c;
    CLUREF p;
    CLUREF dc;
        if (data_chanOPopen_own_init == 0) {
        if (data_chan_own_init == 0) {
            err = data_chan_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        data_chanOPopen_own_init = 1;
    }
    enter_proc(33);

  LINE(35);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    CLUREF T_2_4;
    CLUREF T_2_5;
    err = file_nameOPget_dir(fn, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    T_2_3.num = ((T_2_2.str->size != STR__057dev.str->size)? false :
        !(bcmp(T_2_2.str->data, STR__057dev.str->data, T_2_2.str->size)));
    T_2_1.num = T_2_3.num;
    if (T_2_3.num) {
        err = file_nameOPget_name(fn, &T_2_4);
        if (err != ERR_ok) goto ex_1;
        T_2_5.num = ((T_2_4.str->size != STR_null.str->size)? false :
            !(bcmp(T_2_4.str->data, STR_null.str->data, T_2_4.str->size)));
        T_2_1.num = T_2_5.num;
    }
    if (T_2_1.num == true) {

  LINE(36);
        {
        CLUREF T_3_1;
        err = _chanOPnul(&T_3_1);
        if (err != ERR_ok) goto ex_1;
        c.num = T_3_1.num;
        }
        }
    else {

  LINE(37);
        {
        CLUREF T_3_1;
        err = _chanOPopen(fn, STR_write, CLU_0, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        c.num = T_3_1.num;
        }
        }}/* end if */
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(40);
    {
    if (data_chanOPisfree.num == true) {

  LINE(41);
        {
        p.num = data_chanOPfree.num;
        }

  LINE(42);
        {
        data_chanOPisfree.tf = false;
        }
        }
    else {

  LINE(43);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 2048;
        err = _wordvecOPcreate(T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        p.num = T_2_2.num;
        }
        }}/* end if */

  LINE(45);
    {
        {CLUREF T_1_1;
        RecordAlloc(7, T_1_1);
        T_1_1.vec->data[1]  = c.num;
        T_1_1.vec->data[0]  = 28;
        T_1_1.vec->data[5]  = p.num;
        T_1_1.vec->data[4]  = 10;
        T_1_1.vec->data[2]  = false;
        T_1_1.vec->data[3]  = false;
        T_1_1.vec->data[6]  = STR_.num;
        dc.num = T_1_1.num;
        }
        }

  LINE(52);
    {
    {
    ret_1->num = dc.num;
    }
    {
    CLUREF T_1_1;
    CellAlloc(1, 20, T_1_1);
    ret_2->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE open ****/


/**** BEGIN PROCEDURE store_str ****/

errcode data_chanOPstore_str(dc, s, ret_1)
CLUREF dc;
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF v;
    CLUREF z;
    CLUREF p;
    CLUREF index;
    CLUREF why;
    CLUREF chars;
    CLUREF i;
    CLUREF cnt;
    CLUREF moved;
        if (data_chan_own_init == 0) {
            err = data_chan_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(55);

  LINE(56);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = dc.vec->data[0];
        CellAlloc(1, T_1_1.num, T_1_2);
        v.num = T_1_2.num;
        }
        }

  LINE(57);
    {
        {CLUREF T_1_1;
        err = stringOPsize(s, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        z.num = T_1_1.num;
        }
        }

  LINE(58);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    T_1_1.num = dc.vec->data[0];
    T_1_2.num = z.num + 7;
     if ((T_1_2.num > 0 && z.num < 0 && 7 < 0) || 
         (T_1_2.num < 0 && z.num > 0 && 7 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    err = intOPdiv(T_1_2, CLU_4, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    err = intOPmul(T_1_3, CLU_4, &T_1_4);
    if (err != ERR_ok) goto ex_0;
    T_1_5.num = T_1_1.num + T_1_4.num;
     if ((T_1_5.num > 0 && T_1_1.num < 0 && T_1_4.num < 0) || 
         (T_1_5.num < 0 && T_1_1.num > 0 && T_1_4.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    dc.vec->data[0]  = T_1_5.num;
    }

  LINE(59);
    {
        {CLUREF T_1_1;
        T_1_1.num = dc.vec->data[5];
        p.num = T_1_1.num;
        }
        }

  LINE(60);
    {
        {CLUREF T_1_1;
        T_1_1.num = dc.vec->data[4];
        index.num = T_1_1.num;
        }
        }

  LINE(61);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = 2048;
    T_1_2.num = (index.num == T_1_1.num)? true : false;
    if (T_1_2.num == true) {

  LINE(62);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = dc.vec->data[3];
        T_2_2.num = T_2_1.num ^ 1;
        if (T_2_2.num == true) {

  LINE(63);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = dc.vec->data[1];
            T_4_2.num = 8192;
            err = _chanOPputw(T_4_1, p, CLU_1, T_4_2, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
                goto end_1;
                ex_1:
                    if ((err == ERR_not_possible)) {
                    CLUREF why;
                    why.num = elist[0].num;

  LINE(65);
                        {
                        dc.vec->data[3]  = true;
                        }

  LINE(66);
                        {
                        dc.vec->data[6]  = why.num;
                        }
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;
            }
            }/* end if */

  LINE(69);
        {
        index.num = 0;
        }
        }
        }/* end if */

  LINE(71);
    {
    CLUREF T_1_1;
    T_1_1.num = index.num + 1;
     if ((T_1_1.num > 0 && index.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && index.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    index.num = T_1_1.num;
    }

  LINE(72);
    {
    CLUREF T_1_1;
    T_1_1.num = 8192;
    err = _wordvecOPstore2(p, index, T_1_1, z);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(73);
    {
        {CLUREF T_1_1;
        T_1_1.num = s.num;
        chars.num = T_1_1.num;
        }
        }

  LINE(74);
    {
        {i.num = 1;
        }
        }

  LINE(75);
    for (;;) {
        CLUREF T_1_1;
        T_1_1.num = (z.num > 0)? true : false;
        if (T_1_1.num != true) { break; }

  LINE(76);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 2048;
        T_2_2.num = (index.num == T_2_1.num)? true : false;
        if (T_2_2.num == true) {

  LINE(77);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = dc.vec->data[3];
            T_3_2.num = T_3_1.num ^ 1;
            if (T_3_2.num == true) {

  LINE(78);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                T_5_1.num = dc.vec->data[1];
                T_5_2.num = 8192;
                err = _chanOPputw(T_5_1, p, CLU_1, T_5_2, CLU_0);
                if (err != ERR_ok) goto ex_2;
                }
                    goto end_2;
                    ex_2:
                        if ((err == ERR_not_possible)) {
                        CLUREF why;
                        why.num = elist[0].num;

  LINE(80);
                            {
                            dc.vec->data[3]  = true;
                            }

  LINE(81);
                            {
                            dc.vec->data[6]  = why.num;
                            }
                        }
                        else {
                            goto ex_0;
                        }
                    end_2:;
                }
                }/* end if */

  LINE(84);
            {
            index.num = 0;
            }
            }
            }/* end if */

  LINE(86);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = 2048;
            T_2_2.num = T_2_1.num - index.num;
             if ((T_2_2.num >= 0 && T_2_1.num < 0 && (-index.num) < 0) || 
                 (T_2_2.num <= 0 && T_2_1.num > 0 && (-index.num) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            cnt.num = T_2_2.num;
            }
            }

  LINE(87);
        {
            {CLUREF T_2_1;
            err = intOPmul(cnt, CLU_4, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            moved.num = T_2_1.num;
            }
            }

  LINE(88);
        {
        CLUREF T_2_1;
        T_2_1.num = (moved.num > z.num)? true : false;
        if (T_2_1.num == true) {

  LINE(89);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = z.num + 3;
             if ((T_3_1.num > 0 && z.num < 0 && 3 < 0) || 
                 (T_3_1.num < 0 && z.num > 0 && 3 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            err = intOPdiv(T_3_1, CLU_4, &T_3_2);
            if (err != ERR_ok) goto ex_0;
            cnt.num = T_3_2.num;
            }

  LINE(90);
            {
            moved.num = z.num;
            }
            }
            }/* end if */

  LINE(92);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = intOPmul(index, CLU_4, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        T_2_2.num = T_2_1.num + 1;
         if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
             (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = _wordvecOPmove_b2w(chars, i, p, T_2_2, moved);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(93);
        {
        CLUREF T_2_1;
        T_2_1.num = z.num - moved.num;
         if ((T_2_1.num >= 0 && z.num < 0 && (-moved.num) < 0) || 
             (T_2_1.num <= 0 && z.num > 0 && (-moved.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        z.num = T_2_1.num;
        }

  LINE(94);
        {
        CLUREF T_2_1;
        T_2_1.num = i.num + moved.num;
         if ((T_2_1.num > 0 && i.num < 0 && moved.num < 0) || 
             (T_2_1.num < 0 && i.num > 0 && moved.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        i.num = T_2_1.num;
        }

  LINE(95);
        {
        CLUREF T_2_1;
        T_2_1.num = index.num + cnt.num;
         if ((T_2_1.num > 0 && index.num < 0 && cnt.num < 0) || 
             (T_2_1.num < 0 && index.num > 0 && cnt.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        index.num = T_2_1.num;
        }

  LINE(96);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = intOPmod(moved, CLU_4, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        T_2_2.num = (T_2_1.num == 0)? true : false;
        T_2_3.num = T_2_2.num ^ 1;
        if (T_2_3.num == true) {

  LINE(97);
            {
            CLUREF T_3_1;
            err = intOPmul(index, CLU_4, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            i.num = T_3_1.num;
            }

  LINE(98);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = intOPmod(moved, CLU_4, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            T_3_2.num = (T_3_1.num == 3)? true : false;
            if (T_3_2.num == true) {

  LINE(99);
                {
                err = _wordvecOPbstore(p, i, CLU_0);
                if (err != ERR_ok) goto ex_0;
                }
                }
            else {

  LINE(100);
                {
                CLUREF T_4_1;
                T_4_1.num = i.num - 1;
                 if ((T_4_1.num >= 0 && i.num < 0 && (-1) < 0) || 
                     (T_4_1.num <= 0 && i.num > 0 && (-1) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                err = _wordvecOPwstore(p, T_4_1, CLU_0);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(101);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                err = intOPmod(moved, CLU_4, &T_4_1);
                if (err != ERR_ok) goto ex_0;
                T_4_2.num = (T_4_1.num == 1)? true : false;
                if (T_4_2.num == true) {

  LINE(102);
                    {
                    CLUREF T_5_1;
                    T_5_1.num = i.num - 2;
                     if ((T_5_1.num >= 0 && i.num < 0 && (-2) < 0) || 
                         (T_5_1.num <= 0 && i.num > 0 && (-2) > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    err = _wordvecOPbstore(p, T_5_1, CLU_0);
                    if (err != ERR_ok) goto ex_0;
                    }
                    }
                    }/* end if */
                }}/* end if */
            }
            }/* end if */
        }
        end_while_1:;

  LINE(106);
    {
    dc.vec->data[4]  = index.num;
    }

  LINE(107);
    {
    {
    ret_1->num = v.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE store_str ****/


/**** BEGIN PROCEDURE store_vec ****/

errcode data_chanOPstore_vec(dc, vec, ret_1)
CLUREF dc;
CLUREF vec;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF v;
    CLUREF z;
    CLUREF p;
    CLUREF index;
    CLUREF why;
    CLUREF val;
    CLUREF loc;
    CLUREF i;
        if (data_chan_own_init == 0) {
            err = data_chan_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(110);

  LINE(111);
    {
    CLUREF T_1_1;
    err = sequenceOPempty(vec, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(112);
        {
        {
        CLUREF T_2_1;
        CellAlloc(1, 16, T_2_1);
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(113);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = dc.vec->data[0];
        CellAlloc(1, T_1_1.num, T_1_2);
        v.num = T_1_2.num;
        }
        }

  LINE(114);
    {
        {CLUREF T_1_1;
        T_1_1.num = vec.vec->size;
        z.num = T_1_1.num;
        }
        }

  LINE(115);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = dc.vec->data[0];
    T_1_2.num = z.num + 1;
     if ((T_1_2.num > 0 && z.num < 0 && 1 < 0) || 
         (T_1_2.num < 0 && z.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    err = intOPmul(CLU_4, T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_4.num = T_1_1.num + T_1_3.num;
     if ((T_1_4.num > 0 && T_1_1.num < 0 && T_1_3.num < 0) || 
         (T_1_4.num < 0 && T_1_1.num > 0 && T_1_3.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    dc.vec->data[0]  = T_1_4.num;
    }

  LINE(116);
    {
        {CLUREF T_1_1;
        T_1_1.num = dc.vec->data[5];
        p.num = T_1_1.num;
        }
        }

  LINE(117);
    {
        {CLUREF T_1_1;
        T_1_1.num = dc.vec->data[4];
        index.num = T_1_1.num;
        }
        }

  LINE(118);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = 2048;
    T_1_2.num = (index.num == T_1_1.num)? true : false;
    if (T_1_2.num == true) {

  LINE(119);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = dc.vec->data[3];
        T_2_2.num = T_2_1.num ^ 1;
        if (T_2_2.num == true) {

  LINE(120);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = dc.vec->data[1];
            T_4_2.num = 8192;
            err = _chanOPputw(T_4_1, p, CLU_1, T_4_2, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
                goto end_1;
                ex_1:
                    if ((err == ERR_not_possible)) {
                    CLUREF why;
                    why.num = elist[0].num;

  LINE(122);
                        {
                        dc.vec->data[3]  = true;
                        }

  LINE(123);
                        {
                        dc.vec->data[6]  = why.num;
                        }
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;
            }
            }/* end if */

  LINE(126);
        {
        index.num = 0;
        }
        }
        }/* end if */

  LINE(128);
    {
    CLUREF T_1_1;
    T_1_1.num = index.num + 1;
     if ((T_1_1.num > 0 && index.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && index.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    index.num = T_1_1.num;
    }

  LINE(129);
    {
    err = _wordvecOPstore(p, index, z);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(130);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = vec.vec->size; 
        T_1_3 = vec;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            val.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(131);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = 2048;
            T_2_2.num = (index.num == T_2_1.num)? true : false;
            if (T_2_2.num == true) {

  LINE(132);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = dc.vec->data[3];
                T_3_2.num = T_3_1.num ^ 1;
                if (T_3_2.num == true) {

  LINE(133);
                    {
                    CLUREF T_5_1;
                    CLUREF T_5_2;
                    T_5_1.num = dc.vec->data[1];
                    T_5_2.num = 8192;
                    err = _chanOPputw(T_5_1, p, CLU_1, T_5_2, CLU_0);
                    if (err != ERR_ok) goto ex_2;
                    }
                        goto end_2;
                        ex_2:
                            if ((err == ERR_not_possible)) {
                            CLUREF why;
                            why.num = elist[0].num;

  LINE(135);
                                {
                                dc.vec->data[3]  = true;
                                }

  LINE(136);
                                {
                                dc.vec->data[6]  = why.num;
                                }
                            }
                            else {
                                goto ex_0;
                            }
                        end_2:;
                    }
                    }/* end if */

  LINE(139);
                {
                index.num = 0;
                }
                }
                }/* end if */

  LINE(141);
            {
            CLUREF T_2_1;
            T_2_1.num = index.num + 1;
             if ((T_2_1.num > 0 && index.num < 0 && 1 < 0) || 
                 (T_2_1.num < 0 && index.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            index.num = T_2_1.num;
            }

  LINE(142);
            {
            switch (val.cell->tag) {
            case 1: 
                 {CLUREF T_2_1;
                T_2_1.num = val.cell->value;
                loc.num = T_2_1.num;

  LINE(144);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = 64;
                    err = _wordvecOPxstore(p, index, T_3_1, loc);
                    if (err != ERR_ok) goto ex_0;
                    }
                    break;
                    }
            case 2: 
                 {CLUREF T_2_2;
                T_2_2.num = val.cell->value;
                i.num = T_2_2.num;

  LINE(146);
                    {
                    err = _wordvecOPstore(p, index, i);
                    if (err != ERR_ok) goto ex_0;
                    }
                    break;
                    }
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(149);
    {
    dc.vec->data[4]  = index.num;
    }

  LINE(150);
    {
    {
    ret_1->num = v.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE store_vec ****/


/**** BEGIN PROCEDURE store_avec ****/

errcode data_chanOPstore_avec(dc, vec, ret_1)
CLUREF dc;
CLUREF vec;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF v;
    CLUREF z;
    CLUREF p;
    CLUREF index;
    CLUREF why;
    CLUREF val;
    CLUREF loc;
    CLUREF i;
        if (data_chan_own_init == 0) {
            err = data_chan_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(153);

  LINE(154);
    {
    CLUREF T_1_1;
    T_1_1.num = (vec.array->ext_size == 0)? true : false;
    if (T_1_1.num == true) {

  LINE(155);
        {
        {
        CLUREF T_2_1;
        CellAlloc(1, 16, T_2_1);
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(156);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = dc.vec->data[0];
        CellAlloc(1, T_1_1.num, T_1_2);
        v.num = T_1_2.num;
        }
        }

  LINE(157);
    {
        {CLUREF T_1_1;
        T_1_1.num = vec.array->ext_size;
        z.num = T_1_1.num;
        }
        }

  LINE(158);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = dc.vec->data[0];
    T_1_2.num = z.num + 1;
     if ((T_1_2.num > 0 && z.num < 0 && 1 < 0) || 
         (T_1_2.num < 0 && z.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    err = intOPmul(CLU_4, T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_4.num = T_1_1.num + T_1_3.num;
     if ((T_1_4.num > 0 && T_1_1.num < 0 && T_1_3.num < 0) || 
         (T_1_4.num < 0 && T_1_1.num > 0 && T_1_3.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    dc.vec->data[0]  = T_1_4.num;
    }

  LINE(159);
    {
        {CLUREF T_1_1;
        T_1_1.num = dc.vec->data[5];
        p.num = T_1_1.num;
        }
        }

  LINE(160);
    {
        {CLUREF T_1_1;
        T_1_1.num = dc.vec->data[4];
        index.num = T_1_1.num;
        }
        }

  LINE(161);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = 2048;
    T_1_2.num = (index.num == T_1_1.num)? true : false;
    if (T_1_2.num == true) {

  LINE(162);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = dc.vec->data[3];
        T_2_2.num = T_2_1.num ^ 1;
        if (T_2_2.num == true) {

  LINE(163);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = dc.vec->data[1];
            T_4_2.num = 8192;
            err = _chanOPputw(T_4_1, p, CLU_1, T_4_2, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
                goto end_1;
                ex_1:
                    if ((err == ERR_not_possible)) {
                    CLUREF why;
                    why.num = elist[0].num;

  LINE(165);
                        {
                        dc.vec->data[3]  = true;
                        }

  LINE(166);
                        {
                        dc.vec->data[6]  = why.num;
                        }
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;
            }
            }/* end if */

  LINE(169);
        {
        index.num = 0;
        }
        }
        }/* end if */

  LINE(171);
    {
    CLUREF T_1_1;
    T_1_1.num = index.num + 1;
     if ((T_1_1.num > 0 && index.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && index.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    index.num = T_1_1.num;
    }

  LINE(172);
    {
    err = _wordvecOPstore(p, index, z);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(173);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = vec.array->ext_high; 
        T_1_3 = vec;
        for (T_1_1.num = vec.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            val.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(174);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = 2048;
            T_2_2.num = (index.num == T_2_1.num)? true : false;
            if (T_2_2.num == true) {

  LINE(175);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = dc.vec->data[3];
                T_3_2.num = T_3_1.num ^ 1;
                if (T_3_2.num == true) {

  LINE(176);
                    {
                    CLUREF T_5_1;
                    CLUREF T_5_2;
                    T_5_1.num = dc.vec->data[1];
                    T_5_2.num = 8192;
                    err = _chanOPputw(T_5_1, p, CLU_1, T_5_2, CLU_0);
                    if (err != ERR_ok) goto ex_2;
                    }
                        goto end_2;
                        ex_2:
                            if ((err == ERR_not_possible)) {
                            CLUREF why;
                            why.num = elist[0].num;

  LINE(178);
                                {
                                dc.vec->data[3]  = true;
                                }

  LINE(179);
                                {
                                dc.vec->data[6]  = why.num;
                                }
                            }
                            else {
                                goto ex_0;
                            }
                        end_2:;
                    }
                    }/* end if */

  LINE(182);
                {
                index.num = 0;
                }
                }
                }/* end if */

  LINE(184);
            {
            CLUREF T_2_1;
            T_2_1.num = index.num + 1;
             if ((T_2_1.num > 0 && index.num < 0 && 1 < 0) || 
                 (T_2_1.num < 0 && index.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            index.num = T_2_1.num;
            }

  LINE(185);
            {
            switch (val.cell->tag) {
            case 1: 
                 {CLUREF T_2_1;
                T_2_1.num = val.cell->value;
                loc.num = T_2_1.num;

  LINE(187);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = 64;
                    err = _wordvecOPxstore(p, index, T_3_1, loc);
                    if (err != ERR_ok) goto ex_0;
                    }
                    break;
                    }
            case 2: 
                 {CLUREF T_2_2;
                T_2_2.num = val.cell->value;
                i.num = T_2_2.num;

  LINE(189);
                    {
                    err = _wordvecOPstore(p, index, i);
                    if (err != ERR_ok) goto ex_0;
                    }
                    break;
                    }
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(192);
    {
    dc.vec->data[4]  = index.num;
    }

  LINE(193);
    {
    {
    ret_1->num = v.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE store_avec ****/


/**** BEGIN PROCEDURE store_cell ****/

errcode data_chanOPstore_cell(dc, code, val, ret_1)
CLUREF dc;
CLUREF code;
CLUREF val;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF v;
    CLUREF p;
    CLUREF index;
    CLUREF why;
    CLUREF loc;
    CLUREF i;
        if (data_chan_own_init == 0) {
            err = data_chan_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(196);

  LINE(197);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = dc.vec->data[0];
        CellAlloc(1, T_1_1.num, T_1_2);
        v.num = T_1_2.num;
        }
        }

  LINE(198);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = dc.vec->data[0];
    T_1_2.num = T_1_1.num + 8;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && 8 < 0) || 
         (T_1_2.num < 0 && T_1_1.num > 0 && 8 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    dc.vec->data[0]  = T_1_2.num;
    }

  LINE(199);
    {
        {CLUREF T_1_1;
        T_1_1.num = dc.vec->data[5];
        p.num = T_1_1.num;
        }
        }

  LINE(200);
    {
        {CLUREF T_1_1;
        T_1_1.num = dc.vec->data[4];
        index.num = T_1_1.num;
        }
        }

  LINE(201);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = 2046;
    T_1_2.num = (index.num > T_1_1.num)? true : false;
    if (T_1_2.num == true) {

  LINE(202);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = dc.vec->data[3];
        T_2_2.num = T_2_1.num ^ 1;
        if (T_2_2.num == true) {

  LINE(203);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = dc.vec->data[1];
            err = intOPmul(CLU_4, index, &T_4_2);
            if (err != ERR_ok) goto ex_1;
            err = _chanOPputw(T_4_1, p, CLU_1, T_4_2, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
                goto end_1;
                ex_1:
                    if ((err == ERR_not_possible)) {
                    CLUREF why;
                    why.num = elist[0].num;

  LINE(205);
                        {
                        dc.vec->data[3]  = true;
                        }

  LINE(206);
                        {
                        dc.vec->data[6]  = why.num;
                        }
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;
            }
            }/* end if */

  LINE(209);
        {
        index.num = 0;
        }
        }
        }/* end if */

  LINE(211);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = index.num + 1;
     if ((T_1_1.num > 0 && index.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && index.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    T_1_2.num = 16384;
    err = _wordvecOPstore2(p, T_1_1, T_1_2, code);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(212);
    {
    CLUREF T_1_1;
    T_1_1.num = index.num + 2;
     if ((T_1_1.num > 0 && index.num < 0 && 2 < 0) || 
         (T_1_1.num < 0 && index.num > 0 && 2 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    index.num = T_1_1.num;
    }

  LINE(213);
    {
    switch (val.cell->tag) {
    case 1: 
         {CLUREF T_1_1;
        T_1_1.num = val.cell->value;
        loc.num = T_1_1.num;

  LINE(215);
            {
            CLUREF T_2_1;
            T_2_1.num = 64;
            err = _wordvecOPxstore(p, index, T_2_1, loc);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = val.cell->value;
        i.num = T_1_2.num;

  LINE(217);
            {
            err = _wordvecOPstore(p, index, i);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    }
    }

  LINE(219);
    {
    dc.vec->data[4]  = index.num;
    }

  LINE(220);
    {
    {
    ret_1->num = v.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE store_cell ****/


/**** BEGIN PROCEDURE oneof2 ****/

errcode data_chanOPoneof2(dc, ret_1)
CLUREF dc;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (data_chan_own_init == 0) {
            err = data_chan_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(223);

  LINE(224);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(2, 0, T_1_1);
    err = data_chanOPstore_cell(dc, CLU_2, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE oneof2 ****/

static int data_chanOPadd_close_own_init = 0;

/**** BEGIN PROCEDURE add_close ****/

errcode data_chanOPadd_close(dc, val, cc)
CLUREF dc;
CLUREF val;
CLUREF cc;
    {
    errcode err;
    errcode ecode2;
    CLUREF p;
    CLUREF oc;
    CLUREF cz;
    CLUREF ic;
    CLUREF loc;
    CLUREF i;
    CLUREF why;
        if (data_chanOPadd_close_own_init == 0) {
        if (data_chan_own_init == 0) {
            err = data_chan_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        data_chanOPadd_close_own_init = 1;
    }
    enter_proc(227);

  LINE(229);
    {
    CLUREF T_1_1;
    T_1_1.num = dc.vec->data[2];
    if (T_1_1.num == true) {

  LINE(230);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(231);
    {
        {CLUREF T_1_1;
        T_1_1.num = dc.vec->data[5];
        p.num = T_1_1.num;
        }
        }

  LINE(232);
    {
        {CLUREF T_1_1;
        T_1_1.num = dc.vec->data[1];
        oc.num = T_1_1.num;
        }
        }

  LINE(233);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = dc.vec->data[3];
    T_2_2.num = T_2_1.num ^ 1;
    if (T_2_2.num == true) {

  LINE(234);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = dc.vec->data[4];
        T_3_2.num = (T_3_1.num > 0)? true : false;
        if (T_3_2.num == true) {

  LINE(235);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = dc.vec->data[4];
            err = intOPmul(CLU_4, T_4_1, &T_4_2);
            if (err != ERR_ok) goto ex_1;
            err = _chanOPputw(oc, p, CLU_1, T_4_2, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }
            }
            }/* end if */

  LINE(237);
        {
            {CLUREF T_3_1;
            err = code_chanOPsize(cc, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            cz.num = T_3_1.num;
            }
            }

  LINE(238);
        {
            {CLUREF T_3_1;
            err = code_chanOPget_chan(cc, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            ic.num = T_3_1.num;
            }
            }

  LINE(239);
        {
        err = _chanOPset_access(ic, CLU_0);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(240);
        for (;;) {
            if (true != true) { break; }

  LINE(241);
            {
            CLUREF T_5_1;
            err = _chanOPgetw(ic, p, &T_5_1);
            if (err != ERR_ok) goto ex_2;
            err = _chanOPputw(oc, p, CLU_1, T_5_1, CLU_0);
            if (err != ERR_ok) goto ex_2;
            }
            }
            end_while_1:;
            goto end_2;
            ex_2:
                if ((err == ERR_end_of_file)) {
                }
                else {
                    goto ex_1;
                }
            end_2:;

  LINE(243);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = 14537;
        T_3_2.num = 18112;
        err = _wordvecOPstore2(p, CLU_1, T_3_1, T_3_2);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(244);
        {
        CLUREF T_3_1;
        T_3_1.num = dc.vec->data[0];
        err = _wordvecOPstore(p, CLU_2, T_3_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(245);
        {
        CLUREF T_3_1;
        T_3_1.num = 64;
        err = _wordvecOPxstore(p, CLU_3, T_3_1, CLU_0);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(246);
        {
        err = _wordvecOPstore(p, CLU_4, CLU_3);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(247);
        {
        switch (val.cell->tag) {
        case 1: 
             {CLUREF T_3_1;
            T_3_1.num = val.cell->value;
            loc.num = T_3_1.num;

  LINE(249);
                {
                CLUREF T_4_1;
                T_4_1.num = 64;
                err = _wordvecOPxstore(p, CLU_5, T_4_1, loc);
                if (err != ERR_ok) goto ex_1;
                }
                break;
                }
        case 2: 
             {CLUREF T_3_2;
            T_3_2.num = val.cell->value;
            i.num = T_3_2.num;

  LINE(251);
                {
                err = _wordvecOPstore(p, CLU_5, i);
                if (err != ERR_ok) goto ex_1;
                }
                break;
                }
        }
        }

  LINE(253);
        {
        err = _wordvecOPstore(p, CLU_6, cz);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(254);
        {
        CLUREF T_3_1;
        err = _bin_id(&T_3_1);
        if (err != ERR_ok) goto ex_1;
        err = _wordvecOPstore(p, CLU_7, T_3_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(255);
        {
        err = _wordvecOPstore(p, CLU_8, CLU_0);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(256);
        {
        CLUREF T_3_1;
        T_3_1.num = 16384;
        err = _wordvecOPstore2(p, CLU_9, T_3_1, CLU_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(257);
        {
        err = _wordvecOPstore(p, CLU_10, CLU_0);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(258);
        {
        err = _chanOPset_access(oc, CLU_0);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(259);
        {
        err = _chanOPputw(oc, p, CLU_1, CLU_40, CLU_0);
        if (err != ERR_ok) goto ex_1;
        }
        }
        }/* end if */
        goto end_1;
        ex_1:
            if ((err == ERR_not_possible)) {
            CLUREF why;
            why.num = elist[0].num;

  LINE(261);
                {
                dc.vec->data[3]  = true;
                }

  LINE(262);
                {
                dc.vec->data[6]  = why.num;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(264);
    {
    CLUREF T_2_1;
    T_2_1.num = dc.vec->data[3];
    if (T_2_1.num == true) {

  LINE(265);
        {
        err = _chanOPabort(oc);
        if (err != ERR_ok) goto ex_3;
        }
        }
    else {

  LINE(266);
        {
        err = _chanOPclose(oc);
        if (err != ERR_ok) goto ex_3;
        }
        }}/* end if */
        goto end_3;
        ex_3:
            if ((err == ERR_not_possible)) {
            CLUREF why;
            why.num = elist[0].num;

  LINE(268);
                {
                CLUREF T_2_1;
                CLUREF T_2_2;
                T_2_1.num = dc.vec->data[3];
                T_2_2.num = T_2_1.num ^ 1;
                if (T_2_2.num == true) {

  LINE(269);
                    {
                    dc.vec->data[3]  = true;
                    }

  LINE(270);
                    {
                    dc.vec->data[6]  = why.num;
                    }
                    }
                    }/* end if */
            }
            else if ((err == ERR_permanent)) {
            }
            else {
                goto ex_0;
            }
        end_3:;

  LINE(274);
    {
        {CLUREF T_1_1;
        T_1_1.num = dc.vec->data[6];
        why.num = T_1_1.num;
        }
        }

  LINE(275);
    {
    dc.vec->data[6]  = STR_channel_040is_040closed.num;
    }

  LINE(276);
    {
    dc.vec->data[2]  = true;
    }

  LINE(277);
    {
    data_chanOPfree.num = p.num;
    }

  LINE(278);
    {
    data_chanOPisfree.tf = true;
    }

  LINE(279);
    {
    CLUREF T_1_1;
    T_1_1.num = dc.vec->data[3];
    if (T_1_1.num == true) {

  LINE(280);
        {
        elist[0] = why;
        {signal (ERR_not_possible);}}
        }
    else {

  LINE(281);
        {
        dc.vec->data[3]  = true;
        }
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE add_close ****/

static int data_chanOPclose_own_init = 0;

/**** BEGIN PROCEDURE close ****/

errcode data_chanOPclose(dc)
CLUREF dc;
    {
    errcode err;
    errcode ecode2;
    CLUREF why;
        if (data_chanOPclose_own_init == 0) {
        if (data_chan_own_init == 0) {
            err = data_chan_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        data_chanOPclose_own_init = 1;
    }
    enter_proc(285);

  LINE(286);
    {
    CLUREF T_1_1;
    T_1_1.num = dc.vec->data[2];
    if (T_1_1.num == true) {

  LINE(287);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(288);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    T_1_2.num = dc.vec->data[4];
    T_1_3.num = (T_1_2.num > 0)? true : false;
    T_1_1.num = T_1_3.num;
    if (T_1_3.num) {
        T_1_4.num = dc.vec->data[3];
        T_1_5.num = T_1_4.num ^ 1;
        T_1_1.num = T_1_5.num;
    }
    if (T_1_1.num == true) {

  LINE(289);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        T_3_1.num = dc.vec->data[1];
        T_3_2.num = dc.vec->data[5];
        T_3_3.num = dc.vec->data[4];
        err = intOPmul(CLU_4, T_3_3, &T_3_4);
        if (err != ERR_ok) goto ex_1;
        err = _chanOPputw(T_3_1, T_3_2, CLU_1, T_3_4, CLU_0);
        if (err != ERR_ok) goto ex_1;
        }
            goto end_1;
            ex_1:
                if ((err == ERR_not_possible)) {
                CLUREF why;
                why.num = elist[0].num;

  LINE(291);
                    {
                    dc.vec->data[3]  = true;
                    }

  LINE(292);
                    {
                    dc.vec->data[6]  = why.num;
                    }
                }
                else {
                    goto ex_0;
                }
            end_1:;
        }
        }/* end if */

  LINE(295);
    {
    CLUREF T_2_1;
    T_2_1.num = dc.vec->data[3];
    if (T_2_1.num == true) {

  LINE(296);
        {
        CLUREF T_3_1;
        T_3_1.num = dc.vec->data[1];
        err = _chanOPabort(T_3_1);
        if (err != ERR_ok) goto ex_2;
        }
        }
    else {

  LINE(297);
        {
        CLUREF T_3_1;
        T_3_1.num = dc.vec->data[1];
        err = _chanOPclose(T_3_1);
        if (err != ERR_ok) goto ex_2;
        }
        }}/* end if */
        goto end_2;
        ex_2:
            if ((err == ERR_not_possible)) {
            CLUREF why;
            why.num = elist[0].num;

  LINE(299);
                {
                CLUREF T_2_1;
                CLUREF T_2_2;
                T_2_1.num = dc.vec->data[3];
                T_2_2.num = T_2_1.num ^ 1;
                if (T_2_2.num == true) {

  LINE(300);
                    {
                    dc.vec->data[3]  = true;
                    }

  LINE(301);
                    {
                    dc.vec->data[6]  = why.num;
                    }
                    }
                    }/* end if */
            }
            else if ((err == ERR_permanent)) {
            }
            else {
                goto ex_0;
            }
        end_2:;

  LINE(305);
    {
        {CLUREF T_1_1;
        T_1_1.num = dc.vec->data[6];
        why.num = T_1_1.num;
        }
        }

  LINE(306);
    {
    dc.vec->data[6]  = STR_channel_040is_040closed.num;
    }

  LINE(307);
    {
    dc.vec->data[2]  = true;
    }

  LINE(308);
    {
    CLUREF T_1_1;
    T_1_1.num = dc.vec->data[5];
    data_chanOPfree.num = T_1_1.num;
    }

  LINE(309);
    {
    data_chanOPisfree.tf = true;
    }

  LINE(310);
    {
    CLUREF T_1_1;
    T_1_1.num = dc.vec->data[3];
    if (T_1_1.num == true) {

  LINE(311);
        {
        elist[0] = why;
        {signal (ERR_not_possible);}}
        }
    else {

  LINE(312);
        {
        dc.vec->data[3]  = true;
        }
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE close ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[8];
} data_chan_OPS;

CLU_proc data_chan_oe_add_close = {{0,0,0,0}, data_chanOPadd_close, 0};
CLU_proc data_chan_oe_close = {{0,0,0,0}, data_chanOPclose, 0};
CLU_proc data_chan_oe_oneof2 = {{0,0,0,0}, data_chanOPoneof2, 0};
CLU_proc data_chan_oe_open = {{0,0,0,0}, data_chanOPopen, 0};
CLU_proc data_chan_oe_store_avec = {{0,0,0,0}, data_chanOPstore_avec, 0};
CLU_proc data_chan_oe_store_cell = {{0,0,0,0}, data_chanOPstore_cell, 0};
CLU_proc data_chan_oe_store_str = {{0,0,0,0}, data_chanOPstore_str, 0};
CLU_proc data_chan_oe_store_vec = {{0,0,0,0}, data_chanOPstore_vec, 0};

data_chan_OPS data_chan_ops_actual = {8, (OWNPTR)&data_chan_own_init, (OWNPTR)&data_chan_own_init, {
    {&data_chan_oe_add_close, "add_close"},
    {&data_chan_oe_close, "close"},
    {&data_chan_oe_oneof2, "oneof2"},
    {&data_chan_oe_open, "open"},
    {&data_chan_oe_store_avec, "store_avec"},
    {&data_chan_oe_store_cell, "store_cell"},
    {&data_chan_oe_store_str, "store_str"},
    {&data_chan_oe_store_vec, "store_vec"}}};

struct OPS *data_chan_ops = (struct OPS *)&data_chan_ops_actual;

/**** END CLUSTER data_chan ****/
