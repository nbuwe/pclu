
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


extern errcode intOPunparse();
extern errcode realOPunparse();
extern errcode pt_char();
extern errcode pt_str();
extern errcode idnOPget_str();
extern errcode pt_infixop();
extern errcode typespecOPget_abs();
extern errcode duOPget_unique();
extern errcode recordOPget_1();
extern errcode typekey_string();
extern errcode exprkey_string();
extern errcode stmtkey_string();
extern errcode defnkey_string();
extern errcode streamOPputs();
CLUREF STR_nil;
CLUREF STR_true;
CLUREF STR_false;
CLUREF STR__077_077_077;
CLUREF STR__176;
CLUREF STR__072_075;
CLUREF STR__072;
CLUREF STR__054;
CLUREF STR__073;
CLUREF STR__044;
CLUREF STR__056;
CLUREF STR__043;
CLUREF STR__050;
CLUREF STR__133;
CLUREF STR__173;
CLUREF STR__051;
CLUREF STR__135;
CLUREF STR__175;
CLUREF STR_any;
CLUREF STR_type;
CLUREF STR_cvt;
CLUREF STR_do;
CLUREF STR_end;
CLUREF STR_then;
CLUREF STR_elseif;
CLUREF STR_else;
CLUREF STR_tag;
CLUREF STR_in;
CLUREF STR_others;
CLUREF STR_except;
CLUREF STR_when;
CLUREF STR_returns;
CLUREF STR_signals;
CLUREF STR_resignal;
CLUREF STR_yields;
CLUREF STR_where;
CLUREF STR_is;
CLUREF STR_has;
static int pt_token_own_init = 0;

/**** BEGIN PROCEDURE pt_token ****/

errcode pt_token(t, st)
CLUREF t;
CLUREF st;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
    CLUREF x;
    CLUREF k;
    CLUREF clut;
        if (pt_token_own_init == 0) {
        stringOPcons("nil", CLU_1, CLU_3, &STR_nil);
        stringOPcons("true", CLU_1, CLU_4, &STR_true);
        stringOPcons("false", CLU_1, CLU_5, &STR_false);
        stringOPcons("???", CLU_1, CLU_3, &STR__077_077_077);
        stringOPcons("~", CLU_1, CLU_1, &STR__176);
        stringOPcons(":=", CLU_1, CLU_2, &STR__072_075);
        stringOPcons(":", CLU_1, CLU_1, &STR__072);
        stringOPcons(",", CLU_1, CLU_1, &STR__054);
        stringOPcons(";", CLU_1, CLU_1, &STR__073);
        stringOPcons("$", CLU_1, CLU_1, &STR__044);
        stringOPcons(".", CLU_1, CLU_1, &STR__056);
        stringOPcons("#", CLU_1, CLU_1, &STR__043);
        stringOPcons("(", CLU_1, CLU_1, &STR__050);
        stringOPcons("[", CLU_1, CLU_1, &STR__133);
        stringOPcons("{", CLU_1, CLU_1, &STR__173);
        stringOPcons(")", CLU_1, CLU_1, &STR__051);
        stringOPcons("]", CLU_1, CLU_1, &STR__135);
        stringOPcons("}", CLU_1, CLU_1, &STR__175);
        stringOPcons("any", CLU_1, CLU_3, &STR_any);
        stringOPcons("type", CLU_1, CLU_4, &STR_type);
        stringOPcons("cvt", CLU_1, CLU_3, &STR_cvt);
        stringOPcons("do", CLU_1, CLU_2, &STR_do);
        stringOPcons("end", CLU_1, CLU_3, &STR_end);
        stringOPcons("then", CLU_1, CLU_4, &STR_then);
        stringOPcons("elseif", CLU_1, CLU_6, &STR_elseif);
        stringOPcons("else", CLU_1, CLU_4, &STR_else);
        stringOPcons("tag", CLU_1, CLU_3, &STR_tag);
        stringOPcons("in", CLU_1, CLU_2, &STR_in);
        stringOPcons("others", CLU_1, CLU_6, &STR_others);
        stringOPcons("except", CLU_1, CLU_6, &STR_except);
        stringOPcons("when", CLU_1, CLU_4, &STR_when);
        stringOPcons("returns", CLU_1, CLU_7, &STR_returns);
        stringOPcons("signals", CLU_1, CLU_7, &STR_signals);
        stringOPcons("resignal", CLU_1, CLU_8, &STR_resignal);
        stringOPcons("yields", CLU_1, CLU_6, &STR_yields);
        stringOPcons("where", CLU_1, CLU_5, &STR_where);
        stringOPcons("is", CLU_1, CLU_2, &STR_is);
        stringOPcons("has", CLU_1, CLU_3, &STR_has);
        pt_token_own_init = 1;
    }
    enter_proc(6);

  LINE(8);
    {
    switch (t.cell->tag) {
    case 13: 
         {CLUREF T_1_1;
        T_1_1.num = t.cell->value;
        x.num = T_1_1.num;

  LINE(10);
            {
            switch (x.cell->tag) {
            case 19: 
                 {

  LINE(12);
                    {
                    s = STR_nil;
                    }
                    break;
                    }
            case 5: 
                 {CLUREF T_2_1;
                T_2_1.num = x.cell->value;
                k.num = T_2_1.num;

  LINE(14);
                    {
                    if (k.num == true) {

  LINE(15);
                        {
                        s = STR_true;
                        }
                        }
                    else {

  LINE(16);
                        {
                        s = STR_false;
                        }
                        }}/* end if */
                    break;
                    }
            case 15: 
                 {CLUREF T_2_2;
                T_2_2.num = x.cell->value;
                k.num = T_2_2.num;

  LINE(19);
                    {
                    CLUREF T_3_1;
                    err = intOPunparse(k, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    s.num = T_3_1.num;
                    }
                    break;
                    }
            case 21: 
                 {CLUREF T_2_3;
                T_2_3.num = x.cell->value;
                k.num = T_2_3.num;

  LINE(21);
                    {
                    CLUREF T_3_1;
                    err = realOPunparse(k, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    s.num = T_3_1.num;
                    }
                    break;
                    }
            case 7: 
                 {CLUREF T_2_4;
                T_2_4.num = x.cell->value;
                k.num = T_2_4.num;

  LINE(23);
                    {
                    err = pt_char(k, st);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(24);
                    {
                    {signal (ERR_ok);}}
                    break;
                    }
            case 24: 
                 {CLUREF T_2_5;
                T_2_5.num = x.cell->value;
                k.num = T_2_5.num;

  LINE(26);
                    {
                    err = pt_str(k, st);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(27);
                    {
                    {signal (ERR_ok);}}
                    break;
                    }
            default: {

  LINE(29);
                {
                s = STR__077_077_077;
                }
            }
            }
            }
            break;
            }
    case 16: 
         {CLUREF T_1_2;
        T_1_2.num = t.cell->value;
        k.num = T_1_2.num;

  LINE(32);
            {
            CLUREF T_2_1;
            err = idnOPget_str(k, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            s.num = T_2_1.num;
            }
            break;
            }
    case 11: 
    case 23: 
         {CLUREF T_1_3;
        T_1_3.num = t.cell->value;
        k.num = T_1_3.num;

  LINE(34);
            {
            err = pt_infixop(k, st);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(35);
            {
            {signal (ERR_ok);}}
            break;
            }
    case 22: 
         {

  LINE(36);
            {
            s = STR__176;
            }
            break;
            }
    case 1: 
         {

  LINE(37);
            {
            s = STR__072_075;
            }
            break;
            }
    case 2: 
         {

  LINE(38);
            {
            s = STR__072;
            }
            break;
            }
    case 3: 
         {

  LINE(39);
            {
            s = STR__054;
            }
            break;
            }
    case 31: 
         {

  LINE(40);
            {
            s = STR__073;
            }
            break;
            }
    case 6: 
         {

  LINE(41);
            {
            s = STR__044;
            }
            break;
            }
    case 25: 
         {

  LINE(42);
            {
            s = STR__056;
            }
            break;
            }
    case 32: 
         {

  LINE(43);
            {
            s = STR__043;
            }
            break;
            }
    case 21: 
         {

  LINE(44);
            {
            s = STR__050;
            }
            break;
            }
    case 19: 
         {

  LINE(45);
            {
            s = STR__133;
            }
            break;
            }
    case 20: 
         {

  LINE(46);
            {
            s = STR__173;
            }
            break;
            }
    case 28: 
         {

  LINE(47);
            {
            s = STR__051;
            }
            break;
            }
    case 26: 
         {

  LINE(48);
            {
            s = STR__135;
            }
            break;
            }
    case 27: 
         {

  LINE(49);
            {
            s = STR__175;
            }
            break;
            }
    case 37: 
         {CLUREF T_1_4;
        T_1_4.num = t.cell->value;
        k.num = T_1_4.num;

  LINE(51);
            {
            CLUREF T_2_1;
            err = typespecOPget_abs(k, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_1.cell->tag) {
            case 3: 
                 {CLUREF T_2_2;
                T_2_2.num = T_2_1.cell->value;
                clut.num = T_2_2.num;

  LINE(53);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    T_3_1.num = clut.vec->data[0];
                    err = duOPget_unique(T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    s.num = T_3_2.num;
                    }
                    break;
                    }
            case 1: 
                 {

  LINE(55);
                    {
                    s = STR_any;
                    }
                    break;
                    }
            case 8: 
                 {

  LINE(57);
                    {
                    s = STR_type;
                    }
                    break;
                    }
            case 4: 
                 {

  LINE(59);
                    {
                    s = STR_cvt;
                    }
                    break;
                    }
            default: {

  LINE(61);
                {
                s = STR__077_077_077;
                }
            }
            }
            }
            break;
            }
    case 38: 
         {CLUREF T_1_5;
        T_1_5.num = t.cell->value;
        k.num = T_1_5.num;

  LINE(64);
            {
            CLUREF T_2_1;
            err = typekey_string(k, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            s.num = T_2_1.num;
            }
            break;
            }
    case 14: 
         {CLUREF T_1_6;
        T_1_6.num = t.cell->value;
        k.num = T_1_6.num;

  LINE(66);
            {
            CLUREF T_2_1;
            err = exprkey_string(k, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            s.num = T_2_1.num;
            }
            break;
            }
    case 34: 
         {CLUREF T_1_7;
        T_1_7.num = t.cell->value;
        k.num = T_1_7.num;

  LINE(68);
            {
            CLUREF T_2_1;
            err = stmtkey_string(k, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            s.num = T_2_1.num;
            }
            break;
            }
    case 4: 
         {CLUREF T_1_8;
        T_1_8.num = t.cell->value;
        k.num = T_1_8.num;

  LINE(70);
            {
            CLUREF T_2_1;
            err = defnkey_string(k, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            s.num = T_2_1.num;
            }
            break;
            }
    case 5: 
         {

  LINE(71);
            {
            s = STR_do;
            }
            break;
            }
    case 9: 
         {

  LINE(72);
            {
            s = STR_end;
            }
            break;
            }
    case 36: 
         {

  LINE(73);
            {
            s = STR_then;
            }
            break;
            }
    case 8: 
         {

  LINE(74);
            {
            s = STR_elseif;
            }
            break;
            }
    case 7: 
         {

  LINE(75);
            {
            s = STR_else;
            }
            break;
            }
    case 35: 
         {

  LINE(76);
            {
            s = STR_tag;
            }
            break;
            }
    case 17: 
         {

  LINE(77);
            {
            s = STR_in;
            }
            break;
            }
    case 24: 
         {

  LINE(78);
            {
            s = STR_others;
            }
            break;
            }
    case 12: 
         {

  LINE(79);
            {
            s = STR_except;
            }
            break;
            }
    case 39: 
         {

  LINE(80);
            {
            s = STR_when;
            }
            break;
            }
    case 30: 
         {

  LINE(81);
            {
            s = STR_returns;
            }
            break;
            }
    case 33: 
         {

  LINE(82);
            {
            s = STR_signals;
            }
            break;
            }
    case 29: 
         {

  LINE(83);
            {
            s = STR_resignal;
            }
            break;
            }
    case 41: 
         {

  LINE(84);
            {
            s = STR_yields;
            }
            break;
            }
    case 40: 
         {

  LINE(85);
            {
            s = STR_where;
            }
            break;
            }
    case 18: 
         {

  LINE(86);
            {
            s = STR_is;
            }
            break;
            }
    case 15: 
         {

  LINE(87);
            {
            s = STR_has;
            }
            break;
            }
    case 10: 
         {

  LINE(88);
            {
            {signal (ERR_ok);}}
            break;
            }
    }
    }

  LINE(90);
    {
    err = streamOPputs(st, s);
    if (err != ERR_ok) goto ex_1;
    }
        goto end_1;
        ex_1:
            if ((err == ERR_not_possible)) {
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE pt_token ****/


CLUREF STR_rep;
static int typekey_string_own_init = 0;

/**** BEGIN PROCEDURE typekey_string ****/

errcode typekey_string(k, ret_1)
CLUREF k;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
    CLUREF d;
        if (typekey_string_own_init == 0) {
        stringOPcons("rep", CLU_1, CLU_3, &STR_rep);
        typekey_string_own_init = 1;
    }
    enter_proc(94);

  LINE(96);
    {
    switch (k.cell->tag) {
    case 2: 
    case 4: 
    case 1: 
         {CLUREF T_1_1;
        T_1_1.num = k.cell->value;
        d.num = T_1_1.num;

  LINE(98);
            {
            CLUREF T_2_1;
            err = duOPget_unique(d, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            s.num = T_2_1.num;
            }
            break;
            }
    case 3: 
         {

  LINE(100);
            {
            s = STR_rep;
            }
            break;
            }
    }
    }

  LINE(102);
    {
    {
    ret_1->num = s.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE typekey_string ****/


CLUREF STR_force;
CLUREF STR_type_137of;
CLUREF STR_up;
CLUREF STR_down;
static int exprkey_string_own_init = 0;

/**** BEGIN PROCEDURE exprkey_string ****/

errcode exprkey_string(k, ret_1)
CLUREF k;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
        if (exprkey_string_own_init == 0) {
        stringOPcons("force", CLU_1, CLU_5, &STR_force);
        stringOPcons("type_of", CLU_1, CLU_7, &STR_type_137of);
        stringOPcons("up", CLU_1, CLU_2, &STR_up);
        stringOPcons("down", CLU_1, CLU_4, &STR_down);
        exprkey_string_own_init = 1;
    }
    enter_proc(105);

  LINE(107);
    {
    switch (k.cell->tag) {
    case 2: 
         {

  LINE(108);
            {
            s = STR_force;
            }
            break;
            }
    case 3: 
         {

  LINE(109);
            {
            s = STR_type_137of;
            }
            break;
            }
    case 4: 
         {

  LINE(110);
            {
            s = STR_up;
            }
            break;
            }
    case 1: 
         {

  LINE(111);
            {
            s = STR_down;
            }
            break;
            }
    }
    }

  LINE(113);
    {
    {
    ret_1->num = s.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE exprkey_string ****/


CLUREF STR_if;
CLUREF STR_for;
CLUREF STR_tagcase;
CLUREF STR_while;
CLUREF STR_return;
CLUREF STR_yield;
CLUREF STR_signal;
CLUREF STR_exit;
CLUREF STR_break;
CLUREF STR_continue;
CLUREF STR_begin;
CLUREF STR_own;
static int stmtkey_string_own_init = 0;

/**** BEGIN PROCEDURE stmtkey_string ****/

errcode stmtkey_string(k, ret_1)
CLUREF k;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
        if (stmtkey_string_own_init == 0) {
        stringOPcons("if", CLU_1, CLU_2, &STR_if);
        stringOPcons("for", CLU_1, CLU_3, &STR_for);
        stringOPcons("tagcase", CLU_1, CLU_7, &STR_tagcase);
        stringOPcons("while", CLU_1, CLU_5, &STR_while);
        stringOPcons("return", CLU_1, CLU_6, &STR_return);
        stringOPcons("yield", CLU_1, CLU_5, &STR_yield);
        stringOPcons("signal", CLU_1, CLU_6, &STR_signal);
        stringOPcons("exit", CLU_1, CLU_4, &STR_exit);
        stringOPcons("break", CLU_1, CLU_5, &STR_break);
        stringOPcons("continue", CLU_1, CLU_8, &STR_continue);
        stringOPcons("begin", CLU_1, CLU_5, &STR_begin);
        stringOPcons("own", CLU_1, CLU_3, &STR_own);
        stmtkey_string_own_init = 1;
    }
    enter_proc(116);

  LINE(118);
    {
    switch (k.cell->tag) {
    case 6: 
         {

  LINE(119);
            {
            s = STR_if;
            }
            break;
            }
    case 5: 
         {

  LINE(120);
            {
            s = STR_for;
            }
            break;
            }
    case 10: 
         {

  LINE(121);
            {
            s = STR_tagcase;
            }
            break;
            }
    case 11: 
         {

  LINE(122);
            {
            s = STR_while;
            }
            break;
            }
    case 8: 
         {

  LINE(123);
            {
            s = STR_return;
            }
            break;
            }
    case 12: 
         {

  LINE(124);
            {
            s = STR_yield;
            }
            break;
            }
    case 9: 
         {

  LINE(125);
            {
            s = STR_signal;
            }
            break;
            }
    case 4: 
         {

  LINE(126);
            {
            s = STR_exit;
            }
            break;
            }
    case 2: 
         {

  LINE(127);
            {
            s = STR_break;
            }
            break;
            }
    case 3: 
         {

  LINE(128);
            {
            s = STR_continue;
            }
            break;
            }
    case 1: 
         {

  LINE(129);
            {
            s = STR_begin;
            }
            break;
            }
    case 7: 
         {

  LINE(130);
            {
            s = STR_own;
            }
            break;
            }
    }
    }

  LINE(132);
    {
    {
    ret_1->num = s.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE stmtkey_string ****/


CLUREF STR_proc;
CLUREF STR_iter;
CLUREF STR_cluster;
CLUREF STR_selector;
CLUREF STR_applytype;
static int defnkey_string_own_init = 0;

/**** BEGIN PROCEDURE defnkey_string ****/

errcode defnkey_string(k, ret_1)
CLUREF k;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
        if (defnkey_string_own_init == 0) {
        stringOPcons("proc", CLU_1, CLU_4, &STR_proc);
        stringOPcons("iter", CLU_1, CLU_4, &STR_iter);
        stringOPcons("cluster", CLU_1, CLU_7, &STR_cluster);
        stringOPcons("selector", CLU_1, CLU_8, &STR_selector);
        stringOPcons("applytype", CLU_1, CLU_9, &STR_applytype);
        defnkey_string_own_init = 1;
    }
    enter_proc(135);

  LINE(137);
    {
    switch (k.cell->tag) {
    case 4: 
         {

  LINE(138);
            {
            s = STR_proc;
            }
            break;
            }
    case 3: 
         {

  LINE(139);
            {
            s = STR_iter;
            }
            break;
            }
    case 2: 
         {

  LINE(140);
            {
            s = STR_cluster;
            }
            break;
            }
    case 5: 
         {

  LINE(141);
            {
            s = STR_selector;
            }
            break;
            }
    case 1: 
         {

  LINE(142);
            {
            s = STR_applytype;
            }
            break;
            }
    }
    }

  LINE(144);
    {
    {
    ret_1->num = s.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE defnkey_string ****/


extern errcode streamOPputc();
extern errcode pt_charseq();

/**** BEGIN PROCEDURE pt_str ****/

errcode pt_str(s, st)
CLUREF s;
CLUREF st;
    {
    errcode err;
    errcode ecode2;
    enter_proc(147);

  LINE(148);
    {

  LINE(149);
        {
        CLUREF T_3_1;
        T_3_1.ch = '\"';
        err = streamOPputc(st, T_3_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(150);
        {
        err = pt_charseq(s, CLU_1, st);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(151);
        {
        CLUREF T_3_1;
        T_3_1.ch = '\"';
        err = streamOPputc(st, T_3_1);
        if (err != ERR_ok) goto ex_1;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_not_possible)) {
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE pt_str ****/


extern errcode stringOPc2s();
CLUREF STR__047;
static int pt_char_own_init = 0;

/**** BEGIN PROCEDURE pt_char ****/

errcode pt_char(c, st)
CLUREF c;
CLUREF st;
    {
    errcode err;
    errcode ecode2;
        if (pt_char_own_init == 0) {
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        pt_char_own_init = 1;
    }
    enter_proc(155);

  LINE(156);
    {

  LINE(157);
        {
        err = streamOPputs(st, STR__047);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(158);
        {
        CLUREF T_3_1;
        err = stringOPc2s(c, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        err = pt_charseq(T_3_1, CLU_0, st);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(159);
        {
        err = streamOPputs(st, STR__047);
        if (err != ERR_ok) goto ex_1;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_not_possible)) {
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE pt_char ****/


extern errcode pt_charseq_IB_1();
extern errcode stringOPchars();
extern errcode charOPlt();
extern errcode charOPi2c();
extern errcode intOPadd();
extern errcode charOPc2i();
extern errcode charOPequal();
extern errcode intOPlt();
extern errcode intOPequal();
extern errcode intOPmod();
extern errcode intOPsub();
CLUREF STR__134_136;
CLUREF STR__134_042;
CLUREF STR__134_047;
CLUREF STR__134_134;
CLUREF STR__134_136_077;
CLUREF STR__134_041;
CLUREF STR__134_046;
static int pt_charseq_own_init = 0;

/**** BEGIN PROCEDURE pt_charseq ****/

errcode pt_charseq(s, is_str, st)
CLUREF s;
CLUREF is_str;
CLUREF st;
    {
    struct {
        errcode err;
        errcode ecode2;
        CLUREF c;
        CLUREF i;
        CLUREF s;
        CLUREF is_str;
        CLUREF st;
        } locals;
    locals.s = s;
    locals.is_str = is_str;
    locals.st = st;
        if (pt_charseq_own_init == 0) {
        stringOPcons("\\^", CLU_1, CLU_2, &STR__134_136);
        stringOPcons("\\\"", CLU_1, CLU_2, &STR__134_042);
        stringOPcons("\\\'", CLU_1, CLU_2, &STR__134_047);
        stringOPcons("\\\\", CLU_1, CLU_2, &STR__134_134);
        stringOPcons("\\^?", CLU_1, CLU_3, &STR__134_136_077);
        stringOPcons("\\!", CLU_1, CLU_2, &STR__134_041);
        stringOPcons("\\&", CLU_1, CLU_2, &STR__134_046);
        pt_charseq_own_init = 1;
    }
    enter_proc(163);

  LINE(164);
    {
        locals.err = stringOPchars(locals.s, pt_charseq_IB_1, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {
        signal(ERR_ok);}
        if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
        if (locals.err == ERR_break) locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
        if (locals.err != ERR_ok) goto ex_1;
        }
        goto end_1;
        ex_1:
            if ((locals.err == ERR_not_possible)) {
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE pt_charseq ****/


/**** BEGIN ITERATOR BODIES for pt_charseq ****/

errcode pt_charseq_IB_1(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    errcode err;
    errcode ecode2;
    CLUREF c;
    CLUREF i;
    CLUREF s;
    CLUREF is_str;
    CLUREF st;
    } *locals;
{
    locals->c.num = iv_1.num;
    enter_iter_body_proc(165);

  FB_LINE(165);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = ' ';
    locals->err = charOPlt(locals->c, T_1_1, &T_1_2);
    if (locals->err != ERR_ok) goto ex_0;
    if (T_1_2.num == true) {

  FB_LINE(166);
        {
        locals->err = streamOPputs(locals->st, STR__134_136);
        if (locals->err != ERR_ok) goto ex_0;
        }

  FB_LINE(167);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.num = (long)(locals->c.ch & 0xff);
        T_2_2.num = 64;
        T_2_3.num = T_2_1.num + T_2_2.num;
         if ((T_2_3.num > 0 && T_2_1.num < 0 && T_2_2.num < 0) || 
             (T_2_3.num < 0 && T_2_1.num > 0 && T_2_2.num > 0)) {
            locals->err = ERR_overflow;
            goto ex_0;}
        locals->err = charOPi2c(T_2_3, &T_2_4);
        if (locals->err != ERR_ok) goto ex_0;
        locals->err = streamOPputc(locals->st, T_2_4);
        if (locals->err != ERR_ok) goto ex_0;
        }
        }
    else {
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_3.ch = '\"';
    T_1_4.num = (locals->c.ch == T_1_3.ch)? true : false;
    if (T_1_4.num == true) {

  FB_LINE(169);
        {
        if (locals->is_str.num == true) {

  FB_LINE(170);
            {
            locals->err = streamOPputs(locals->st, STR__134_042);
            if (locals->err != ERR_ok) goto ex_0;
            }
            }
        else {

  FB_LINE(171);
            {
            CLUREF T_3_1;
            T_3_1.ch = '\"';
            locals->err = streamOPputc(locals->st, T_3_1);
            if (locals->err != ERR_ok) goto ex_0;
            }
            }}/* end if */
        }
    else {
    CLUREF T_1_5;
    CLUREF T_1_6;
    T_1_5.ch = '\'';
    T_1_6.num = (locals->c.ch == T_1_5.ch)? true : false;
    if (T_1_6.num == true) {

  FB_LINE(174);
        {
        if (locals->is_str.num == true) {

  FB_LINE(175);
            {
            CLUREF T_3_1;
            T_3_1.ch = '\'';
            locals->err = streamOPputc(locals->st, T_3_1);
            if (locals->err != ERR_ok) goto ex_0;
            }
            }
        else {

  FB_LINE(176);
            {
            locals->err = streamOPputs(locals->st, STR__134_047);
            if (locals->err != ERR_ok) goto ex_0;
            }
            }}/* end if */
        }
    else {
    CLUREF T_1_7;
    CLUREF T_1_8;
    T_1_7.ch = '\\';
    T_1_8.num = (locals->c.ch == T_1_7.ch)? true : false;
    if (T_1_8.num == true) {

  FB_LINE(179);
        {
        locals->err = streamOPputs(locals->st, STR__134_134);
        if (locals->err != ERR_ok) goto ex_0;
        }
        }
    else {
    CLUREF T_1_9;
    CLUREF T_1_10;
    T_1_9.ch = '\177';
    locals->err = charOPlt(locals->c, T_1_9, &T_1_10);
    if (locals->err != ERR_ok) goto ex_0;
    if (T_1_10.num == true) {

  FB_LINE(181);
        {
        locals->err = streamOPputc(locals->st, locals->c);
        if (locals->err != ERR_ok) goto ex_0;
        }
        }
    else {
    CLUREF T_1_11;
    CLUREF T_1_12;
    T_1_11.ch = '\177';
    T_1_12.num = (locals->c.ch == T_1_11.ch)? true : false;
    if (T_1_12.num == true) {

  FB_LINE(183);
        {
        locals->err = streamOPputs(locals->st, STR__134_136_077);
        if (locals->err != ERR_ok) goto ex_0;
        }
        }
    else {

  FB_LINE(184);
        {
            {CLUREF T_2_1;
            T_2_1.num = (long)(locals->c.ch & 0xff);
            locals->i.num = T_2_1.num;
            }
            }

  FB_LINE(185);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_2.num = 160;
        T_2_3.num = (locals->i.num < T_2_2.num)? true : false;
        T_2_1.num = T_2_3.num;
        if (!T_2_3.num) {
            T_2_4.num = 255;
            T_2_5.num = (locals->i.num == T_2_4.num)? true : false;
            T_2_1.num = T_2_5.num;
        }
        if (T_2_1.num == true) {

  FB_LINE(186);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_1.num = 64;
            T_3_2.num = locals->i.num - T_3_1.num;
             if ((T_3_2.num >= 0 && locals->i.num < 0 && (-T_3_1.num) < 0) || 
                 (T_3_2.num <= 0 && locals->i.num > 0 && (-T_3_1.num) > 0)) {
                locals->err = ERR_overflow;
                goto ex_0;}
            T_3_3.num = 128;
            locals->err = intOPmod(T_3_2, T_3_3, &T_3_4);
            if (locals->err != ERR_ok) goto ex_0;
            locals->i.num = T_3_4.num;
            }

  FB_LINE(187);
            {
            locals->err = streamOPputs(locals->st, STR__134_041);
            if (locals->err != ERR_ok) goto ex_0;
            }
            }
        else {

  FB_LINE(188);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = 128;
            T_3_2.num = locals->i.num - T_3_1.num;
             if ((T_3_2.num >= 0 && locals->i.num < 0 && (-T_3_1.num) < 0) || 
                 (T_3_2.num <= 0 && locals->i.num > 0 && (-T_3_1.num) > 0)) {
                locals->err = ERR_overflow;
                goto ex_0;}
            locals->i.num = T_3_2.num;
            }

  FB_LINE(189);
            {
            locals->err = streamOPputs(locals->st, STR__134_046);
            if (locals->err != ERR_ok) goto ex_0;
            }
            }}/* end if */

  FB_LINE(191);
        {
        CLUREF T_2_1;
        locals->err = charOPi2c(locals->i, &T_2_1);
        if (locals->err != ERR_ok) goto ex_0;
        locals->err = streamOPputc(locals->st, T_2_1);
        if (locals->err != ERR_ok) goto ex_0;
        }
        }}}}}}}/* end if */
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end pt_charseq_IB_1 */

/**** END ITERATOR BODIES for pt_charseq ****/


extern errcode structOPget_2();
extern errcode stringOPequal();
extern errcode structOPget_1();
CLUREF STR_power;
CLUREF STR__052_052;
CLUREF STR_mod;
CLUREF STR__057_057;
CLUREF STR_div;
CLUREF STR__057;
CLUREF STR_mul;
CLUREF STR__052;
CLUREF STR_concat;
CLUREF STR__174_174;
CLUREF STR_add;
CLUREF STR__053;
CLUREF STR_sub;
CLUREF STR__055;
CLUREF STR_lt;
CLUREF STR__074;
CLUREF STR_le;
CLUREF STR__074_075;
CLUREF STR_gt;
CLUREF STR__076;
CLUREF STR_ge;
CLUREF STR__076_075;
CLUREF STR_equal;
CLUREF STR__075;
CLUREF STR_and;
CLUREF STR__046;
CLUREF STR_cand;
CLUREF STR_or;
CLUREF STR__174;
CLUREF STR_cor;
static int pt_infixop_own_init = 0;

/**** BEGIN PROCEDURE pt_infixop ****/

errcode pt_infixop(op, st)
CLUREF op;
CLUREF st;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
        if (pt_infixop_own_init == 0) {
        stringOPcons("power", CLU_1, CLU_5, &STR_power);
        stringOPcons("**", CLU_1, CLU_2, &STR__052_052);
        stringOPcons("mod", CLU_1, CLU_3, &STR_mod);
        stringOPcons("//", CLU_1, CLU_2, &STR__057_057);
        stringOPcons("div", CLU_1, CLU_3, &STR_div);
        stringOPcons("/", CLU_1, CLU_1, &STR__057);
        stringOPcons("mul", CLU_1, CLU_3, &STR_mul);
        stringOPcons("*", CLU_1, CLU_1, &STR__052);
        stringOPcons("concat", CLU_1, CLU_6, &STR_concat);
        stringOPcons("||", CLU_1, CLU_2, &STR__174_174);
        stringOPcons("add", CLU_1, CLU_3, &STR_add);
        stringOPcons("+", CLU_1, CLU_1, &STR__053);
        stringOPcons("sub", CLU_1, CLU_3, &STR_sub);
        stringOPcons("-", CLU_1, CLU_1, &STR__055);
        stringOPcons("lt", CLU_1, CLU_2, &STR_lt);
        stringOPcons("<", CLU_1, CLU_1, &STR__074);
        stringOPcons("le", CLU_1, CLU_2, &STR_le);
        stringOPcons("<=", CLU_1, CLU_2, &STR__074_075);
        stringOPcons("gt", CLU_1, CLU_2, &STR_gt);
        stringOPcons(">", CLU_1, CLU_1, &STR__076);
        stringOPcons("ge", CLU_1, CLU_2, &STR_ge);
        stringOPcons(">=", CLU_1, CLU_2, &STR__076_075);
        stringOPcons("equal", CLU_1, CLU_5, &STR_equal);
        stringOPcons("=", CLU_1, CLU_1, &STR__075);
        stringOPcons("and", CLU_1, CLU_3, &STR_and);
        stringOPcons("&", CLU_1, CLU_1, &STR__046);
        stringOPcons("cand", CLU_1, CLU_4, &STR_cand);
        stringOPcons("or", CLU_1, CLU_2, &STR_or);
        stringOPcons("|", CLU_1, CLU_1, &STR__174);
        stringOPcons("cor", CLU_1, CLU_3, &STR_cor);
        pt_infixop_own_init = 1;
    }
    enter_proc(196);

  LINE(197);
    {
        {CLUREF T_1_1;
        T_1_1.num = op.vec->data[1];
        s.num = T_1_1.num;
        }
        }

  LINE(198);
    {
    CLUREF T_1_1;
    T_1_1.num = ((s.str->size != STR_power.str->size)? false :
        !(bcmp(s.str->data, STR_power.str->data, s.str->size)));
    if (T_1_1.num == true) {
        {
        s = STR__052_052;
        }
        }
    else {
    CLUREF T_1_2;
    T_1_2.num = ((s.str->size != STR_mod.str->size)? false :
        !(bcmp(s.str->data, STR_mod.str->data, s.str->size)));
    if (T_1_2.num == true) {

  LINE(199);
        {
        s = STR__057_057;
        }
        }
    else {
    CLUREF T_1_3;
    T_1_3.num = ((s.str->size != STR_div.str->size)? false :
        !(bcmp(s.str->data, STR_div.str->data, s.str->size)));
    if (T_1_3.num == true) {

  LINE(200);
        {
        s = STR__057;
        }
        }
    else {
    CLUREF T_1_4;
    T_1_4.num = ((s.str->size != STR_mul.str->size)? false :
        !(bcmp(s.str->data, STR_mul.str->data, s.str->size)));
    if (T_1_4.num == true) {

  LINE(201);
        {
        s = STR__052;
        }
        }
    else {
    CLUREF T_1_5;
    T_1_5.num = ((s.str->size != STR_concat.str->size)? false :
        !(bcmp(s.str->data, STR_concat.str->data, s.str->size)));
    if (T_1_5.num == true) {

  LINE(202);
        {
        s = STR__174_174;
        }
        }
    else {
    CLUREF T_1_6;
    T_1_6.num = ((s.str->size != STR_add.str->size)? false :
        !(bcmp(s.str->data, STR_add.str->data, s.str->size)));
    if (T_1_6.num == true) {

  LINE(203);
        {
        s = STR__053;
        }
        }
    else {
    CLUREF T_1_7;
    T_1_7.num = ((s.str->size != STR_sub.str->size)? false :
        !(bcmp(s.str->data, STR_sub.str->data, s.str->size)));
    if (T_1_7.num == true) {

  LINE(204);
        {
        s = STR__055;
        }
        }
    else {
    CLUREF T_1_8;
    T_1_8.num = ((s.str->size != STR_lt.str->size)? false :
        !(bcmp(s.str->data, STR_lt.str->data, s.str->size)));
    if (T_1_8.num == true) {

  LINE(205);
        {
        s = STR__074;
        }
        }
    else {
    CLUREF T_1_9;
    T_1_9.num = ((s.str->size != STR_le.str->size)? false :
        !(bcmp(s.str->data, STR_le.str->data, s.str->size)));
    if (T_1_9.num == true) {

  LINE(206);
        {
        s = STR__074_075;
        }
        }
    else {
    CLUREF T_1_10;
    T_1_10.num = ((s.str->size != STR_gt.str->size)? false :
        !(bcmp(s.str->data, STR_gt.str->data, s.str->size)));
    if (T_1_10.num == true) {

  LINE(207);
        {
        s = STR__076;
        }
        }
    else {
    CLUREF T_1_11;
    T_1_11.num = ((s.str->size != STR_ge.str->size)? false :
        !(bcmp(s.str->data, STR_ge.str->data, s.str->size)));
    if (T_1_11.num == true) {

  LINE(208);
        {
        s = STR__076_075;
        }
        }
    else {
    CLUREF T_1_12;
    T_1_12.num = ((s.str->size != STR_equal.str->size)? false :
        !(bcmp(s.str->data, STR_equal.str->data, s.str->size)));
    if (T_1_12.num == true) {

  LINE(209);
        {
        s = STR__075;
        }
        }
    else {
    CLUREF T_1_13;
    T_1_13.num = ((s.str->size != STR_and.str->size)? false :
        !(bcmp(s.str->data, STR_and.str->data, s.str->size)));
    if (T_1_13.num == true) {

  LINE(210);
        {
        s = STR__046;
        }
        }
    else {
    CLUREF T_1_14;
    T_1_14.num = ((s.str->size != STR_cand.str->size)? false :
        !(bcmp(s.str->data, STR_cand.str->data, s.str->size)));
    if (T_1_14.num == true) {

  LINE(211);
        {
        s = STR_cand;
        }
        }
    else {
    CLUREF T_1_15;
    T_1_15.num = ((s.str->size != STR_or.str->size)? false :
        !(bcmp(s.str->data, STR_or.str->data, s.str->size)));
    if (T_1_15.num == true) {

  LINE(212);
        {
        s = STR__174;
        }
        }
    else {

  LINE(213);
        {
        s = STR_cor;
        }
        }}}}}}}}}}}}}}}}/* end if */

  LINE(214);
    {
    CLUREF T_1_1;
    T_1_1.num = op.vec->data[0];
    if (T_1_1.num == true) {

  LINE(215);
        {
        CLUREF T_3_1;
        T_3_1.ch = '~';
        err = streamOPputc(st, T_3_1);
        if (err != ERR_ok) goto ex_1;
        }
            goto end_1;
            ex_1:
                if ((err == ERR_not_possible)) {
                }
                else {
                    goto ex_0;
                }
            end_1:;
        }
        }/* end if */

  LINE(218);
    {
    err = streamOPputs(st, s);
    if (err != ERR_ok) goto ex_2;
    }
        goto end_2;
        ex_2:
            if ((err == ERR_not_possible)) {
            }
            else {
                goto ex_0;
            }
        end_2:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE pt_infixop ****/

