
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


extern errcode c_envOPbegin_scope();
extern errcode c_envOPequates();
extern errcode recordOPget_1();
extern errcode sequenceOPelements();
extern errcode recordOPget_2();
extern errcode c_stmt();
extern errcode c_envOPend_scope();

/**** BEGIN PROCEDURE c_body ****/

errcode c_body(e, b)
CLUREF e;
CLUREF b;
    {
    errcode err;
    errcode ecode2;
    CLUREF s;
    enter_proc(6);

  LINE(7);
    {
    err = c_envOPbegin_scope(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(8);
    {
    CLUREF T_1_1;
    T_1_1.num = b.vec->data[0];
    err = c_envOPequates(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(9);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = b.vec->data[1];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            s.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(10);
            {
            err = c_stmt(e, s);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(12);
    {
    err = c_envOPend_scope(e);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_body ****/


extern errcode c_envOPset_line();
extern errcode stmtOPget_line();
extern errcode stmtOPget_abs();
extern errcode c_decl();
extern errcode c_declinit();
extern errcode c_assn();
extern errcode c_sugarassn();
extern errcode c_invoke();
extern errcode c_while();
extern errcode c_for();
extern errcode c_if();
extern errcode c_tagcase();
extern errcode stmtOPset_abs();
extern errcode oneofOPmake_15();
extern errcode c_return();
extern errcode oneofOPmake_20();
extern errcode c_yield();
extern errcode c_signal();
extern errcode c_exit();
extern errcode c_envOPbreak_illegal();
extern errcode c_envOPerr1();
extern errcode c_envOPcontinue_illegal();
extern errcode c_body();
extern errcode c_except();
extern errcode c_resignal();
extern errcode c_forcestmt();
CLUREF STR_break_040statement_040not_040inside_040a_040loop;
CLUREF STR_continue_040statement_040not_040inside_040a_040loop;
static int c_stmt_own_init = 0;

/**** BEGIN PROCEDURE c_stmt ****/

errcode c_stmt(e, s)
CLUREF e;
CLUREF s;
    {
    errcode err;
    errcode ecode2;
    CLUREF sa;
        if (c_stmt_own_init == 0) {
        stringOPcons("break statement not inside a loop", CLU_1, CLU_33, &STR_break_040statement_040not_040inside_040a_040loop);
        stringOPcons("continue statement not inside a loop", CLU_1, CLU_36, &STR_continue_040statement_040not_040inside_040a_040loop);
        c_stmt_own_init = 1;
    }
    enter_proc(15);

  LINE(16);
    {
    CLUREF T_1_1;
    err = stmtOPget_line(s, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = c_envOPset_line(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(17);
    {
    CLUREF T_1_1;
    err = stmtOPget_abs(s, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 6: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        sa.num = T_1_2.num;

  LINE(19);
            {
            err = c_decl(e, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 7: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        sa.num = T_1_3.num;

  LINE(21);
            {
            err = c_declinit(e, sa, CLU_0);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 1: 
         {CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        sa.num = T_1_4.num;

  LINE(23);
            {
            err = c_assn(e, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 17: 
         {CLUREF T_1_5;
        T_1_5.num = T_1_1.cell->value;
        sa.num = T_1_5.num;

  LINE(25);
            {
            err = c_sugarassn(e, s, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 13: 
         {CLUREF T_1_6;
        T_1_6.num = T_1_1.cell->value;
        sa.num = T_1_6.num;

  LINE(27);
            {
            CLUREF T_2_1;
            err = c_invoke(e, sa, CLU_0, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 19: 
         {CLUREF T_1_7;
        T_1_7.num = T_1_1.cell->value;
        sa.num = T_1_7.num;

  LINE(29);
            {
            err = c_while(e, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 10: 
         {CLUREF T_1_8;
        T_1_8.num = T_1_1.cell->value;
        sa.num = T_1_8.num;

  LINE(31);
            {
            err = c_for(e, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 12: 
         {CLUREF T_1_9;
        T_1_9.num = T_1_1.cell->value;
        sa.num = T_1_9.num;

  LINE(33);
            {
            err = c_if(e, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 18: 
         {CLUREF T_1_10;
        T_1_10.num = T_1_1.cell->value;
        sa.num = T_1_10.num;

  LINE(35);
            {
            err = c_tagcase(e, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 15: 
         {CLUREF T_1_11;
        T_1_11.num = T_1_1.cell->value;
        sa.num = T_1_11.num;

  LINE(37);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = c_return(e, sa, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            CellAlloc(15, T_2_1.num, T_2_2);
            err = stmtOPset_abs(s, T_2_2);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 20: 
         {CLUREF T_1_12;
        T_1_12.num = T_1_1.cell->value;
        sa.num = T_1_12.num;

  LINE(39);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = c_yield(e, sa, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            CellAlloc(20, T_2_1.num, T_2_2);
            err = stmtOPset_abs(s, T_2_2);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 16: 
         {CLUREF T_1_13;
        T_1_13.num = T_1_1.cell->value;
        sa.num = T_1_13.num;

  LINE(41);
            {
            err = c_signal(e, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 9: 
         {CLUREF T_1_14;
        T_1_14.num = T_1_1.cell->value;
        sa.num = T_1_14.num;

  LINE(43);
            {
            err = c_exit(e, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 4: 
         {

  LINE(45);
            {
            CLUREF T_2_1;
            err = c_envOPbreak_illegal(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            if (T_2_1.num == true) {

  LINE(46);
                {
                err = c_envOPerr1(e, STR_break_040statement_040not_040inside_040a_040loop);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */
            break;
            }
    case 5: 
         {

  LINE(48);
            {
            CLUREF T_2_1;
            err = c_envOPcontinue_illegal(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            if (T_2_1.num == true) {

  LINE(49);
                {
                err = c_envOPerr1(e, STR_continue_040statement_040not_040inside_040a_040loop);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */
            break;
            }
    case 3: 
         {CLUREF T_1_15;
        T_1_15.num = T_1_1.cell->value;
        sa.num = T_1_15.num;

  LINE(52);
            {
            err = c_body(e, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 8: 
         {CLUREF T_1_16;
        T_1_16.num = T_1_1.cell->value;
        sa.num = T_1_16.num;

  LINE(54);
            {
            err = c_except(e, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 14: 
         {CLUREF T_1_17;
        T_1_17.num = T_1_1.cell->value;
        sa.num = T_1_17.num;

  LINE(56);
            {
            err = c_resignal(e, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 11: 
         {CLUREF T_1_18;
        T_1_18.num = T_1_1.cell->value;
        sa.num = T_1_18.num;

  LINE(58);
            {
            err = c_forcestmt(e, sa);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    case 2: 
         {
            break;
            }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_stmt ****/


extern errcode c_type();
extern errcode recordOPset_2();
extern errcode c_envOPadd_var();

/**** BEGIN PROCEDURE c_decl ****/

errcode c_decl(e, d)
CLUREF e;
CLUREF d;
    {
    errcode err;
    errcode ecode2;
    CLUREF t;
    CLUREF i;
    enter_proc(63);

  LINE(64);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = d.vec->data[1];
        err = c_type(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        t.num = T_1_2.num;
        }
        }

  LINE(65);
    {
    d.vec->data[1]  = t.num;
    }

  LINE(66);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = d.vec->data[0];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            i.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(67);
            {
            err = c_envOPadd_var(e, i, t);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_decl ****/


extern errcode c_own_decls();
extern errcode c_decllist();
extern errcode recordOPget_3();
extern errcode exprOPget_abs();
extern errcode intOPgt();
extern errcode sequenceOPsize();
extern errcode sequenceOPbottom();
extern errcode c_expr();
extern errcode sequenceOPe2s();
extern errcode recordOPset_1();
extern errcode c_decl_assn();
extern errcode intOPequal();
extern errcode recordOPset_3();
extern errcode exprOPcreate();
extern errcode oneofOPmake_2();
extern errcode c_envOPget_any_type();
extern errcode exprOPset_typespec();
extern errcode sequenceOPnew();
CLUREF STR_right_040side_040of_040multiple_040assignment_040not_040an_040invocation;
static int c_declinit_own_init = 0;

/**** BEGIN PROCEDURE c_declinit ****/

errcode c_declinit(e, di, own_vars)
CLUREF e;
CLUREF di;
CLUREF own_vars;
    {
    errcode err;
    errcode ecode2;
    CLUREF decls;
    CLUREF x;
    CLUREF types;
    CLUREF xa;
    CLUREF t;
        if (c_declinit_own_init == 0) {
        CLU_string_size.num = 51;
        stringOPcons("right side of multiple assignment not an invocation", CLU_1, CLU_string_size, &STR_right_040side_040of_040multiple_040assignment_040not_040an_040invocation);
        c_declinit_own_init = 1;
    }
    enter_proc(71);

  LINE(72);
    {
        {CLUREF T_1_1;
        T_1_1.num = di.vec->data[1];
        decls.num = T_1_1.num;
        }
        }

  LINE(73);
    {
    if (own_vars.num == true) {

  LINE(74);
        {
        err = c_own_decls(e, decls);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(75);
        {
        err = c_decllist(e, decls);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(77);
    {
        {CLUREF T_1_1;
        T_1_1.num = di.vec->data[2];
        x.num = T_1_1.num;
        }
        }

  LINE(79);
    {
    CLUREF T_1_1;
    err = exprOPget_abs(x, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 16: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        xa.num = T_1_2.num;

  LINE(81);
            {
            CLUREF T_2_1;
            err = c_invoke(e, xa, CLU_0, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            types.num = T_2_1.num;
            }
            break;
            }
    default: {

  LINE(83);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        CLUREF T_2_7;
        T_2_2.num = decls.vec->size;
        T_2_3.num = (T_2_2.num > 1)? true : false;
        T_2_1.num = T_2_3.num;
        if (!T_2_3.num) {
            err = sequenceOPbottom(decls, &T_2_4);
            if (err != ERR_ok) goto ex_0;
            T_2_5.num = T_2_4.vec->data[0];
            T_2_6.num = T_2_5.vec->size;
            T_2_7.num = (T_2_6.num > 1)? true : false;
            T_2_1.num = T_2_7.num;
        }
        if (T_2_1.num == true) {

  LINE(85);
            {
            err = c_envOPerr1(e, STR_right_040side_040of_040multiple_040assignment_040not_040an_040invocation);
            if (err != ERR_ok) goto ex_0;
            }
            }
            }/* end if */

  LINE(88);
        {
            {CLUREF T_2_1;
            err = c_expr(e, x, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            t.num = T_2_1.num;
            }
            }

  LINE(89);
        {
        CLUREF T_2_1;
        err = sequenceOPe2s(t, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        types.num = T_2_1.num;
        }
    }
    }
    }

  LINE(91);
    {
    CLUREF T_1_1;
    err = c_decl_assn(e, decls, types, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    di.vec->data[0]  = T_1_1.num;
    }

  LINE(92);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    T_1_2.num = di.vec->data[0];
    T_1_3.num = T_1_2.vec->size;
    T_1_4.num = (T_1_3.num == 1)? true : false;
    T_1_1.num = T_1_4.num;
    if (T_1_4.num) {
        T_1_5.num = types.vec->size;
        T_1_6.num = (T_1_5.num == 1)? true : false;
        T_1_1.num = T_1_6.num;
    }
    if (T_1_1.num == true) {

  LINE(93);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CellAlloc(2, x.num, T_2_1);
        err = c_envOPget_any_type(e, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        err = exprOPcreate(T_2_1, T_2_2, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        di.vec->data[2]  = T_2_3.num;
        }

  LINE(94);
        {
        CLUREF T_2_1;
        err = sequenceOPbottom(types, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = exprOPset_typespec(x, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(95);
        {
        CLUREF T_2_1;
        err = sequenceOPnew(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        di.vec->data[0]  = T_2_1.num;
        }
        }
        }/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_declinit ****/


extern errcode c_envOPadd_ownvar();

/**** BEGIN PROCEDURE c_own_decls ****/

errcode c_own_decls(e, decls)
CLUREF e;
CLUREF decls;
    {
    errcode err;
    errcode ecode2;
    CLUREF d;
    CLUREF t;
    CLUREF i;
    enter_proc(99);

  LINE(100);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = decls.vec->size; 
        T_1_3 = decls;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            d.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(101);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                T_2_1.num = d.vec->data[1];
                err = c_type(e, T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                t.num = T_2_2.num;
                }
                }

  LINE(102);
            {
            d.vec->data[1]  = t.num;
            }

  LINE(103);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = d.vec->data[0];
                T_2_3.num = T_2_1.vec->size; 
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    i.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(104);
                    {
                    err = c_envOPadd_ownvar(e, i, t);
                    if (err != ERR_ok) goto ex_0;
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_own_decls ****/



/**** BEGIN PROCEDURE c_decllist ****/

errcode c_decllist(e, decls)
CLUREF e;
CLUREF decls;
    {
    errcode err;
    errcode ecode2;
    CLUREF d;
    enter_proc(109);

  LINE(110);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = decls.vec->size; 
        T_1_3 = decls;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            d.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(111);
            {
            err = c_decl(e, d);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_decllist ****/


extern errcode c_return_type();
extern errcode c_envOPerr();
extern errcode intOPunparse();
extern errcode typespecOPmismatch();
extern errcode sequenceOPfetch();
extern errcode c_envOPerrt();
extern errcode idnOPget_str();
extern errcode sequenceOPaddh();
extern errcode intOPadd();
extern errcode intOPle();
CLUREF STR_more_040variables_040than_040values_040_050;
CLUREF STR__051_040for_040assignment;
CLUREF STR_object_040assigned_040to_040_047;
CLUREF STR__047;
CLUREF STR_more_040values_040_050;
CLUREF STR__051_040than_040variables_040for_040assignment;
static int c_decl_assn_own_init = 0;

/**** BEGIN PROCEDURE c_decl_assn ****/

errcode c_decl_assn(e, decls, types, ret_1)
CLUREF e;
CLUREF decls;
CLUREF types;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF anys;
    CLUREF j;
    CLUREF h;
    CLUREF d;
    CLUREF t;
    CLUREF i;
        if (c_decl_assn_own_init == 0) {
        stringOPcons("more variables than values (", CLU_1, CLU_28, &STR_more_040variables_040than_040values_040_050);
        stringOPcons(") for assignment", CLU_1, CLU_16, &STR__051_040for_040assignment);
        stringOPcons("object assigned to \'", CLU_1, CLU_20, &STR_object_040assigned_040to_040_047);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        stringOPcons("more values (", CLU_1, CLU_13, &STR_more_040values_040_050);
        stringOPcons(") than variables for assignment", CLU_1, CLU_31, &STR__051_040than_040variables_040for_040assignment);
        c_decl_assn_own_init = 1;
    }
    enter_proc(115);

  LINE(117);
    {
        {CLUREF T_1_1;
        err = sequenceOPnew(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        anys.num = T_1_1.num;
        }
        }

  LINE(118);
    {
    CLUREF T_1_1;
    err = c_return_type(types, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {
        {
        {
        ret_1->num = anys.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(119);
    {
        {j.num = 1;
        }
        }

  LINE(120);
    {
        {CLUREF T_1_1;
        T_1_1.num = types.vec->size;
        h.num = T_1_1.num;
        }
        }

  LINE(121);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = decls.vec->size; 
        T_1_3 = decls;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            d.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(122);
            {
                {CLUREF T_2_1;
                T_2_1.num = d.vec->data[1];
                t.num = T_2_1.num;
                }
                }

  LINE(123);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = d.vec->data[0];
                T_2_3.num = T_2_1.vec->size; 
                T_2_4 = T_2_1;
                for (T_2_2.num = 1; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    i.num = T_2_4.vec->data[T_2_2.num - 1];

  LINE(124);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = (j.num > h.num)? true : false;
                    if (T_3_1.num == true) {

  LINE(125);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        sequenceOPnew2(CLU_3, &T_4_1);
                        T_4_1.vec->data[0] = STR_more_040variables_040than_040values_040_050.num;
                        err = intOPunparse(h, &T_4_2);
                        if (err != ERR_ok) goto ex_0;
                        T_4_1.vec->data[1] = T_4_2.num;
                        T_4_1.vec->data[2] = STR__051_040for_040assignment.num;
                        err = c_envOPerr(e, T_4_1);
                        if (err != ERR_ok) goto ex_0;
                        }

  LINE(127);
                        {
                        {
                        ret_1->num = anys.num;
                        }
                        {signal (ERR_ok);}}
                        }
                        }/* end if */

  LINE(129);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    if (j.num < 1 || j.num > types.vec->size ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = types.vec->data[j.num - 1];
                    err = typespecOPmismatch(t, T_4_1, &T_4_2);
                    if (err != ERR_ok) goto ex_1;
                    if (T_4_2.num == true) {

  LINE(130);
                        {
                        CLUREF T_5_1;
                        CLUREF T_5_2;
                        CLUREF T_5_3;
                        sequenceOPnew2(CLU_3, &T_5_1);
                        T_5_1.vec->data[0] = STR_object_040assigned_040to_040_047.num;
                        err = idnOPget_str(i, &T_5_2);
                        if (err != ERR_ok) goto ex_1;
                        T_5_1.vec->data[1] = T_5_2.num;
                        T_5_1.vec->data[2] = STR__047.num;
                        if (j.num < 1 || j.num > types.vec->size ) {
                            err = ERR_bounds;
                            goto ex_1;}
                        T_5_3.num = types.vec->data[j.num - 1];
                        err = c_envOPerrt(e, T_5_1, t, T_5_3);
                        if (err != ERR_ok) goto ex_1;
                        }
                        }
                        }/* end if */
                        goto end_1;
                        ex_1:
                            if ((err == ERR_anyize)) {

  LINE(134);
                                {
                                CLUREF T_4_1;
                                CLUREF T_4_2;
                                CLUREF T_4_3;
                                CLUREF T_4_4;
                                RecordAlloc(2, T_4_1);
                                err = sequenceOPe2s(i, &T_4_2);
                                if (err != ERR_ok) goto ex_0;
                                T_4_1.vec->data[0]  = T_4_2.num;
                                if (j.num < 1 || j.num > types.vec->size ) {
                                    err = ERR_bounds;
                                    goto ex_0;}
                                T_4_3.num = types.vec->data[j.num - 1];
                                T_4_1.vec->data[1]  = T_4_3.num;
                                err = sequenceOPaddh(anys, T_4_1, &T_4_4);
                                if (err != ERR_ok) goto ex_0;
                                anys.num = T_4_4.num;
                                }
                            }
                            else {
                                goto ex_0;
                            }
                        end_1:;

  LINE(137);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = j.num + 1;
                     if ((T_3_1.num > 0 && j.num < 0 && 1 < 0) || 
                         (T_3_1.num < 0 && j.num > 0 && 1 > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    j.num = T_3_1.num;
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(140);
    {
    CLUREF T_1_1;
    T_1_1.num = (j.num <= h.num)? true : false;
    if (T_1_1.num == true) {

  LINE(141);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_3, &T_2_1);
        T_2_1.vec->data[0] = STR_more_040values_040_050.num;
        err = intOPunparse(h, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        T_2_1.vec->data[2] = STR__051_040than_040variables_040for_040assignment.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(144);
    {
    {
    ret_1->num = anys.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_decl_assn ****/


extern errcode c_mult_assn();
extern errcode c_variables();
extern errcode boolOPnot();
extern errcode sequenceOPindexes();
extern errcode idnOPget_kind();
extern errcode exprOPget_typespec();
extern errcode sequenceOPreplace();
CLUREF STR__040variables_040to_040assign_040to_054_040;
CLUREF STR__040values_040to_040assign;
static int c_assn_own_init = 0;

/**** BEGIN PROCEDURE c_assn ****/

errcode c_assn(e, sgn)
CLUREF e;
CLUREF sgn;
    {
    errcode err;
    errcode ecode2;
    CLUREF vars;
    CLUREF vals;
    CLUREF xa;
    CLUREF x;
    CLUREF i;
    CLUREF k;
        if (c_assn_own_init == 0) {
        CLU_string_size.num = 51;
        stringOPcons("right side of multiple assignment not an invocation", CLU_1, CLU_string_size, &STR_right_040side_040of_040multiple_040assignment_040not_040an_040invocation);
        stringOPcons(" variables to assign to, ", CLU_1, CLU_25, &STR__040variables_040to_040assign_040to_054_040);
        stringOPcons(" values to assign", CLU_1, CLU_17, &STR__040values_040to_040assign);
        stringOPcons("object assigned to \'", CLU_1, CLU_20, &STR_object_040assigned_040to_040_047);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        c_assn_own_init = 1;
    }
    enter_proc(147);

  LINE(148);
    {
        {CLUREF T_1_1;
        T_1_1.num = sgn.vec->data[1];
        vars.num = T_1_1.num;
        }
        }

  LINE(149);
    {
        {CLUREF T_1_1;
        T_1_1.num = sgn.vec->data[2];
        vals.num = T_1_1.num;
        }
        }

  LINE(150);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    T_1_2.num = vars.vec->size;
    T_1_3.num = (T_1_2.num > 1)? true : false;
    T_1_1.num = T_1_3.num;
    if (T_1_3.num) {
        T_1_4.num = vals.vec->size;
        T_1_5.num = (T_1_4.num == 1)? true : false;
        T_1_1.num = T_1_5.num;
    }
    if (T_1_1.num == true) {

  LINE(151);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = sequenceOPbottom(vals, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = exprOPget_abs(T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        switch (T_2_2.cell->tag) {
        case 16: 
             {CLUREF T_2_3;
            T_2_3.num = T_2_2.cell->value;
            xa.num = T_2_3.num;

  LINE(153);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                err = c_invoke(e, xa, CLU_0, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                err = c_mult_assn(e, vars, T_3_1, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                sgn.vec->data[0]  = T_3_2.num;
                }

  LINE(154);
                {
                {signal (ERR_ok);}}
                break;
                }
        default: {

  LINE(156);
            {
            err = c_variables(e, vars);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(157);
            {
            err = c_envOPerr1(e, STR_right_040side_040of_040multiple_040assignment_040not_040an_040invocation);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(158);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = sequenceOPbottom(vals, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            err = c_expr(e, T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(159);
            {
            {signal (ERR_ok);}}
        }
        }
        }
        }
        }/* end if */

  LINE(162);
    {
    err = c_variables(e, vars);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(163);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = vals.vec->size; 
        T_1_3 = vals;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            x.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(164);
            {
            CLUREF T_2_1;
            err = c_expr(e, x, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(166);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = vars.vec->size;
    T_1_2.num = vals.vec->size;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {

  LINE(167);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        sequenceOPnew2(CLU_4, &T_2_1);
        T_2_2.num = vars.vec->size;
        err = intOPunparse(T_2_2, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[0] = T_2_3.num;
        T_2_1.vec->data[1] = STR__040variables_040to_040assign_040to_054_040.num;
        T_2_4.num = vals.vec->size;
        err = intOPunparse(T_2_4, &T_2_5);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[2] = T_2_5.num;
        T_2_1.vec->data[3] = STR__040values_040to_040assign.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(171);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(173);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = vars.vec->size; 
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(174);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            if (i.num < 1 || i.num > vars.vec->size ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = vars.vec->data[i.num - 1];
            err = idnOPget_kind(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_2.cell->tag) {
            case 9: 
            case 4: 
                 {CLUREF T_2_3;
                T_2_3.num = T_2_2.cell->value;
                k.num = T_2_3.num;

  LINE(176);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    CLUREF T_4_3;
                    if (i.num < 1 || i.num > vals.vec->size ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = vals.vec->data[i.num - 1];
                    err = exprOPget_typespec(T_4_1, &T_4_2);
                    if (err != ERR_ok) goto ex_1;
                    err = typespecOPmismatch(k, T_4_2, &T_4_3);
                    if (err != ERR_ok) goto ex_1;
                    if (T_4_3.num == true) {

  LINE(177);
                        {
                        CLUREF T_5_1;
                        CLUREF T_5_2;
                        CLUREF T_5_3;
                        CLUREF T_5_4;
                        CLUREF T_5_5;
                        sequenceOPnew2(CLU_3, &T_5_1);
                        T_5_1.vec->data[0] = STR_object_040assigned_040to_040_047.num;
                        if (i.num < 1 || i.num > vars.vec->size ) {
                            err = ERR_bounds;
                            goto ex_1;}
                        T_5_2.num = vars.vec->data[i.num - 1];
                        err = idnOPget_str(T_5_2, &T_5_3);
                        if (err != ERR_ok) goto ex_1;
                        T_5_1.vec->data[1] = T_5_3.num;
                        T_5_1.vec->data[2] = STR__047.num;
                        if (i.num < 1 || i.num > vals.vec->size ) {
                            err = ERR_bounds;
                            goto ex_1;}
                        T_5_4.num = vals.vec->data[i.num - 1];
                        err = exprOPget_typespec(T_5_4, &T_5_5);
                        if (err != ERR_ok) goto ex_1;
                        err = c_envOPerrt(e, T_5_1, k, T_5_5);
                        if (err != ERR_ok) goto ex_1;
                        }
                        }
                        }/* end if */
                        goto end_1;
                        ex_1:
                            if ((err == ERR_anyize)) {

  LINE(182);
                                {
                                    {CLUREF T_4_1;
                                    CLUREF T_4_2;
                                    CLUREF T_4_3;
                                    CLUREF T_4_4;
                                    if (i.num < 1 || i.num > vals.vec->size ) {
                                        err = ERR_bounds;
                                        goto ex_0;}
                                    T_4_1.num = vals.vec->data[i.num - 1];
                                    CellAlloc(2, T_4_1.num, T_4_2);
                                    err = c_envOPget_any_type(e, &T_4_3);
                                    if (err != ERR_ok) goto ex_0;
                                    err = exprOPcreate(T_4_2, T_4_3, &T_4_4);
                                    if (err != ERR_ok) goto ex_0;
                                    x.num = T_4_4.num;
                                    }
                                    }

  LINE(184);
                                {
                                CLUREF T_4_1;
                                CLUREF T_4_2;
                                T_4_1.num = sgn.vec->data[2];
                                err = sequenceOPreplace(T_4_1, i, x, &T_4_2);
                                if (err != ERR_ok) goto ex_0;
                                sgn.vec->data[2]  = T_4_2.num;
                                }
                            }
                            else {
                                goto ex_0;
                            }
                        end_1:;
                    break;
                    }
            default: {
            }
            }
            }
        }
    }
    end_inline_for_2:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_assn ****/


static int c_mult_assn_own_init = 0;

/**** BEGIN PROCEDURE c_mult_assn ****/

errcode c_mult_assn(e, idns, types, ret_1)
CLUREF e;
CLUREF idns;
CLUREF types;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF anys;
    CLUREF i;
    CLUREF k;
        if (c_mult_assn_own_init == 0) {
        stringOPcons(" variables to assign to, ", CLU_1, CLU_25, &STR__040variables_040to_040assign_040to_054_040);
        stringOPcons(" values to assign", CLU_1, CLU_17, &STR__040values_040to_040assign);
        stringOPcons("object assigned to \'", CLU_1, CLU_20, &STR_object_040assigned_040to_040_047);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        c_mult_assn_own_init = 1;
    }
    enter_proc(191);

  LINE(193);
    {
        {CLUREF T_1_1;
        err = sequenceOPnew(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        anys.num = T_1_1.num;
        }
        }

  LINE(194);
    {
    err = c_variables(e, idns);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(195);
    {
    CLUREF T_1_1;
    err = c_return_type(types, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {
        {
        {
        ret_1->num = anys.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(196);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = idns.vec->size;
    T_1_2.num = types.vec->size;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {

  LINE(197);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        sequenceOPnew2(CLU_4, &T_2_1);
        T_2_2.num = idns.vec->size;
        err = intOPunparse(T_2_2, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[0] = T_2_3.num;
        T_2_1.vec->data[1] = STR__040variables_040to_040assign_040to_054_040.num;
        T_2_4.num = types.vec->size;
        err = intOPunparse(T_2_4, &T_2_5);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[2] = T_2_5.num;
        T_2_1.vec->data[3] = STR__040values_040to_040assign.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(201);
        {
        {
        ret_1->num = anys.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(203);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = idns.vec->size; 
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(204);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            if (i.num < 1 || i.num > idns.vec->size ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = idns.vec->data[i.num - 1];
            err = idnOPget_kind(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_2.cell->tag) {
            case 9: 
            case 4: 
                 {CLUREF T_2_3;
                T_2_3.num = T_2_2.cell->value;
                k.num = T_2_3.num;

  LINE(206);
                    {
                    CLUREF T_4_1;
                    CLUREF T_4_2;
                    if (i.num < 1 || i.num > types.vec->size ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = types.vec->data[i.num - 1];
                    err = typespecOPmismatch(k, T_4_1, &T_4_2);
                    if (err != ERR_ok) goto ex_1;
                    if (T_4_2.num == true) {

  LINE(207);
                        {
                        CLUREF T_5_1;
                        CLUREF T_5_2;
                        CLUREF T_5_3;
                        CLUREF T_5_4;
                        sequenceOPnew2(CLU_3, &T_5_1);
                        T_5_1.vec->data[0] = STR_object_040assigned_040to_040_047.num;
                        if (i.num < 1 || i.num > idns.vec->size ) {
                            err = ERR_bounds;
                            goto ex_1;}
                        T_5_2.num = idns.vec->data[i.num - 1];
                        err = idnOPget_str(T_5_2, &T_5_3);
                        if (err != ERR_ok) goto ex_1;
                        T_5_1.vec->data[1] = T_5_3.num;
                        T_5_1.vec->data[2] = STR__047.num;
                        if (i.num < 1 || i.num > types.vec->size ) {
                            err = ERR_bounds;
                            goto ex_1;}
                        T_5_4.num = types.vec->data[i.num - 1];
                        err = c_envOPerrt(e, T_5_1, k, T_5_4);
                        if (err != ERR_ok) goto ex_1;
                        }
                        }
                        }/* end if */
                        goto end_1;
                        ex_1:
                            if ((err == ERR_anyize)) {

  LINE(212);
                                {
                                CLUREF T_4_1;
                                CLUREF T_4_2;
                                CLUREF T_4_3;
                                CLUREF T_4_4;
                                CLUREF T_4_5;
                                RecordAlloc(2, T_4_1);
                                if (i.num < 1 || i.num > idns.vec->size ) {
                                    err = ERR_bounds;
                                    goto ex_0;}
                                T_4_2.num = idns.vec->data[i.num - 1];
                                err = sequenceOPe2s(T_4_2, &T_4_3);
                                if (err != ERR_ok) goto ex_0;
                                T_4_1.vec->data[0]  = T_4_3.num;
                                if (i.num < 1 || i.num > types.vec->size ) {
                                    err = ERR_bounds;
                                    goto ex_0;}
                                T_4_4.num = types.vec->data[i.num - 1];
                                T_4_1.vec->data[1]  = T_4_4.num;
                                err = sequenceOPaddh(anys, T_4_1, &T_4_5);
                                if (err != ERR_ok) goto ex_0;
                                anys.num = T_4_5.num;
                                }
                            }
                            else {
                                goto ex_0;
                            }
                        end_1:;
                    break;
                    }
            default: {
            }
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(218);
    {
    {
    ret_1->num = anys.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_mult_assn ****/


CLUREF STR_identifier_040_047;
CLUREF STR__047_040not_040a_040variable;
static int c_variables_own_init = 0;

/**** BEGIN PROCEDURE c_variables ****/

errcode c_variables(e, idns)
CLUREF e;
CLUREF idns;
    {
    errcode err;
    errcode ecode2;
    CLUREF i;
        if (c_variables_own_init == 0) {
        stringOPcons("identifier \'", CLU_1, CLU_12, &STR_identifier_040_047);
        stringOPcons("\' not a variable", CLU_1, CLU_16, &STR__047_040not_040a_040variable);
        c_variables_own_init = 1;
    }
    enter_proc(221);

  LINE(222);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = idns.vec->size; 
        T_1_3 = idns;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(223);
            {
            CLUREF T_2_1;
            err = idnOPget_kind(i, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_1.cell->tag) {
            case 9: 
            case 4: 
                 {
                    break;
                    }
            default: {

  LINE(225);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                sequenceOPnew2(CLU_3, &T_3_1);
                T_3_1.vec->data[0] = STR_identifier_040_047.num;
                err = idnOPget_str(i, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_1.vec->data[1] = T_3_2.num;
                T_3_1.vec->data[2] = STR__047_040not_040a_040variable.num;
                err = c_envOPerr(e, T_3_1);
                if (err != ERR_ok) goto ex_0;
                }
            }
            }
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_variables ****/


extern errcode typespecOPget_abs();

/**** BEGIN PROCEDURE c_return_type ****/

errcode c_return_type(types, ret_1)
CLUREF types;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ta;
    enter_proc(230);

  LINE(231);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = types.vec->size;
    T_1_2.num = (T_1_1.num == 1)? true : false;
    T_1_3.num = T_1_2.num ^ 1;
    if (T_1_3.num == true) {

  LINE(232);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(233);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = sequenceOPbottom(types, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = typespecOPget_abs(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_2.cell->tag) {
    case 6: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_2.cell->value;
        ta.num = T_1_3.num;

  LINE(235);
            {
            switch (ta.cell->tag) {
            case 3: 
                 {

  LINE(236);
                    {
                    {
                    ret_1->tf = true;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            default: {
            }
            }
            }
            break;
            }
    case 9: 
         {

  LINE(240);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {
    }
    }
    }

  LINE(243);
    {
    {
    ret_1->tf = false;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_return_type ****/


extern errcode stringOPconcat();
extern errcode c_idn_store();
extern errcode c_envOPget_unknown_type();
extern errcode oneofOPmake_13();
CLUREF STR_set_137;
CLUREF STR_store;
CLUREF STR_illegal_040form_040of_040assignment;
static int c_sugarassn_own_init = 0;

/**** BEGIN PROCEDURE c_sugarassn ****/

errcode c_sugarassn(e, s, sa)
CLUREF e;
CLUREF s;
CLUREF sa;
    {
    errcode err;
    errcode ecode2;
    CLUREF x;
    CLUREF args;
    CLUREF op;
    CLUREF xa;
    CLUREF t;
    CLUREF cop;
    CLUREF inv;
        if (c_sugarassn_own_init == 0) {
        stringOPcons("set_", CLU_1, CLU_4, &STR_set_137);
        stringOPcons("store", CLU_1, CLU_5, &STR_store);
        stringOPcons("illegal form of assignment", CLU_1, CLU_26, &STR_illegal_040form_040of_040assignment);
        c_sugarassn_own_init = 1;
    }
    enter_proc(246);

  LINE(247);
    {
        {CLUREF T_1_1;
        T_1_1.num = sa.vec->data[0];
        x.num = T_1_1.num;
        }
        }

  LINE(250);
    {
    CLUREF T_1_1;
    err = exprOPget_abs(x, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 12: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        xa.num = T_1_2.num;

  LINE(252);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            sequenceOPnew2(CLU_2, &T_2_1);
            T_2_2.num = xa.vec->data[0];
            T_2_1.vec->data[0] = T_2_2.num;
            T_2_3.num = sa.vec->data[1];
            T_2_1.vec->data[1] = T_2_3.num;
            args.num = T_2_1.num;
            }

  LINE(253);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = xa.vec->data[1];
            err = stringOPconcat(STR_set_137, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            op.num = T_2_2.num;
            }
            break;
            }
    case 10: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        xa.num = T_1_3.num;

  LINE(255);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            sequenceOPnew2(CLU_3, &T_2_1);
            T_2_2.num = xa.vec->data[1];
            T_2_1.vec->data[0] = T_2_2.num;
            T_2_3.num = xa.vec->data[0];
            T_2_1.vec->data[1] = T_2_3.num;
            T_2_4.num = sa.vec->data[1];
            T_2_1.vec->data[2] = T_2_4.num;
            args.num = T_2_1.num;
            }

  LINE(256);
            {
            op = STR_store;
            }
            break;
            }
    case 22: 
         {CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        xa.num = T_1_4.num;

  LINE(258);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = sa.vec->data[1];
            err = c_idn_store(e, xa, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            args.num = T_2_2.num;
            }

  LINE(259);
            {
            op = STR_store;
            }
            break;
            }
    default: {

  LINE(261);
        {
        err = c_envOPerr1(e, STR_illegal_040form_040of_040assignment);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(262);
        {
        {signal (ERR_ok);}}
    }
    }
    }

  LINE(264);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = sequenceOPbottom(args, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        err = c_expr(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        t.num = T_1_2.num;
        }
        }

  LINE(265);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        RecordAlloc(3, T_1_1);
        T_1_1.vec->data[2]  = t.num;
        T_1_1.vec->data[0]  = op.num;
        err = sequenceOPnew(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1]  = T_1_2.num;
        cop.num = T_1_1.num;
        }
        }

  LINE(268);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        RecordAlloc(2, T_1_1);
        CellAlloc(20, cop.num, T_1_2);
        err = c_envOPget_unknown_type(e, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        err = exprOPcreate(T_1_2, T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_4.num;
        T_1_1.vec->data[1]  = args.num;
        inv.num = T_1_1.num;
        }
        }

  LINE(270);
    {
    CLUREF T_1_1;
    CellAlloc(13, inv.num, T_1_1);
    err = stmtOPset_abs(s, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(271);
    {
    CLUREF T_1_1;
    err = c_invoke(e, inv, CLU_1, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_sugarassn ****/


CLUREF STR__040expressions_040in_040square_040brackets_040of_040store_040sugar_054_0401_040expected;
static int c_idn_store_own_init = 0;

/**** BEGIN PROCEDURE c_idn_store ****/

errcode c_idn_store(e, ref, x3, ret_1)
CLUREF e;
CLUREF ref;
CLUREF x3;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF x1;
    CLUREF parms;
    CLUREF x2;
        if (c_idn_store_own_init == 0) {
        CLU_string_size.num = 58;
        stringOPcons(" expressions in square brackets of store sugar, 1 expected", CLU_1, CLU_string_size, &STR__040expressions_040in_040square_040brackets_040of_040store_040sugar_054_0401_040expected);
        c_idn_store_own_init = 1;
    }
    enter_proc(274);

  LINE(275);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        T_1_1.num = ref.vec->data[0];
        CellAlloc(13, T_1_1.num, T_1_2);
        err = c_envOPget_unknown_type(e, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        err = exprOPcreate(T_1_2, T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        x1.num = T_1_4.num;
        }
        }

  LINE(276);
    {
        {CLUREF T_1_1;
        T_1_1.num = ref.vec->data[1];
        parms.num = T_1_1.num;
        }
        }

  LINE(277);
    {
        {CLUREF T_1_1;
        err = sequenceOPbottom(parms, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        x2.num = T_1_1.num;
        }
        }

  LINE(278);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = parms.vec->size;
    T_1_2.num = (T_1_1.num > 1)? true : false;
    if (T_1_2.num == true) {

  LINE(279);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        sequenceOPnew2(CLU_2, &T_2_1);
        T_2_2.num = parms.vec->size;
        err = intOPunparse(T_2_2, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[0] = T_2_3.num;
        T_2_1.vec->data[1] = STR__040expressions_040in_040square_040brackets_040of_040store_040sugar_054_0401_040expected.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(282);
    {
    {
    CLUREF T_1_1;
    sequenceOPnew2(CLU_3, &T_1_1);
    T_1_1.vec->data[0] = x1.num;
    T_1_1.vec->data[1] = x2.num;
    T_1_1.vec->data[2] = x3.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_idn_store ****/


extern errcode c_envOPget_bool_type();
extern errcode c_envOPbegin_while();
extern errcode c_envOPend_loop();
CLUREF STR_result_040of_040loop_040test;
static int c_while_own_init = 0;

/**** BEGIN PROCEDURE c_while ****/

errcode c_while(e, ws)
CLUREF e;
CLUREF ws;
    {
    errcode err;
    errcode ecode2;
        if (c_while_own_init == 0) {
        stringOPcons("result of loop test", CLU_1, CLU_19, &STR_result_040of_040loop_040test);
        c_while_own_init = 1;
    }
    enter_proc(285);

  LINE(286);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    err = c_envOPget_bool_type(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = ws.vec->data[1];
    err = c_expr(e, T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    err = typespecOPmismatch(T_1_1, T_1_3, &T_1_4);
    if (err != ERR_ok) goto ex_0;
    if (T_1_4.num == true) {

  LINE(287);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        sequenceOPnew2(CLU_1, &T_2_1);
        T_2_1.vec->data[0] = STR_result_040of_040loop_040test.num;
        err = c_envOPget_bool_type(e, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_3.num = ws.vec->data[1];
        err = exprOPget_typespec(T_2_3, &T_2_4);
        if (err != ERR_ok) goto ex_0;
        err = c_envOPerrt(e, T_2_1, T_2_2, T_2_4);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(290);
    {
    err = c_envOPbegin_while(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(291);
    {
    CLUREF T_1_1;
    T_1_1.num = ws.vec->data[0];
    err = c_body(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(292);
    {
    CLUREF T_1_1;
    err = c_envOPend_loop(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_while ****/


extern errcode recordOPget_4();
extern errcode duOPequal();
extern errcode c_envOPget_iter_();
extern errcode get_inv_print();
extern errcode c_call();
extern errcode c_unknown_assn();
extern errcode c_envOPbegin_for();
extern errcode recordOPset_5();
CLUREF STR_invocation_040of_040non_055iterator_072_040;
static int c_for_own_init = 0;

/**** BEGIN PROCEDURE c_for ****/

errcode c_for(e, fs)
CLUREF e;
CLUREF fs;
    {
    errcode err;
    errcode ecode2;
    CLUREF fvars;
    CLUREF vars;
    CLUREF inv;
    CLUREF it;
    CLUREF args;
    CLUREF arg;
    CLUREF ita;
        if (c_for_own_init == 0) {
        stringOPcons("invocation of non-iterator: ", CLU_1, CLU_28, &STR_invocation_040of_040non_055iterator_072_040);
        c_for_own_init = 1;
    }
    enter_proc(295);

  LINE(296);
    {
    err = c_envOPbegin_scope(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(297);
    {
        {CLUREF T_1_1;
        T_1_1.num = fs.vec->data[3];
        fvars.num = T_1_1.num;
        }
        }

  LINE(298);
    {
    switch (fvars.cell->tag) {
    case 1: 
         {CLUREF T_1_1;
        T_1_1.num = fvars.cell->value;
        vars.num = T_1_1.num;

  LINE(300);
            {
            err = c_decllist(e, vars);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {
    }
    }
    }

  LINE(303);
    {
        {CLUREF T_1_1;
        T_1_1.num = fs.vec->data[2];
        inv.num = T_1_1.num;
        }
        }

  LINE(304);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = inv.vec->data[0];
        err = c_expr(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        it.num = T_1_2.num;
        }
        }

  LINE(305);
    {
        {CLUREF T_1_1;
        T_1_1.num = inv.vec->data[1];
        args.num = T_1_1.num;
        }
        }

  LINE(306);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = args.vec->size; 
        T_1_3 = args;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            arg.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(307);
            {
            CLUREF T_2_1;
            err = c_expr(e, arg, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(309);
    {
    CLUREF T_1_1;
    err = typespecOPget_abs(it, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        ita.num = T_1_2.num;

  LINE(311);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            T_2_1.num = ita.vec->data[1];
            err = c_envOPget_iter_(e, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            err = duOPequal(T_2_1, T_2_2, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            T_2_4.num = T_2_3.num ^ 1;
            if (T_2_4.num == true) {

  LINE(312);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                sequenceOPnew2(CLU_2, &T_3_1);
                T_3_1.vec->data[0] = STR_invocation_040of_040non_055iterator_072_040.num;
                err = get_inv_print(inv, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_1.vec->data[1] = T_3_2.num;
                err = c_envOPerr(e, T_3_1);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */

  LINE(315);
            {
            switch (fvars.cell->tag) {
            case 1: 
                 {CLUREF T_2_1;
                T_2_1.num = fvars.cell->value;
                vars.num = T_2_1.num;

  LINE(317);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = c_call(e, ita, inv, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = c_decl_assn(e, vars, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    fs.vec->data[0]  = T_3_2.num;
                    }
                    break;
                    }
            case 2: 
                 {CLUREF T_2_2;
                T_2_2.num = fvars.cell->value;
                vars.num = T_2_2.num;

  LINE(319);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = c_call(e, ita, inv, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = c_mult_assn(e, vars, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    fs.vec->data[0]  = T_3_2.num;
                    }
                    break;
                    }
            }
            }
            break;
            }
    case 6: 
    case 9: 
         {

  LINE(322);
            {
            err = c_unknown_assn(e, fvars);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(324);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_2, &T_2_1);
        T_2_1.vec->data[0] = STR_invocation_040of_040non_055iterator_072_040.num;
        err = get_inv_print(inv, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(326);
        {
        err = c_unknown_assn(e, fvars);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(328);
    {
    err = c_envOPbegin_for(e);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(329);
    {
    CLUREF T_1_1;
    T_1_1.num = fs.vec->data[1];
    err = c_body(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(330);
    {
    CLUREF T_1_1;
    err = c_envOPend_loop(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    fs.vec->data[4]  = T_1_1.num;
    }

  LINE(331);
    {
    err = c_envOPend_scope(e);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_for ****/



/**** BEGIN PROCEDURE c_unknown_assn ****/

errcode c_unknown_assn(e, vars)
CLUREF e;
CLUREF vars;
    {
    errcode err;
    errcode ecode2;
    CLUREF idns;
    enter_proc(334);

  LINE(335);
    {
    switch (vars.cell->tag) {
    case 2: 
         {CLUREF T_1_1;
        T_1_1.num = vars.cell->value;
        idns.num = T_1_1.num;

  LINE(337);
            {
            err = c_variables(e, idns);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_unknown_assn ****/


CLUREF STR_result_040of_040conditional_040test;
static int c_if_own_init = 0;

/**** BEGIN PROCEDURE c_if ****/

errcode c_if(e, ifs)
CLUREF e;
CLUREF ifs;
    {
    errcode err;
    errcode ecode2;
    CLUREF arm;
    CLUREF mb;
        if (c_if_own_init == 0) {
        stringOPcons("result of conditional test", CLU_1, CLU_26, &STR_result_040of_040conditional_040test);
        c_if_own_init = 1;
    }
    enter_proc(342);

  LINE(343);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = ifs.vec->data[0];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            arm.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(344);
            {
            CLUREF T_2_1;
            T_2_1.num = arm.vec->data[1];
            err = c_envOPset_line(e, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(345);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            err = c_envOPget_bool_type(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            T_2_2.num = arm.vec->data[2];
            err = c_expr(e, T_2_2, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            err = typespecOPmismatch(T_2_1, T_2_3, &T_2_4);
            if (err != ERR_ok) goto ex_0;
            if (T_2_4.num == true) {

  LINE(346);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CLUREF T_3_4;
                sequenceOPnew2(CLU_1, &T_3_1);
                T_3_1.vec->data[0] = STR_result_040of_040conditional_040test.num;
                err = c_envOPget_bool_type(e, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_3.num = arm.vec->data[2];
                err = exprOPget_typespec(T_3_3, &T_3_4);
                if (err != ERR_ok) goto ex_0;
                err = c_envOPerrt(e, T_3_1, T_3_2, T_3_4);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */

  LINE(349);
            {
            CLUREF T_2_1;
            T_2_1.num = arm.vec->data[0];
            err = c_body(e, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(351);
    {
    CLUREF T_1_1;
    T_1_1.num = ifs.vec->data[1];
    switch (T_1_1.cell->tag) {
    case 1: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        mb.num = T_1_2.num;

  LINE(353);
            {
            err = c_body(e, mb);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_if ****/

