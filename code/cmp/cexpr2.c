
/* This file was automatically generated by pclu. */

#include "pclu_err.h"
#include "pclu_sys.h"



/**** BEGIN PROCEDURE c_force ****/

extern errcode c_type();
extern errcode exprOPset_abs();
extern errcode oneofOPmake_11();
extern errcode sequenceOPnew();
extern errcode c_envOPget_proc_();
extern errcode sequenceOPe2s();
extern errcode c_envOPget_any_type();
extern errcode c_envOPget_type();
extern errcode oneofOPmake_2();
static CLUREF STR_wrong_137type;
static int c_force_own_init = 0;

errcode
c_force(CLUREF e, CLUREF x, CLUREF t, CLUREF *ret_1)
{
    errcode err;
    CLUREF sig;
    CLUREF at;
    if (c_force_own_init == 0) {
        stringOPcons("wrong_type", CLU_1, CLUREF_make_num(10), &STR_wrong_137type);
        c_force_own_init = 1;
    }
    enter_proc(6);

  LINE(7);
    {
    CLUREF T_1_1;
    err = c_type(e, t, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    t.num = T_1_1.num;
    }

  LINE(8);
    {
    CLUREF T_1_1;
    CellAlloc(11, t.num, T_1_1);
    err = exprOPset_abs(x, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(10);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[0] = STR_wrong_137type.num;
    err = sequenceOPnew(&T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    sig.num = T_1_1.num;
    }

  LINE(12);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    RecordAlloc(4, T_1_1);
    err = c_envOPget_proc_(e, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    err = c_envOPget_any_type(e, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    err = sequenceOPe2s(T_1_3, &T_1_4);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[0] = T_1_4.num;
    err = sequenceOPe2s(t, &T_1_5);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[3] = T_1_5.num;
    err = sequenceOPe2s(sig, &T_1_6);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[2] = T_1_6.num;
    at.num = T_1_1.num;
    }

  LINE(16);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(2, at.num, T_1_1);
    err = c_envOPget_type(e, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_2.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_force ****/



/**** BEGIN PROCEDURE c_up ****/

extern errcode c_expr();
extern errcode c_envOPin_cluster();
extern errcode typespecOPmismatch();
extern errcode c_envOPget_down_type();
extern errcode c_envOPerrt();
extern errcode exprOPcreate();
extern errcode exprOPget_abs();
extern errcode exprOPset_typespec();
extern errcode c_envOPerr1();
extern errcode c_envOPget_up_type();
static CLUREF STR_argument_040to_040UP;
static CLUREF STR_use_040of_040UP_040operation_040outside_040of_040a_040cluster;
static int c_up_own_init = 0;

errcode
c_up(CLUREF e, CLUREF x, CLUREF *ret_1)
{
    errcode err;
    CLUREF t;
    if (c_up_own_init == 0) {
        stringOPcons("argument to UP", CLU_1, CLUREF_make_num(14), &STR_argument_040to_040UP);
        stringOPcons("use of UP operation outside of a cluster", CLU_1, CLUREF_make_num(40), &STR_use_040of_040UP_040operation_040outside_040of_040a_040cluster);
        c_up_own_init = 1;
    }
    enter_proc(19);

  LINE(20);
    {
    CLUREF T_1_1;
    err = c_expr(e, x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    t.num = T_1_1.num;
    }

  LINE(21);
    { /* if */
    CLUREF T_1_1;
    err = c_envOPin_cluster(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_1.num == true) { /* if */

  LINE(22);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = c_envOPget_down_type(e, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        err = typespecOPmismatch(T_3_1, t, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        if (T_3_2.num == true) { /* if */

  LINE(23);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            sequenceOPnew2(CLU_1, &T_4_1);
            T_4_1.vec->data[0] = STR_argument_040to_040UP.num;
            err = c_envOPget_down_type(e, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            err = c_envOPerrt(e, T_4_1, T_4_2, t);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        } /* end if */
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_anyize) {

  LINE(26);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = exprOPget_abs(x, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            err = exprOPcreate(T_3_1, t, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            CellAlloc(2, T_3_2.num, T_3_3);
            err = exprOPset_abs(x, T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(27);
            {
            CLUREF T_3_1;
            err = c_envOPget_any_type(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            err = exprOPset_typespec(x, T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;
    }
    else { /* else */

  LINE(29);
        {
        err = c_envOPerr1(e, STR_use_040of_040UP_040operation_040outside_040of_040a_040cluster);
        if (err != ERR_ok)
            goto ex_0;
        }
    }} /* end if */

  LINE(31);
    { /* return */
    {
    CLUREF T_1_1;
    err = c_envOPget_up_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_up ****/



/**** BEGIN PROCEDURE c_down ****/

static CLUREF STR_argument_040to_040DOWN;
static CLUREF STR_use_040of_040DOWN_040operation_040outside_040of_040a_040cluster;
static int c_down_own_init = 0;

errcode
c_down(CLUREF e, CLUREF x, CLUREF *ret_1)
{
    errcode err;
    CLUREF t;
    if (c_down_own_init == 0) {
        stringOPcons("argument to DOWN", CLU_1, CLUREF_make_num(16), &STR_argument_040to_040DOWN);
        stringOPcons("use of DOWN operation outside of a cluster", CLU_1, CLUREF_make_num(42), &STR_use_040of_040DOWN_040operation_040outside_040of_040a_040cluster);
        c_down_own_init = 1;
    }
    enter_proc(34);

  LINE(35);
    {
    CLUREF T_1_1;
    err = c_expr(e, x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    t.num = T_1_1.num;
    }

  LINE(36);
    { /* if */
    CLUREF T_1_1;
    err = c_envOPin_cluster(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_1.num == true) { /* if */

  LINE(37);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = c_envOPget_up_type(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = typespecOPmismatch(T_2_1, t, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        if (T_2_2.num == true) { /* if */

  LINE(38);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            sequenceOPnew2(CLU_1, &T_3_1);
            T_3_1.vec->data[0] = STR_argument_040to_040DOWN.num;
            err = c_envOPget_up_type(e, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            err = c_envOPerrt(e, T_3_1, T_3_2, t);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        } /* end if */
    }
    else { /* else */

  LINE(40);
        {
        err = c_envOPerr1(e, STR_use_040of_040DOWN_040operation_040outside_040of_040a_040cluster);
        if (err != ERR_ok)
            goto ex_0;
        }
    }} /* end if */

  LINE(42);
    { /* return */
    {
    CLUREF T_1_1;
    err = c_envOPget_down_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_down ****/



/**** BEGIN PROCEDURE c_bracketref ****/

extern errcode recordOPget_1();
extern errcode recordOPget_2();
extern errcode idnOPget_kind();
extern errcode c_gen_expr();
extern errcode recordOPset_2();
extern errcode c_constlist();
extern errcode oneofOPmake_20();
extern errcode c_clusterop1();
extern errcode c_envOPlookup();
extern errcode c_bracketref();
extern errcode intOPgt();
extern errcode sequenceOPsize();
extern errcode c_envOPerr();
extern errcode idnOPget_str();
extern errcode c_envOPget_unknown_type();
extern errcode oneofOPmake_13();
extern errcode c_sugar();
extern errcode sequenceOPbottom();
static CLUREF STR__047;
static CLUREF STR__047_040does_040not_040name_040a_040DU;
static CLUREF STR_fetch;
static int c_bracketref_own_init = 0;

errcode
c_bracketref(CLUREF e, CLUREF x, CLUREF ref, CLUREF *ret_1)
{
    errcode err;
    CLUREF i;
    CLUREF parms;
    CLUREF k;
    CLUREF cop;
    CLUREF x1;
    if (c_bracketref_own_init == 0) {
        stringOPcons("\'", CLU_1, CLUREF_make_num(1), &STR__047);
        stringOPcons("\' does not name a DU", CLU_1, CLUREF_make_num(20), &STR__047_040does_040not_040name_040a_040DU);
        stringOPcons("fetch", CLU_1, CLUREF_make_num(5), &STR_fetch);
        c_bracketref_own_init = 1;
    }
    enter_proc(45);

  LINE(46);
    {
    CLUREF T_1_1;
    T_1_1.num = ref.vec->data[0];
    i.num = T_1_1.num;
    }

  LINE(47);
    {
    CLUREF T_1_1;
    T_1_1.num = ref.vec->data[1];
    parms.num = T_1_1.num;
    }

  LINE(48);
    { /* qtagcase */
    CLUREF T_1_1;
    err = idnOPget_kind(i, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: /* gen */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(50);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(2, T_2_1);
        T_2_1.vec->data[0] = k.num;
        T_2_1.vec->data[1] = parms.num;
        err = c_gen_expr(e, x, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 3: /* opgen */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        k.num = T_1_3.num;

  LINE(53);
        {
        CLUREF T_2_1;
        err = c_constlist(e, parms, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ref.vec->data[1] = T_2_1.num;
        }

  LINE(54);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        RecordAlloc(3, T_2_1);
        err = c_envOPget_up_type(e, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[2] = T_2_2.num;
        T_2_1.vec->data[0] = k.num;
        T_2_3.num = ref.vec->data[1];
        T_2_1.vec->data[1] = T_2_3.num;
        cop.num = T_2_1.num;
        }

  LINE(57);
        {
        CLUREF T_2_1;
        CellAlloc(20, cop.num, T_2_1);
        err = exprOPset_abs(x, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(58);
        { /* return */
        {
        CLUREF T_2_1;
        err = c_clusterop1(e, cop, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 8: /* unknown */ {

  LINE(60);
        {
        err = c_envOPlookup(e, i, CLU_0);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(61);
        { /* return */
        {
        CLUREF T_2_1;
        err = c_bracketref(e, x, ref, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(64);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = parms.vec->size;
    T_1_2.num = (T_1_1.num > 1);
    if (T_1_2.num == true) { /* if */

  LINE(65);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_3, &T_2_1);
        T_2_1.vec->data[0] = STR__047.num;
        err = idnOPget_str(i, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        T_2_1.vec->data[2] = STR__047_040does_040not_040name_040a_040DU.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(66);
        { /* return */
        {
        CLUREF T_2_1;
        err = c_envOPget_unknown_type(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(68);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CellAlloc(13, i.num, T_1_1);
    err = c_envOPget_unknown_type(e, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    err = exprOPcreate(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    x1.num = T_1_3.num;
    }

  LINE(69);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    sequenceOPnew2(CLU_2, &T_1_1);
    T_1_1.vec->data[0] = x1.num;
    err = sequenceOPbottom(parms, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    err = c_sugar(e, x, STR_fetch, T_1_1, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_3.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_bracketref ****/



/**** BEGIN PROCEDURE c_apply_ref ****/

extern errcode c_gen_parms();
extern errcode typespecOPequal();
extern errcode c_envOPget_type_type();
extern errcode oneofOPmake_3();
extern errcode oneofOPmake_25();
extern errcode c_envOPtypes_illegal();
extern errcode get_type_print();
static CLUREF STR_use_040of_040type_040as_040expression_072_040;
static int c_apply_ref_own_init = 0;

errcode
c_apply_ref(CLUREF e, CLUREF x, CLUREF clut, CLUREF *ret_1)
{
    errcode err;
    CLUREF t;
    CLUREF tt;
    if (c_apply_ref_own_init == 0) {
        stringOPcons("use of type as expression: ", CLU_1, CLUREF_make_num(27), &STR_use_040of_040type_040as_040expression_072_040);
        c_apply_ref_own_init = 1;
    }
    enter_proc(72);

  LINE(73);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = clut.vec->data[1];
    err = c_constlist(e, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    clut.vec->data[1] = T_1_2.num;
    }

  LINE(74);
    {
    CLUREF T_1_1;
    err = c_gen_parms(e, clut, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    t.num = T_1_1.num;
    }

  LINE(75);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = c_envOPget_type_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = typespecOPequal(t, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_2.num == true) { /* if */

  LINE(76);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CellAlloc(3, clut.num, T_2_1);
        err = c_envOPget_type(e, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        tt.num = T_2_2.num;
        }

  LINE(77);
        {
        CLUREF T_2_1;
        CellAlloc(25, tt.num, T_2_1);
        err = exprOPset_abs(x, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(78);
        { /* if */
        CLUREF T_2_1;
        err = c_envOPtypes_illegal(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        if (T_2_1.num == true) { /* if */

  LINE(79);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            sequenceOPnew2(CLU_2, &T_3_1);
            T_3_1.vec->data[0] = STR_use_040of_040type_040as_040expression_072_040.num;
            err = get_type_print(t, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            T_3_1.vec->data[1] = T_3_2.num;
            err = c_envOPerr(e, T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        } /* end if */
    }
    } /* end if */

  LINE(83);
    { /* return */
    {
    ret_1->num = t.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_apply_ref ****/



/**** BEGIN PROCEDURE c_expr_type ****/

static int c_expr_type_own_init = 0;

errcode
c_expr_type(CLUREF e, CLUREF x, CLUREF t, CLUREF *ret_1)
{
    errcode err;
    if (c_expr_type_own_init == 0) {
        stringOPcons("use of type as expression: ", CLU_1, CLUREF_make_num(27), &STR_use_040of_040type_040as_040expression_072_040);
        c_expr_type_own_init = 1;
    }
    enter_proc(86);

  LINE(87);
    {
    CLUREF T_1_1;
    err = c_type(e, t, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    t.num = T_1_1.num;
    }

  LINE(88);
    {
    CLUREF T_1_1;
    CellAlloc(25, t.num, T_1_1);
    err = exprOPset_abs(x, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(89);
    { /* if */
    CLUREF T_1_1;
    err = c_envOPtypes_illegal(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_1.num == true) { /* if */

  LINE(90);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_2, &T_2_1);
        T_2_1.vec->data[0] = STR_use_040of_040type_040as_040expression_072_040.num;
        err = get_type_print(t, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    } /* end if */

  LINE(93);
    { /* return */
    {
    CLUREF T_1_1;
    err = c_envOPget_type_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_expr_type ****/



/**** BEGIN PROCEDURE c_anyize ****/


errcode
c_anyize(CLUREF e, CLUREF x, CLUREF *ret_1)
{
    errcode err;
    enter_proc(96);

  LINE(97);
    {
    CLUREF T_1_1;
    err = c_expr(e, x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(98);
    { /* return */
    {
    CLUREF T_1_1;
    err = c_envOPget_any_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_anyize ****/



/**** BEGIN PROCEDURE c_type_of ****/


errcode
c_type_of(CLUREF e, CLUREF x, CLUREF *ret_1)
{
    errcode err;
    enter_proc(101);

  LINE(102);
    {
    CLUREF T_1_1;
    err = c_expr(e, x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(103);
    { /* return */
    {
    CLUREF T_1_1;
    err = c_envOPget_type_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_type_of ****/



/**** BEGIN PROCEDURE c_gen_expr ****/

extern errcode typespecOPget_abs();
static int c_gen_expr_own_init = 0;

errcode
c_gen_expr(CLUREF e, CLUREF x, CLUREF dut, CLUREF *ret_1)
{
    errcode err;
    CLUREF t;
    CLUREF xt;
    if (c_gen_expr_own_init == 0) {
        stringOPcons("use of type as expression: ", CLU_1, CLUREF_make_num(27), &STR_use_040of_040type_040as_040expression_072_040);
        c_gen_expr_own_init = 1;
    }
    enter_proc(106);

  LINE(107);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = dut.vec->data[1];
    err = c_constlist(e, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    dut.vec->data[1] = T_1_2.num;
    }

  LINE(108);
    {
    CLUREF T_1_1;
    err = c_gen_parms(e, dut, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    t.num = T_1_1.num;
    }

  LINE(109);
    { /* qtagcase */
    CLUREF T_1_1;
    err = typespecOPget_abs(t, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 8: /* type_ */ {

  LINE(111);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CellAlloc(3, dut.num, T_2_1);
        err = c_envOPget_type(e, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        xt.num = T_2_2.num;
        }

  LINE(112);
        { /* if */
        CLUREF T_2_1;
        err = c_envOPtypes_illegal(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        if (T_2_1.num == true) { /* if */

  LINE(113);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            sequenceOPnew2(CLU_2, &T_3_1);
            T_3_1.vec->data[0] = STR_use_040of_040type_040as_040expression_072_040.num;
            err = get_type_print(xt, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            T_3_1.vec->data[1] = T_3_2.num;
            err = c_envOPerr(e, T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        } /* end if */

  LINE(116);
        {
        CLUREF T_2_1;
        CellAlloc(25, xt.num, T_2_1);
        err = exprOPset_abs(x, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    default: {

  LINE(118);
        {
        CLUREF T_2_1;
        CellAlloc(3, dut.num, T_2_1);
        err = exprOPset_abs(x, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(120);
    { /* return */
    {
    ret_1->num = t.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_gen_expr ****/



/**** BEGIN PROCEDURE c_gen_parms ****/

extern errcode c_get_duspecs();
extern errcode c_parms();
extern errcode subst_parms();
extern errcode oneofOPmake_1();
extern errcode oneofOPmake_6();
extern errcode duOPget_common();
static CLUREF STR_illegal_040parameters_040to_040DU_040_047;
static int c_gen_parms_own_init = 0;

errcode
c_gen_parms(CLUREF e, CLUREF dut, CLUREF *ret_1)
{
    errcode err;
    CLUREF gen;
    CLUREF parms;
    CLUREF specs;
    CLUREF inf;
    CLUREF ot;
    if (c_gen_parms_own_init == 0) {
        stringOPcons("illegal parameters to DU \'", CLU_1, CLUREF_make_num(26), &STR_illegal_040parameters_040to_040DU_040_047);
        stringOPcons("\'", CLU_1, CLUREF_make_num(1), &STR__047);
        c_gen_parms_own_init = 1;
    }
    enter_proc(123);

  LINE(124);
    {
    CLUREF T_1_1;
    T_1_1.num = dut.vec->data[0];
    gen.num = T_1_1.num;
    }

  LINE(125);
    {
    CLUREF T_1_1;
    T_1_1.num = dut.vec->data[1];
    parms.num = T_1_1.num;
    }

  LINE(126);
    {
    CLUREF T_1_1;
    err = c_get_duspecs(e, gen, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    specs.num = T_1_1.num;
    }

  LINE(127);
    { /* qtagcase */
    switch (specs.cell->tag) {
    case 3: /* cluster_ */ {
        CLUREF T_1_1;
        T_1_1.num = specs.cell->value;
        inf.num = T_1_1.num;

  LINE(129);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = inf.vec->data[1];
        err = c_parms(e, parms, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        if (T_2_2.num == true) { /* if */

  LINE(130);
            { /* return */
            {
            CLUREF T_3_1;
            err = c_envOPget_type_type(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            ret_1->num = T_3_1.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */
        break;
    }
    case 1: /* apply */ {
        CLUREF T_1_2;
        T_1_2.num = specs.cell->value;
        inf.num = T_1_2.num;

  LINE(132);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = inf.vec->data[0];
        err = c_parms(e, parms, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        if (T_2_2.num == true) { /* if */

  LINE(133);
            { /* return */
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = inf.vec->data[0];
            T_3_2.num = inf.vec->data[1];
            err = subst_parms(e, parms, T_3_1, T_3_2, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            ret_1->num = T_3_3.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */
        break;
    }
    case 4: /* none */ {

  LINE(135);
        {
        CLUREF T_2_1;
        CellAlloc(1, dut.num, T_2_1);
        ot.num = T_2_1.num;
        }

  LINE(136);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CellAlloc(6, ot.num, T_2_1);
        err = c_envOPget_type(e, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(139);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    sequenceOPnew2(CLU_3, &T_1_1);
    T_1_1.vec->data[0] = STR_illegal_040parameters_040to_040DU_040_047.num;
    err = duOPget_common(gen, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    T_1_1.vec->data[2] = STR__047.num;
    err = c_envOPerr(e, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(140);
    { /* return */
    {
    CLUREF T_1_1;
    err = c_envOPget_unknown_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_gen_parms ****/



/**** BEGIN PROCEDURE c_parms1 ****/

extern errcode boolOPnot();
extern errcode intOPequal();
extern errcode sequenceOPindexes();
extern errcode exprOPget_typespec();
extern errcode sequenceOPfetch();

errcode
c_parms1(CLUREF e, CLUREF vals, CLUREF forms, CLUREF *ret_1)
{
    errcode err;
    CLUREF i;
    CLUREF t;
    CLUREF k;
    enter_proc(143);

  LINE(144);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = vals.vec->size;
    T_1_2.num = forms.vec->size;
    T_1_3.num = (T_1_1.num == T_1_2.num);
    T_1_4.num = !T_1_3.num;
    if (T_1_4.num == true) { /* if */

  LINE(145);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(146);
    { /* for sequence$indexes */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = vals.vec->size;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        i.num = T_1_1.num;

  LINE(147);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (i.num < 1 || i.num > vals.vec->size) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.num = vals.vec->data[i.num - 1];
        err = exprOPget_typespec(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        t.num = T_2_2.num;
        }

  LINE(148);
        { /* qtagcase */
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (i.num < 1 || i.num > forms.vec->size) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.num = forms.vec->data[i.num - 1];
        err = idnOPget_kind(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_2.cell->tag) {
        case 6: /* tparm */ {

  LINE(150);
            { /* if */
            CLUREF T_3_1;
            CLUREF T_3_2;
            err = c_envOPget_type_type(e, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            err = typespecOPmismatch(T_3_1, t, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            if (T_3_2.num == true) { /* if */

  LINE(151);
                { /* return */
                {
                ret_1->tf = false;
                }
                signal (ERR_ok);
                }
            }
            } /* end if */
            break;
        }
        case 10: /* vparm */ {
            CLUREF T_2_3;
            T_2_3.num = T_2_2.cell->value;
            k.num = T_2_3.num;

  LINE(153);
            { /* if */
            CLUREF T_3_1;
            err = typespecOPmismatch(k, t, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            if (T_3_1.num == true) { /* if */

  LINE(154);
                { /* return */
                {
                ret_1->tf = false;
                }
                signal (ERR_ok);
                }
            }
            } /* end if */
            break;
        }
        default: {

  LINE(156);
            { /* return */
            {
            ret_1->tf = false;
            }
            signal (ERR_ok);
            }
            break;
        }
        }
        } /* end qtagcase */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(159);
    { /* return */
    {
    ret_1->tf = true;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_parms1 ****/



/**** BEGIN PROCEDURE c_parms ****/

extern errcode c_parms1();
extern errcode c_restrictions();

errcode
c_parms(CLUREF e, CLUREF vals, CLUREF forms, CLUREF *ret_1)
{
    errcode err;
    CLUREF ok;
    CLUREF i;
    CLUREF k;
    enter_proc(162);

  LINE(163);
    {
    CLUREF T_1_1;
    err = c_parms1(e, vals, forms, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ok.num = T_1_1.num;
    }

  LINE(164);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = !ok.num;
    if (T_1_1.num == true) { /* if */

  LINE(165);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(166);
    { /* for sequence$indexes */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = vals.vec->size;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        i.num = T_1_1.num;

  LINE(167);
        { /* qtagcase */
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (i.num < 1 || i.num > forms.vec->size) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.num = forms.vec->data[i.num - 1];
        err = idnOPget_kind(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_2.cell->tag) {
        case 6: /* tparm */ {
            CLUREF T_2_3;
            T_2_3.num = T_2_2.cell->value;
            k.num = T_2_3.num;

  LINE(169);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            if (i.num < 1 || i.num > vals.vec->size) {
                err = ERR_bounds;
                goto ex_0;
            }
            T_3_2.num = vals.vec->data[i.num - 1];
            err = c_restrictions(e, T_3_2, vals, forms, k, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            T_3_1.num = T_3_3.num;
            if (T_3_3.num) {
                T_3_1.num = ok.num;
            }
            ok.num = T_3_1.num;
            }
            break;
        }
        }
        } /* end qtagcase */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(173);
    { /* return */
    {
    ret_1->num = ok.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_parms ****/



/**** BEGIN PROCEDURE c_2_parms ****/

extern errcode sequenceOPconcat();
extern errcode sequenceOPelements();
extern errcode idnOPequal();

errcode
c_2_parms(CLUREF e, CLUREF vals, CLUREF forms, CLUREF cvals, CLUREF cforms, CLUREF reqs, CLUREF *ret_1)
{
    errcode err;
    CLUREF ok;
    CLUREF bvals;
    CLUREF bforms;
    CLUREF i;
    CLUREF k;
    CLUREF req;
    CLUREF p;
    enter_proc(176);

  LINE(179);
    {
    CLUREF T_1_1;
    err = c_parms1(e, vals, forms, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ok.num = T_1_1.num;
    }

  LINE(180);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = !ok.num;
    if (T_1_1.num == true) { /* if */

  LINE(181);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(182);
    {
    CLUREF T_1_1;
    err = sequenceOPconcat(cvals, vals, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    bvals.num = T_1_1.num;
    }

  LINE(183);
    {
    CLUREF T_1_1;
    err = sequenceOPconcat(cforms, forms, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    bforms.num = T_1_1.num;
    }

  LINE(184);
    { /* for sequence$indexes */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = vals.vec->size;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        i.num = T_1_1.num;

  LINE(185);
        { /* qtagcase */
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (i.num < 1 || i.num > forms.vec->size) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.num = forms.vec->data[i.num - 1];
        err = idnOPget_kind(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        switch (T_2_2.cell->tag) {
        case 6: /* tparm */ {
            CLUREF T_2_3;
            T_2_3.num = T_2_2.cell->value;
            k.num = T_2_3.num;

  LINE(187);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            if (i.num < 1 || i.num > vals.vec->size) {
                err = ERR_bounds;
                goto ex_0;
            }
            T_3_2.num = vals.vec->data[i.num - 1];
            err = c_restrictions(e, T_3_2, bvals, bforms, k, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            T_3_1.num = T_3_3.num;
            if (T_3_3.num) {
                T_3_1.num = ok.num;
            }
            ok.num = T_3_1.num;
            }
            break;
        }
        }
        } /* end qtagcase */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(192);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = reqs.vec->size;
    T_1_3 = reqs;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        req.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(193);
        {
        CLUREF T_2_1;
        T_2_1.num = req.vec->data[1];
        p.num = T_2_1.num;
        }

  LINE(194);
        { /* for sequence$indexes */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_2.num = cforms.vec->size;
        for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
            i.num = T_2_1.num;

  LINE(195);
            { /* if */
            CLUREF T_3_1;
            CLUREF T_3_2;
            if (i.num < 1 || i.num > cforms.vec->size) {
                err = ERR_bounds;
                goto ex_0;
            }
            T_3_1.num = cforms.vec->data[i.num - 1];
            err = idnOPequal(p, T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            if (T_3_2.num == true) { /* if */

  LINE(196);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                if (i.num < 1 || i.num > cvals.vec->size) {
                    err = ERR_bounds;
                    goto ex_0;
                }
                T_4_1.num = cvals.vec->data[i.num - 1];
                T_4_2.num = req.vec->data[0];
                err = c_restrictions(e, T_4_1, bvals, bforms, T_4_2, &T_4_3);
                if (err != ERR_ok)
                    goto ex_0;
                }
            }
            } /* end if */
        }
        }
        end_inline_for_3:
        __CLU_END_LABEL;
    }
    }
    end_inline_for_2:
    __CLU_END_LABEL;

  LINE(201);
    { /* return */
    {
    ret_1->num = ok.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_2_parms ****/



/**** BEGIN PROCEDURE c_invoke ****/

extern errcode intOPadd();
extern errcode intOPfrom_to_by();
extern errcode c_call();
extern errcode duOPequal();
extern errcode c_envOPget_iter_();
extern errcode get_inv_print();
extern errcode c_envOPget_seq_();
extern errcode recordOPget_4();
extern errcode recordOPget_3();
extern errcode recordOPset_1();
static CLUREF STR_illegal_040iterator_040invocation_072_040;
static CLUREF STR__045call;
static CLUREF STR_invocation_040of_040non_055procedure_072_040;
static int c_invoke_own_init = 0;

errcode
c_invoke(CLUREF e, CLUREF inv, CLUREF done_first, CLUREF *ret_1)
{
    errcode err;
    CLUREF pt;
    CLUREF args;
    CLUREF beg;
    CLUREF i;
    CLUREF pta;
    CLUREF vals;
    CLUREF x;
    CLUREF st;
    CLUREF p;
    CLUREF ot;
    CLUREF t;
    CLUREF ut;
    if (c_invoke_own_init == 0) {
        stringOPcons("illegal iterator invocation: ", CLU_1, CLUREF_make_num(29), &STR_illegal_040iterator_040invocation_072_040);
        stringOPcons("%call", CLU_1, CLUREF_make_num(5), &STR__045call);
        stringOPcons("invocation of non-procedure: ", CLU_1, CLUREF_make_num(29), &STR_invocation_040of_040non_055procedure_072_040);
        c_invoke_own_init = 1;
    }
    enter_proc(204);

  LINE(205);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = inv.vec->data[0];
    err = c_expr(e, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    pt.num = T_1_2.num;
    }

  LINE(206);
    {
    CLUREF T_1_1;
    T_1_1.num = inv.vec->data[1];
    args.num = T_1_1.num;
    }

  LINE(207);
    {
    beg.num = 1;
    }

  LINE(208);
    { /* if */
    if (done_first.num == true) { /* if */
        {
        CLUREF T_2_1;
        T_2_1.num = beg.num + 1;
        if ((T_2_1.num > 0 && beg.num < 0 && 1 < 0) ||
            (T_2_1.num < 0 && beg.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        beg.num = T_2_1.num;
        }
    }
    } /* end if */

  LINE(209);
    { /* for int$from_to_by */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = args.vec->size;
    T_1_3.num = T_1_1.num;
    T_1_4.num = 1;
    for (T_1_2.num = beg.num; ((T_1_4.num == 0) || ((T_1_4.num > 0)? (T_1_2.num <= T_1_3.num) : (T_1_2.num >= T_1_3.num))); T_1_2.num += T_1_4.num) {
        i.num = T_1_2.num;

  LINE(210);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (i.num < 1 || i.num > args.vec->size) {
            err = ERR_bounds;
            goto ex_0;
        }
        T_2_1.num = args.vec->data[i.num - 1];
        err = c_expr(e, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(212);
    { /* qtagcase */
    CLUREF T_1_1;
    err = typespecOPget_abs(pt, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: /* apply */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        pta.num = T_1_2.num;

  LINE(214);
        {
        CLUREF T_2_1;
        err = c_call(e, pta, inv, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        vals.num = T_2_1.num;
        }

  LINE(215);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = pta.vec->data[1];
        err = c_envOPget_proc_(e, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        err = duOPequal(T_2_1, T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        if (T_2_3.num == true) { /* if */

  LINE(216);
            { /* return */
            {
            ret_1->num = vals.num;
            }
            signal (ERR_ok);
            }
        }
        else {

  LINE(217);
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        T_2_4.num = pta.vec->data[1];
        err = c_envOPget_iter_(e, &T_2_5);
        if (err != ERR_ok)
            goto ex_0;
        err = duOPequal(T_2_4, T_2_5, &T_2_6);
        if (err != ERR_ok)
            goto ex_0;
        if (T_2_6.num == true) { /* elseif */

  LINE(218);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            sequenceOPnew2(CLU_2, &T_3_1);
            T_3_1.vec->data[0] = STR_illegal_040iterator_040invocation_072_040.num;
            err = get_inv_print(inv, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            T_3_1.vec->data[1] = T_3_2.num;
            err = c_envOPerr(e, T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            }

  LINE(220);
            { /* return */
            {
            ret_1->num = vals.num;
            }
            signal (ERR_ok);
            }
        }
        }} /* end if */

  LINE(222);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        err = c_envOPget_any_type(e, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        CellAlloc(25, T_2_1.num, T_2_2);
        err = c_envOPget_type_type(e, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        err = exprOPcreate(T_2_2, T_2_3, &T_2_4);
        if (err != ERR_ok)
            goto ex_0;
        x.num = T_2_4.num;
        }

  LINE(224);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        RecordAlloc(2, T_2_1);
        err = c_envOPget_seq_(e, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[0] = T_2_2.num;
        sequenceOPnew2(CLU_1, &T_2_3);
        T_2_3.vec->data[0] = x.num;
        T_2_1.vec->data[1] = T_2_3.num;
        CellAlloc(3, T_2_1.num, T_2_4);
        err = c_envOPget_type(e, T_2_4, &T_2_5);
        if (err != ERR_ok)
            goto ex_0;
        st.num = T_2_5.num;
        }

  LINE(228);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        RecordAlloc(3, T_2_1);
        T_2_1.vec->data[2] = st.num;
        CellAlloc(1, nil, T_2_2);
        T_2_1.vec->data[1] = T_2_2.num;
        T_2_1.vec->data[0] = args.num;
        CellAlloc(1, T_2_1.num, T_2_3);
        err = exprOPcreate(T_2_3, st, &T_2_4);
        if (err != ERR_ok)
            goto ex_0;
        x.num = T_2_4.num;
        }

  LINE(233);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_2, &T_2_1);
        T_2_2.num = inv.vec->data[0];
        T_2_1.vec->data[0] = T_2_2.num;
        T_2_1.vec->data[1] = x.num;
        inv.vec->data[1] = T_2_1.num;
        }

  LINE(234);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        RecordAlloc(3, T_2_1);
        T_2_1.vec->data[2] = pt.num;
        T_2_1.vec->data[0] = STR__045call.num;
        sequenceOPnew2(CLU_0, &T_2_2);
        T_2_1.vec->data[1] = T_2_2.num;
        CellAlloc(20, T_2_1.num, T_2_3);
        p.num = T_2_3.num;
        }

  LINE(237);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        RecordAlloc(4, T_2_1);
        err = c_envOPget_proc_(e, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        sequenceOPnew2(CLU_2, &T_2_3);
        T_2_3.vec->data[0] = pt.num;
        T_2_3.vec->data[1] = st.num;
        T_2_1.vec->data[0] = T_2_3.num;
        T_2_4.num = pta.vec->data[3];
        T_2_1.vec->data[3] = T_2_4.num;
        T_2_5.num = pta.vec->data[2];
        T_2_1.vec->data[2] = T_2_5.num;
        pta.num = T_2_1.num;
        }

  LINE(241);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CellAlloc(2, pta.num, T_2_1);
        err = c_envOPget_type(e, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        pt.num = T_2_2.num;
        }

  LINE(242);
        {
        CLUREF T_2_1;
        err = exprOPcreate(p, pt, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        inv.vec->data[0] = T_2_1.num;
        }

  LINE(243);
        { /* return */
        {
        ret_1->num = vals.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 6: /* other */ {

  LINE(245);
        {
        CLUREF T_2_1;
        CellAlloc(3, pt.num, T_2_1);
        ot.num = T_2_1.num;
        }

  LINE(246);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CellAlloc(6, ot.num, T_2_1);
        err = c_envOPget_type(e, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        t.num = T_2_2.num;
        }

  LINE(247);
        { /* return */
        {
        CLUREF T_2_1;
        err = sequenceOPe2s(t, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 9: /* unknown */ {
        break;
    }
    default: {

  LINE(250);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_2, &T_2_1);
        T_2_1.vec->data[0] = STR_invocation_040of_040non_055procedure_072_040.num;
        err = get_inv_print(inv, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
        break;
    }
    }
    } /* end qtagcase */

  LINE(253);
    {
    CLUREF T_1_1;
    err = c_envOPget_unknown_type(e, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ut.num = T_1_1.num;
    }

  LINE(254);
    { /* return */
    {
    CLUREF T_1_1;
    err = sequenceOPe2s(ut, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_invoke ****/



/**** BEGIN PROCEDURE c_call ****/

extern errcode c_args();
extern errcode c_envOPadd_cond();

errcode
c_call(CLUREF e, CLUREF at, CLUREF inv, CLUREF *ret_1)
{
    errcode err;
    CLUREF sig;
    enter_proc(257);

  LINE(258);
    {
    CLUREF T_1_1;
    T_1_1.num = at.vec->data[0];
    err = c_args(e, T_1_1, inv);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(259);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = at.vec->data[2];
    T_1_3.num = T_1_1.vec->size;
    T_1_4 = T_1_1;
    for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
        sig.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(260);
        {
        err = c_envOPadd_cond(e, sig, CLU_false);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(262);
    { /* return */
    {
    CLUREF T_1_1;
    T_1_1.num = at.vec->data[3];
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_call ****/



/**** BEGIN PROCEDURE c_args ****/

extern errcode intOPunparse();
extern errcode sequenceOPreplace();
static CLUREF STR__040arguments_040to_040_047;
static CLUREF STR__047_054_040;
static CLUREF STR__040expected;
static CLUREF STR_argument_040;
static CLUREF STR__040to_040_047;
static int c_args_own_init = 0;

errcode
c_args(CLUREF e, CLUREF types, CLUREF inv)
{
    errcode err;
    CLUREF args;
    CLUREF i;
    CLUREF x;
    if (c_args_own_init == 0) {
        stringOPcons(" arguments to \'", CLU_1, CLUREF_make_num(15), &STR__040arguments_040to_040_047);
        stringOPcons("\', ", CLU_1, CLUREF_make_num(3), &STR__047_054_040);
        stringOPcons(" expected", CLU_1, CLUREF_make_num(9), &STR__040expected);
        stringOPcons("argument ", CLU_1, CLUREF_make_num(9), &STR_argument_040);
        stringOPcons(" to \'", CLU_1, CLUREF_make_num(5), &STR__040to_040_047);
        stringOPcons("\'", CLU_1, CLUREF_make_num(1), &STR__047);
        c_args_own_init = 1;
    }
    enter_proc(265);

  LINE(266);
    {
    CLUREF T_1_1;
    T_1_1.num = inv.vec->data[1];
    args.num = T_1_1.num;
    }

  LINE(267);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = args.vec->size;
    T_1_2.num = types.vec->size;
    T_1_3.num = (T_1_1.num == T_1_2.num);
    T_1_4.num = !T_1_3.num;
    if (T_1_4.num == true) { /* if */

  LINE(268);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        sequenceOPnew2(CLU_6, &T_2_1);
        T_2_2.num = args.vec->size;
        err = intOPunparse(T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[0] = T_2_3.num;
        T_2_1.vec->data[1] = STR__040arguments_040to_040_047.num;
        err = get_inv_print(inv, &T_2_4);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[2] = T_2_4.num;
        T_2_1.vec->data[3] = STR__047_054_040.num;
        T_2_5.num = types.vec->size;
        err = intOPunparse(T_2_5, &T_2_6);
        if (err != ERR_ok)
            goto ex_0;
        T_2_1.vec->data[4] = T_2_6.num;
        T_2_1.vec->data[5] = STR__040expected.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(273);
        { /* return */
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(275);
    { /* for sequence$indexes */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = args.vec->size;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        i.num = T_1_1.num;

  LINE(276);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        if (i.num < 1 || i.num > types.vec->size) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_1.num = types.vec->data[i.num - 1];
        if (i.num < 1 || i.num > args.vec->size) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_2.num = args.vec->data[i.num - 1];
        err = exprOPget_typespec(T_3_2, &T_3_3);
        if (err != ERR_ok)
            goto ex_1;
        err = typespecOPmismatch(T_3_1, T_3_3, &T_3_4);
        if (err != ERR_ok)
            goto ex_1;
        if (T_3_4.num == true) { /* if */

  LINE(277);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            CLUREF T_4_6;
            sequenceOPnew2(CLU_5, &T_4_1);
            T_4_1.vec->data[0] = STR_argument_040.num;
            err = intOPunparse(i, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            T_4_1.vec->data[1] = T_4_2.num;
            T_4_1.vec->data[2] = STR__040to_040_047.num;
            err = get_inv_print(inv, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            T_4_1.vec->data[3] = T_4_3.num;
            T_4_1.vec->data[4] = STR__047.num;
            if (i.num < 1 || i.num > types.vec->size) {
                err = ERR_bounds;
                goto ex_1;
            }
            T_4_4.num = types.vec->data[i.num - 1];
            if (i.num < 1 || i.num > args.vec->size) {
                err = ERR_bounds;
                goto ex_1;
            }
            T_4_5.num = args.vec->data[i.num - 1];
            err = exprOPget_typespec(T_4_5, &T_4_6);
            if (err != ERR_ok)
                goto ex_1;
            err = c_envOPerrt(e, T_4_1, T_4_4, T_4_6);
            if (err != ERR_ok)
                goto ex_1;
            }
        }
        } /* end if */
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_anyize) {

  LINE(281);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            if (i.num < 1 || i.num > args.vec->size) {
                err = ERR_bounds;
                goto ex_0;
            }
            T_3_1.num = args.vec->data[i.num - 1];
            CellAlloc(2, T_3_1.num, T_3_2);
            if (i.num < 1 || i.num > types.vec->size) {
                err = ERR_bounds;
                goto ex_0;
            }
            T_3_3.num = types.vec->data[i.num - 1];
            err = exprOPcreate(T_3_2, T_3_3, &T_3_4);
            if (err != ERR_ok)
                goto ex_0;
            x.num = T_3_4.num;
            }

  LINE(283);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = inv.vec->data[1];
            err = sequenceOPreplace(T_3_1, i, x, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            inv.vec->data[1] = T_3_2.num;
            }
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE c_args ****/



/**** BEGIN PROCEDURE c_exprlist ****/

extern errcode sequenceOPaddh();

errcode
c_exprlist(CLUREF e, CLUREF exprs, CLUREF *ret_1)
{
    errcode err;
    CLUREF types;
    CLUREF x;
    enter_proc(288);

  LINE(289);
    {
    CLUREF T_1_1;
    err = sequenceOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    types.num = T_1_1.num;
    }

  LINE(290);
    { /* for sequence$elements */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_2.num = exprs.vec->size;
    T_1_3 = exprs;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
        x.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(291);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = c_expr(e, x, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = sequenceOPaddh(types, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        types.num = T_2_2.num;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

  LINE(293);
    { /* return */
    {
    ret_1->num = types.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE c_exprlist ****/



/**** BEGIN PROCEDURE get_type_print ****/

extern errcode get_clutype_print();
extern errcode stringOPconcat();
extern errcode get_clusterop_print();
static CLUREF STR__133_056_056;
static CLUREF STR__056_056_135;
static CLUREF STR_type_137of_050;
static CLUREF STR__051;
static CLUREF STR_return_137type_137of_050;
static CLUREF STR_any;
static CLUREF STR_type;
static CLUREF STR_cvt;
static CLUREF STR__056_056;
static CLUREF STR__077type_077;
static CLUREF STR__047ILLEGAL_040TYPE_041_047;
static int get_type_print_own_init = 0;

errcode
get_type_print(CLUREF t, CLUREF *ret_1)
{
    errcode err;
    CLUREF ta;
    CLUREF clut;
    CLUREF cop;
    CLUREF ty;
    if (get_type_print_own_init == 0) {
        stringOPcons("[..", CLU_1, CLUREF_make_num(3), &STR__133_056_056);
        stringOPcons("..]", CLU_1, CLUREF_make_num(3), &STR__056_056_135);
        stringOPcons("type_of(", CLU_1, CLUREF_make_num(8), &STR_type_137of_050);
        stringOPcons(")", CLU_1, CLUREF_make_num(1), &STR__051);
        stringOPcons("return_type_of(", CLU_1, CLUREF_make_num(15), &STR_return_137type_137of_050);
        stringOPcons("any", CLU_1, CLUREF_make_num(3), &STR_any);
        stringOPcons("type", CLU_1, CLUREF_make_num(4), &STR_type);
        stringOPcons("cvt", CLU_1, CLUREF_make_num(3), &STR_cvt);
        stringOPcons("..", CLU_1, CLUREF_make_num(2), &STR__056_056);
        stringOPcons("?type?", CLU_1, CLUREF_make_num(6), &STR__077type_077);
        stringOPcons("\'ILLEGAL TYPE!\'", CLU_1, CLUREF_make_num(15), &STR__047ILLEGAL_040TYPE_041_047);
        get_type_print_own_init = 1;
    }
    enter_proc(296);

  LINE(297);
    { /* qtagcase */
    CLUREF T_1_1;
    err = typespecOPget_abs(t, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 3: /* cluster_ */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        ta.num = T_1_2.num;

  LINE(299);
        { /* return */
        {
        CLUREF T_2_1;
        err = get_clutype_print(ta, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 7: /* select */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        ta.num = T_1_3.num;

  LINE(301);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        CLUREF T_2_7;
        CLUREF T_2_8;
        T_2_1.num = ta.vec->data[0];
        err = duOPget_common(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_2, STR__133_056_056, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_4.num = ta.vec->data[1];
        T_2_5.num = T_2_4.vec->size;
        err = intOPunparse(T_2_5, &T_2_6);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_3, T_2_6, &T_2_7);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_7, STR__056_056_135, &T_2_8);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_8.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 5: /* idn */ {
        CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        ta.num = T_1_4.num;

  LINE(304);
        { /* return */
        {
        CLUREF T_2_1;
        err = idnOPget_str(ta, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 6: /* other */ {
        CLUREF T_1_5;
        T_1_5.num = T_1_1.cell->value;
        ta.num = T_1_5.num;

  LINE(306);
        { /* qtagcase */
        switch (ta.cell->tag) {
        case 1: /* du */ {
            CLUREF T_2_1;
            T_2_1.num = ta.cell->value;
            clut.num = T_2_1.num;

  LINE(308);
            { /* return */
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = get_clutype_print(clut, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(STR_type_137of_050, T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_2, STR__051, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            ret_1->num = T_3_3.num;
            }
            signal (ERR_ok);
            }
            break;
        }
        case 2: /* op */ {
            CLUREF T_2_2;
            T_2_2.num = ta.cell->value;
            cop.num = T_2_2.num;

  LINE(310);
            { /* return */
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = get_clusterop_print(cop, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(STR_type_137of_050, T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_2, STR__051, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            ret_1->num = T_3_3.num;
            }
            signal (ERR_ok);
            }
            break;
        }
        case 3: /* return_ */ {
            CLUREF T_2_3;
            T_2_3.num = ta.cell->value;
            ty.num = T_2_3.num;

  LINE(312);
            { /* return */
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = get_type_print(ty, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(STR_return_137type_137of_050, T_3_1, &T_3_2);
            if (err != ERR_ok)
                goto ex_0;
            err = stringOPconcat(T_3_2, STR__051, &T_3_3);
            if (err != ERR_ok)
                goto ex_0;
            ret_1->num = T_3_3.num;
            }
            signal (ERR_ok);
            }
            break;
        }
        }
        } /* end qtagcase */
        break;
    }
    case 1: /* any_ */ {

  LINE(315);
        { /* return */
        {
        ret_1->str = STR_any.str;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 8: /* type_ */ {

  LINE(317);
        { /* return */
        {
        ret_1->str = STR_type.str;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 4: /* cvt_ */ {

  LINE(319);
        { /* return */
        {
        ret_1->str = STR_cvt.str;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 2: /* apply */ {
        CLUREF T_1_6;
        T_1_6.num = T_1_1.cell->value;
        ta.num = T_1_6.num;

  LINE(321);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        CLUREF T_2_7;
        CLUREF T_2_8;
        CLUREF T_2_9;
        CLUREF T_2_10;
        CLUREF T_2_11;
        CLUREF T_2_12;
        CLUREF T_2_13;
        CLUREF T_2_14;
        CLUREF T_2_15;
        CLUREF T_2_16;
        CLUREF T_2_17;
        CLUREF T_2_18;
        T_2_1.num = ta.vec->data[1];
        err = duOPget_common(T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_2, STR__133_056_056, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        T_2_4.num = ta.vec->data[0];
        T_2_5.num = T_2_4.vec->size;
        err = intOPunparse(T_2_5, &T_2_6);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_3, T_2_6, &T_2_7);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_7, STR__056_056, &T_2_8);
        if (err != ERR_ok)
            goto ex_0;
        T_2_9.num = ta.vec->data[3];
        T_2_10.num = T_2_9.vec->size;
        err = intOPunparse(T_2_10, &T_2_11);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_8, T_2_11, &T_2_12);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_12, STR__056_056, &T_2_13);
        if (err != ERR_ok)
            goto ex_0;
        T_2_14.num = ta.vec->data[2];
        T_2_15.num = T_2_14.vec->size;
        err = intOPunparse(T_2_15, &T_2_16);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_13, T_2_16, &T_2_17);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_17, STR__056_056_135, &T_2_18);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_18.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 9: /* unknown */ {

  LINE(326);
        { /* return */
        {
        ret_1->str = STR__077type_077.str;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(328);
        { /* return */
        {
        ret_1->str = STR__047ILLEGAL_040TYPE_041_047.str;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_type_print ****/



/**** BEGIN PROCEDURE get_inv_print ****/

static CLUREF STR_force_133;
static CLUREF STR__135;
static CLUREF STR__050computed_040value_051;
static int get_inv_print_own_init = 0;

errcode
get_inv_print(CLUREF inv, CLUREF *ret_1)
{
    errcode err;
    CLUREF xa;
    if (get_inv_print_own_init == 0) {
        stringOPcons("force[", CLU_1, CLUREF_make_num(6), &STR_force_133);
        stringOPcons("]", CLU_1, CLUREF_make_num(1), &STR__135);
        stringOPcons("(computed value)", CLU_1, CLUREF_make_num(16), &STR__050computed_040value_051);
        get_inv_print_own_init = 1;
    }
    enter_proc(332);

  LINE(333);
    { /* qtagcase */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = inv.vec->data[0];
    err = exprOPget_abs(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_2.cell->tag) {
    case 13: /* idn */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_2.cell->value;
        xa.num = T_1_3.num;

  LINE(335);
        { /* return */
        {
        CLUREF T_2_1;
        err = idnOPget_str(xa, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 3: /* apply */ {
        CLUREF T_1_4;
        T_1_4.num = T_1_2.cell->value;
        xa.num = T_1_4.num;

  LINE(337);
        { /* return */
        {
        CLUREF T_2_1;
        err = get_clutype_print(xa, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 20: /* op */ {
        CLUREF T_1_5;
        T_1_5.num = T_1_2.cell->value;
        xa.num = T_1_5.num;

  LINE(339);
        { /* return */
        {
        CLUREF T_2_1;
        err = get_clusterop_print(xa, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 11: /* force_ */ {
        CLUREF T_1_6;
        T_1_6.num = T_1_2.cell->value;
        xa.num = T_1_6.num;

  LINE(341);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = get_type_print(xa, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(STR_force_133, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_2, STR__135, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_3.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(343);
        { /* return */
        {
        ret_1->str = STR__050computed_040value_051.str;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_inv_print ****/



/**** BEGIN PROCEDURE get_clusterop_print ****/

extern errcode c_fixup_opname();
extern errcode sequenceOPempty();
static CLUREF STR__044;
static int get_clusterop_print_own_init = 0;

errcode
get_clusterop_print(CLUREF cop, CLUREF *ret_1)
{
    errcode err;
    CLUREF n;
    if (get_clusterop_print_own_init == 0) {
        stringOPcons("$", CLU_1, CLUREF_make_num(1), &STR__044);
        stringOPcons("[..", CLU_1, CLUREF_make_num(3), &STR__133_056_056);
        stringOPcons("..]", CLU_1, CLUREF_make_num(3), &STR__056_056_135);
        get_clusterop_print_own_init = 1;
    }
    enter_proc(347);

  LINE(348);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = cop.vec->data[0];
    err = c_fixup_opname(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    n.num = T_1_2.num;
    }

  LINE(349);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = cop.vec->data[2];
    err = get_type_print(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    err = stringOPconcat(T_1_2, STR__044, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    err = stringOPconcat(T_1_3, n, &T_1_4);
    if (err != ERR_ok)
        goto ex_0;
    n.num = T_1_4.num;
    }

  LINE(350);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = cop.vec->data[1];
    err = sequenceOPempty(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_2.num == true) { /* if */

  LINE(351);
        { /* return */
        {
        ret_1->num = n.num;
        }
        signal (ERR_ok);
        }
    }
    else { /* else */

  LINE(352);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        err = stringOPconcat(n, STR__133_056_056, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        T_2_2.num = cop.vec->data[1];
        T_2_3.num = T_2_2.vec->size;
        err = intOPunparse(T_2_3, &T_2_4);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_1, T_2_4, &T_2_5);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_5, STR__056_056_135, &T_2_6);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_6.num;
        }
        signal (ERR_ok);
        }
    }} /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_clusterop_print ****/



/**** BEGIN PROCEDURE get_clutype_print ****/

extern errcode get_expr_print();
static CLUREF STR__133;
static int get_clutype_print_own_init = 0;

errcode
get_clutype_print(CLUREF clut, CLUREF *ret_1)
{
    errcode err;
    CLUREF gs;
    if (get_clutype_print_own_init == 0) {
        stringOPcons("[", CLU_1, CLUREF_make_num(1), &STR__133);
        stringOPcons("]", CLU_1, CLUREF_make_num(1), &STR__135);
        stringOPcons("[..", CLU_1, CLUREF_make_num(3), &STR__133_056_056);
        stringOPcons("..]", CLU_1, CLUREF_make_num(3), &STR__056_056_135);
        get_clutype_print_own_init = 1;
    }
    enter_proc(357);

  LINE(358);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = clut.vec->data[0];
    err = duOPget_common(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    gs.num = T_1_2.num;
    }

  LINE(359);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = clut.vec->data[1];
    err = sequenceOPempty(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    if (T_1_2.num == true) { /* if */

  LINE(360);
        { /* return */
        {
        ret_1->num = gs.num;
        }
        signal (ERR_ok);
        }
    }
    else {

  LINE(361);
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    T_1_3.num = clut.vec->data[1];
    T_1_4.num = T_1_3.vec->size;
    T_1_5.num = (T_1_4.num == 1);
    if (T_1_5.num == true) { /* elseif */

  LINE(362);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        err = stringOPconcat(gs, STR__133, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        T_2_2.num = clut.vec->data[1];
        err = sequenceOPbottom(T_2_2, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        err = get_expr_print(T_2_3, &T_2_4);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_1, T_2_4, &T_2_5);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_5, STR__135, &T_2_6);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_6.num;
        }
        signal (ERR_ok);
        }
    }
    else { /* else */

  LINE(364);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        err = stringOPconcat(gs, STR__133_056_056, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        T_2_2.num = clut.vec->data[1];
        T_2_3.num = T_2_2.vec->size;
        err = intOPunparse(T_2_3, &T_2_4);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_1, T_2_4, &T_2_5);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_5, STR__056_056_135, &T_2_6);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_6.num;
        }
        signal (ERR_ok);
        }
    }}} /* end if */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_clutype_print ****/



/**** BEGIN PROCEDURE get_expr_print ****/

extern errcode realOPunparse();
extern errcode stringOPc2s();
static CLUREF STR_nil;
static CLUREF STR_true;
static CLUREF STR_false;
static CLUREF STR__042;
static CLUREF STR__056_056_056;
static int get_expr_print_own_init = 0;

errcode
get_expr_print(CLUREF x, CLUREF *ret_1)
{
    errcode err;
    CLUREF b;
    CLUREF i;
    CLUREF r;
    CLUREF c;
    CLUREF s;
    CLUREF t;
    if (get_expr_print_own_init == 0) {
        stringOPcons("nil", CLU_1, CLUREF_make_num(3), &STR_nil);
        stringOPcons("true", CLU_1, CLUREF_make_num(4), &STR_true);
        stringOPcons("false", CLU_1, CLUREF_make_num(5), &STR_false);
        stringOPcons("\'", CLU_1, CLUREF_make_num(1), &STR__047);
        stringOPcons("\"", CLU_1, CLUREF_make_num(1), &STR__042);
        stringOPcons("...", CLU_1, CLUREF_make_num(3), &STR__056_056_056);
        get_expr_print_own_init = 1;
    }
    enter_proc(369);

  LINE(370);
    { /* qtagcase */
    CLUREF T_1_1;
    err = exprOPget_abs(x, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    switch (T_1_1.cell->tag) {
    case 19: /* null_ */ {

  LINE(372);
        { /* return */
        {
        ret_1->str = STR_nil.str;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 5: /* bool_ */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        b.num = T_1_2.num;

  LINE(374);
        { /* if */
        if (b.num == true) { /* if */

  LINE(375);
            { /* return */
            {
            ret_1->str = STR_true.str;
            }
            signal (ERR_ok);
            }
        }
        else { /* else */

  LINE(376);
            { /* return */
            {
            ret_1->str = STR_false.str;
            }
            signal (ERR_ok);
            }
        }} /* end if */
        break;
    }
    case 15: /* int_ */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        i.num = T_1_3.num;

  LINE(379);
        { /* return */
        {
        CLUREF T_2_1;
        err = intOPunparse(i, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 21: /* real_ */ {
        CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        r.num = T_1_4.num;

  LINE(381);
        { /* return */
        {
        CLUREF T_2_1;
        err = realOPunparse(r, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 7: /* char_ */ {
        CLUREF T_1_5;
        T_1_5.num = T_1_1.cell->value;
        c.num = T_1_5.num;

  LINE(383);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = stringOPc2s(c, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(STR__047, T_2_1, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_2, STR__047, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_3.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 24: /* str */ {
        CLUREF T_1_6;
        T_1_6.num = T_1_1.cell->value;
        s.num = T_1_6.num;

  LINE(385);
        { /* return */
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = stringOPconcat(STR__042, s, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = stringOPconcat(T_2_1, STR__042, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 25: /* type_ */ {
        CLUREF T_1_7;
        T_1_7.num = T_1_1.cell->value;
        t.num = T_1_7.num;

  LINE(387);
        { /* return */
        {
        CLUREF T_2_1;
        err = get_type_print(t, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 13: /* idn */ {
        CLUREF T_1_8;
        T_1_8.num = T_1_1.cell->value;
        i.num = T_1_8.num;

  LINE(389);
        { /* return */
        {
        CLUREF T_2_1;
        err = idnOPget_str(i, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(391);
        { /* return */
        {
        ret_1->str = STR__056_056_056.str;
        }
        signal (ERR_ok);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_expr_print ****/

