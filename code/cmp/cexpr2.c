
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"

extern errcode c_type();
extern errcode exprOPset_abs();
extern errcode oneofOPmake_11();
extern errcode sequenceOPnew();
extern errcode c_envOPget_proc_();
extern errcode sequenceOPe2s();
extern errcode c_envOPget_any_type();
extern errcode c_envOPget_type();
extern errcode oneofOPmake_2();
CLUREF STR_wrong_137type;
static int c_force_own_init = 0;

/**** BEGIN PROCEDURE c_force ****/

errcode c_force(e, x, t, ret_1)
CLUREF e;
CLUREF x;
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF sig;
    CLUREF at;
        if (c_force_own_init == 0) {
        stringOPcons("wrong_type", CLU_1, CLU_10, &STR_wrong_137type);
        c_force_own_init = 1;
    }
    enter_proc(6);

  LINE(7);
    {
    CLUREF T_1_1;
    err = c_type(e, t, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    t.num = T_1_1.num;
    }

  LINE(8);
    {
    CLUREF T_1_1;
    CellAlloc(11, t.num, T_1_1);
    err = exprOPset_abs(x, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(10);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        RecordAlloc(2, T_1_1);
        T_1_1.vec->data[0]  = STR_wrong_137type.num;
        err = sequenceOPnew(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1]  = T_1_2.num;
        sig.num = T_1_1.num;
        }
        }

  LINE(12);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        CLUREF T_1_6;
        RecordAlloc(4, T_1_1);
        err = c_envOPget_proc_(e, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1]  = T_1_2.num;
        err = c_envOPget_any_type(e, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        err = sequenceOPe2s(T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_4.num;
        err = sequenceOPe2s(t, &T_1_5);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[3]  = T_1_5.num;
        err = sequenceOPe2s(sig, &T_1_6);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[2]  = T_1_6.num;
        at.num = T_1_1.num;
        }
        }

  LINE(16);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CellAlloc(2, at.num, T_1_1);
    err = c_envOPget_type(e, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_force ****/


extern errcode c_expr();
extern errcode c_envOPin_cluster();
extern errcode typespecOPmismatch();
extern errcode c_envOPget_down_type();
extern errcode c_envOPerrt();
extern errcode exprOPcreate();
extern errcode exprOPget_abs();
extern errcode exprOPset_typespec();
extern errcode c_envOPerr1();
extern errcode c_envOPget_up_type();
CLUREF STR_argument_040to_040UP;
CLUREF STR_use_040of_040UP_040operation_040outside_040of_040a_040cluster;
static int c_up_own_init = 0;

/**** BEGIN PROCEDURE c_up ****/

errcode c_up(e, x, ret_1)
CLUREF e;
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF t;
        if (c_up_own_init == 0) {
        stringOPcons("argument to UP", CLU_1, CLU_14, &STR_argument_040to_040UP);
        stringOPcons("use of UP operation outside of a cluster", CLU_1, CLU_40, &STR_use_040of_040UP_040operation_040outside_040of_040a_040cluster);
        c_up_own_init = 1;
    }
    enter_proc(19);

  LINE(20);
    {
        {CLUREF T_1_1;
        err = c_expr(e, x, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        t.num = T_1_1.num;
        }
        }

  LINE(21);
    {
    CLUREF T_1_1;
    err = c_envOPin_cluster(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(22);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = c_envOPget_down_type(e, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        err = typespecOPmismatch(T_3_1, t, &T_3_2);
        if (err != ERR_ok) goto ex_1;
        if (T_3_2.num == true) {

  LINE(23);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            sequenceOPnew2(CLU_1, &T_4_1);
            T_4_1.vec->data[0] = STR_argument_040to_040UP.num;
            err = c_envOPget_down_type(e, &T_4_2);
            if (err != ERR_ok) goto ex_1;
            err = c_envOPerrt(e, T_4_1, T_4_2, t);
            if (err != ERR_ok) goto ex_1;
            }
            }
            }/* end if */
            goto end_1;
            ex_1:
                if ((err == ERR_anyize)) {

  LINE(26);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    err = exprOPget_abs(x, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = exprOPcreate(T_3_1, t, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    CellAlloc(2, T_3_2.num, T_3_3);
                    err = exprOPset_abs(x, T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    }

  LINE(27);
                    {
                    CLUREF T_3_1;
                    err = c_envOPget_any_type(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = exprOPset_typespec(x, T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    }
                }
                else {
                    goto ex_0;
                }
            end_1:;
        }
    else {

  LINE(29);
        {
        err = c_envOPerr1(e, STR_use_040of_040UP_040operation_040outside_040of_040a_040cluster);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(31);
    {
    {
    CLUREF T_1_1;
    err = c_envOPget_up_type(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_up ****/


CLUREF STR_argument_040to_040DOWN;
CLUREF STR_use_040of_040DOWN_040operation_040outside_040of_040a_040cluster;
static int c_down_own_init = 0;

/**** BEGIN PROCEDURE c_down ****/

errcode c_down(e, x, ret_1)
CLUREF e;
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF t;
        if (c_down_own_init == 0) {
        stringOPcons("argument to DOWN", CLU_1, CLU_16, &STR_argument_040to_040DOWN);
        stringOPcons("use of DOWN operation outside of a cluster", CLU_1, CLU_42, &STR_use_040of_040DOWN_040operation_040outside_040of_040a_040cluster);
        c_down_own_init = 1;
    }
    enter_proc(34);

  LINE(35);
    {
        {CLUREF T_1_1;
        err = c_expr(e, x, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        t.num = T_1_1.num;
        }
        }

  LINE(36);
    {
    CLUREF T_1_1;
    err = c_envOPin_cluster(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(37);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = c_envOPget_up_type(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = typespecOPmismatch(T_2_1, t, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        if (T_2_2.num == true) {

  LINE(38);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            sequenceOPnew2(CLU_1, &T_3_1);
            T_3_1.vec->data[0] = STR_argument_040to_040DOWN.num;
            err = c_envOPget_up_type(e, &T_3_2);
            if (err != ERR_ok) goto ex_0;
            err = c_envOPerrt(e, T_3_1, T_3_2, t);
            if (err != ERR_ok) goto ex_0;
            }
            }
            }/* end if */
        }
    else {

  LINE(40);
        {
        err = c_envOPerr1(e, STR_use_040of_040DOWN_040operation_040outside_040of_040a_040cluster);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(42);
    {
    {
    CLUREF T_1_1;
    err = c_envOPget_down_type(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_down ****/


extern errcode recordOPget_1();
extern errcode recordOPget_2();
extern errcode idnOPget_kind();
extern errcode c_gen_expr();
extern errcode recordOPset_2();
extern errcode c_constlist();
extern errcode oneofOPmake_20();
extern errcode c_clusterop1();
extern errcode c_envOPlookup();
extern errcode c_bracketref();
extern errcode intOPgt();
extern errcode sequenceOPsize();
extern errcode c_envOPerr();
extern errcode idnOPget_str();
extern errcode c_envOPget_unknown_type();
extern errcode oneofOPmake_13();
extern errcode c_sugar();
extern errcode sequenceOPbottom();
CLUREF STR__047;
CLUREF STR__047_040does_040not_040name_040a_040DU;
CLUREF STR_fetch;
static int c_bracketref_own_init = 0;

/**** BEGIN PROCEDURE c_bracketref ****/

errcode c_bracketref(e, x, ref, ret_1)
CLUREF e;
CLUREF x;
CLUREF ref;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF i;
    CLUREF parms;
    CLUREF k;
    CLUREF cop;
    CLUREF x1;
        if (c_bracketref_own_init == 0) {
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        stringOPcons("\' does not name a DU", CLU_1, CLU_20, &STR__047_040does_040not_040name_040a_040DU);
        stringOPcons("fetch", CLU_1, CLU_5, &STR_fetch);
        c_bracketref_own_init = 1;
    }
    enter_proc(45);

  LINE(46);
    {
        {CLUREF T_1_1;
        T_1_1.num = ref.vec->data[0];
        i.num = T_1_1.num;
        }
        }

  LINE(47);
    {
        {CLUREF T_1_1;
        T_1_1.num = ref.vec->data[1];
        parms.num = T_1_1.num;
        }
        }

  LINE(48);
    {
    CLUREF T_1_1;
    err = idnOPget_kind(i, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        k.num = T_1_2.num;

  LINE(50);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            RecordAlloc(2, T_2_1);
            T_2_1.vec->data[0]  = k.num;
            T_2_1.vec->data[1]  = parms.num;
            err = c_gen_expr(e, x, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 3: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        k.num = T_1_3.num;

  LINE(53);
            {
            CLUREF T_2_1;
            err = c_constlist(e, parms, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ref.vec->data[1]  = T_2_1.num;
            }

  LINE(54);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                RecordAlloc(3, T_2_1);
                err = c_envOPget_up_type(e, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                T_2_1.vec->data[2]  = T_2_2.num;
                T_2_1.vec->data[0]  = k.num;
                T_2_3.num = ref.vec->data[1];
                T_2_1.vec->data[1]  = T_2_3.num;
                cop.num = T_2_1.num;
                }
                }

  LINE(57);
            {
            CLUREF T_2_1;
            CellAlloc(20, cop.num, T_2_1);
            err = exprOPset_abs(x, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(58);
            {
            {
            CLUREF T_2_1;
            err = c_clusterop1(e, cop, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 8: 
         {

  LINE(60);
            {
            err = c_envOPlookup(e, i, CLU_0);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(61);
            {
            {
            CLUREF T_2_1;
            err = c_bracketref(e, x, ref, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {
    }
    }
    }

  LINE(64);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = parms.vec->size;
    T_1_2.num = (T_1_1.num > 1)? true : false;
    if (T_1_2.num == true) {

  LINE(65);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_3, &T_2_1);
        T_2_1.vec->data[0] = STR__047.num;
        err = idnOPget_str(i, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        T_2_1.vec->data[2] = STR__047_040does_040not_040name_040a_040DU.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(66);
        {
        {
        CLUREF T_2_1;
        err = c_envOPget_unknown_type(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(68);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CellAlloc(13, i.num, T_1_1);
        err = c_envOPget_unknown_type(e, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        err = exprOPcreate(T_1_1, T_1_2, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        x1.num = T_1_3.num;
        }
        }

  LINE(69);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    sequenceOPnew2(CLU_2, &T_1_1);
    T_1_1.vec->data[0] = x1.num;
    err = sequenceOPbottom(parms, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    err = c_sugar(e, x, STR_fetch, T_1_1, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_3.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_bracketref ****/


extern errcode c_gen_parms();
extern errcode typespecOPequal();
extern errcode c_envOPget_type_type();
extern errcode oneofOPmake_3();
extern errcode oneofOPmake_25();
extern errcode c_envOPtypes_illegal();
extern errcode get_type_print();
CLUREF STR_use_040of_040type_040as_040expression_072_040;
static int c_apply_ref_own_init = 0;

/**** BEGIN PROCEDURE c_apply_ref ****/

errcode c_apply_ref(e, x, clut, ret_1)
CLUREF e;
CLUREF x;
CLUREF clut;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF t;
    CLUREF tt;
        if (c_apply_ref_own_init == 0) {
        stringOPcons("use of type as expression: ", CLU_1, CLU_27, &STR_use_040of_040type_040as_040expression_072_040);
        c_apply_ref_own_init = 1;
    }
    enter_proc(72);

  LINE(73);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = clut.vec->data[1];
    err = c_constlist(e, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    clut.vec->data[1]  = T_1_2.num;
    }

  LINE(74);
    {
        {CLUREF T_1_1;
        err = c_gen_parms(e, clut, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        t.num = T_1_1.num;
        }
        }

  LINE(75);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = c_envOPget_type_type(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = typespecOPequal(t, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    if (T_1_2.num == true) {

  LINE(76);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            CellAlloc(3, clut.num, T_2_1);
            err = c_envOPget_type(e, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            tt.num = T_2_2.num;
            }
            }

  LINE(77);
        {
        CLUREF T_2_1;
        CellAlloc(25, tt.num, T_2_1);
        err = exprOPset_abs(x, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(78);
        {
        CLUREF T_2_1;
        err = c_envOPtypes_illegal(e, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        if (T_2_1.num == true) {

  LINE(79);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            sequenceOPnew2(CLU_2, &T_3_1);
            T_3_1.vec->data[0] = STR_use_040of_040type_040as_040expression_072_040.num;
            err = get_type_print(t, &T_3_2);
            if (err != ERR_ok) goto ex_0;
            T_3_1.vec->data[1] = T_3_2.num;
            err = c_envOPerr(e, T_3_1);
            if (err != ERR_ok) goto ex_0;
            }
            }
            }/* end if */
        }
        }/* end if */

  LINE(83);
    {
    {
    ret_1->num = t.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_apply_ref ****/


static int c_expr_type_own_init = 0;

/**** BEGIN PROCEDURE c_expr_type ****/

errcode c_expr_type(e, x, t, ret_1)
CLUREF e;
CLUREF x;
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (c_expr_type_own_init == 0) {
        stringOPcons("use of type as expression: ", CLU_1, CLU_27, &STR_use_040of_040type_040as_040expression_072_040);
        c_expr_type_own_init = 1;
    }
    enter_proc(86);

  LINE(87);
    {
    CLUREF T_1_1;
    err = c_type(e, t, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    t.num = T_1_1.num;
    }

  LINE(88);
    {
    CLUREF T_1_1;
    CellAlloc(25, t.num, T_1_1);
    err = exprOPset_abs(x, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(89);
    {
    CLUREF T_1_1;
    err = c_envOPtypes_illegal(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(90);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_2, &T_2_1);
        T_2_1.vec->data[0] = STR_use_040of_040type_040as_040expression_072_040.num;
        err = get_type_print(t, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(93);
    {
    {
    CLUREF T_1_1;
    err = c_envOPget_type_type(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_expr_type ****/



/**** BEGIN PROCEDURE c_anyize ****/

errcode c_anyize(e, x, ret_1)
CLUREF e;
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    enter_proc(96);

  LINE(97);
    {
    CLUREF T_1_1;
    err = c_expr(e, x, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(98);
    {
    {
    CLUREF T_1_1;
    err = c_envOPget_any_type(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_anyize ****/



/**** BEGIN PROCEDURE c_type_of ****/

errcode c_type_of(e, x, ret_1)
CLUREF e;
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    enter_proc(101);

  LINE(102);
    {
    CLUREF T_1_1;
    err = c_expr(e, x, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(103);
    {
    {
    CLUREF T_1_1;
    err = c_envOPget_type_type(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_type_of ****/


extern errcode typespecOPget_abs();
static int c_gen_expr_own_init = 0;

/**** BEGIN PROCEDURE c_gen_expr ****/

errcode c_gen_expr(e, x, dut, ret_1)
CLUREF e;
CLUREF x;
CLUREF dut;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF t;
    CLUREF xt;
        if (c_gen_expr_own_init == 0) {
        stringOPcons("use of type as expression: ", CLU_1, CLU_27, &STR_use_040of_040type_040as_040expression_072_040);
        c_gen_expr_own_init = 1;
    }
    enter_proc(106);

  LINE(107);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = dut.vec->data[1];
    err = c_constlist(e, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    dut.vec->data[1]  = T_1_2.num;
    }

  LINE(108);
    {
        {CLUREF T_1_1;
        err = c_gen_parms(e, dut, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        t.num = T_1_1.num;
        }
        }

  LINE(109);
    {
    CLUREF T_1_1;
    err = typespecOPget_abs(t, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 8: 
         {

  LINE(111);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CellAlloc(3, dut.num, T_2_1);
                err = c_envOPget_type(e, T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                xt.num = T_2_2.num;
                }
                }

  LINE(112);
            {
            CLUREF T_2_1;
            err = c_envOPtypes_illegal(e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            if (T_2_1.num == true) {

  LINE(113);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                sequenceOPnew2(CLU_2, &T_3_1);
                T_3_1.vec->data[0] = STR_use_040of_040type_040as_040expression_072_040.num;
                err = get_type_print(xt, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_1.vec->data[1] = T_3_2.num;
                err = c_envOPerr(e, T_3_1);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */

  LINE(116);
            {
            CLUREF T_2_1;
            CellAlloc(25, xt.num, T_2_1);
            err = exprOPset_abs(x, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
            break;
            }
    default: {

  LINE(118);
        {
        CLUREF T_2_1;
        CellAlloc(3, dut.num, T_2_1);
        err = exprOPset_abs(x, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(120);
    {
    {
    ret_1->num = t.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_gen_expr ****/


extern errcode c_get_duspecs();
extern errcode c_parms();
extern errcode subst_parms();
extern errcode oneofOPmake_1();
extern errcode oneofOPmake_6();
extern errcode duOPget_common();
CLUREF STR_illegal_040parameters_040to_040DU_040_047;
static int c_gen_parms_own_init = 0;

/**** BEGIN PROCEDURE c_gen_parms ****/

errcode c_gen_parms(e, dut, ret_1)
CLUREF e;
CLUREF dut;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF gen;
    CLUREF parms;
    CLUREF specs;
    CLUREF inf;
    CLUREF ot;
        if (c_gen_parms_own_init == 0) {
        stringOPcons("illegal parameters to DU \'", CLU_1, CLU_26, &STR_illegal_040parameters_040to_040DU_040_047);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        c_gen_parms_own_init = 1;
    }
    enter_proc(123);

  LINE(124);
    {
        {CLUREF T_1_1;
        T_1_1.num = dut.vec->data[0];
        gen.num = T_1_1.num;
        }
        }

  LINE(125);
    {
        {CLUREF T_1_1;
        T_1_1.num = dut.vec->data[1];
        parms.num = T_1_1.num;
        }
        }

  LINE(126);
    {
        {CLUREF T_1_1;
        err = c_get_duspecs(e, gen, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        specs.num = T_1_1.num;
        }
        }

  LINE(127);
    {
    switch (specs.cell->tag) {
    case 3: 
         {CLUREF T_1_1;
        T_1_1.num = specs.cell->value;
        inf.num = T_1_1.num;

  LINE(129);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = inf.vec->data[1];
            err = c_parms(e, parms, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            if (T_2_2.num == true) {

  LINE(130);
                {
                {
                CLUREF T_3_1;
                err = c_envOPget_type_type(e, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                ret_1->num = T_3_1.num;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */
            break;
            }
    case 1: 
         {CLUREF T_1_2;
        T_1_2.num = specs.cell->value;
        inf.num = T_1_2.num;

  LINE(132);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = inf.vec->data[0];
            err = c_parms(e, parms, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            if (T_2_2.num == true) {

  LINE(133);
                {
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                T_3_1.num = inf.vec->data[0];
                T_3_2.num = inf.vec->data[1];
                err = subst_parms(e, parms, T_3_1, T_3_2, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                ret_1->num = T_3_3.num;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */
            break;
            }
    case 4: 
         {

  LINE(135);
            {
                {CLUREF T_2_1;
                CellAlloc(1, dut.num, T_2_1);
                ot.num = T_2_1.num;
                }
                }

  LINE(136);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CellAlloc(6, ot.num, T_2_1);
            err = c_envOPget_type(e, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {
    }
    }
    }

  LINE(139);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    sequenceOPnew2(CLU_3, &T_1_1);
    T_1_1.vec->data[0] = STR_illegal_040parameters_040to_040DU_040_047.num;
    err = duOPget_common(gen, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    T_1_1.vec->data[2] = STR__047.num;
    err = c_envOPerr(e, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(140);
    {
    {
    CLUREF T_1_1;
    err = c_envOPget_unknown_type(e, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_gen_parms ****/


extern errcode boolOPnot();
extern errcode intOPequal();
extern errcode sequenceOPindexes();
extern errcode exprOPget_typespec();
extern errcode sequenceOPfetch();

/**** BEGIN PROCEDURE c_parms1 ****/

errcode c_parms1(e, vals, forms, ret_1)
CLUREF e;
CLUREF vals;
CLUREF forms;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF i;
    CLUREF t;
    CLUREF k;
    enter_proc(143);

  LINE(144);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = vals.vec->size;
    T_1_2.num = forms.vec->size;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {

  LINE(145);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(146);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = vals.vec->size; 
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(147);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                if (i.num < 1 || i.num > vals.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = vals.vec->data[i.num - 1];
                err = exprOPget_typespec(T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                t.num = T_2_2.num;
                }
                }

  LINE(148);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            if (i.num < 1 || i.num > forms.vec->size ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = forms.vec->data[i.num - 1];
            err = idnOPget_kind(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_2.cell->tag) {
            case 6: 
                 {

  LINE(150);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = c_envOPget_type_type(e, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = typespecOPmismatch(T_3_1, t, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    if (T_3_2.num == true) {

  LINE(151);
                        {
                        {
                        ret_1->tf = false;
                        }
                        {signal (ERR_ok);}}
                        }
                        }/* end if */
                    break;
                    }
            case 10: 
                 {CLUREF T_2_3;
                T_2_3.num = T_2_2.cell->value;
                k.num = T_2_3.num;

  LINE(153);
                    {
                    CLUREF T_3_1;
                    err = typespecOPmismatch(k, t, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    if (T_3_1.num == true) {

  LINE(154);
                        {
                        {
                        ret_1->tf = false;
                        }
                        {signal (ERR_ok);}}
                        }
                        }/* end if */
                    break;
                    }
            default: {

  LINE(156);
                {
                {
                ret_1->tf = false;
                }
                {signal (ERR_ok);}}
            }
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(159);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_parms1 ****/


extern errcode c_parms1();
extern errcode c_restrictions();

/**** BEGIN PROCEDURE c_parms ****/

errcode c_parms(e, vals, forms, ret_1)
CLUREF e;
CLUREF vals;
CLUREF forms;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ok;
    CLUREF i;
    CLUREF k;
    enter_proc(162);

  LINE(163);
    {
        {CLUREF T_1_1;
        err = c_parms1(e, vals, forms, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        ok.num = T_1_1.num;
        }
        }

  LINE(164);
    {
    CLUREF T_1_1;
    T_1_1.num = ok.num ^ 1;
    if (T_1_1.num == true) {

  LINE(165);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(166);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = vals.vec->size; 
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(167);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            if (i.num < 1 || i.num > forms.vec->size ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = forms.vec->data[i.num - 1];
            err = idnOPget_kind(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_2.cell->tag) {
            case 6: 
                 {CLUREF T_2_3;
                T_2_3.num = T_2_2.cell->value;
                k.num = T_2_3.num;

  LINE(169);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    if (i.num < 1 || i.num > vals.vec->size ) {
                        err = ERR_bounds;
                        goto ex_0;}
                    T_3_2.num = vals.vec->data[i.num - 1];
                    err = c_restrictions(e, T_3_2, vals, forms, k, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    T_3_1.num = T_3_3.num;
                    if (T_3_3.num) {
                        T_3_1.num = ok.num;
                    }
                    ok.num = T_3_1.num;
                    }
                    break;
                    }
            default: {
            }
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(173);
    {
    {
    ret_1->num = ok.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_parms ****/


extern errcode sequenceOPconcat();
extern errcode sequenceOPelements();
extern errcode idnOPequal();

/**** BEGIN PROCEDURE c_2_parms ****/

errcode c_2_parms(e, vals, forms, cvals, cforms, reqs, ret_1)
CLUREF e;
CLUREF vals;
CLUREF forms;
CLUREF cvals;
CLUREF cforms;
CLUREF reqs;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ok;
    CLUREF bvals;
    CLUREF bforms;
    CLUREF i;
    CLUREF k;
    CLUREF req;
    CLUREF p;
    enter_proc(176);

  LINE(179);
    {
        {CLUREF T_1_1;
        err = c_parms1(e, vals, forms, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        ok.num = T_1_1.num;
        }
        }

  LINE(180);
    {
    CLUREF T_1_1;
    T_1_1.num = ok.num ^ 1;
    if (T_1_1.num == true) {

  LINE(181);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(182);
    {
        {CLUREF T_1_1;
        err = sequenceOPconcat(cvals, vals, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        bvals.num = T_1_1.num;
        }
        }

  LINE(183);
    {
        {CLUREF T_1_1;
        err = sequenceOPconcat(cforms, forms, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        bforms.num = T_1_1.num;
        }
        }

  LINE(184);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = vals.vec->size; 
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(185);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            if (i.num < 1 || i.num > forms.vec->size ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = forms.vec->data[i.num - 1];
            err = idnOPget_kind(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            switch (T_2_2.cell->tag) {
            case 6: 
                 {CLUREF T_2_3;
                T_2_3.num = T_2_2.cell->value;
                k.num = T_2_3.num;

  LINE(187);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    if (i.num < 1 || i.num > vals.vec->size ) {
                        err = ERR_bounds;
                        goto ex_0;}
                    T_3_2.num = vals.vec->data[i.num - 1];
                    err = c_restrictions(e, T_3_2, bvals, bforms, k, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    T_3_1.num = T_3_3.num;
                    if (T_3_3.num) {
                        T_3_1.num = ok.num;
                    }
                    ok.num = T_3_1.num;
                    }
                    break;
                    }
            default: {
            }
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(192);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = reqs.vec->size; 
        T_1_3 = reqs;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            req.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(193);
            {
                {CLUREF T_2_1;
                T_2_1.num = req.vec->data[1];
                p.num = T_2_1.num;
                }
                }

  LINE(194);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
                T_2_2.num = cforms.vec->size; 
                for (T_2_1.num = 1; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                    i.num = T_2_1.num;

  LINE(195);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    if (i.num < 1 || i.num > cforms.vec->size ) {
                        err = ERR_bounds;
                        goto ex_0;}
                    T_3_1.num = cforms.vec->data[i.num - 1];
                    err = idnOPequal(p, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    if (T_3_2.num == true) {

  LINE(196);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        CLUREF T_4_3;
                        if (i.num < 1 || i.num > cvals.vec->size ) {
                            err = ERR_bounds;
                            goto ex_0;}
                        T_4_1.num = cvals.vec->data[i.num - 1];
                        T_4_2.num = req.vec->data[0];
                        err = c_restrictions(e, T_4_1, bvals, bforms, T_4_2, &T_4_3);
                        if (err != ERR_ok) goto ex_0;
                        }
                        }
                        }/* end if */
                }
            }
            end_inline_for_3:;
        }
    }
    end_inline_for_2:;

  LINE(201);
    {
    {
    ret_1->num = ok.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_2_parms ****/


extern errcode intOPadd();
extern errcode intOPfrom_to_by();
extern errcode c_call();
extern errcode duOPequal();
extern errcode c_envOPget_iter_();
extern errcode get_inv_print();
extern errcode c_envOPget_seq_();
extern errcode recordOPget_4();
extern errcode recordOPget_3();
extern errcode recordOPset_1();
CLUREF STR_illegal_040iterator_040invocation_072_040;
CLUREF STR__045call;
CLUREF STR_invocation_040of_040non_055procedure_072_040;
static int c_invoke_own_init = 0;

/**** BEGIN PROCEDURE c_invoke ****/

errcode c_invoke(e, inv, done_first, ret_1)
CLUREF e;
CLUREF inv;
CLUREF done_first;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF pt;
    CLUREF args;
    CLUREF beg;
    CLUREF i;
    CLUREF pta;
    CLUREF vals;
    CLUREF x;
    CLUREF st;
    CLUREF p;
    CLUREF ot;
    CLUREF t;
    CLUREF ut;
        if (c_invoke_own_init == 0) {
        stringOPcons("illegal iterator invocation: ", CLU_1, CLU_29, &STR_illegal_040iterator_040invocation_072_040);
        stringOPcons("%call", CLU_1, CLU_5, &STR__045call);
        stringOPcons("invocation of non-procedure: ", CLU_1, CLU_29, &STR_invocation_040of_040non_055procedure_072_040);
        c_invoke_own_init = 1;
    }
    enter_proc(204);

  LINE(205);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = inv.vec->data[0];
        err = c_expr(e, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        pt.num = T_1_2.num;
        }
        }

  LINE(206);
    {
        {CLUREF T_1_1;
        T_1_1.num = inv.vec->data[1];
        args.num = T_1_1.num;
        }
        }

  LINE(207);
    {
        {beg.num = 1;
        }
        }

  LINE(208);
    {
    if (done_first.num == true) {
        {
        CLUREF T_2_1;
        T_2_1.num = beg.num + 1;
         if ((T_2_1.num > 0 && beg.num < 0 && 1 < 0) || 
             (T_2_1.num < 0 && beg.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        beg.num = T_2_1.num;
        }
        }
        }/* end if */

  LINE(209);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = args.vec->size;
        T_1_3.num = T_1_1.num;
        T_1_4.num = 1;
        for (T_1_2.num = beg.num; ((T_1_4.num == 0) || ((T_1_4.num > 0)? (T_1_2.num <= T_1_3.num) : (T_1_2.num >= T_1_3.num))); T_1_2.num += T_1_4.num) {
            i.num = T_1_2.num;

  LINE(210);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            if (i.num < 1 || i.num > args.vec->size ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = args.vec->data[i.num - 1];
            err = c_expr(e, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(212);
    {
    CLUREF T_1_1;
    err = typespecOPget_abs(pt, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        pta.num = T_1_2.num;

  LINE(214);
            {
                {CLUREF T_2_1;
                err = c_call(e, pta, inv, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                vals.num = T_2_1.num;
                }
                }

  LINE(215);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            T_2_1.num = pta.vec->data[1];
            err = c_envOPget_proc_(e, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            err = duOPequal(T_2_1, T_2_2, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            if (T_2_3.num == true) {

  LINE(216);
                {
                {
                ret_1->num = vals.num;
                }
                {signal (ERR_ok);}}
                }
            else {
            CLUREF T_2_4;
            CLUREF T_2_5;
            CLUREF T_2_6;
            T_2_4.num = pta.vec->data[1];
            err = c_envOPget_iter_(e, &T_2_5);
            if (err != ERR_ok) goto ex_0;
            err = duOPequal(T_2_4, T_2_5, &T_2_6);
            if (err != ERR_ok) goto ex_0;
            if (T_2_6.num == true) {

  LINE(218);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                sequenceOPnew2(CLU_2, &T_3_1);
                T_3_1.vec->data[0] = STR_illegal_040iterator_040invocation_072_040.num;
                err = get_inv_print(inv, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                T_3_1.vec->data[1] = T_3_2.num;
                err = c_envOPerr(e, T_3_1);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(220);
                {
                {
                ret_1->num = vals.num;
                }
                {signal (ERR_ok);}}
                }
                }}/* end if */

  LINE(222);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                CLUREF T_2_4;
                err = c_envOPget_any_type(e, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                CellAlloc(25, T_2_1.num, T_2_2);
                err = c_envOPget_type_type(e, &T_2_3);
                if (err != ERR_ok) goto ex_0;
                err = exprOPcreate(T_2_2, T_2_3, &T_2_4);
                if (err != ERR_ok) goto ex_0;
                x.num = T_2_4.num;
                }
                }

  LINE(224);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                CLUREF T_2_4;
                CLUREF T_2_5;
                RecordAlloc(2, T_2_1);
                err = c_envOPget_seq_(e, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                T_2_1.vec->data[0]  = T_2_2.num;
                sequenceOPnew2(CLU_1, &T_2_3);
                T_2_3.vec->data[0] = x.num;
                T_2_1.vec->data[1]  = T_2_3.num;
                CellAlloc(3, T_2_1.num, T_2_4);
                err = c_envOPget_type(e, T_2_4, &T_2_5);
                if (err != ERR_ok) goto ex_0;
                st.num = T_2_5.num;
                }
                }

  LINE(228);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            RecordAlloc(3, T_2_1);
            T_2_1.vec->data[2]  = st.num;
            CellAlloc(1, nil, T_2_2);
            T_2_1.vec->data[1]  = T_2_2.num;
            T_2_1.vec->data[0]  = args.num;
            CellAlloc(1, T_2_1.num, T_2_3);
            err = exprOPcreate(T_2_3, st, &T_2_4);
            if (err != ERR_ok) goto ex_0;
            x.num = T_2_4.num;
            }

  LINE(233);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            sequenceOPnew2(CLU_2, &T_2_1);
            T_2_2.num = inv.vec->data[0];
            T_2_1.vec->data[0] = T_2_2.num;
            T_2_1.vec->data[1] = x.num;
            inv.vec->data[1]  = T_2_1.num;
            }

  LINE(234);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                RecordAlloc(3, T_2_1);
                T_2_1.vec->data[2]  = pt.num;
                T_2_1.vec->data[0]  = STR__045call.num;
                sequenceOPnew2(CLU_0, &T_2_2);
                T_2_1.vec->data[1]  = T_2_2.num;
                CellAlloc(20, T_2_1.num, T_2_3);
                p.num = T_2_3.num;
                }
                }

  LINE(237);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            RecordAlloc(4, T_2_1);
            err = c_envOPget_proc_(e, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            T_2_1.vec->data[1]  = T_2_2.num;
            sequenceOPnew2(CLU_2, &T_2_3);
            T_2_3.vec->data[0] = pt.num;
            T_2_3.vec->data[1] = st.num;
            T_2_1.vec->data[0]  = T_2_3.num;
            T_2_4.num = pta.vec->data[3];
            T_2_1.vec->data[3]  = T_2_4.num;
            T_2_5.num = pta.vec->data[2];
            T_2_1.vec->data[2]  = T_2_5.num;
            pta.num = T_2_1.num;
            }

  LINE(241);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CellAlloc(2, pta.num, T_2_1);
            err = c_envOPget_type(e, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            pt.num = T_2_2.num;
            }

  LINE(242);
            {
            CLUREF T_2_1;
            err = exprOPcreate(p, pt, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            inv.vec->data[0]  = T_2_1.num;
            }

  LINE(243);
            {
            {
            ret_1->num = vals.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 6: 
         {

  LINE(245);
            {
                {CLUREF T_2_1;
                CellAlloc(3, pt.num, T_2_1);
                ot.num = T_2_1.num;
                }
                }

  LINE(246);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CellAlloc(6, ot.num, T_2_1);
                err = c_envOPget_type(e, T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                t.num = T_2_2.num;
                }
                }

  LINE(247);
            {
            {
            CLUREF T_2_1;
            err = sequenceOPe2s(t, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 9: 
         {
            break;
            }
    default: {

  LINE(250);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        sequenceOPnew2(CLU_2, &T_2_1);
        T_2_1.vec->data[0] = STR_invocation_040of_040non_055procedure_072_040.num;
        err = get_inv_print(inv, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[1] = T_2_2.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
    }
    }
    }

  LINE(253);
    {
        {CLUREF T_1_1;
        err = c_envOPget_unknown_type(e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        ut.num = T_1_1.num;
        }
        }

  LINE(254);
    {
    {
    CLUREF T_1_1;
    err = sequenceOPe2s(ut, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_invoke ****/


extern errcode c_args();
extern errcode c_envOPadd_cond();

/**** BEGIN PROCEDURE c_call ****/

errcode c_call(e, at, inv, ret_1)
CLUREF e;
CLUREF at;
CLUREF inv;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF sig;
    enter_proc(257);

  LINE(258);
    {
    CLUREF T_1_1;
    T_1_1.num = at.vec->data[0];
    err = c_args(e, T_1_1, inv);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(259);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = at.vec->data[2];
        T_1_3.num = T_1_1.vec->size; 
        T_1_4 = T_1_1;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            sig.num = T_1_4.vec->data[T_1_2.num - 1];

  LINE(260);
            {
            err = c_envOPadd_cond(e, sig, CLU_0);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(262);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = at.vec->data[3];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_call ****/


extern errcode intOPunparse();
extern errcode sequenceOPreplace();
CLUREF STR__040arguments_040to_040_047;
CLUREF STR__047_054_040;
CLUREF STR__040expected;
CLUREF STR_argument_040;
CLUREF STR__040to_040_047;
static int c_args_own_init = 0;

/**** BEGIN PROCEDURE c_args ****/

errcode c_args(e, types, inv)
CLUREF e;
CLUREF types;
CLUREF inv;
    {
    errcode err;
    errcode ecode2;
    CLUREF args;
    CLUREF i;
    CLUREF x;
        if (c_args_own_init == 0) {
        stringOPcons(" arguments to \'", CLU_1, CLU_15, &STR__040arguments_040to_040_047);
        stringOPcons("\', ", CLU_1, CLU_3, &STR__047_054_040);
        stringOPcons(" expected", CLU_1, CLU_9, &STR__040expected);
        stringOPcons("argument ", CLU_1, CLU_9, &STR_argument_040);
        stringOPcons(" to \'", CLU_1, CLU_5, &STR__040to_040_047);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        c_args_own_init = 1;
    }
    enter_proc(265);

  LINE(266);
    {
        {CLUREF T_1_1;
        T_1_1.num = inv.vec->data[1];
        args.num = T_1_1.num;
        }
        }

  LINE(267);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = args.vec->size;
    T_1_2.num = types.vec->size;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {

  LINE(268);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        sequenceOPnew2(CLU_6, &T_2_1);
        T_2_2.num = args.vec->size;
        err = intOPunparse(T_2_2, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[0] = T_2_3.num;
        T_2_1.vec->data[1] = STR__040arguments_040to_040_047.num;
        err = get_inv_print(inv, &T_2_4);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[2] = T_2_4.num;
        T_2_1.vec->data[3] = STR__047_054_040.num;
        T_2_5.num = types.vec->size;
        err = intOPunparse(T_2_5, &T_2_6);
        if (err != ERR_ok) goto ex_0;
        T_2_1.vec->data[4] = T_2_6.num;
        T_2_1.vec->data[5] = STR__040expected.num;
        err = c_envOPerr(e, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(273);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(275);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = args.vec->size; 
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(276);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            if (i.num < 1 || i.num > types.vec->size ) {
                err = ERR_bounds;
                goto ex_1;}
            T_3_1.num = types.vec->data[i.num - 1];
            if (i.num < 1 || i.num > args.vec->size ) {
                err = ERR_bounds;
                goto ex_1;}
            T_3_2.num = args.vec->data[i.num - 1];
            err = exprOPget_typespec(T_3_2, &T_3_3);
            if (err != ERR_ok) goto ex_1;
            err = typespecOPmismatch(T_3_1, T_3_3, &T_3_4);
            if (err != ERR_ok) goto ex_1;
            if (T_3_4.num == true) {

  LINE(277);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                CLUREF T_4_4;
                CLUREF T_4_5;
                CLUREF T_4_6;
                sequenceOPnew2(CLU_5, &T_4_1);
                T_4_1.vec->data[0] = STR_argument_040.num;
                err = intOPunparse(i, &T_4_2);
                if (err != ERR_ok) goto ex_1;
                T_4_1.vec->data[1] = T_4_2.num;
                T_4_1.vec->data[2] = STR__040to_040_047.num;
                err = get_inv_print(inv, &T_4_3);
                if (err != ERR_ok) goto ex_1;
                T_4_1.vec->data[3] = T_4_3.num;
                T_4_1.vec->data[4] = STR__047.num;
                if (i.num < 1 || i.num > types.vec->size ) {
                    err = ERR_bounds;
                    goto ex_1;}
                T_4_4.num = types.vec->data[i.num - 1];
                if (i.num < 1 || i.num > args.vec->size ) {
                    err = ERR_bounds;
                    goto ex_1;}
                T_4_5.num = args.vec->data[i.num - 1];
                err = exprOPget_typespec(T_4_5, &T_4_6);
                if (err != ERR_ok) goto ex_1;
                err = c_envOPerrt(e, T_4_1, T_4_4, T_4_6);
                if (err != ERR_ok) goto ex_1;
                }
                }
                }/* end if */
                goto end_1;
                ex_1:
                    if ((err == ERR_anyize)) {

  LINE(281);
                        {
                            {CLUREF T_3_1;
                            CLUREF T_3_2;
                            CLUREF T_3_3;
                            CLUREF T_3_4;
                            if (i.num < 1 || i.num > args.vec->size ) {
                                err = ERR_bounds;
                                goto ex_0;}
                            T_3_1.num = args.vec->data[i.num - 1];
                            CellAlloc(2, T_3_1.num, T_3_2);
                            if (i.num < 1 || i.num > types.vec->size ) {
                                err = ERR_bounds;
                                goto ex_0;}
                            T_3_3.num = types.vec->data[i.num - 1];
                            err = exprOPcreate(T_3_2, T_3_3, &T_3_4);
                            if (err != ERR_ok) goto ex_0;
                            x.num = T_3_4.num;
                            }
                            }

  LINE(283);
                        {
                        CLUREF T_3_1;
                        CLUREF T_3_2;
                        T_3_1.num = inv.vec->data[1];
                        err = sequenceOPreplace(T_3_1, i, x, &T_3_2);
                        if (err != ERR_ok) goto ex_0;
                        inv.vec->data[1]  = T_3_2.num;
                        }
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE c_args ****/


extern errcode sequenceOPaddh();

/**** BEGIN PROCEDURE c_exprlist ****/

errcode c_exprlist(e, exprs, ret_1)
CLUREF e;
CLUREF exprs;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF types;
    CLUREF x;
    enter_proc(288);

  LINE(289);
    {
        {CLUREF T_1_1;
        err = sequenceOPnew(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        types.num = T_1_1.num;
        }
        }

  LINE(290);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = exprs.vec->size; 
        T_1_3 = exprs;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            x.num = T_1_3.vec->data[T_1_1.num - 1];

  LINE(291);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = c_expr(e, x, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = sequenceOPaddh(types, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            types.num = T_2_2.num;
            }
        }
    }
    end_inline_for_1:;

  LINE(293);
    {
    {
    ret_1->num = types.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE c_exprlist ****/


extern errcode get_clutype_print();
extern errcode stringOPconcat();
extern errcode get_clusterop_print();
CLUREF STR__133_056_056;
CLUREF STR__056_056_135;
CLUREF STR_type_137of_050;
CLUREF STR__051;
CLUREF STR_return_137type_137of_050;
CLUREF STR_any;
CLUREF STR_type;
CLUREF STR_cvt;
CLUREF STR__056_056;
CLUREF STR__077type_077;
CLUREF STR__047ILLEGAL_040TYPE_041_047;
static int get_type_print_own_init = 0;

/**** BEGIN PROCEDURE get_type_print ****/

errcode get_type_print(t, ret_1)
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ta;
    CLUREF clut;
    CLUREF cop;
    CLUREF ty;
        if (get_type_print_own_init == 0) {
        stringOPcons("[..", CLU_1, CLU_3, &STR__133_056_056);
        stringOPcons("..]", CLU_1, CLU_3, &STR__056_056_135);
        stringOPcons("type_of(", CLU_1, CLU_8, &STR_type_137of_050);
        stringOPcons(")", CLU_1, CLU_1, &STR__051);
        stringOPcons("return_type_of(", CLU_1, CLU_15, &STR_return_137type_137of_050);
        stringOPcons("any", CLU_1, CLU_3, &STR_any);
        stringOPcons("type", CLU_1, CLU_4, &STR_type);
        stringOPcons("cvt", CLU_1, CLU_3, &STR_cvt);
        stringOPcons("..", CLU_1, CLU_2, &STR__056_056);
        stringOPcons("?type?", CLU_1, CLU_6, &STR__077type_077);
        stringOPcons("\'ILLEGAL TYPE!\'", CLU_1, CLU_15, &STR__047ILLEGAL_040TYPE_041_047);
        get_type_print_own_init = 1;
    }
    enter_proc(296);

  LINE(297);
    {
    CLUREF T_1_1;
    err = typespecOPget_abs(t, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 3: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        ta.num = T_1_2.num;

  LINE(299);
            {
            {
            CLUREF T_2_1;
            err = get_clutype_print(ta, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 7: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        ta.num = T_1_3.num;

  LINE(301);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            CLUREF T_2_6;
            CLUREF T_2_7;
            CLUREF T_2_8;
            T_2_1.num = ta.vec->data[0];
            err = duOPget_common(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_2, STR__133_056_056, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            T_2_4.num = ta.vec->data[1];
            T_2_5.num = T_2_4.vec->size;
            err = intOPunparse(T_2_5, &T_2_6);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_3, T_2_6, &T_2_7);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_7, STR__056_056_135, &T_2_8);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_8.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 5: 
         {CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        ta.num = T_1_4.num;

  LINE(304);
            {
            {
            CLUREF T_2_1;
            err = idnOPget_str(ta, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 6: 
         {CLUREF T_1_5;
        T_1_5.num = T_1_1.cell->value;
        ta.num = T_1_5.num;

  LINE(306);
            {
            switch (ta.cell->tag) {
            case 1: 
                 {CLUREF T_2_1;
                T_2_1.num = ta.cell->value;
                clut.num = T_2_1.num;

  LINE(308);
                    {
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    err = get_clutype_print(clut, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(STR_type_137of_050, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(T_3_2, STR__051, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    ret_1->num = T_3_3.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            case 2: 
                 {CLUREF T_2_2;
                T_2_2.num = ta.cell->value;
                cop.num = T_2_2.num;

  LINE(310);
                    {
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    err = get_clusterop_print(cop, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(STR_type_137of_050, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(T_3_2, STR__051, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    ret_1->num = T_3_3.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            case 3: 
                 {CLUREF T_2_3;
                T_2_3.num = ta.cell->value;
                ty.num = T_2_3.num;

  LINE(312);
                    {
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    err = get_type_print(ty, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(STR_return_137type_137of_050, T_3_1, &T_3_2);
                    if (err != ERR_ok) goto ex_0;
                    err = stringOPconcat(T_3_2, STR__051, &T_3_3);
                    if (err != ERR_ok) goto ex_0;
                    ret_1->num = T_3_3.num;
                    }
                    {signal (ERR_ok);}}
                    break;
                    }
            }
            }
            break;
            }
    case 1: 
         {

  LINE(315);
            {
            {
            ret_1->str = STR_any.str;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 8: 
         {

  LINE(317);
            {
            {
            ret_1->str = STR_type.str;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 4: 
         {

  LINE(319);
            {
            {
            ret_1->str = STR_cvt.str;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 2: 
         {CLUREF T_1_6;
        T_1_6.num = T_1_1.cell->value;
        ta.num = T_1_6.num;

  LINE(321);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            CLUREF T_2_6;
            CLUREF T_2_7;
            CLUREF T_2_8;
            CLUREF T_2_9;
            CLUREF T_2_10;
            CLUREF T_2_11;
            CLUREF T_2_12;
            CLUREF T_2_13;
            CLUREF T_2_14;
            CLUREF T_2_15;
            CLUREF T_2_16;
            CLUREF T_2_17;
            CLUREF T_2_18;
            T_2_1.num = ta.vec->data[1];
            err = duOPget_common(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_2, STR__133_056_056, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            T_2_4.num = ta.vec->data[0];
            T_2_5.num = T_2_4.vec->size;
            err = intOPunparse(T_2_5, &T_2_6);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_3, T_2_6, &T_2_7);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_7, STR__056_056, &T_2_8);
            if (err != ERR_ok) goto ex_0;
            T_2_9.num = ta.vec->data[3];
            T_2_10.num = T_2_9.vec->size;
            err = intOPunparse(T_2_10, &T_2_11);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_8, T_2_11, &T_2_12);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_12, STR__056_056, &T_2_13);
            if (err != ERR_ok) goto ex_0;
            T_2_14.num = ta.vec->data[2];
            T_2_15.num = T_2_14.vec->size;
            err = intOPunparse(T_2_15, &T_2_16);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_13, T_2_16, &T_2_17);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_17, STR__056_056_135, &T_2_18);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_18.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 9: 
         {

  LINE(326);
            {
            {
            ret_1->str = STR__077type_077.str;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(328);
        {
        {
        ret_1->str = STR__047ILLEGAL_040TYPE_041_047.str;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_type_print ****/


CLUREF STR_force_133;
CLUREF STR__135;
CLUREF STR__050computed_040value_051;
static int get_inv_print_own_init = 0;

/**** BEGIN PROCEDURE get_inv_print ****/

errcode get_inv_print(inv, ret_1)
CLUREF inv;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF xa;
        if (get_inv_print_own_init == 0) {
        stringOPcons("force[", CLU_1, CLU_6, &STR_force_133);
        stringOPcons("]", CLU_1, CLU_1, &STR__135);
        stringOPcons("(computed value)", CLU_1, CLU_16, &STR__050computed_040value_051);
        get_inv_print_own_init = 1;
    }
    enter_proc(332);

  LINE(333);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = inv.vec->data[0];
    err = exprOPget_abs(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_2.cell->tag) {
    case 13: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_2.cell->value;
        xa.num = T_1_3.num;

  LINE(335);
            {
            {
            CLUREF T_2_1;
            err = idnOPget_str(xa, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 3: 
         {CLUREF T_1_4;
        T_1_4.num = T_1_2.cell->value;
        xa.num = T_1_4.num;

  LINE(337);
            {
            {
            CLUREF T_2_1;
            err = get_clutype_print(xa, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 20: 
         {CLUREF T_1_5;
        T_1_5.num = T_1_2.cell->value;
        xa.num = T_1_5.num;

  LINE(339);
            {
            {
            CLUREF T_2_1;
            err = get_clusterop_print(xa, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 11: 
         {CLUREF T_1_6;
        T_1_6.num = T_1_2.cell->value;
        xa.num = T_1_6.num;

  LINE(341);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            err = get_type_print(xa, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(STR_force_133, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_2, STR__135, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_3.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(343);
        {
        {
        ret_1->str = STR__050computed_040value_051.str;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_inv_print ****/


extern errcode charOPequal();
extern errcode stringOPfetch();
extern errcode stringOPrest();
extern errcode sequenceOPempty();
CLUREF STR__044;
static int get_clusterop_print_own_init = 0;

/**** BEGIN PROCEDURE get_clusterop_print ****/

errcode get_clusterop_print(cop, ret_1)
CLUREF cop;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF n;
        if (get_clusterop_print_own_init == 0) {
        stringOPcons("$", CLU_1, CLU_1, &STR__044);
        stringOPcons("[..", CLU_1, CLU_3, &STR__133_056_056);
        stringOPcons("..]", CLU_1, CLU_3, &STR__056_056_135);
        get_clusterop_print_own_init = 1;
    }
    enter_proc(347);

  LINE(348);
    {
        {CLUREF T_1_1;
        T_1_1.num = cop.vec->data[0];
        n.num = T_1_1.num;
        }
        }

  LINE(349);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = stringOPfetch(n, CLU_1, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.ch = '%';
    T_1_3.num = (T_1_1.ch == T_1_2.ch)? true : false;
    if (T_1_3.num == true) {
        {
        CLUREF T_2_1;
        err = stringOPrest(n, CLU_2, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        n.num = T_2_1.num;
        }
        }
        }/* end if */

  LINE(350);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = cop.vec->data[2];
    err = get_type_print(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_2, STR__044, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    err = stringOPconcat(T_1_3, n, &T_1_4);
    if (err != ERR_ok) goto ex_0;
    n.num = T_1_4.num;
    }

  LINE(351);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = cop.vec->data[1];
    err = sequenceOPempty(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    if (T_1_2.num == true) {

  LINE(352);
        {
        {
        ret_1->num = n.num;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(353);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        err = stringOPconcat(n, STR__133_056_056, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        T_2_2.num = cop.vec->data[1];
        T_2_3.num = T_2_2.vec->size;
        err = intOPunparse(T_2_3, &T_2_4);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_1, T_2_4, &T_2_5);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_5, STR__056_056_135, &T_2_6);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_6.num;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_clusterop_print ****/


extern errcode get_expr_print();
CLUREF STR__133;
static int get_clutype_print_own_init = 0;

/**** BEGIN PROCEDURE get_clutype_print ****/

errcode get_clutype_print(clut, ret_1)
CLUREF clut;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF gs;
        if (get_clutype_print_own_init == 0) {
        stringOPcons("[", CLU_1, CLU_1, &STR__133);
        stringOPcons("]", CLU_1, CLU_1, &STR__135);
        stringOPcons("[..", CLU_1, CLU_3, &STR__133_056_056);
        stringOPcons("..]", CLU_1, CLU_3, &STR__056_056_135);
        get_clutype_print_own_init = 1;
    }
    enter_proc(358);

  LINE(359);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = clut.vec->data[0];
        err = duOPget_common(T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        gs.num = T_1_2.num;
        }
        }

  LINE(360);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = clut.vec->data[1];
    err = sequenceOPempty(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    if (T_1_2.num == true) {

  LINE(361);
        {
        {
        ret_1->num = gs.num;
        }
        {signal (ERR_ok);}}
        }
    else {
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    T_1_3.num = clut.vec->data[1];
    T_1_4.num = T_1_3.vec->size;
    T_1_5.num = (T_1_4.num == 1)? true : false;
    if (T_1_5.num == true) {

  LINE(363);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        err = stringOPconcat(gs, STR__133, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        T_2_2.num = clut.vec->data[1];
        err = sequenceOPbottom(T_2_2, &T_2_3);
        if (err != ERR_ok) goto ex_0;
        err = get_expr_print(T_2_3, &T_2_4);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_1, T_2_4, &T_2_5);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_5, STR__135, &T_2_6);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_6.num;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(365);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        err = stringOPconcat(gs, STR__133_056_056, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        T_2_2.num = clut.vec->data[1];
        T_2_3.num = T_2_2.vec->size;
        err = intOPunparse(T_2_3, &T_2_4);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_1, T_2_4, &T_2_5);
        if (err != ERR_ok) goto ex_0;
        err = stringOPconcat(T_2_5, STR__056_056_135, &T_2_6);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_6.num;
        }
        {signal (ERR_ok);}}
        }}}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_clutype_print ****/


extern errcode realOPunparse();
extern errcode stringOPc2s();
CLUREF STR_nil;
CLUREF STR_true;
CLUREF STR_false;
CLUREF STR__042;
CLUREF STR__056_056_056;
static int get_expr_print_own_init = 0;

/**** BEGIN PROCEDURE get_expr_print ****/

errcode get_expr_print(x, ret_1)
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF b;
    CLUREF i;
    CLUREF r;
    CLUREF c;
    CLUREF s;
    CLUREF t;
        if (get_expr_print_own_init == 0) {
        stringOPcons("nil", CLU_1, CLU_3, &STR_nil);
        stringOPcons("true", CLU_1, CLU_4, &STR_true);
        stringOPcons("false", CLU_1, CLU_5, &STR_false);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        stringOPcons("\"", CLU_1, CLU_1, &STR__042);
        stringOPcons("...", CLU_1, CLU_3, &STR__056_056_056);
        get_expr_print_own_init = 1;
    }
    enter_proc(370);

  LINE(371);
    {
    CLUREF T_1_1;
    err = exprOPget_abs(x, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    switch (T_1_1.cell->tag) {
    case 19: 
         {

  LINE(373);
            {
            {
            ret_1->str = STR_nil.str;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 5: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        b.num = T_1_2.num;

  LINE(375);
            {
            if (b.num == true) {

  LINE(376);
                {
                {
                ret_1->str = STR_true.str;
                }
                {signal (ERR_ok);}}
                }
            else {

  LINE(377);
                {
                {
                ret_1->str = STR_false.str;
                }
                {signal (ERR_ok);}}
                }}/* end if */
            break;
            }
    case 15: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        i.num = T_1_3.num;

  LINE(380);
            {
            {
            CLUREF T_2_1;
            err = intOPunparse(i, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 21: 
         {CLUREF T_1_4;
        T_1_4.num = T_1_1.cell->value;
        r.num = T_1_4.num;

  LINE(382);
            {
            {
            CLUREF T_2_1;
            err = realOPunparse(r, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 7: 
         {CLUREF T_1_5;
        T_1_5.num = T_1_1.cell->value;
        c.num = T_1_5.num;

  LINE(384);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            err = stringOPc2s(c, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(STR__047, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_2, STR__047, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_3.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 24: 
         {CLUREF T_1_6;
        T_1_6.num = T_1_1.cell->value;
        s.num = T_1_6.num;

  LINE(386);
            {
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = stringOPconcat(STR__042, s, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = stringOPconcat(T_2_1, STR__042, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 25: 
         {CLUREF T_1_7;
        T_1_7.num = T_1_1.cell->value;
        t.num = T_1_7.num;

  LINE(388);
            {
            {
            CLUREF T_2_1;
            err = get_type_print(t, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 13: 
         {CLUREF T_1_8;
        T_1_8.num = T_1_1.cell->value;
        i.num = T_1_8.num;

  LINE(390);
            {
            {
            CLUREF T_2_1;
            err = idnOPget_str(i, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(392);
        {
        {
        ret_1->str = STR__056_056_056.str;
        }
        {signal (ERR_ok);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_expr_print ****/

