
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


extern errcode unify();
extern errcode get_output_part();
extern errcode arrayOPnew();
extern errcode get_option_parts();
extern errcode get_command_part();
extern errcode intOPequal();
extern errcode arrayOPsize();
extern errcode get_input_parts();
extern errcode arrayOPaddh();
extern errcode charOPequal();
extern errcode flush_blanks();
extern errcode arrayOPreml();
CLUREF STR_;
static int parse_command_line_own_init = 0;

/**** BEGIN PROCEDURE parse_command_line ****/

errcode parse_command_line(line, ret_1, ret_2, ret_3)
CLUREF line;
CLUREF *ret_1;
CLUREF *ret_2;
CLUREF *ret_3;
    {
    errcode err;
    errcode ecode2;
    CLUREF ohave;
    CLUREF opart;
    CLUREF comms;
    CLUREF opts;
    CLUREF cmnd;
    CLUREF args;
        if (parse_command_line_own_init == 0) {
        stringOPcons("", CLU_1, CLU_0, &STR_);
        parse_command_line_own_init = 1;
    }
    enter_proc(5);

  LINE(6);
    {
    err = unify(line);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(7);
    {
        {ohave.tf = true;
        }
        }

  LINE(8);
    {
        {CLUREF T_2_1;
        err = get_output_part(line, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        opart.num = T_2_1.num;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_none)) {

  LINE(10);
                {
                ohave.tf = false;
                }

  LINE(11);
                {
                opart = STR_;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(13);
    {
        {CLUREF T_1_1;
        err = arrayOPnew(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        comms.num = T_1_1.num;
        }
        }

  LINE(14);
    for (;;) {
        if (true != true) { break; }

  LINE(15);
        {
            {CLUREF T_2_1;
            err = get_option_parts(line, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            opts.num = T_2_1.num;
            }
            }

  LINE(16);
        {
            {CLUREF T_3_1;
            err = get_command_part(line, &T_3_1);
            if (err != ERR_ok) goto ex_2;
            cmnd.num = T_3_1.num;
            }
            }
            goto end_2;
            ex_2:
                if ((err == ERR_none)) {

  LINE(17);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    T_3_1.num = opts.array->ext_size;
                    T_3_2.num = (T_3_1.num == 0)? true : false;
                    if (T_3_2.num == true) {

  LINE(18);
                        goto end_while_1;
                        }
                    else {

  LINE(19);
                        {
                        cmnd = STR_;
                        }
                        }}/* end if */
                }
                else {
                    goto ex_0;
                }
            end_2:;

  LINE(22);
        {
            {CLUREF T_2_1;
            err = get_input_parts(line, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            args.num = T_2_1.num;
            }
            }

  LINE(23);
        {
        CLUREF T_2_1;
        RecordAlloc(3, T_2_1);
        T_2_1.vec->data[2]  = opts.num;
        T_2_1.vec->data[1]  = cmnd.num;
        T_2_1.vec->data[0]  = args.num;
        {
        if ((comms.array->int_low + comms.array->ext_size + 1) < comms.array->int_size) {
            comms.array->store->data[comms.array->int_low + comms.array->ext_size] = T_2_1.num;
            comms.array->ext_size++; comms.array->ext_high++;}
        else {
            err = arrayOPaddh(comms, T_2_1);
            if (err != ERR_ok) goto ex_0;}
        }
        }

  LINE(26);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.ch = '#';
        err = flush_blanks(line, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_3.num = (T_2_1.ch == T_2_2.ch)? true : false;
        if (T_2_3.num == true) {

  LINE(27);
            {
            CLUREF T_3_1;
            err = arrayOPreml(line, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            }
            }
        else {

  LINE(28);
            goto end_while_1;
            }}/* end if */
        }
        end_while_1:;

  LINE(31);
    {
    {
    ret_1->num = comms.num;
    }
    {
    ret_2->num = opart.num;
    }
    {
    ret_3->num = ohave.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE parse_command_line ****/


extern errcode arrayOPset_low();
extern errcode arrayOPhigh();
extern errcode intOPle();
extern errcode arrayOPfetch();
extern errcode intOPadd();
extern errcode arrayOPpredict();
extern errcode intOPsub();
extern errcode arrayOPtrim();
extern errcode gets_to();
static int get_output_part_own_init = 0;

/**** BEGIN PROCEDURE get_output_part ****/

errcode get_output_part(line, ret_1)
CLUREF line;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF h;
    CLUREF i;
    CLUREF last;
    CLUREF c;
    CLUREF fs;
        if (get_output_part_own_init == 0) {
        stringOPcons("", CLU_1, CLU_0, &STR_);
        get_output_part_own_init = 1;
    }
    enter_proc(34);

  LINE(36);
    {
    err = arrayOPset_low(line, CLU_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(37);
    {
        {CLUREF T_1_1;
        T_1_1.num = line.array->ext_high;
        h.num = T_1_1.num;
        }
        }

  LINE(38);
    {
        {i.num = 1;
        }
        }

  LINE(39);
    {
        {last.num = 0;
        }
        }

  LINE(40);
    for (;;) {
        CLUREF T_1_1;
        T_1_1.num = (i.num <= h.num)? true : false;
        if (T_1_1.num != true) { break; }

  LINE(41);
        {
            {CLUREF T_2_1;
            if (i.num < line.array->ext_low || i.num > line.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = line.array->store->data[i.num - line.array->ext_low + line.array->int_low];
            c.num = T_2_1.num;
            }
            }

  LINE(42);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.ch = '^';
        T_2_2.num = (c.ch == T_2_1.ch)? true : false;
        if (T_2_2.num == true) {

  LINE(43);
            {
            last.num = i.num;
            }
            }
        else {
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_3.ch = '\\';
        T_2_4.num = (c.ch == T_2_3.ch)? true : false;
        if (T_2_4.num == true) {

  LINE(45);
            {
            CLUREF T_3_1;
            T_3_1.num = i.num + 1;
             if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) || 
                 (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            i.num = T_3_1.num;
            }
            }
            }}/* end if */

  LINE(46);
        {
        CLUREF T_2_1;
        T_2_1.num = i.num + 1;
         if ((T_2_1.num > 0 && i.num < 0 && 1 < 0) || 
             (T_2_1.num < 0 && i.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        i.num = T_2_1.num;
        }
        }
        end_while_1:;

  LINE(48);
    {
    CLUREF T_1_1;
    T_1_1.num = (last.num == 0)? true : false;
    if (T_1_1.num == true) {

  LINE(49);
        {
        {signal (ERR_none);}}
        }
        }/* end if */

  LINE(50);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = h.num - last.num;
         if ((T_1_1.num >= 0 && h.num < 0 && (-last.num) < 0) || 
             (T_1_1.num <= 0 && h.num > 0 && (-last.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = arrayOPpredict(CLU_1, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        fs.num = T_1_2.num;
        }
        }

  LINE(51);
    {
    CLUREF T_1_1;
    T_1_1.num = last.num + 1;
     if ((T_1_1.num > 0 && last.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && last.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    i.num = T_1_1.num;
    }

  LINE(52);
    for (;;) {
        CLUREF T_1_1;
        T_1_1.num = (i.num <= h.num)? true : false;
        if (T_1_1.num != true) { break; }

  LINE(53);
        {
        CLUREF T_2_1;
        if (i.num < line.array->ext_low || i.num > line.array->ext_high ) {
            err = ERR_bounds;
            goto ex_0;}
        T_2_1.num = line.array->store->data[i.num - line.array->ext_low + line.array->int_low];
        {
        if ((fs.array->int_low + fs.array->ext_size + 1) < fs.array->int_size) {
            fs.array->store->data[fs.array->int_low + fs.array->ext_size] = T_2_1.num;
            fs.array->ext_size++; fs.array->ext_high++;}
        else {
            err = arrayOPaddh(fs, T_2_1);
            if (err != ERR_ok) goto ex_0;}
        }
        }

  LINE(54);
        {
        CLUREF T_2_1;
        T_2_1.num = i.num + 1;
         if ((T_2_1.num > 0 && i.num < 0 && 1 < 0) || 
             (T_2_1.num < 0 && i.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        i.num = T_2_1.num;
        }
        }
        end_while_2:;

  LINE(56);
    {
    CLUREF T_1_1;
    T_1_1.num = last.num - 1;
     if ((T_1_1.num >= 0 && last.num < 0 && (-1) < 0) || 
         (T_1_1.num <= 0 && last.num > 0 && (-1) > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    err = arrayOPtrim(line, CLU_1, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(57);
    {
    CLUREF T_1_1;
    err = flush_blanks(fs, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(58);
    {
    {
    CLUREF T_1_1;
    err = gets_to(fs, STR_, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_output_part ****/


extern errcode get_option_part();

/**** BEGIN PROCEDURE get_option_parts ****/

errcode get_option_parts(line, ret_1)
CLUREF line;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF opts;
    enter_proc(61);

  LINE(62);
    {
        {CLUREF T_1_1;
        err = arrayOPnew(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        opts.num = T_1_1.num;
        }
        }

  LINE(63);
    for (;;) {
        if (true != true) { break; }

  LINE(64);
        {
        CLUREF T_3_1;
        err = get_option_part(line, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        {
        if ((opts.array->int_low + opts.array->ext_size + 1) < opts.array->int_size) {
            opts.array->store->data[opts.array->int_low + opts.array->ext_size] = T_3_1.num;
            opts.array->ext_size++; opts.array->ext_high++;}
        else {
            err = arrayOPaddh(opts, T_3_1);
            if (err != ERR_ok) goto ex_1;}
        }
        }
        }
        end_while_1:;
        goto end_1;
        ex_1:
            if ((err == ERR_none)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(67);
    {
    {
    ret_1->num = opts.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_option_parts ****/


CLUREF STR__040_011_043_054_136_055;
static int get_option_part_own_init = 0;

/**** BEGIN PROCEDURE get_option_part ****/

errcode get_option_part(line, ret_1)
CLUREF line;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF c;
        if (get_option_part_own_init == 0) {
        stringOPcons(" \t#,^-", CLU_1, CLU_6, &STR__040_011_043_054_136_055);
        get_option_part_own_init = 1;
    }
    enter_proc(70);

  LINE(71);
    {
        {CLUREF T_1_1;
        err = flush_blanks(line, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        c.num = T_1_1.num;
        }
        }

  LINE(72);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = '-';
    T_1_2.num = (c.ch == T_1_1.ch)? true : false;
    if (T_1_2.num == true) {

  LINE(73);
        {
        CLUREF T_2_1;
        err = arrayOPreml(line, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(74);
        {
        CLUREF T_2_1;
        err = flush_blanks(line, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        c.num = T_2_1.num;
        }

  LINE(75);
        {
        {
        CLUREF T_2_1;
        err = gets_to(line, STR__040_011_043_054_136_055, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(76);
        {
        {signal (ERR_none);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_option_part ****/


CLUREF STR__040_011_043_054_136;
static int get_command_part_own_init = 0;

/**** BEGIN PROCEDURE get_command_part ****/

errcode get_command_part(line, ret_1)
CLUREF line;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (get_command_part_own_init == 0) {
        stringOPcons(" \t#,^", CLU_1, CLU_5, &STR__040_011_043_054_136);
        get_command_part_own_init = 1;
    }
    enter_proc(80);

  LINE(81);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.ch = ' ';
    err = flush_blanks(line, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_3.num = (T_1_1.ch == T_1_2.ch)? true : false;
    if (T_1_3.num == true) {

  LINE(82);
        {
        {signal (ERR_none);}}
        }
        }/* end if */

  LINE(83);
    {
    {
    CLUREF T_1_1;
    err = gets_to(line, STR__040_011_043_054_136, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_command_part ****/


extern errcode intOPgt();
extern errcode stringOPindexc();
CLUREF STR__040_043;
CLUREF STR__040_011_054_043;
static int get_input_parts_own_init = 0;

/**** BEGIN PROCEDURE get_input_parts ****/

errcode get_input_parts(line, ret_1)
CLUREF line;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF inputs;
        if (get_input_parts_own_init == 0) {
        stringOPcons(" #", CLU_1, CLU_2, &STR__040_043);
        stringOPcons(" \t,#", CLU_1, CLU_4, &STR__040_011_054_043);
        get_input_parts_own_init = 1;
    }
    enter_proc(86);

  LINE(87);
    {
        {CLUREF T_1_1;
        err = arrayOPnew(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        inputs.num = T_1_1.num;
        }
        }

  LINE(88);
    for (;;) {
        if (true != true) { break; }

  LINE(89);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = flush_blanks(line, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = stringOPindexc(T_2_1, STR__040_043, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_3.num = (T_2_2.num > 0)? true : false;
        if (T_2_3.num == true) {

  LINE(90);
            {
            {
            ret_1->num = inputs.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(91);
        {
        CLUREF T_2_1;
        err = gets_to(line, STR__040_011_054_043, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        {
        if ((inputs.array->int_low + inputs.array->ext_size + 1) < inputs.array->int_size) {
            inputs.array->store->data[inputs.array->int_low + inputs.array->ext_size] = T_2_1.num;
            inputs.array->ext_size++; inputs.array->ext_high++;}
        else {
            err = arrayOPaddh(inputs, T_2_1);
            if (err != ERR_ok) goto ex_0;}
        }
        }

  LINE(92);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.ch = ',';
        err = flush_blanks(line, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_3.num = (T_2_1.ch == T_2_2.ch)? true : false;
        if (T_2_3.num == true) {

  LINE(93);
            {
            CLUREF T_3_1;
            err = arrayOPreml(line, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            }
            }
            }/* end if */
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_input_parts ****/


CLUREF STR__043;
static int get_input_part_own_init = 0;

/**** BEGIN PROCEDURE get_input_part ****/

errcode get_input_part(line, ret_1)
CLUREF line;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (get_input_part_own_init == 0) {
        stringOPcons("", CLU_1, CLU_0, &STR_);
        stringOPcons("#", CLU_1, CLU_1, &STR__043);
        get_input_part_own_init = 1;
    }
    enter_proc(97);

  LINE(98);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.ch = '#';
    err = flush_blanks(line, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_3.num = (T_1_1.ch == T_1_2.ch)? true : false;
    if (T_1_3.num == true) {

  LINE(99);
        {
        {
        ret_1->str = STR_.str;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(100);
        {
        {
        CLUREF T_2_1;
        err = gets_to(line, STR__043, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_input_part ****/


extern errcode boolOPnot();
extern errcode stringOPequal();
static int move_to_next_own_init = 0;

/**** BEGIN PROCEDURE move_to_next ****/

errcode move_to_next(line)
CLUREF line;
    {
    errcode err;
    errcode ecode2;
    CLUREF extra;
        if (move_to_next_own_init == 0) {
        stringOPcons("#", CLU_1, CLU_1, &STR__043);
        stringOPcons("", CLU_1, CLU_0, &STR_);
        move_to_next_own_init = 1;
    }
    enter_proc(104);

  LINE(105);
    {
        {CLUREF T_1_1;
        err = gets_to(line, STR__043, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        extra.num = T_1_1.num;
        }
        }

  LINE(106);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.ch = '#';
    err = flush_blanks(line, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_3.num = (T_1_1.ch == T_1_2.ch)? true : false;
    if (T_1_3.num == true) {

  LINE(107);
        {
        CLUREF T_2_1;
        err = arrayOPreml(line, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(108);
        {
        CLUREF T_2_1;
        err = flush_blanks(line, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {
    CLUREF T_1_4;
    CLUREF T_1_5;
    T_1_4.num = ((extra.str->size != STR_.str->size)? false :
        !(bcmp(extra.str->data, STR_.str->data, extra.str->size)));
    T_1_5.num = T_1_4.num ^ 1;
    if (T_1_5.num == true) {

  LINE(110);
        {
        elist[0] = extra;
        {signal (ERR_extra);}}
        }
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE move_to_next ****/


extern errcode arrayOPbottom();
CLUREF STR__040_011;
static int flush_blanks_own_init = 0;

/**** BEGIN PROCEDURE flush_blanks ****/

errcode flush_blanks(line, ret_1)
CLUREF line;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (flush_blanks_own_init == 0) {
        stringOPcons(" \t", CLU_1, CLU_2, &STR__040_011);
        flush_blanks_own_init = 1;
    }
    enter_proc(113);

  LINE(114);
    {

  LINE(115);
        for (;;) {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            err = arrayOPbottom(line, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            err = stringOPindexc(T_3_1, STR__040_011, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            T_3_3.num = (T_3_2.num > 0)? true : false;
            if (T_3_3.num != true) { break; }

  LINE(116);
            {
            CLUREF T_4_1;
            err = arrayOPreml(line, &T_4_1);
            if (err != ERR_ok) goto ex_1;
            }
            }
            end_while_1:;

  LINE(118);
        {
        {
        CLUREF T_3_1;
        err = arrayOPbottom(line, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        ret_1->num = T_3_1.num;
        }
        {signal (ERR_ok);}}
        }
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {

  LINE(120);
                {
                {
                CLUREF T_2_1;
                T_2_1.ch = ' ';
                ret_1->num = T_2_1.num;
                }
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE flush_blanks ****/


extern errcode arrayOPtop();
extern errcode arrayOPremh();
extern errcode stringOPac2s();
static int gets_to_own_init = 0;

/**** BEGIN PROCEDURE gets_to ****/

errcode gets_to(line, terms, ret_1)
CLUREF line;
CLUREF terms;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF temp;
    CLUREF beyond;
    CLUREF c;
        if (gets_to_own_init == 0) {
        stringOPcons(" \t", CLU_1, CLU_2, &STR__040_011);
        gets_to_own_init = 1;
    }
    enter_proc(123);

  LINE(125);
    {
        {CLUREF T_1_1;
        err = arrayOPnew(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        temp.num = T_1_1.num;
        }
        }

  LINE(126);
    {
        {beyond.num = 0;
        }
        }

  LINE(127);
    for (;;) {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = arrayOPbottom(line, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        err = stringOPindexc(T_2_1, terms, &T_2_2);
        if (err != ERR_ok) goto ex_1;
        T_2_3.num = (T_2_2.num == 0)? true : false;
        if (T_2_3.num != true) { break; }

  LINE(128);
        {
            {CLUREF T_3_1;
            err = arrayOPreml(line, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            c.num = T_3_1.num;
            }
            }

  LINE(129);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.ch = '\\';
        T_3_2.num = (c.ch == T_3_1.ch)? true : false;
        if (T_3_2.num == true) {

  LINE(130);
            {
            CLUREF T_4_1;
            err = arrayOPreml(line, &T_4_1);
            if (err != ERR_ok) goto ex_1;
            c.num = T_4_1.num;
            }

  LINE(131);
            {
            beyond.num = -1;
            }
            }
            }/* end if */

  LINE(133);
        {
        {
        if ((temp.array->int_low + temp.array->ext_size + 1) < temp.array->int_size) {
            temp.array->store->data[temp.array->int_low + temp.array->ext_size] = c.num;
            temp.array->ext_size++; temp.array->ext_high++;}
        else {
            err = arrayOPaddh(temp, c);
            if (err != ERR_ok) goto ex_1;}
        }
        }

  LINE(134);
        {
        CLUREF T_3_1;
        T_3_1.num = beyond.num + 1;
         if ((T_3_1.num > 0 && beyond.num < 0 && 1 < 0) || 
             (T_3_1.num < 0 && beyond.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        beyond.num = T_3_1.num;
        }
        }
        end_while_1:;
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(137);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        T_1_2.num = (beyond.num > 0)? true : false;
        T_1_1.num = T_1_2.num;
        if (T_1_2.num) {
            err = arrayOPtop(temp, &T_1_3);
            if (err != ERR_ok) goto ex_0;
            err = stringOPindexc(T_1_3, STR__040_011, &T_1_4);
            if (err != ERR_ok) goto ex_0;
            T_1_5.num = (T_1_4.num > 0)? true : false;
            T_1_1.num = T_1_5.num;
        }
        if (T_1_1.num != true) { break; }

  LINE(138);
        {
        CLUREF T_2_1;
        err = arrayOPremh(temp, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(139);
        {
        CLUREF T_2_1;
        T_2_1.num = beyond.num - 1;
         if ((T_2_1.num >= 0 && beyond.num < 0 && (-1) < 0) || 
             (T_2_1.num <= 0 && beyond.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        beyond.num = T_2_1.num;
        }
        }
        end_while_2:;

  LINE(141);
    {
    {
    CLUREF T_1_1;
    err = stringOPac2s(temp, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE gets_to ****/


extern errcode arrayOPlow();
extern errcode arrayOPindexes();
extern errcode arrayOPstore();
CLUREF STR__040_011_054;
static int unify_own_init = 0;

/**** BEGIN PROCEDURE unify ****/

errcode unify(line)
CLUREF line;
    {
    errcode err;
    errcode ecode2;
    CLUREF least;
    CLUREF i;
        if (unify_own_init == 0) {
        stringOPcons(" \t,", CLU_1, CLU_3, &STR__040_011_054);
        unify_own_init = 1;
    }
    enter_proc(150);

  LINE(151);
    {
        {CLUREF T_1_1;
        T_1_1.num = line.array->ext_low;
        least.num = T_1_1.num;
        }
        }

  LINE(152);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = line.array->ext_high; 
        for (T_1_1.num = line.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(153);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            if (i.num < line.array->ext_low || i.num > line.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = line.array->store->data[i.num - line.array->ext_low + line.array->int_low];
            T_2_2.ch = '-';
            T_2_3.num = (T_2_1.ch == T_2_2.ch)? true : false;
            if (T_2_3.num == true) {

  LINE(154);
                {
                CLUREF T_3_1;
                T_3_1.num = (i.num == least.num)? true : false;
                if (T_3_1.num == true) {

  LINE(155);
                    {
                    CLUREF T_4_1;
                    T_4_1.ch = '#';
                    {
                    if (i.num < line.array->ext_low || i.num > line.array->ext_high) {
                        err = ERR_bounds;
                        goto ex_0;}
                    line.array->store->data[i.num + line.array->int_low - line.array->ext_low] = T_4_1.num;
                    }
                    }
                    continue;
                    }
                    }/* end if */

  LINE(156);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CLUREF T_3_4;
                T_3_1.num = i.num - 1;
                 if ((T_3_1.num >= 0 && i.num < 0 && (-1) < 0) || 
                     (T_3_1.num <= 0 && i.num > 0 && (-1) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                if (T_3_1.num < line.array->ext_low || T_3_1.num > line.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_3_2.num = line.array->store->data[T_3_1.num - line.array->ext_low + line.array->int_low];
                err = stringOPindexc(T_3_2, STR__040_011_054, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                T_3_4.num = (T_3_3.num > 0)? true : false;
                if (T_3_4.num == true) {

  LINE(157);
                    {
                    CLUREF T_4_1;
                    T_4_1.ch = '#';
                    {
                    if (i.num < line.array->ext_low || i.num > line.array->ext_high) {
                        err = ERR_bounds;
                        goto ex_0;}
                    line.array->store->data[i.num + line.array->int_low - line.array->ext_low] = T_4_1.num;
                    }
                    }
                    }
                    }/* end if */
                }
                }/* end if */
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE unify ****/

