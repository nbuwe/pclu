
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER bigint ****/

extern errcode intOPge();
extern errcode intOPlt();
extern errcode intOPmod();
extern errcode intOPdiv();
extern errcode intOPgt();
extern errcode arrayOPsize();
extern errcode arrayOPtop();
extern errcode intOPsub();
extern errcode intOPequal();
extern errcode intOPadd();
extern errcode intOPmul();
extern errcode arrayOPfetch();
extern errcode charOPequal();
extern errcode stringOPfetch();
extern errcode stringOPsize();
extern errcode intOPfrom_to();
extern errcode charOPlt();
extern errcode charOPgt();
extern errcode arrayOPstore();
extern errcode charOPc2i();
extern errcode bigintOPadd();
extern errcode bigintOPmul();
extern errcode bigintOPminus();
extern errcode bigintOPnew_base();
extern errcode arrayOPfill();
extern errcode bigintOPone_digit_divide();
extern errcode charOPi2c();
extern errcode arrayOPtrim();
extern errcode stringOPac2s();
extern errcode intOPfrom_to_by();
extern errcode boolOPnot();
extern errcode bigintOPaddsub();
extern errcode bigintOPmax_size();
extern errcode arrayOPpredict();
extern errcode bigintOPfetch_digit();
extern errcode arrayOPaddh();
extern errcode bigintOPclear_leads();
extern errcode intOPmax();
extern errcode bigintOPgtge();
extern errcode arrayOPindexes();
extern errcode bigintOPgt();
extern errcode bigintOPequal();
extern errcode arrayOPencode();
extern errcode arrayOPdecode();
extern errcode bigintOPmul_sub_in();
extern errcode arrayOPelements();
extern errcode bigintOPdivmodhack();
extern errcode boolOPequal();
extern errcode bigintOPsub();
extern errcode bigintOPdivmod();
extern errcode bigintOPold_base();
extern errcode intOPle();
extern errcode bigintOPdiv_one();
extern errcode bigintOPdiv_lt();
extern errcode bigintOPdiv_sub();
extern errcode arrayOPremh();
extern struct REQS *array_of_t_reqs;
extern struct OPS *int_ops;
extern OWN_req array_ownreqs;
extern struct OPS *array_ops;
struct OPS *array_of_int_table;
struct OPS *array_of_int_ops;
struct OPS *array_of_int_ops;
OWNPTR array_of_int_owns;
static int bigint_own_init = 0;
OWN_req bigint_ownreqs = {0,0};
errcode bigint_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (bigint_own_init == 0) {
        add_parm_info_type(0, int_ops, array_of_t_reqs);
        find_type_instance(array_ops, 1, &array_ownreqs, &(array_of_int_ops));
        bigint_own_init = 1;
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE i2bi ****/

errcode bigintOPi2bi(i, ret_1)
CLUREF i;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF first;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(19);

  LINE(20);
    {
    CLUREF T_1_1;
    T_1_1.num = (i.num >= 0)? true : false;
    if (T_1_1.num == true) {

  LINE(21);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 134217728;
        T_2_2.num = (i.num < T_2_1.num)? true : false;
        if (T_2_2.num == true) {

  LINE(22);
            {
            {
            CLUREF T_3_1;
            err = arrayOPnew( &T_3_1);
            if (err != ERR_ok) goto ex_0;
            err = arrayOPaddh(T_3_1, i);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            }
        else {

  LINE(24);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            err = arrayOPnew( &T_3_1);
            if (err != ERR_ok) goto ex_0;
            T_3_2.num = 268435456;
            err = intOPmod(i, T_3_2, &T_3_3);
            if (err != ERR_ok) goto ex_0;
            err = arrayOPaddh(T_3_1, T_3_3);
            if (err != ERR_ok) goto ex_0;
            T_3_4.num = 268435456;
            err = intOPdiv(i, T_3_4, &T_3_5);
            if (err != ERR_ok) goto ex_0;
            err = arrayOPaddh(T_3_1, T_3_5);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            }}/* end if */
        }
    else {

  LINE(27);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = 268435456;
            err = intOPmod(i, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            first.num = T_2_2.num;
            }
            }

  LINE(28);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = -134217728;
        T_2_2.num = (i.num >= T_2_1.num)? true : false;
        if (T_2_2.num == true) {

  LINE(29);
            {
            {
            CLUREF T_3_1;
            err = arrayOPnew( &T_3_1);
            if (err != ERR_ok) goto ex_0;
            err = arrayOPaddh(T_3_1, first);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            }
        else {

  LINE(31);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            err = arrayOPnew( &T_3_1);
            if (err != ERR_ok) goto ex_0;
            err = arrayOPaddh(T_3_1, first);
            if (err != ERR_ok) goto ex_0;
            T_3_2.num = 268435456;
            err = intOPdiv(i, T_3_2, &T_3_3);
            if (err != ERR_ok) goto ex_0;
            T_3_4.num = 268435456;
            err = intOPmod(T_3_3, T_3_4, &T_3_5);
            if (err != ERR_ok) goto ex_0;
            err = arrayOPaddh(T_3_1, T_3_5);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            }}/* end if */
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE i2bi ****/


/**** BEGIN PROCEDURE bi2i ****/

errcode bigintOPbi2i(a, ret_1)
CLUREF a;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF at;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(36);

  LINE(37);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = a.array->ext_size;
    T_1_2.num = (T_1_1.num > 2)? true : false;
    if (T_1_2.num == true) {
        {
        {signal (ERR_overflow);}}
        }
        }/* end if */

  LINE(38);
    {
        {CLUREF T_1_1;
        err = arrayOPtop(a, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        at.num = T_1_1.num;
        }
        }

  LINE(39);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = 134217728;
    T_1_2.num = (at.num >= T_1_1.num)? true : false;
    if (T_1_2.num == true) {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 268435456;
        T_2_2.num = at.num - T_2_1.num;
         if ((T_2_2.num >= 0 && at.num < 0 && (-T_2_1.num) < 0) || 
             (T_2_2.num <= 0 && at.num > 0 && (-T_2_1.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        at.num = T_2_2.num;
        }
        }
        }/* end if */

  LINE(40);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = a.array->ext_size;
    T_1_2.num = (T_1_1.num == 2)? true : false;
    if (T_1_2.num == true) {

  LINE(41);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        T_3_1.num = 268435456;
        err = intOPmul(at, T_3_1, &T_3_2);
        if (err != ERR_ok) goto ex_1;
        if (1 < a.array->ext_low || 1 > a.array->ext_high ) {
            err = ERR_bounds;
            goto ex_1;}
        T_3_3.num = a.array->store->data[1 - a.array->ext_low + a.array->int_low];
        T_3_4.num = T_3_2.num + T_3_3.num;
         if ((T_3_4.num > 0 && T_3_2.num < 0 && T_3_3.num < 0) || 
             (T_3_4.num < 0 && T_3_2.num > 0 && T_3_3.num > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        at.num = T_3_4.num;
        }
        goto end_1;
        ex_1:
            if (err == ERR_overflow) {signal(ERR_overflow);}
            else {
                goto ex_0;}
        end_1:;
        }
        }/* end if */

  LINE(43);
    {
    {
    ret_1->num = at.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE bi2i ****/


/**** BEGIN PROCEDURE parse ****/

errcode bigintOPparse(a, ret_1)
CLUREF a;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF neg;
    CLUREF i;
    CLUREF psum;
    CLUREF ten;
    CLUREF digit;
    CLUREF j;
    CLUREF nc;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(46);

  LINE(51);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    CLUREF T_2_3;
    err = stringOPfetch(a, CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    T_2_2.ch = '-';
    T_2_3.num = (T_2_1.ch == T_2_2.ch)? true : false;
    if (T_2_3.num == true) {

  LINE(52);
        {
        neg.tf = true;
        }
        {
        i.num = 2;
        }

  LINE(53);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = stringOPsize(a, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        T_3_2.num = (T_3_1.num == 1)? true : false;
        if (T_3_2.num == true) {
            {
            {signal (ERR_bad_format);}}
            }
            }/* end if */
        }
    else {

  LINE(55);
        {
        neg.tf = false;
        }
        {
        i.num = 1;
        }
        }}/* end if */
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {

  LINE(56);
                {
                {signal (ERR_bad_format);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(57);
    {
        {CLUREF T_1_1;
        err = arrayOPnew( &T_1_1);
        if (err != ERR_ok) goto ex_0;
        err = arrayOPaddh(T_1_1, CLU_0);
        if (err != ERR_ok) goto ex_0;
        psum.num = T_1_1.num;
        }
        }

  LINE(58);
    {
        {CLUREF T_1_1;
        err = arrayOPnew( &T_1_1);
        if (err != ERR_ok) goto ex_0;
        err = arrayOPaddh(T_1_1, CLU_10);
        if (err != ERR_ok) goto ex_0;
        ten.num = T_1_1.num;
        }
        }

  LINE(59);
    {
        {CLUREF T_1_1;
        err = arrayOPnew( &T_1_1);
        if (err != ERR_ok) goto ex_0;
        err = arrayOPaddh(T_1_1, CLU_0);
        if (err != ERR_ok) goto ex_0;
        digit.num = T_1_1.num;
        }
        }

  LINE(60);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        err = stringOPsize(a, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = T_1_1.num;
        for (T_1_2.num = i.num; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            j.num = T_1_2.num;

  LINE(61);
            {
                {CLUREF T_2_1;
                err = stringOPfetch(a, j, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                nc.num = T_2_1.num;
                }
                }

  LINE(62);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            T_2_2.ch = '0';
            err = charOPlt(nc, T_2_2, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            T_2_1.num = T_2_3.num;
            if (!T_2_3.num) {
                T_2_4.ch = '9';
                err = charOPgt(nc, T_2_4, &T_2_5);
                if (err != ERR_ok) goto ex_0;
                T_2_1.num = T_2_5.num;
            }
            if (T_2_1.num == true) {
                {
                {signal (ERR_bad_format);}}
                }
                }/* end if */

  LINE(63);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = (long)(nc.ch & 0xff);
            T_2_2.num = T_2_1.num - 48;
             if ((T_2_2.num >= 0 && T_2_1.num < 0 && (-48) < 0) || 
                 (T_2_2.num <= 0 && T_2_1.num > 0 && (-48) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            {
            if (1 < digit.array->ext_low || 1 > digit.array->ext_high) {
                err = ERR_bounds;
                goto ex_0;}
            digit.array->store->data[1 + digit.array->int_low - digit.array->ext_low] = T_2_2.num;
            }
            }

  LINE(64);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            err = bigintOPmul(psum, ten, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = bigintOPadd(T_2_1, digit, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            psum.num = T_2_2.num;
            }
        }
    }
    end_inline_for_1:;

  LINE(66);
    {
    if (neg.num == true) {
        {
        CLUREF T_2_1;
        err = bigintOPminus(psum, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        psum.num = T_2_1.num;
        }
        }
        }/* end if */

  LINE(67);
    {
    {
    ret_1->num = psum.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE parse ****/


/**** BEGIN PROCEDURE unparse ****/

errcode bigintOPunparse(r, ret_1)
CLUREF r;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF neg;
    CLUREF rnb;
    CLUREF cbsiz;
    CLUREF cbptr;
    CLUREF cbuff;
    CLUREF non_zero;
    CLUREF rem;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(70);

  LINE(74);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = arrayOPtop(r, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = 134217728;
    T_1_3.num = (T_1_1.num < T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(75);
        {
        neg.tf = false;
        }
        }
    else {

  LINE(77);
        {
        CLUREF T_2_1;
        err = bigintOPminus(r, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        r.num = T_2_1.num;
        }

  LINE(78);
        {
        neg.tf = true;
        }
        }}/* end if */

  LINE(80);
    {
        {CLUREF T_1_1;
        err = bigintOPnew_base(r, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        rnb.num = T_1_1.num;
        }
        }

  LINE(81);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = rnb.array->ext_size;
        err = intOPmul(T_1_1, CLU_5, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        cbsiz.num = T_1_2.num;
        }
        }

  LINE(82);
    {
        {cbptr.num = cbsiz.num;
        }
        }

  LINE(83);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.ch = ' ';
        err = arrayOPfill(CLU_1, cbsiz, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        cbuff.num = T_1_2.num;
        }
        }

  LINE(84);
    {
        {non_zero.tf = true;
        }
        }

  LINE(85);
    for (;;) {
        if (non_zero.num != true) { break; }

  LINE(87);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = bigintOPone_digit_divide(rnb, CLU_10, &T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        non_zero.num = T_2_1.num;
        rem.num = T_2_2.num;
        }

  LINE(88);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 48 + rem.num;
         if ((T_2_1.num > 0 && 48 < 0 && rem.num < 0) || 
             (T_2_1.num < 0 && 48 > 0 && rem.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = charOPi2c(T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        {
        if (cbptr.num < cbuff.array->ext_low || cbptr.num > cbuff.array->ext_high) {
            err = ERR_bounds;
            goto ex_0;}
        cbuff.array->store->data[cbptr.num + cbuff.array->int_low - cbuff.array->ext_low] = T_2_2.num;
        }
        }

  LINE(89);
        {
        CLUREF T_2_1;
        T_2_1.num = cbptr.num - 1;
         if ((T_2_1.num >= 0 && cbptr.num < 0 && (-1) < 0) || 
             (T_2_1.num <= 0 && cbptr.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        cbptr.num = T_2_1.num;
        }
        }
        end_while_1:;

  LINE(91);
    {
    if (neg.num == true) {

  LINE(92);
        {
        CLUREF T_2_1;
        T_2_1.ch = '-';
        {
        if (cbptr.num < cbuff.array->ext_low || cbptr.num > cbuff.array->ext_high) {
            err = ERR_bounds;
            goto ex_0;}
        cbuff.array->store->data[cbptr.num + cbuff.array->int_low - cbuff.array->ext_low] = T_2_1.num;
        }
        }

  LINE(93);
        {
        CLUREF T_2_1;
        T_2_1.num = cbptr.num - 1;
         if ((T_2_1.num >= 0 && cbptr.num < 0 && (-1) < 0) || 
             (T_2_1.num <= 0 && cbptr.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        cbptr.num = T_2_1.num;
        }
        }
        }/* end if */

  LINE(95);
    {
    CLUREF T_1_1;
    T_1_1.num = cbptr.num + 1;
     if ((T_1_1.num > 0 && cbptr.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && cbptr.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    err = arrayOPtrim(cbuff, T_1_1, cbsiz);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(96);
    {
    {
    CLUREF T_1_1;
    err = stringOPac2s(cbuff, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE unparse ****/


/**** BEGIN PROCEDURE one_digit_divide ****/

errcode bigintOPone_digit_divide(rnb, d, ret_1, ret_2)
CLUREF rnb;
CLUREF d;
CLUREF *ret_1;
CLUREF *ret_2;
    {
    errcode err;
    errcode ecode2;
    CLUREF non_zero;
    CLUREF rem;
    CLUREF i;
    CLUREF rv;
    CLUREF nrv;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(100);

  LINE(101);
    {
        {non_zero.tf = false;
        }
        }

  LINE(102);
    {
        {rem.num = 0;
        }
        }

  LINE(103);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = rnb.array->ext_size;
        T_1_3.num = 1;
        T_1_4.num = -1;
        for (T_1_2.num = T_1_1.num; ((T_1_4.num == 0) || ((T_1_4.num > 0)? (T_1_2.num <= T_1_3.num) : (T_1_2.num >= T_1_3.num))); T_1_2.num += T_1_4.num) {
            i.num = T_1_2.num;

  LINE(104);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                CLUREF T_2_4;
                T_2_1.num = 16384;
                err = intOPmul(rem, T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                if (i.num < rnb.array->ext_low || i.num > rnb.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_3.num = rnb.array->store->data[i.num - rnb.array->ext_low + rnb.array->int_low];
                T_2_4.num = T_2_2.num + T_2_3.num;
                 if ((T_2_4.num > 0 && T_2_2.num < 0 && T_2_3.num < 0) || 
                     (T_2_4.num < 0 && T_2_2.num > 0 && T_2_3.num > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                rv.num = T_2_4.num;
                }
                }

  LINE(105);
            {
                {CLUREF T_2_1;
                err = intOPdiv(rv, d, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                nrv.num = T_2_1.num;
                }
                }

  LINE(106);
            {
            CLUREF T_2_1;
            err = intOPmod(rv, d, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            rem.num = T_2_1.num;
            }

  LINE(107);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = (nrv.num == 0)? true : false;
            T_2_2.num = T_2_1.num ^ 1;
            if (T_2_2.num == true) {
                {
                non_zero.tf = true;
                }
                }
                }/* end if */

  LINE(108);
            {
            {
            if (i.num < rnb.array->ext_low || i.num > rnb.array->ext_high) {
                err = ERR_bounds;
                goto ex_0;}
            rnb.array->store->data[i.num + rnb.array->int_low - rnb.array->ext_low] = nrv.num;
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(110);
    {
    {
    ret_1->num = non_zero.num;
    }
    {
    ret_2->num = rem.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE one_digit_divide ****/


/**** BEGIN PROCEDURE add ****/

errcode bigintOPadd(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(114);

  LINE(115);
    {
    {
    CLUREF T_1_1;
    err = bigintOPaddsub(a, b, CLU_0, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE add ****/


/**** BEGIN PROCEDURE sub ****/

errcode bigintOPsub(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(118);

  LINE(119);
    {
    {
    CLUREF T_1_1;
    err = bigintOPaddsub(a, b, CLU_1, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE sub ****/


/**** BEGIN PROCEDURE minus ****/

errcode bigintOPminus(a, ret_1)
CLUREF a;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(122);

  LINE(123);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = arrayOPnew( &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = arrayOPaddh(T_1_1, CLU_0);
    if (err != ERR_ok) goto ex_0;
    err = bigintOPaddsub(T_1_1, a, CLU_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE minus ****/


/**** BEGIN PROCEDURE addsub ****/

errcode bigintOPaddsub(a, b, neg, ret_1)
CLUREF a;
CLUREF b;
CLUREF neg;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF sz;
    CLUREF c;
    CLUREF carry;
    CLUREF fa;
    CLUREF fb;
    CLUREF psum;
    CLUREF i;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(127);

  LINE(128);
    {
        {CLUREF T_1_1;
        err = bigintOPmax_size(a, b, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        sz.num = T_1_1.num;
        }
        }

  LINE(129);
    {
        {CLUREF T_1_1;
        err = arrayOPpredict(CLU_1, sz, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        c.num = T_1_1.num;
        }
        }

  LINE(131);
    {
    if (neg.num == true) {
        {
        carry.num = 1;
        }
        }
    else {
        {
        carry.num = 0;
        }
        }}/* end if */

  LINE(133);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = sz.num;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(134);
            {
            CLUREF T_2_1;
            err = bigintOPfetch_digit(a, i, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            fa.num = T_2_1.num;
            }

  LINE(135);
            {
            CLUREF T_2_1;
            err = bigintOPfetch_digit(b, i, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            fb.num = T_2_1.num;
            }

  LINE(136);
            {
            if (neg.num == true) {
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = 268435455;
                T_3_2.num = T_3_1.num - fb.num;
                 if ((T_3_2.num >= 0 && T_3_1.num < 0 && (-fb.num) < 0) || 
                     (T_3_2.num <= 0 && T_3_1.num > 0 && (-fb.num) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                fb.num = T_3_2.num;
                }
                }
                }/* end if */

  LINE(137);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = fa.num + fb.num;
             if ((T_2_1.num > 0 && fa.num < 0 && fb.num < 0) || 
                 (T_2_1.num < 0 && fa.num > 0 && fb.num > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            T_2_2.num = T_2_1.num + carry.num;
             if ((T_2_2.num > 0 && T_2_1.num < 0 && carry.num < 0) || 
                 (T_2_2.num < 0 && T_2_1.num > 0 && carry.num > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            psum.num = T_2_2.num;
            }

  LINE(138);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = 268435456;
            T_2_2.num = (psum.num >= T_2_1.num)? true : false;
            if (T_2_2.num == true) {

  LINE(139);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = 268435456;
                T_3_2.num = psum.num - T_3_1.num;
                 if ((T_3_2.num >= 0 && psum.num < 0 && (-T_3_1.num) < 0) || 
                     (T_3_2.num <= 0 && psum.num > 0 && (-T_3_1.num) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                psum.num = T_3_2.num;
                }

  LINE(140);
                {
                carry.num = 1;
                }
                }
            else {

  LINE(142);
                {
                carry.num = 0;
                }
                }}/* end if */

  LINE(144);
            {
            {
            if ((c.array->int_low + c.array->ext_size + 1) < c.array->int_size) {
                c.array->store->data[c.array->int_low + c.array->ext_size] = psum.num;
                c.array->ext_size++; c.array->ext_high++;}
            else {
                err = arrayOPaddh(c, psum);
                if (err != ERR_ok) goto ex_0;}
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(147);
    {
    CLUREF T_1_1;
    T_1_1.num = (carry.num == 1)? true : false;
    if (T_1_1.num == true) {

  LINE(148);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        CLUREF T_2_7;
        CLUREF T_2_8;
        T_2_3.num = 134217728;
        T_2_4.num = (fa.num >= T_2_3.num)? true : false;
        T_2_2.num = T_2_4.num;
        if (T_2_4.num) {
            T_2_5.num = 134217728;
            T_2_6.num = (fb.num >= T_2_5.num)? true : false;
            T_2_2.num = T_2_6.num;
        }
        T_2_1.num = T_2_2.num;
        if (T_2_2.num) {
            T_2_7.num = 134217728;
            T_2_8.num = (psum.num < T_2_7.num)? true : false;
            T_2_1.num = T_2_8.num;
        }
        if (T_2_1.num == true) {

  LINE(150);
            {
            CLUREF T_3_1;
            T_3_1.num = 268435455;
            {
            if ((c.array->int_low + c.array->ext_size + 1) < c.array->int_size) {
                c.array->store->data[c.array->int_low + c.array->ext_size] = T_3_1.num;
                c.array->ext_size++; c.array->ext_high++;}
            else {
                err = arrayOPaddh(c, T_3_1);
                if (err != ERR_ok) goto ex_0;}
            }
            }
            }
            }/* end if */
        }
    else {

  LINE(153);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        CLUREF T_2_7;
        CLUREF T_2_8;
        T_2_3.num = 134217728;
        T_2_4.num = (fa.num < T_2_3.num)? true : false;
        T_2_2.num = T_2_4.num;
        if (T_2_4.num) {
            T_2_5.num = 134217728;
            T_2_6.num = (fb.num < T_2_5.num)? true : false;
            T_2_2.num = T_2_6.num;
        }
        T_2_1.num = T_2_2.num;
        if (T_2_2.num) {
            T_2_7.num = 134217728;
            T_2_8.num = (psum.num >= T_2_7.num)? true : false;
            T_2_1.num = T_2_8.num;
        }
        if (T_2_1.num == true) {

  LINE(155);
            {
            {
            if ((c.array->int_low + c.array->ext_size + 1) < c.array->int_size) {
                c.array->store->data[c.array->int_low + c.array->ext_size] = 0;
                c.array->ext_size++; c.array->ext_high++;}
            else {
                err = arrayOPaddh(c, CLU_0);
                if (err != ERR_ok) goto ex_0;}
            }
            }
            }
            }/* end if */
        }}/* end if */

  LINE(158);
    {
    err = bigintOPclear_leads(c);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(159);
    {
    {
    ret_1->num = c.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE addsub ****/


/**** BEGIN PROCEDURE max_size ****/

errcode bigintOPmax_size(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(163);

  LINE(164);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = a.array->ext_size;
    T_1_2.num = b.array->ext_size;
    err = intOPmax(T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_3.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE max_size ****/


/**** BEGIN PROCEDURE fetch_digit ****/

errcode bigintOPfetch_digit(n, i, ret_1)
CLUREF n;
CLUREF i;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(168);

  LINE(169);
    {
    {
    CLUREF T_2_1;
    if (i.num < n.array->ext_low || i.num > n.array->ext_high ) {
        err = ERR_bounds;
        goto ex_1;}
    T_2_1.num = n.array->store->data[i.num - n.array->ext_low + n.array->int_low];
    ret_1->num = T_2_1.num;
    }
    {signal (ERR_ok);}}
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {

  LINE(172);
                {
                CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                err = arrayOPtop(n, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                T_2_2.num = 134217728;
                T_2_3.num = (T_2_1.num >= T_2_2.num)? true : false;
                if (T_2_3.num == true) {

  LINE(173);
                    {
                    {
                    ret_1->num = 268435455;
                    }
                    {signal (ERR_ok);}}
                    }
                else {

  LINE(175);
                    {
                    {
                    ret_1->num = 0;
                    }
                    {signal (ERR_ok);}}
                    }}/* end if */
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE fetch_digit ****/


/**** BEGIN PROCEDURE gt ****/

errcode bigintOPgt(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(181);

  LINE(182);
    {
    {
    CLUREF T_1_1;
    err = bigintOPgtge(a, b, CLU_0, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE gt ****/


/**** BEGIN PROCEDURE ge ****/

errcode bigintOPge(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(185);

  LINE(186);
    {
    {
    CLUREF T_1_1;
    err = bigintOPgtge(a, b, CLU_1, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE ge ****/


/**** BEGIN PROCEDURE lt ****/

errcode bigintOPlt(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(189);

  LINE(190);
    {
    {
    CLUREF T_1_1;
    err = bigintOPgtge(b, a, CLU_0, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE lt ****/


/**** BEGIN PROCEDURE le ****/

errcode bigintOPle(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(193);

  LINE(194);
    {
    {
    CLUREF T_1_1;
    err = bigintOPgtge(b, a, CLU_1, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE le ****/


/**** BEGIN PROCEDURE equal ****/

errcode bigintOPequal(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF i;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(197);

  LINE(198);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = a.array->ext_size;
    T_1_2.num = b.array->ext_size;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(199);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = a.array->ext_high; 
        for (T_1_1.num = a.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(200);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            if (i.num < a.array->ext_low || i.num > a.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = a.array->store->data[i.num - a.array->ext_low + a.array->int_low];
            if (i.num < b.array->ext_low || i.num > b.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_2.num = b.array->store->data[i.num - b.array->ext_low + b.array->int_low];
            T_2_3.num = (T_2_1.num == T_2_2.num)? true : false;
            T_2_4.num = T_2_3.num ^ 1;
            if (T_2_4.num == true) {
                {
                {
                ret_1->tf = false;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */
        }
    }
    end_inline_for_1:;

  LINE(202);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE equal ****/


/**** BEGIN PROCEDURE max ****/

errcode bigintOPmax(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(205);

  LINE(206);
    {
    CLUREF T_1_1;
    err = bigintOPgt(a, b, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {
        {
        {
        ret_1->num = a.num;
        }
        {signal (ERR_ok);}}
        }
    else {
        {
        {
        ret_1->num = b.num;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE max ****/


/**** BEGIN PROCEDURE min ****/

errcode bigintOPmin(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(209);

  LINE(210);
    {
    CLUREF T_1_1;
    err = bigintOPgt(a, b, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {
        {
        {
        ret_1->num = b.num;
        }
        {signal (ERR_ok);}}
        }
    else {
        {
        {
        ret_1->num = a.num;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE min ****/


/**** BEGIN PROCEDURE abs ****/

errcode bigintOPabs(a, ret_1)
CLUREF a;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(213);

  LINE(214);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = arrayOPtop(a, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = 134217728;
    T_1_3.num = (T_1_1.num < T_1_2.num)? true : false;
    if (T_1_3.num == true) {
        {
        {
        ret_1->num = a.num;
        }
        {signal (ERR_ok);}}
        }
    else {
        {
        {
        CLUREF T_2_1;
        err = bigintOPminus(a, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE abs ****/


/**** BEGIN PROCEDURE gtge ****/

errcode bigintOPgtge(a, b, eq, ret_1)
CLUREF a;
CLUREF b;
CLUREF eq;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF i;
    CLUREF fa;
    CLUREF fb;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(218);

  LINE(219);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = arrayOPtop(a, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = 134217728;
    T_1_3.num = (T_1_1.num < T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(220);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = arrayOPtop(b, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        T_2_2.num = 134217728;
        T_2_3.num = (T_2_1.num >= T_2_2.num)? true : false;
        if (T_2_3.num == true) {

  LINE(222);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */
        }
    else {

  LINE(225);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        err = arrayOPtop(b, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        T_2_2.num = 134217728;
        T_2_3.num = (T_2_1.num < T_2_2.num)? true : false;
        if (T_2_3.num == true) {

  LINE(227);
            {
            {
            ret_1->tf = false;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */
        }}/* end if */

  LINE(230);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        err = bigintOPmax_size(a, b, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = 1;
        T_1_4.num = -1;
        for (T_1_2.num = T_1_1.num; ((T_1_4.num == 0) || ((T_1_4.num > 0)? (T_1_2.num <= T_1_3.num) : (T_1_2.num >= T_1_3.num))); T_1_2.num += T_1_4.num) {
            i.num = T_1_2.num;

  LINE(231);
            {
                {CLUREF T_2_1;
                err = bigintOPfetch_digit(a, i, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                fa.num = T_2_1.num;
                }
                }

  LINE(232);
            {
                {CLUREF T_2_1;
                err = bigintOPfetch_digit(b, i, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                fb.num = T_2_1.num;
                }
                }

  LINE(233);
            {
            CLUREF T_2_1;
            T_2_1.num = (fa.num > fb.num)? true : false;
            if (T_2_1.num == true) {
                {
                {
                ret_1->tf = true;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */

  LINE(234);
            {
            CLUREF T_2_1;
            T_2_1.num = (fa.num < fb.num)? true : false;
            if (T_2_1.num == true) {
                {
                {
                ret_1->tf = false;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */
        }
    }
    end_inline_for_1:;

  LINE(236);
    {
    {
    ret_1->num = eq.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE gtge ****/


/**** BEGIN PROCEDURE similar ****/

errcode bigintOPsimilar(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(240);

  LINE(241);
    {
    {
    CLUREF T_1_1;
    err = bigintOPequal(a, b, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE similar ****/


/**** BEGIN PROCEDURE copy ****/

errcode bigintOPcopy(a, ret_1)
CLUREF a;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(244);

  LINE(245);
    {
    {
    ret_1->num = a.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE copy ****/

struct OPS *array_of_int_table;
struct OPS *array_of_int_ops;
struct OPS *array_of_int_ops;
OWNPTR array_of_int_owns;
static int bigintOPencode_own_init = 0;

/**** BEGIN PROCEDURE encode ****/

errcode bigintOPencode(v, i)
CLUREF v;
CLUREF i;
    {
    errcode err;
    errcode ecode2;
        if (bigintOPencode_own_init == 0) {
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        bigintOPencode_own_init = 1;
    }
    enter_proc(248);

  LINE(249);
    {
    generic_CLU_proc.type_owns = array_of_int_ops->type_owns;
    generic_CLU_proc.proc = arrayOPencode;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = arrayOPencode(v, i);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE encode ****/

struct OPS *array_of_int_table;
struct OPS *array_of_int_ops;
struct OPS *array_of_int_ops;
OWNPTR array_of_int_owns;
static int bigintOPdecode_own_init = 0;

/**** BEGIN PROCEDURE decode ****/

errcode bigintOPdecode(i, ret_1)
CLUREF i;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (bigintOPdecode_own_init == 0) {
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        bigintOPdecode_own_init = 1;
    }
    enter_proc(252);

  LINE(254);
    {
    {
    CLUREF T_2_1;
    generic_CLU_proc.type_owns = array_of_int_ops->type_owns;
    generic_CLU_proc.proc = arrayOPdecode;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = arrayOPdecode(i, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    ret_1->num = T_2_1.num;
    }
    {signal (ERR_ok);}}
    goto end_1;
    ex_1:
        if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
        else if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE decode ****/


/**** BEGIN PROCEDURE mul ****/

errcode bigintOPmul(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF c;
    CLUREF ia;
    CLUREF digalo;
    CLUREF digahi;
    CLUREF ib;
    CLUREF digblo;
    CLUREF digbhi;
    CLUREF splitd;
    CLUREF addlo;
    CLUREF addhi;
    CLUREF store_at;
    CLUREF newd;
    CLUREF add_in;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(258);

  LINE(259);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        T_1_1.num = a.array->ext_size;
        T_1_2.num = b.array->ext_size;
        T_1_3.num = T_1_1.num + T_1_2.num;
         if ((T_1_3.num > 0 && T_1_1.num < 0 && T_1_2.num < 0) || 
             (T_1_3.num < 0 && T_1_1.num > 0 && T_1_2.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = arrayOPfill(CLU_1, T_1_3, CLU_0, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        c.num = T_1_4.num;
        }
        }

  LINE(260);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = a.array->ext_high; 
        for (T_1_1.num = a.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            ia.num = T_1_1.num;

  LINE(261);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                if (ia.num < a.array->ext_low || ia.num > a.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = a.array->store->data[ia.num - a.array->ext_low + a.array->int_low];
                T_2_2.num = 16384;
                err = intOPmod(T_2_1, T_2_2, &T_2_3);
                if (err != ERR_ok) goto ex_0;
                digalo.num = T_2_3.num;
                }
                }

  LINE(262);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                if (ia.num < a.array->ext_low || ia.num > a.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = a.array->store->data[ia.num - a.array->ext_low + a.array->int_low];
                T_2_2.num = 16384;
                err = intOPdiv(T_2_1, T_2_2, &T_2_3);
                if (err != ERR_ok) goto ex_0;
                digahi.num = T_2_3.num;
                }
                }

  LINE(263);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
                T_2_2.num = b.array->ext_high; 
                for (T_2_1.num = b.array->ext_low; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                    ib.num = T_2_1.num;

  LINE(264);
                    {
                        {CLUREF T_3_1;
                        CLUREF T_3_2;
                        CLUREF T_3_3;
                        if (ib.num < b.array->ext_low || ib.num > b.array->ext_high ) {
                            err = ERR_bounds;
                            goto ex_0;}
                        T_3_1.num = b.array->store->data[ib.num - b.array->ext_low + b.array->int_low];
                        T_3_2.num = 16384;
                        err = intOPmod(T_3_1, T_3_2, &T_3_3);
                        if (err != ERR_ok) goto ex_0;
                        digblo.num = T_3_3.num;
                        }
                        }

  LINE(265);
                    {
                        {CLUREF T_3_1;
                        CLUREF T_3_2;
                        CLUREF T_3_3;
                        if (ib.num < b.array->ext_low || ib.num > b.array->ext_high ) {
                            err = ERR_bounds;
                            goto ex_0;}
                        T_3_1.num = b.array->store->data[ib.num - b.array->ext_low + b.array->int_low];
                        T_3_2.num = 16384;
                        err = intOPdiv(T_3_1, T_3_2, &T_3_3);
                        if (err != ERR_ok) goto ex_0;
                        digbhi.num = T_3_3.num;
                        }
                        }

  LINE(266);
                    {
                        {CLUREF T_3_1;
                        CLUREF T_3_2;
                        CLUREF T_3_3;
                        err = intOPmul(digalo, digbhi, &T_3_1);
                        if (err != ERR_ok) goto ex_0;
                        err = intOPmul(digahi, digblo, &T_3_2);
                        if (err != ERR_ok) goto ex_0;
                        T_3_3.num = T_3_1.num + T_3_2.num;
                         if ((T_3_3.num > 0 && T_3_1.num < 0 && T_3_2.num < 0) || 
                             (T_3_3.num < 0 && T_3_1.num > 0 && T_3_2.num > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        splitd.num = T_3_3.num;
                        }
                        }

  LINE(267);
                    {
                        {CLUREF T_3_1;
                        CLUREF T_3_2;
                        CLUREF T_3_3;
                        CLUREF T_3_4;
                        CLUREF T_3_5;
                        CLUREF T_3_6;
                        err = intOPmul(digalo, digblo, &T_3_1);
                        if (err != ERR_ok) goto ex_0;
                        T_3_2.num = 16384;
                        err = intOPmod(splitd, T_3_2, &T_3_3);
                        if (err != ERR_ok) goto ex_0;
                        T_3_4.num = 16384;
                        err = intOPmul(T_3_3, T_3_4, &T_3_5);
                        if (err != ERR_ok) goto ex_0;
                        T_3_6.num = T_3_1.num + T_3_5.num;
                         if ((T_3_6.num > 0 && T_3_1.num < 0 && T_3_5.num < 0) || 
                             (T_3_6.num < 0 && T_3_1.num > 0 && T_3_5.num > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        addlo.num = T_3_6.num;
                        }
                        }

  LINE(268);
                    {
                        {CLUREF T_3_1;
                        CLUREF T_3_2;
                        CLUREF T_3_3;
                        CLUREF T_3_4;
                        err = intOPmul(digahi, digbhi, &T_3_1);
                        if (err != ERR_ok) goto ex_0;
                        T_3_2.num = 16384;
                        err = intOPdiv(splitd, T_3_2, &T_3_3);
                        if (err != ERR_ok) goto ex_0;
                        T_3_4.num = T_3_1.num + T_3_3.num;
                         if ((T_3_4.num > 0 && T_3_1.num < 0 && T_3_3.num < 0) || 
                             (T_3_4.num < 0 && T_3_1.num > 0 && T_3_3.num > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        addhi.num = T_3_4.num;
                        }
                        }

  LINE(269);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    T_3_1.num = 268435456;
                    T_3_2.num = (addlo.num >= T_3_1.num)? true : false;
                    if (T_3_2.num == true) {

  LINE(270);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        T_4_1.num = 268435456;
                        T_4_2.num = addlo.num - T_4_1.num;
                         if ((T_4_2.num >= 0 && addlo.num < 0 && (-T_4_1.num) < 0) || 
                             (T_4_2.num <= 0 && addlo.num > 0 && (-T_4_1.num) > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        addlo.num = T_4_2.num;
                        }

  LINE(271);
                        {
                        CLUREF T_4_1;
                        T_4_1.num = addhi.num + 1;
                         if ((T_4_1.num > 0 && addhi.num < 0 && 1 < 0) || 
                             (T_4_1.num < 0 && addhi.num > 0 && 1 > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        addhi.num = T_4_1.num;
                        }
                        }
                        }/* end if */

  LINE(273);
                    {
                        {CLUREF T_3_1;
                        CLUREF T_3_2;
                        T_3_1.num = ia.num + ib.num;
                         if ((T_3_1.num > 0 && ia.num < 0 && ib.num < 0) || 
                             (T_3_1.num < 0 && ia.num > 0 && ib.num > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        T_3_2.num = T_3_1.num - 1;
                         if ((T_3_2.num >= 0 && T_3_1.num < 0 && (-1) < 0) || 
                             (T_3_2.num <= 0 && T_3_1.num > 0 && (-1) > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        store_at.num = T_3_2.num;
                        }
                        }

  LINE(274);
                    {
                        {CLUREF T_3_1;
                        CLUREF T_3_2;
                        if (store_at.num < c.array->ext_low || store_at.num > c.array->ext_high ) {
                            err = ERR_bounds;
                            goto ex_0;}
                        T_3_1.num = c.array->store->data[store_at.num - c.array->ext_low + c.array->int_low];
                        T_3_2.num = T_3_1.num + addlo.num;
                         if ((T_3_2.num > 0 && T_3_1.num < 0 && addlo.num < 0) || 
                             (T_3_2.num < 0 && T_3_1.num > 0 && addlo.num > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        newd.num = T_3_2.num;
                        }
                        }

  LINE(275);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    T_3_1.num = 268435456;
                    T_3_2.num = (newd.num >= T_3_1.num)? true : false;
                    if (T_3_2.num == true) {

  LINE(276);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        T_4_1.num = 268435456;
                        T_4_2.num = newd.num - T_4_1.num;
                         if ((T_4_2.num >= 0 && newd.num < 0 && (-T_4_1.num) < 0) || 
                             (T_4_2.num <= 0 && newd.num > 0 && (-T_4_1.num) > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        newd.num = T_4_2.num;
                        }

  LINE(277);
                        {
                        CLUREF T_4_1;
                        T_4_1.num = addhi.num + 1;
                         if ((T_4_1.num > 0 && addhi.num < 0 && 1 < 0) || 
                             (T_4_1.num < 0 && addhi.num > 0 && 1 > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        addhi.num = T_4_1.num;
                        }
                        }
                        }/* end if */

  LINE(279);
                    {
                    {
                    if (store_at.num < c.array->ext_low || store_at.num > c.array->ext_high) {
                        err = ERR_bounds;
                        goto ex_0;}
                    c.array->store->data[store_at.num + c.array->int_low - c.array->ext_low] = newd.num;
                    }
                    }

  LINE(280);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = store_at.num + 1;
                     if ((T_3_1.num > 0 && store_at.num < 0 && 1 < 0) || 
                         (T_3_1.num < 0 && store_at.num > 0 && 1 > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    store_at.num = T_3_1.num;
                    }

  LINE(281);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    if (store_at.num < c.array->ext_low || store_at.num > c.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_0;}
                    T_3_1.num = c.array->store->data[store_at.num - c.array->ext_low + c.array->int_low];
                    T_3_2.num = T_3_1.num + addhi.num;
                     if ((T_3_2.num > 0 && T_3_1.num < 0 && addhi.num < 0) || 
                         (T_3_2.num < 0 && T_3_1.num > 0 && addhi.num > 0)) {
                        err = ERR_overflow;
                        goto ex_0;}
                    newd.num = T_3_2.num;
                    }

  LINE(282);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    T_3_1.num = 268435456;
                    T_3_2.num = (newd.num >= T_3_1.num)? true : false;
                    if (T_3_2.num == true) {

  LINE(283);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        T_4_1.num = 268435456;
                        T_4_2.num = newd.num - T_4_1.num;
                         if ((T_4_2.num >= 0 && newd.num < 0 && (-T_4_1.num) < 0) || 
                             (T_4_2.num <= 0 && newd.num > 0 && (-T_4_1.num) > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        newd.num = T_4_2.num;
                        }

  LINE(284);
                        {
                            {CLUREF T_4_1;
                            T_4_1.num = store_at.num + 1;
                             if ((T_4_1.num > 0 && store_at.num < 0 && 1 < 0) || 
                                 (T_4_1.num < 0 && store_at.num > 0 && 1 > 0)) {
                                err = ERR_overflow;
                                goto ex_0;}
                            add_in.num = T_4_1.num;
                            }
                            }

  LINE(285);
                        for (;;) {
                            CLUREF T_4_1;
                            CLUREF T_4_2;
                            CLUREF T_4_3;
                            if (add_in.num < c.array->ext_low || add_in.num > c.array->ext_high ) {
                                err = ERR_bounds;
                                goto ex_0;}
                            T_4_1.num = c.array->store->data[add_in.num - c.array->ext_low + c.array->int_low];
                            T_4_2.num = 268435455;
                            T_4_3.num = (T_4_1.num == T_4_2.num)? true : false;
                            if (T_4_3.num != true) { break; }

  LINE(286);
                            {
                            {
                            if (add_in.num < c.array->ext_low || add_in.num > c.array->ext_high) {
                                err = ERR_bounds;
                                goto ex_0;}
                            c.array->store->data[add_in.num + c.array->int_low - c.array->ext_low] = 0;
                            }
                            }

  LINE(287);
                            {
                            CLUREF T_5_1;
                            T_5_1.num = add_in.num + 1;
                             if ((T_5_1.num > 0 && add_in.num < 0 && 1 < 0) || 
                                 (T_5_1.num < 0 && add_in.num > 0 && 1 > 0)) {
                                err = ERR_overflow;
                                goto ex_0;}
                            add_in.num = T_5_1.num;
                            }
                            }
                            end_while_1:;

  LINE(289);
                        {
                        CLUREF T_4_1;
                        CLUREF T_4_2;
                        if (add_in.num < c.array->ext_low || add_in.num > c.array->ext_high ) {
                            err = ERR_bounds;
                            goto ex_0;}
                        T_4_1.num = c.array->store->data[add_in.num - c.array->ext_low + c.array->int_low];
                        T_4_2.num = T_4_1.num + 1;
                         if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) || 
                             (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                            err = ERR_overflow;
                            goto ex_0;}
                        {
                        if (add_in.num < c.array->ext_low || add_in.num > c.array->ext_high) {
                            err = ERR_bounds;
                            goto ex_0;}
                        c.array->store->data[add_in.num + c.array->int_low - c.array->ext_low] = T_4_2.num;
                        }
                        }
                        }
                        }/* end if */

  LINE(291);
                    {
                    {
                    if (store_at.num < c.array->ext_low || store_at.num > c.array->ext_high) {
                        err = ERR_bounds;
                        goto ex_0;}
                    c.array->store->data[store_at.num + c.array->int_low - c.array->ext_low] = newd.num;
                    }
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(295);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = arrayOPtop(a, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = 134217728;
    T_1_3.num = (T_1_1.num >= T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(296);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = a.array->ext_size;
        T_2_2.num = T_2_1.num + 1;
         if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
             (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = bigintOPmul_sub_in(c, b, T_2_2);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(298);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = arrayOPtop(b, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = 134217728;
    T_1_3.num = (T_1_1.num >= T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(299);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = b.array->ext_size;
        T_2_2.num = T_2_1.num + 1;
         if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
             (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = bigintOPmul_sub_in(c, a, T_2_2);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(301);
    {
    err = bigintOPclear_leads(c);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(302);
    {
    {
    ret_1->num = c.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE mul ****/


/**** BEGIN PROCEDURE mul_sub_in ****/

errcode bigintOPmul_sub_in(c, a, p)
CLUREF c;
CLUREF a;
CLUREF p;
    {
    errcode err;
    errcode ecode2;
    CLUREF carry;
    CLUREF aa;
    CLUREF newc;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(306);

  LINE(307);
    {
        {carry.num = 1;
        }
        }

  LINE(308);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = a.array->ext_high; 
        T_1_3 = a;
        for (T_1_1.num = a.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            aa.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(309);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                CLUREF T_2_4;
                CLUREF T_2_5;
                if (p.num < c.array->ext_low || p.num > c.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = c.array->store->data[p.num - c.array->ext_low + c.array->int_low];
                T_2_2.num = 268435455;
                T_2_3.num = T_2_2.num - aa.num;
                 if ((T_2_3.num >= 0 && T_2_2.num < 0 && (-aa.num) < 0) || 
                     (T_2_3.num <= 0 && T_2_2.num > 0 && (-aa.num) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                T_2_4.num = T_2_1.num + T_2_3.num;
                 if ((T_2_4.num > 0 && T_2_1.num < 0 && T_2_3.num < 0) || 
                     (T_2_4.num < 0 && T_2_1.num > 0 && T_2_3.num > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                T_2_5.num = T_2_4.num + carry.num;
                 if ((T_2_5.num > 0 && T_2_4.num < 0 && carry.num < 0) || 
                     (T_2_5.num < 0 && T_2_4.num > 0 && carry.num > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                newc.num = T_2_5.num;
                }
                }

  LINE(310);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = 268435456;
            T_2_2.num = (newc.num >= T_2_1.num)? true : false;
            if (T_2_2.num == true) {

  LINE(311);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = 268435456;
                T_3_2.num = newc.num - T_3_1.num;
                 if ((T_3_2.num >= 0 && newc.num < 0 && (-T_3_1.num) < 0) || 
                     (T_3_2.num <= 0 && newc.num > 0 && (-T_3_1.num) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                newc.num = T_3_2.num;
                }

  LINE(312);
                {
                carry.num = 1;
                }
                }
            else {

  LINE(314);
                {
                carry.num = 0;
                }
                }}/* end if */

  LINE(316);
            {
            {
            if (p.num < c.array->ext_low || p.num > c.array->ext_high) {
                err = ERR_bounds;
                goto ex_0;}
            c.array->store->data[p.num + c.array->int_low - c.array->ext_low] = newc.num;
            }
            }

  LINE(317);
            {
            CLUREF T_2_1;
            T_2_1.num = p.num + 1;
             if ((T_2_1.num > 0 && p.num < 0 && 1 < 0) || 
                 (T_2_1.num < 0 && p.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            p.num = T_2_1.num;
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE mul_sub_in ****/


/**** BEGIN PROCEDURE clear_leads ****/

errcode bigintOPclear_leads(r)
CLUREF r;
    {
    errcode err;
    errcode ecode2;
    CLUREF fd;
    CLUREF rsz;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(323);

  LINE(324);
    {
        {CLUREF T_1_1;
        err = arrayOPtop(r, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        fd.num = T_1_1.num;
        }
        }

  LINE(326);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_2.num = (fd.num == 0)? true : false;
    T_1_1.num = T_1_2.num;
    if (!T_1_2.num) {
        T_1_3.num = 268435455;
        T_1_4.num = (fd.num == T_1_3.num)? true : false;
        T_1_1.num = T_1_4.num;
    }
    if (T_1_1.num == true) {

  LINE(327);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = r.array->ext_size;
            T_2_2.num = T_2_1.num - 1;
             if ((T_2_2.num >= 0 && T_2_1.num < 0 && (-1) < 0) || 
                 (T_2_2.num <= 0 && T_2_1.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            rsz.num = T_2_2.num;
            }
            }

  LINE(328);
        {

  LINE(329);
            for (;;) {
                CLUREF T_4_1;
                CLUREF T_4_2;
                if (rsz.num < r.array->ext_low || rsz.num > r.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_1;}
                T_4_1.num = r.array->store->data[rsz.num - r.array->ext_low + r.array->int_low];
                T_4_2.num = (T_4_1.num == fd.num)? true : false;
                if (T_4_2.num != true) { break; }
                {
                CLUREF T_5_1;
                T_5_1.num = rsz.num - 1;
                 if ((T_5_1.num >= 0 && rsz.num < 0 && (-1) < 0) || 
                     (T_5_1.num <= 0 && rsz.num > 0 && (-1) > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                rsz.num = T_5_1.num;
                }
                }
                end_while_1:;

  LINE(330);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            CLUREF T_4_5;
            CLUREF T_4_6;
            CLUREF T_4_7;
            CLUREF T_4_8;
            CLUREF T_4_9;
            CLUREF T_4_10;
            CLUREF T_4_11;
            CLUREF T_4_12;
            T_4_3.num = (fd.num == 0)? true : false;
            T_4_2.num = T_4_3.num;
            if (T_4_3.num) {
                if (rsz.num < r.array->ext_low || rsz.num > r.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_1;}
                T_4_4.num = r.array->store->data[rsz.num - r.array->ext_low + r.array->int_low];
                T_4_5.num = 134217728;
                T_4_6.num = (T_4_4.num >= T_4_5.num)? true : false;
                T_4_2.num = T_4_6.num;
            }
            T_4_1.num = T_4_2.num;
            if (!T_4_2.num) {
                T_4_8.num = 268435455;
                T_4_9.num = (fd.num == T_4_8.num)? true : false;
                T_4_7.num = T_4_9.num;
                if (T_4_9.num) {
                    if (rsz.num < r.array->ext_low || rsz.num > r.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_10.num = r.array->store->data[rsz.num - r.array->ext_low + r.array->int_low];
                    T_4_11.num = 134217728;
                    T_4_12.num = (T_4_10.num < T_4_11.num)? true : false;
                    T_4_7.num = T_4_12.num;
                }
                T_4_1.num = T_4_7.num;
            }
            if (T_4_1.num == true) {

  LINE(331);
                {
                CLUREF T_5_1;
                T_5_1.num = rsz.num + 1;
                 if ((T_5_1.num > 0 && rsz.num < 0 && 1 < 0) || 
                     (T_5_1.num < 0 && rsz.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                rsz.num = T_5_1.num;
                }
                }
                }/* end if */
            }
            goto end_1;
            ex_1:
                if ((err == ERR_bounds)) {

  LINE(333);
                    {
                    rsz.num = 1;
                    }
                }
                else {
                    goto ex_0;
                }
            end_1:;

  LINE(334);
        {
        err = arrayOPtrim(r, CLU_1, rsz);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE clear_leads ****/


/**** BEGIN PROCEDURE power ****/

errcode bigintOPpower(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF pexp;
    CLUREF sexp;
    CLUREF w;
    CLUREF x;
    CLUREF d;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(339);

  LINE(340);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = arrayOPtop(b, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = 134217728;
    T_1_3.num = (T_1_1.num >= T_1_2.num)? true : false;
    if (T_1_3.num == true) {
        {
        {signal (ERR_negative_exponent);}}
        }
        }/* end if */

  LINE(346);
    {
        {pexp.num = a.num;
        }
        }

  LINE(347);
    {
        {CLUREF T_1_1;
        err = arrayOPnew( &T_1_1);
        if (err != ERR_ok) goto ex_0;
        err = arrayOPaddh(T_1_1, CLU_1);
        if (err != ERR_ok) goto ex_0;
        sexp.num = T_1_1.num;
        }
        }

  LINE(348);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = b.array->ext_high; 
        for (T_1_1.num = b.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            w.num = T_1_1.num;

  LINE(349);
            {
                {CLUREF T_2_1;
                if (w.num < b.array->ext_low || w.num > b.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = b.array->store->data[w.num - b.array->ext_low + b.array->int_low];
                x.num = T_2_1.num;
                }
                }

  LINE(350);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
                T_2_2.num = 31;
                for (T_2_1.num = 0; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                    d.num = T_2_1.num;

  LINE(351);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    err = intOPmod(x, CLU_2, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    T_3_2.num = (T_3_1.num == 1)? true : false;
                    if (T_3_2.num == true) {

  LINE(352);
                        {
                        CLUREF T_4_1;
                        err = bigintOPmul(sexp, pexp, &T_4_1);
                        if (err != ERR_ok) goto ex_0;
                        sexp.num = T_4_1.num;
                        }
                        }
                        }/* end if */

  LINE(354);
                    {
                    CLUREF T_3_1;
                    err = intOPdiv(x, CLU_2, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    x.num = T_3_1.num;
                    }

  LINE(356);
                    {
                    CLUREF T_3_1;
                    CLUREF T_3_2;
                    CLUREF T_3_3;
                    CLUREF T_3_4;
                    T_3_2.num = (x.num == 0)? true : false;
                    T_3_1.num = T_3_2.num;
                    if (T_3_2.num) {
                        T_3_3.num = b.array->ext_size;
                        T_3_4.num = (w.num == T_3_3.num)? true : false;
                        T_3_1.num = T_3_4.num;
                    }
                    if (T_3_1.num == true) {
                        goto end_inline_for_2;
                        }
                        }/* end if */

  LINE(357);
                    {
                    CLUREF T_3_1;
                    err = bigintOPmul(pexp, pexp, &T_3_1);
                    if (err != ERR_ok) goto ex_0;
                    pexp.num = T_3_1.num;
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;

  LINE(360);
    {
    {
    ret_1->num = sexp.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE power ****/


/**** BEGIN PROCEDURE div ****/

errcode bigintOPdiv(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF q;
    CLUREF r;
    CLUREF nega;
    CLUREF negb;
    CLUREF mod0;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(364);

  LINE(365);
    {
        {CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        err = bigintOPdivmodhack(a, b, &T_2_1, &T_2_2, &T_2_3, &T_2_4, &T_2_5);
        if (err != ERR_ok) goto ex_1;
        q.num = T_2_1.num;
        r.num = T_2_2.num;
        nega.num = T_2_3.num;
        negb.num = T_2_4.num;
        mod0.num = T_2_5.num;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_zero_divide) {signal(ERR_zero_divide);}
        else {
            goto ex_0;}
    end_1:;

  LINE(366);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = mod0.num ^ 1;
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        T_1_1.num = nega.num;
    }
    if (T_1_1.num == true) {

  LINE(367);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = arrayOPnew( &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = arrayOPaddh(T_2_1, CLU_1);
        if (err != ERR_ok) goto ex_0;
        err = bigintOPadd(q, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        q.num = T_2_2.num;
        }
        }
        }/* end if */

  LINE(369);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = (nega.tf == negb.tf)? true : false;
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(370);
        {
        CLUREF T_2_1;
        err = bigintOPminus(q, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        q.num = T_2_1.num;
        }
        }
        }/* end if */

  LINE(372);
    {
    {
    ret_1->num = q.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE div ****/


/**** BEGIN PROCEDURE mod ****/

errcode bigintOPmod(a, b, ret_1)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF q;
    CLUREF r;
    CLUREF nega;
    CLUREF negb;
    CLUREF mod0;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(375);

  LINE(376);
    {
        {CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        err = bigintOPdivmodhack(a, b, &T_2_1, &T_2_2, &T_2_3, &T_2_4, &T_2_5);
        if (err != ERR_ok) goto ex_1;
        q.num = T_2_1.num;
        r.num = T_2_2.num;
        nega.num = T_2_3.num;
        negb.num = T_2_4.num;
        mod0.num = T_2_5.num;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_zero_divide) {signal(ERR_zero_divide);}
        else {
            goto ex_0;}
    end_1:;

  LINE(377);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = mod0.num;
    if (!mod0.num) {
        T_1_2.num = nega.num ^ 1;
        T_1_1.num = T_1_2.num;
    }
    if (T_1_1.num == true) {

  LINE(378);
        {
        {
        ret_1->num = r.num;
        }
        {signal (ERR_ok);}}
        }
    else {
    CLUREF T_1_3;
    T_1_3.num = negb.num ^ 1;
    if (T_1_3.num == true) {

  LINE(380);
        {
        {
        CLUREF T_2_1;
        err = bigintOPsub(b, r, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(382);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = bigintOPminus(b, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = bigintOPsub(T_2_1, r, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_2.num;
        }
        {signal (ERR_ok);}}
        }}}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE mod ****/


/**** BEGIN PROCEDURE divmodhack ****/

errcode bigintOPdivmodhack(a, b, ret_1, ret_2, ret_3, ret_4, ret_5)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
CLUREF *ret_2;
CLUREF *ret_3;
CLUREF *ret_4;
CLUREF *ret_5;
    {
    errcode err;
    errcode ecode2;
    CLUREF q;
    CLUREF r;
    CLUREF nega;
    CLUREF negb;
    CLUREF mod0;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(386);

  LINE(389);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = arrayOPtop(a, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = 134217728;
    T_1_3.num = (T_1_1.num >= T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(390);
        {
        CLUREF T_2_1;
        err = bigintOPminus(a, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        a.num = T_2_1.num;
        }

  LINE(391);
        {
        nega.tf = true;
        }
        }
    else {

  LINE(393);
        {
        nega.tf = false;
        }
        }}/* end if */

  LINE(395);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = arrayOPtop(b, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = 134217728;
    T_1_3.num = (T_1_1.num >= T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(396);
        {
        CLUREF T_2_1;
        err = bigintOPminus(b, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        b.num = T_2_1.num;
        }

  LINE(397);
        {
        negb.tf = true;
        }
        }
    else {

  LINE(399);
        {
        negb.tf = false;
        }
        }}/* end if */

  LINE(401);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    err = bigintOPdivmod(a, b, &T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    q.num = T_2_1.num;
    r.num = T_2_2.num;
    }
    goto end_1;
    ex_1:
        if (err == ERR_zero_divide) {signal(ERR_zero_divide);}
        else {
            goto ex_0;}
    end_1:;

  LINE(402);
    {
    CLUREF T_1_1;
    err = bigintOPold_base(q, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    q.num = T_1_1.num;
    }

  LINE(403);
    {
    CLUREF T_1_1;
    err = bigintOPold_base(r, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    r.num = T_1_1.num;
    }

  LINE(404);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    T_1_2.num = r.array->ext_size;
    T_1_3.num = (T_1_2.num == 1)? true : false;
    T_1_1.num = T_1_3.num;
    if (T_1_3.num) {
        if (1 < r.array->ext_low || 1 > r.array->ext_high ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_4.num = r.array->store->data[1 - r.array->ext_low + r.array->int_low];
        T_1_5.num = (T_1_4.num == 0)? true : false;
        T_1_1.num = T_1_5.num;
    }
    if (T_1_1.num == true) {

  LINE(405);
        {
        mod0.tf = true;
        }
        }
    else {

  LINE(407);
        {
        mod0.tf = false;
        }
        }}/* end if */

  LINE(409);
    {
    {
    ret_1->num = q.num;
    }
    {
    ret_2->num = r.num;
    }
    {
    ret_3->num = nega.num;
    }
    {
    ret_4->num = negb.num;
    }
    {
    ret_5->num = mod0.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE divmodhack ****/


/**** BEGIN PROCEDURE divmod ****/

errcode bigintOPdivmod(a, b, ret_1, ret_2)
CLUREF a;
CLUREF b;
CLUREF *ret_1;
CLUREF *ret_2;
    {
    errcode err;
    errcode ecode2;
    CLUREF newba;
    CLUREF newbb;
    CLUREF forget_it;
    CLUREF remainder;
    CLUREF rsize;
    CLUREF r;
    CLUREF e;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(412);

  LINE(413);
    {
        {CLUREF T_1_1;
        err = bigintOPnew_base(a, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        newba.num = T_1_1.num;
        }
        }

  LINE(414);
    {
        {CLUREF T_1_1;
        err = bigintOPnew_base(b, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        newbb.num = T_1_1.num;
        }
        }

  LINE(415);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = newbb.array->ext_size;
    T_1_2.num = (T_1_1.num == 1)? true : false;
    if (T_1_2.num == true) {

  LINE(416);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (1 < newbb.array->ext_low || 1 > newbb.array->ext_high ) {
            err = ERR_bounds;
            goto ex_0;}
        T_2_1.num = newbb.array->store->data[1 - newbb.array->ext_low + newbb.array->int_low];
        T_2_2.num = (T_2_1.num == 0)? true : false;
        if (T_2_2.num == true) {
            {
            {signal (ERR_zero_divide);}}
            }
            }/* end if */

  LINE(417);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            if (1 < newbb.array->ext_low || 1 > newbb.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = newbb.array->store->data[1 - newbb.array->ext_low + newbb.array->int_low];
            err = bigintOPone_digit_divide(newba, T_2_1, &T_2_2, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            forget_it.num = T_2_2.num;
            remainder.num = T_2_3.num;
            }
            }

  LINE(418);
        {
        {
        ret_1->num = newba.num;
        }
        {
        CLUREF T_2_1;
        err = arrayOPnew( &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = arrayOPaddh(T_2_1, remainder);
        if (err != ERR_ok) goto ex_0;
        ret_2->num = T_2_1.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(420);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        T_1_1.num = newba.array->ext_size;
        T_1_2.num = newbb.array->ext_size;
        T_1_3.num = T_1_1.num - T_1_2.num;
         if ((T_1_3.num >= 0 && T_1_1.num < 0 && (-T_1_2.num) < 0) || 
             (T_1_3.num <= 0 && T_1_1.num > 0 && (-T_1_2.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        T_1_4.num = T_1_3.num + 1;
         if ((T_1_4.num > 0 && T_1_3.num < 0 && 1 < 0) || 
             (T_1_4.num < 0 && T_1_3.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        rsize.num = T_1_4.num;
        }
        }

  LINE(421);
    {
    CLUREF T_1_1;
    T_1_1.num = (rsize.num <= 0)? true : false;
    if (T_1_1.num == true) {

  LINE(422);
        {
        {
        CLUREF T_2_1;
        err = arrayOPnew( &T_2_1);
        if (err != ERR_ok) goto ex_0;
        err = arrayOPaddh(T_2_1, CLU_0);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_1.num;
        }
        {
        ret_2->num = newba.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(424);
    {
    {
    if ((newba.array->int_low + newba.array->ext_size + 1) < newba.array->int_size) {
        newba.array->store->data[newba.array->int_low + newba.array->ext_size] = 0;
        newba.array->ext_size++; newba.array->ext_high++;}
    else {
        err = arrayOPaddh(newba, CLU_0);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(425);
    {
        {CLUREF T_1_1;
        err = arrayOPfill(CLU_1, rsize, CLU_0, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        r.num = T_1_1.num;
        }
        }

  LINE(426);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = 1;
        T_1_3.num = -1;
        for (T_1_1.num = rsize.num; ((T_1_3.num == 0) || ((T_1_3.num > 0)? (T_1_1.num <= T_1_2.num) : (T_1_1.num >= T_1_2.num))); T_1_1.num += T_1_3.num) {
            e.num = T_1_1.num;

  LINE(427);
            {
            CLUREF T_2_1;
            err = bigintOPdiv_one(newba, newbb, e, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            {
            if (e.num < r.array->ext_low || e.num > r.array->ext_high) {
                err = ERR_bounds;
                goto ex_0;}
            r.array->store->data[e.num + r.array->int_low - r.array->ext_low] = T_2_1.num;
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(429);
    {
    {
    ret_1->num = r.num;
    }
    {
    ret_2->num = newba.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE divmod ****/


/**** BEGIN PROCEDURE div_one ****/

errcode bigintOPdiv_one(iden, isor, e, ret_1)
CLUREF iden;
CLUREF isor;
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ssz;
    CLUREF d;
    CLUREF divsofar;
    CLUREF quess;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(434);

  LINE(435);
    {
        {CLUREF T_1_1;
        T_1_1.num = isor.array->ext_size;
        ssz.num = T_1_1.num;
        }
        }

  LINE(436);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = isor.array->ext_size;
        T_1_2.num = e.num + T_1_1.num;
         if ((T_1_2.num > 0 && e.num < 0 && T_1_1.num < 0) || 
             (T_1_2.num < 0 && e.num > 0 && T_1_1.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        T_1_3.num = T_1_2.num - 1;
         if ((T_1_3.num >= 0 && T_1_2.num < 0 && (-1) < 0) || 
             (T_1_3.num <= 0 && T_1_2.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        d.num = T_1_3.num;
        }
        }

  LINE(440);
    {
        {divsofar.num = 0;
        }
        }

  LINE(441);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        err = bigintOPdiv_lt(iden, isor, e, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = T_1_1.num ^ 1;
        if (T_1_2.num != true) { break; }

  LINE(444);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = d.num + 1;
         if ((T_2_1.num > 0 && d.num < 0 && 1 < 0) || 
             (T_2_1.num < 0 && d.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        if (T_2_1.num < iden.array->ext_low || T_2_1.num > iden.array->ext_high ) {
            err = ERR_bounds;
            goto ex_0;}
        T_2_2.num = iden.array->store->data[T_2_1.num - iden.array->ext_low + iden.array->int_low];
        T_2_3.num = (T_2_2.num == 0)? true : false;
        if (T_2_3.num == true) {

  LINE(445);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            CLUREF T_3_6;
            CLUREF T_3_7;
            CLUREF T_3_8;
            CLUREF T_3_9;
            CLUREF T_3_10;
            CLUREF T_3_11;
            CLUREF T_3_12;
            CLUREF T_3_13;
            CLUREF T_3_14;
            if (d.num < iden.array->ext_low || d.num > iden.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_3_1.num = iden.array->store->data[d.num - iden.array->ext_low + iden.array->int_low];
            T_3_2.num = 16384;
            err = intOPmul(T_3_1, T_3_2, &T_3_3);
            if (err != ERR_ok) goto ex_0;
            T_3_4.num = d.num - 1;
             if ((T_3_4.num >= 0 && d.num < 0 && (-1) < 0) || 
                 (T_3_4.num <= 0 && d.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            if (T_3_4.num < iden.array->ext_low || T_3_4.num > iden.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_3_5.num = iden.array->store->data[T_3_4.num - iden.array->ext_low + iden.array->int_low];
            T_3_6.num = T_3_3.num + T_3_5.num;
             if ((T_3_6.num > 0 && T_3_3.num < 0 && T_3_5.num < 0) || 
                 (T_3_6.num < 0 && T_3_3.num > 0 && T_3_5.num > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            if (ssz.num < isor.array->ext_low || ssz.num > isor.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_3_7.num = isor.array->store->data[ssz.num - isor.array->ext_low + isor.array->int_low];
            T_3_8.num = 16384;
            err = intOPmul(T_3_7, T_3_8, &T_3_9);
            if (err != ERR_ok) goto ex_0;
            T_3_10.num = ssz.num - 1;
             if ((T_3_10.num >= 0 && ssz.num < 0 && (-1) < 0) || 
                 (T_3_10.num <= 0 && ssz.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            if (T_3_10.num < isor.array->ext_low || T_3_10.num > isor.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_3_11.num = isor.array->store->data[T_3_10.num - isor.array->ext_low + isor.array->int_low];
            T_3_12.num = T_3_9.num + T_3_11.num;
             if ((T_3_12.num > 0 && T_3_9.num < 0 && T_3_11.num < 0) || 
                 (T_3_12.num < 0 && T_3_9.num > 0 && T_3_11.num > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            T_3_13.num = T_3_12.num + 1;
             if ((T_3_13.num > 0 && T_3_12.num < 0 && 1 < 0) || 
                 (T_3_13.num < 0 && T_3_12.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            err = intOPdiv(T_3_6, T_3_13, &T_3_14);
            if (err != ERR_ok) goto ex_0;
            quess.num = T_3_14.num;
            }
            }
        else {

  LINE(448);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            CLUREF T_3_5;
            CLUREF T_3_6;
            CLUREF T_3_7;
            CLUREF T_3_8;
            CLUREF T_3_9;
            T_3_1.num = d.num + 1;
             if ((T_3_1.num > 0 && d.num < 0 && 1 < 0) || 
                 (T_3_1.num < 0 && d.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            if (T_3_1.num < iden.array->ext_low || T_3_1.num > iden.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_3_2.num = iden.array->store->data[T_3_1.num - iden.array->ext_low + iden.array->int_low];
            T_3_3.num = 16384;
            err = intOPmul(T_3_2, T_3_3, &T_3_4);
            if (err != ERR_ok) goto ex_0;
            if (d.num < iden.array->ext_low || d.num > iden.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_3_5.num = iden.array->store->data[d.num - iden.array->ext_low + iden.array->int_low];
            T_3_6.num = T_3_4.num + T_3_5.num;
             if ((T_3_6.num > 0 && T_3_4.num < 0 && T_3_5.num < 0) || 
                 (T_3_6.num < 0 && T_3_4.num > 0 && T_3_5.num > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            if (ssz.num < isor.array->ext_low || ssz.num > isor.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_3_7.num = isor.array->store->data[ssz.num - isor.array->ext_low + isor.array->int_low];
            T_3_8.num = T_3_7.num + 1;
             if ((T_3_8.num > 0 && T_3_7.num < 0 && 1 < 0) || 
                 (T_3_8.num < 0 && T_3_7.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            err = intOPdiv(T_3_6, T_3_8, &T_3_9);
            if (err != ERR_ok) goto ex_0;
            quess.num = T_3_9.num;
            }
            }}/* end if */

  LINE(450);
        {
        CLUREF T_2_1;
        T_2_1.num = (quess.num == 0)? true : false;
        if (T_2_1.num == true) {
            {
            quess.num = 1;
            }
            }
            }/* end if */

  LINE(451);
        {
        err = bigintOPdiv_sub(iden, isor, e, quess);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(452);
        {
        CLUREF T_2_1;
        T_2_1.num = divsofar.num + quess.num;
         if ((T_2_1.num > 0 && divsofar.num < 0 && quess.num < 0) || 
             (T_2_1.num < 0 && divsofar.num > 0 && quess.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        divsofar.num = T_2_1.num;
        }
        }
        end_while_1:;

  LINE(454);
    {
    {
    ret_1->num = divsofar.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE div_one ****/


/**** BEGIN PROCEDURE div_lt ****/

errcode bigintOPdiv_lt(iden, isor, e, ret_1)
CLUREF iden;
CLUREF isor;
CLUREF e;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF d;
    CLUREF s;
    CLUREF dd;
    CLUREF ss;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(458);

  LINE(459);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = isor.array->ext_size;
        T_1_2.num = e.num + T_1_1.num;
         if ((T_1_2.num > 0 && e.num < 0 && T_1_1.num < 0) || 
             (T_1_2.num < 0 && e.num > 0 && T_1_1.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        T_1_3.num = T_1_2.num - 1;
         if ((T_1_3.num >= 0 && T_1_2.num < 0 && (-1) < 0) || 
             (T_1_3.num <= 0 && T_1_2.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        d.num = T_1_3.num;
        }
        }

  LINE(460);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = d.num + 1;
     if ((T_1_1.num > 0 && d.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && d.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    if (T_1_1.num < iden.array->ext_low || T_1_1.num > iden.array->ext_high ) {
        err = ERR_bounds;
        goto ex_0;}
    T_1_2.num = iden.array->store->data[T_1_1.num - iden.array->ext_low + iden.array->int_low];
    T_1_3.num = (T_1_2.num > 0)? true : false;
    if (T_1_3.num == true) {
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(461);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = isor.array->ext_size;
        T_1_3.num = 1;
        T_1_4.num = -1;
        for (T_1_2.num = T_1_1.num; ((T_1_4.num == 0) || ((T_1_4.num > 0)? (T_1_2.num <= T_1_3.num) : (T_1_2.num >= T_1_3.num))); T_1_2.num += T_1_4.num) {
            s.num = T_1_2.num;

  LINE(462);
            {
                {CLUREF T_2_1;
                if (d.num < iden.array->ext_low || d.num > iden.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = iden.array->store->data[d.num - iden.array->ext_low + iden.array->int_low];
                dd.num = T_2_1.num;
                }
                }
            {
                {CLUREF T_2_1;
                if (s.num < isor.array->ext_low || s.num > isor.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = isor.array->store->data[s.num - isor.array->ext_low + isor.array->int_low];
                ss.num = T_2_1.num;
                }
                }

  LINE(463);
            {
            CLUREF T_2_1;
            T_2_1.num = (dd.num < ss.num)? true : false;
            if (T_2_1.num == true) {
                {
                {
                ret_1->tf = true;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */

  LINE(464);
            {
            CLUREF T_2_1;
            T_2_1.num = (dd.num > ss.num)? true : false;
            if (T_2_1.num == true) {
                {
                {
                ret_1->tf = false;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */

  LINE(465);
            {
            CLUREF T_2_1;
            T_2_1.num = d.num - 1;
             if ((T_2_1.num >= 0 && d.num < 0 && (-1) < 0) || 
                 (T_2_1.num <= 0 && d.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            d.num = T_2_1.num;
            }
        }
    }
    end_inline_for_1:;

  LINE(467);
    {
    {
    ret_1->tf = false;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE div_lt ****/


/**** BEGIN PROCEDURE div_sub ****/

errcode bigintOPdiv_sub(iden, isor, e, x)
CLUREF iden;
CLUREF isor;
CLUREF e;
CLUREF x;
    {
    errcode err;
    errcode ecode2;
    CLUREF borry;
    CLUREF ss;
    CLUREF psum;
    CLUREF newee;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(471);

  LINE(472);
    {
        {borry.num = 0;
        }
        }

  LINE(473);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = isor.array->ext_high; 
        T_1_3 = isor;
        for (T_1_1.num = isor.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            ss.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(474);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                err = intOPmul(ss, x, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                T_2_2.num = borry.num + T_2_1.num;
                 if ((T_2_2.num > 0 && borry.num < 0 && T_2_1.num < 0) || 
                     (T_2_2.num < 0 && borry.num > 0 && T_2_1.num > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                psum.num = T_2_2.num;
                }
                }

  LINE(475);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                CLUREF T_2_4;
                if (e.num < iden.array->ext_low || e.num > iden.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = iden.array->store->data[e.num - iden.array->ext_low + iden.array->int_low];
                T_2_2.num = 16384;
                err = intOPmod(psum, T_2_2, &T_2_3);
                if (err != ERR_ok) goto ex_0;
                T_2_4.num = T_2_1.num - T_2_3.num;
                 if ((T_2_4.num >= 0 && T_2_1.num < 0 && (-T_2_3.num) < 0) || 
                     (T_2_4.num <= 0 && T_2_1.num > 0 && (-T_2_3.num) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                newee.num = T_2_4.num;
                }
                }

  LINE(476);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = 16384;
            err = intOPdiv(psum, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            borry.num = T_2_2.num;
            }

  LINE(477);
            {
            CLUREF T_2_1;
            T_2_1.num = (newee.num < 0)? true : false;
            if (T_2_1.num == true) {

  LINE(478);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = 16384;
                T_3_2.num = newee.num + T_3_1.num;
                 if ((T_3_2.num > 0 && newee.num < 0 && T_3_1.num < 0) || 
                     (T_3_2.num < 0 && newee.num > 0 && T_3_1.num > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                newee.num = T_3_2.num;
                }

  LINE(479);
                {
                CLUREF T_3_1;
                T_3_1.num = borry.num + 1;
                 if ((T_3_1.num > 0 && borry.num < 0 && 1 < 0) || 
                     (T_3_1.num < 0 && borry.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                borry.num = T_3_1.num;
                }
                }
                }/* end if */

  LINE(481);
            {
            {
            if (e.num < iden.array->ext_low || e.num > iden.array->ext_high) {
                err = ERR_bounds;
                goto ex_0;}
            iden.array->store->data[e.num + iden.array->int_low - iden.array->ext_low] = newee.num;
            }
            }

  LINE(482);
            {
            CLUREF T_2_1;
            T_2_1.num = e.num + 1;
             if ((T_2_1.num > 0 && e.num < 0 && 1 < 0) || 
                 (T_2_1.num < 0 && e.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            e.num = T_2_1.num;
            }
        }
    }
    end_inline_for_1:;

  LINE(484);
    {
    CLUREF T_1_1;
    T_1_1.num = (borry.num > 0)? true : false;
    if (T_1_1.num == true) {

  LINE(485);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        if (e.num < iden.array->ext_low || e.num > iden.array->ext_high ) {
            err = ERR_bounds;
            goto ex_0;}
        T_2_1.num = iden.array->store->data[e.num - iden.array->ext_low + iden.array->int_low];
        T_2_2.num = T_2_1.num - borry.num;
         if ((T_2_2.num >= 0 && T_2_1.num < 0 && (-borry.num) < 0) || 
             (T_2_2.num <= 0 && T_2_1.num > 0 && (-borry.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        {
        if (e.num < iden.array->ext_low || e.num > iden.array->ext_high) {
            err = ERR_bounds;
            goto ex_0;}
        iden.array->store->data[e.num + iden.array->int_low - iden.array->ext_low] = T_2_2.num;
        }
        }
        }
        }/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE div_sub ****/


/**** BEGIN PROCEDURE new_base ****/

errcode bigintOPnew_base(a, ret_1)
CLUREF a;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF r;
    CLUREF adig;
    CLUREF topa;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(491);

  LINE(492);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = a.array->ext_size;
        err = intOPmul(CLU_2, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        err = arrayOPpredict(CLU_1, T_1_2, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        r.num = T_1_3.num;
        }
        }

  LINE(493);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = a.array->ext_high; 
        T_1_3 = a;
        for (T_1_1.num = a.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            adig.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(494);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = 16384;
            err = intOPmod(adig, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            {
            if ((r.array->int_low + r.array->ext_size + 1) < r.array->int_size) {
                r.array->store->data[r.array->int_low + r.array->ext_size] = T_2_2.num;
                r.array->ext_size++; r.array->ext_high++;}
            else {
                err = arrayOPaddh(r, T_2_2);
                if (err != ERR_ok) goto ex_0;}
            }
            }

  LINE(495);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = 16384;
            err = intOPdiv(adig, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            {
            if ((r.array->int_low + r.array->ext_size + 1) < r.array->int_size) {
                r.array->store->data[r.array->int_low + r.array->ext_size] = T_2_2.num;
                r.array->ext_size++; r.array->ext_high++;}
            else {
                err = arrayOPaddh(r, T_2_2);
                if (err != ERR_ok) goto ex_0;}
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(497);
    {
        {CLUREF T_1_1;
        err = arrayOPtop(a, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        topa.num = T_1_1.num;
        }
        }

  LINE(498);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = 134217728;
    T_1_2.num = (topa.num < T_1_1.num)? true : false;
    if (T_1_2.num == true) {

  LINE(499);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 8192;
        T_2_2.num = (topa.num < T_2_1.num)? true : false;
        if (T_2_2.num == true) {
            {
            CLUREF T_3_1;
            err = arrayOPremh(r, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            }
            }
            }/* end if */
        }
    else {

  LINE(502);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 268427265;
        T_2_2.num = (topa.num >= T_2_1.num)? true : false;
        if (T_2_2.num == true) {
            {
            CLUREF T_3_1;
            err = arrayOPremh(r, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            }
            }
            }/* end if */
        }}/* end if */

  LINE(504);
    {
    {
    ret_1->num = r.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE new_base ****/


/**** BEGIN PROCEDURE old_base ****/

errcode bigintOPold_base(a, ret_1)
CLUREF a;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF rsz;
    CLUREF r;
    CLUREF carry;
    CLUREF i;
    CLUREF ai;
    CLUREF aip1;
    CLUREF nsum;
        if (bigint_own_init == 0) {
            err = bigint_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(509);

  LINE(510);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = a.array->ext_size;
        err = intOPdiv(T_1_1, CLU_2, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        rsz.num = T_1_2.num;
        }
        }

  LINE(511);
    {
        {CLUREF T_1_1;
        err = arrayOPpredict(CLU_1, rsz, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        r.num = T_1_1.num;
        }
        }

  LINE(512);
    {
        {carry.num = 0;
        }
        }

  LINE(513);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
        T_1_1.num = a.array->ext_size;
        T_1_3.num = T_1_1.num;
        T_1_4.num = 2;
        for (T_1_2.num = 1; ((T_1_4.num == 0) || ((T_1_4.num > 0)? (T_1_2.num <= T_1_3.num) : (T_1_2.num >= T_1_3.num))); T_1_2.num += T_1_4.num) {
            i.num = T_1_2.num;

  LINE(514);
            {
                {CLUREF T_2_1;
                if (i.num < a.array->ext_low || i.num > a.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = a.array->store->data[i.num - a.array->ext_low + a.array->int_low];
                ai.num = T_2_1.num;
                }
                }

  LINE(515);
            {
                {CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = i.num + 1;
                 if ((T_3_1.num > 0 && i.num < 0 && 1 < 0) || 
                     (T_3_1.num < 0 && i.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                if (T_3_1.num < a.array->ext_low || T_3_1.num > a.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_1;}
                T_3_2.num = a.array->store->data[T_3_1.num - a.array->ext_low + a.array->int_low];
                aip1.num = T_3_2.num;
                }
                }
                goto end_1;
                ex_1:
                    if ((err == ERR_bounds)) {

  LINE(518);
                        {
                        CLUREF T_3_1;
                        CLUREF T_3_2;
                        T_3_1.num = 8192;
                        T_3_2.num = (ai.num < T_3_1.num)? true : false;
                        if (T_3_2.num == true) {

  LINE(519);
                            {
                            aip1.num = 0;
                            }
                            }
                        else {

  LINE(521);
                            {
                            aip1.num = 16383;
                            }
                            }}/* end if */
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;

  LINE(524);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                CLUREF T_2_4;
                CLUREF T_2_5;
                CLUREF T_2_6;
                T_2_1.num = 16384;
                err = intOPmod(aip1, T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                T_2_3.num = 16384;
                err = intOPmul(T_2_2, T_2_3, &T_2_4);
                if (err != ERR_ok) goto ex_0;
                T_2_5.num = T_2_4.num + ai.num;
                 if ((T_2_5.num > 0 && T_2_4.num < 0 && ai.num < 0) || 
                     (T_2_5.num < 0 && T_2_4.num > 0 && ai.num > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                T_2_6.num = T_2_5.num + carry.num;
                 if ((T_2_6.num > 0 && T_2_5.num < 0 && carry.num < 0) || 
                     (T_2_6.num < 0 && T_2_5.num > 0 && carry.num > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                nsum.num = T_2_6.num;
                }
                }

  LINE(525);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = 16384;
            err = intOPdiv(aip1, T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            carry.num = T_2_2.num;
            }

  LINE(526);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = 268435456;
            T_2_2.num = (nsum.num >= T_2_1.num)? true : false;
            if (T_2_2.num == true) {

  LINE(527);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = 268435456;
                T_3_2.num = nsum.num - T_3_1.num;
                 if ((T_3_2.num >= 0 && nsum.num < 0 && (-T_3_1.num) < 0) || 
                     (T_3_2.num <= 0 && nsum.num > 0 && (-T_3_1.num) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                nsum.num = T_3_2.num;
                }

  LINE(528);
                {
                CLUREF T_3_1;
                T_3_1.num = carry.num + 1;
                 if ((T_3_1.num > 0 && carry.num < 0 && 1 < 0) || 
                     (T_3_1.num < 0 && carry.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                carry.num = T_3_1.num;
                }
                }
                }/* end if */

  LINE(530);
            {
            {
            if ((r.array->int_low + r.array->ext_size + 1) < r.array->int_size) {
                r.array->store->data[r.array->int_low + r.array->ext_size] = nsum.num;
                r.array->ext_size++; r.array->ext_high++;}
            else {
                err = arrayOPaddh(r, nsum);
                if (err != ERR_ok) goto ex_0;}
            }
            }
        }
    }
    end_inline_for_1:;

  LINE(533);
    {
    err = bigintOPclear_leads(r);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(534);
    {
    {
    ret_1->num = r.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE old_base ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[23];
} bigint_OPS;

CLU_proc bigint_oe_abs = {{0,0,0,0}, bigintOPabs, 0};
CLU_proc bigint_oe_add = {{0,0,0,0}, bigintOPadd, 0};
CLU_proc bigint_oe_bi2i = {{0,0,0,0}, bigintOPbi2i, 0};
CLU_proc bigint_oe_copy = {{0,0,0,0}, bigintOPcopy, 0};
CLU_proc bigint_oe_decode = {{0,0,0,0}, bigintOPdecode, 0};
CLU_proc bigint_oe_div = {{0,0,0,0}, bigintOPdiv, 0};
CLU_proc bigint_oe_encode = {{0,0,0,0}, bigintOPencode, 0};
CLU_proc bigint_oe_equal = {{0,0,0,0}, bigintOPequal, 0};
CLU_proc bigint_oe_ge = {{0,0,0,0}, bigintOPge, 0};
CLU_proc bigint_oe_gt = {{0,0,0,0}, bigintOPgt, 0};
CLU_proc bigint_oe_i2bi = {{0,0,0,0}, bigintOPi2bi, 0};
CLU_proc bigint_oe_le = {{0,0,0,0}, bigintOPle, 0};
CLU_proc bigint_oe_lt = {{0,0,0,0}, bigintOPlt, 0};
CLU_proc bigint_oe_max = {{0,0,0,0}, bigintOPmax, 0};
CLU_proc bigint_oe_min = {{0,0,0,0}, bigintOPmin, 0};
CLU_proc bigint_oe_minus = {{0,0,0,0}, bigintOPminus, 0};
CLU_proc bigint_oe_mod = {{0,0,0,0}, bigintOPmod, 0};
CLU_proc bigint_oe_mul = {{0,0,0,0}, bigintOPmul, 0};
CLU_proc bigint_oe_parse = {{0,0,0,0}, bigintOPparse, 0};
CLU_proc bigint_oe_power = {{0,0,0,0}, bigintOPpower, 0};
CLU_proc bigint_oe_similar = {{0,0,0,0}, bigintOPsimilar, 0};
CLU_proc bigint_oe_sub = {{0,0,0,0}, bigintOPsub, 0};
CLU_proc bigint_oe_unparse = {{0,0,0,0}, bigintOPunparse, 0};

bigint_OPS bigint_ops_actual = {23, (OWNPTR)&bigint_own_init, (OWNPTR)&bigint_own_init, {
    {&bigint_oe_abs, "abs"},
    {&bigint_oe_add, "add"},
    {&bigint_oe_bi2i, "bi2i"},
    {&bigint_oe_copy, "copy"},
    {&bigint_oe_decode, "decode"},
    {&bigint_oe_div, "div"},
    {&bigint_oe_encode, "encode"},
    {&bigint_oe_equal, "equal"},
    {&bigint_oe_ge, "ge"},
    {&bigint_oe_gt, "gt"},
    {&bigint_oe_i2bi, "i2bi"},
    {&bigint_oe_le, "le"},
    {&bigint_oe_lt, "lt"},
    {&bigint_oe_max, "max"},
    {&bigint_oe_min, "min"},
    {&bigint_oe_minus, "minus"},
    {&bigint_oe_mod, "mod"},
    {&bigint_oe_mul, "mul"},
    {&bigint_oe_parse, "parse"},
    {&bigint_oe_power, "power"},
    {&bigint_oe_similar, "similar"},
    {&bigint_oe_sub, "sub"},
    {&bigint_oe_unparse, "unparse"}}};

struct OPS *bigint_ops = (struct OPS *)&bigint_ops_actual;

/**** END CLUSTER bigint ****/
