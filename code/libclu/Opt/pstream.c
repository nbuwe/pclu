
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"

/**** BEGIN CLUSTER pstream ****/

extern errcode pstreamOPcreate();
extern errcode streamOPprimary_output();
extern errcode boolOPnot();
extern errcode streamOPcan_write();
extern errcode arrayOPnew();
extern errcode recordOPset_7();
extern errcode streamOPget_line_length();
extern errcode recordOPset_12();
extern errcode recordOPget_4();
extern errcode recordOPget_6();
extern errcode intOPadd();
extern errcode recordOPset_4();
extern errcode recordOPget_1();
extern errcode pstreamOPputs();
extern errcode arrayOPaddh();
extern errcode recordOPget_3();
extern errcode recordOPget_2();
extern errcode intOPgt();
extern errcode recordOPget_8();
extern errcode recordOPset_1();
extern errcode intOPsub();
extern errcode intOPge();
extern errcode arrayOPsize();
extern errcode arrayOPremh();
extern errcode intOPequal();
extern errcode streamOPputc();
extern errcode recordOPget_11();
extern errcode recordOPset_6();
extern errcode recordOPset_10();
extern errcode recordOPget_5();
extern errcode pstreamOPputsp();
extern errcode arrayOPtop();
extern errcode arrayOPstore();
extern errcode recordOPget_9();
extern errcode charOPequal();
extern errcode recordOPget_12();
extern errcode intOPlt();
extern errcode recordOPget_10();
extern errcode recordOPget_7();
extern errcode stringOPsize();
extern errcode pstreamOPtext();
extern errcode pstreamOPputspace();
extern errcode stringOPindexc();
extern errcode intOPle();
extern errcode streamOPputs();
extern errcode stringOPchars();
extern errcode streamOPputspace();
extern errcode recordOPset_8();
extern errcode recordOPset_9();
extern errcode recordOPset_5();
extern errcode streamOPget_page_length();
extern errcode recordOPequal();
extern errcode arrayOPtrim();
extern errcode intOPprint();
extern errcode file_nameOPprint();
extern errcode streamOPget_name();
extern errcode pstreamOPtextc();
static CLUREF STR__056_056_056;
static CLUREF STR__040;
static CLUREF STR_pstream_133;
static CLUREF STR_d_040;
static CLUREF STR_w_040f_040;
static CLUREF STR_w_040i_040;
static CLUREF STR_m_040;
static CLUREF STR_s_040;
static CLUREF STR__050internal_051;
static int pstream_own_init = 0;
const OWN_req pstream_ownreqs = { 0, 0 };

errcode
pstream_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (pstream_own_init == 0) {
        stringOPcons("...", CLU_1, CLUREF_make_num(3), &STR__056_056_056);
        stringOPcons(" ", CLU_1, CLUREF_make_num(1), &STR__040);
        stringOPcons("pstream[", CLU_1, CLUREF_make_num(8), &STR_pstream_133);
        stringOPcons("d ", CLU_1, CLUREF_make_num(2), &STR_d_040);
        stringOPcons("w f ", CLU_1, CLUREF_make_num(4), &STR_w_040f_040);
        stringOPcons("w i ", CLU_1, CLUREF_make_num(4), &STR_w_040i_040);
        stringOPcons("m ", CLU_1, CLUREF_make_num(2), &STR_m_040);
        stringOPcons("s ", CLU_1, CLUREF_make_num(2), &STR_s_040);
        stringOPcons("(internal)", CLU_1, CLUREF_make_num(10), &STR__050internal_051);
        pstream_own_init = 1;
        signal(ERR_ok);
      ex_0:
        __CLU_EX_HANDLER;
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE primary_output ****/

static int pstreamOPprimary_output_own_init = 0;
CLUREF pstreamOPprimary_outputOPpo;

errcode
pstreamOPprimary_output(CLUREF *ret_1)
{
    errcode err;
    if (pstreamOPprimary_output_own_init == 0) {
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        pstreamOPprimary_output_own_init = 1;
        {
            {CLUREF T_0_1;
            CLUREF T_0_2;
            err = streamOPprimary_output(&T_0_1);
            if (err != ERR_ok) goto ex_0;
            err = pstreamOPcreate(T_0_1, CLU_4, CLU_4, &T_0_2);
            if (err != ERR_ok) goto ex_0;
            pstreamOPprimary_outputOPpo.num = T_0_2.num;
            }
            }
    }
    enter_proc(30);

  LINE(32);
    {
    {
    ret_1->num = pstreamOPprimary_outputOPpo.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE primary_output ****/


/**** BEGIN PROCEDURE create ****/


errcode
pstreamOPcreate(CLUREF st, CLUREF max_depth, CLUREF max_width, CLUREF *ret_1)
{
    errcode err;
    CLUREF ps;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(35);

  LINE(37);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = streamOPcan_write(st, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(38);
        {
        {signal (ERR_illegal_stream);}}
        }
        }/* end if */

  LINE(39);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        RecordAlloc(12, T_1_1);
        T_1_1.vec->data[10] = st.num;
        T_1_1.vec->data[4] = false;
        T_1_1.vec->data[11] = true;
        T_1_1.vec->data[0] = false;
        T_1_1.vec->data[7] = max_depth.num;
        T_1_1.vec->data[8] = max_width.num;
        T_1_1.vec->data[3] = 0;
        T_1_1.vec->data[5] = 0;
        T_1_1.vec->data[9] = 0;
        T_1_1.vec->data[6] = 1073741823;
        err = arrayOPnew(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[2] = T_1_2.num;
        err = arrayOPnew(&T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1] = T_1_3.num;
        ps.num = T_1_1.num;
        }
        }

  LINE(51);
    {
    CLUREF T_2_1;
    err = streamOPget_line_length(st, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    ps.vec->data[6] = T_2_1.num;
    }
        goto end_1;
        ex_1:
            __CLU_EX_HANDLER;
            if ((err == ERR_no_limit)) {

  LINE(52);
                {
                ps.vec->data[11] = false;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(53);
    {
    {
    ret_1->num = ps.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE create ****/


/**** BEGIN PROCEDURE get_depth ****/


errcode
pstreamOPget_depth(CLUREF x, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(56);

  LINE(57);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = x.vec->data[3];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_depth ****/


/**** BEGIN PROCEDURE get_hpos ****/


errcode
pstreamOPget_hpos(CLUREF x, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(60);

  LINE(61);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = x.vec->data[5];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_hpos ****/


/**** BEGIN PROCEDURE start ****/

static int pstreamOPstart_own_init = 0;

errcode
pstreamOPstart(CLUREF ps, CLUREF s, CLUREF *ret_1)
{
    errcode err;
    CLUREF depth;
    if (pstreamOPstart_own_init == 0) {
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        pstreamOPstart_own_init = 1;
    }
    enter_proc(72);

  LINE(73);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = ps.vec->data[3];
        T_1_2.num = T_1_1.num + 1;
         if ((T_1_2.num > 0 && T_1_1.num < 0 && 1 < 0) ||
             (T_1_2.num < 0 && T_1_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        depth.num = T_1_2.num;
        }
        }

  LINE(74);
    {
    ps.vec->data[3] = depth.num;
    }

  LINE(75);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[0];
    if (T_1_1.num == true) {

  LINE(76);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(77);
    {
    err = pstreamOPputs(ps, s);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(78);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[2];
    {
    if ((T_1_1.array->int_low + T_1_1.array->ext_size + 1) < T_1_1.array->int_size) {
        T_1_1.array->store->data[T_1_1.array->int_low + T_1_1.array->ext_size] = 0;
        T_1_1.array->ext_size++; T_1_1.array->ext_high++;}
    else {
        err = arrayOPaddh(T_1_1, CLU_0);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(79);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[1];
    T_1_2.num = ps.vec->data[5];
    {
    if ((T_1_1.array->int_low + T_1_1.array->ext_size + 1) < T_1_1.array->int_size) {
        T_1_1.array->store->data[T_1_1.array->int_low + T_1_1.array->ext_size] = T_1_2.num;
        T_1_1.array->ext_size++; T_1_1.array->ext_high++;}
    else {
        err = arrayOPaddh(T_1_1, T_1_2);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(80);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[7];
    T_1_2.num = (depth.num > T_1_1.num)? true : false;
    if (T_1_2.num == true) {

  LINE(81);
        {
        err = pstreamOPputs(ps, STR__056_056_056);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(82);
        {
        ps.vec->data[0] = true;
        }

  LINE(83);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(85);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE start ****/


/**** BEGIN PROCEDURE stop ****/


errcode
pstreamOPstop(CLUREF ps, CLUREF s, CLUREF *ret_1)
{
    errcode err;
    CLUREF depth;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(88);

  LINE(89);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = ps.vec->data[3];
        T_1_2.num = T_1_1.num - 1;
         if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-1) < 0) ||
             (T_1_2.num <= 0 && T_1_1.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        depth.num = T_1_2.num;
        }
        }

  LINE(90);
    {
    ps.vec->data[3] = depth.num;
    }

  LINE(91);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = ps.vec->data[1];
    T_1_2.num = T_1_1.array->ext_size;
    T_1_3.num = (depth.num >= T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(92);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(93);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[1];
    err = arrayOPremh(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(94);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[2];
    err = arrayOPremh(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(95);
    {
    ps.vec->data[0] = false;
    }

  LINE(96);
    {
    err = pstreamOPputs(ps, s);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(97);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE stop ****/


/**** BEGIN PROCEDURE pause ****/

static int pstreamOPpause_own_init = 0;

errcode
pstreamOPpause(CLUREF ps, CLUREF s, CLUREF *ret_1)
{
    errcode err;
    CLUREF depth;
    CLUREF width;
    if (pstreamOPpause_own_init == 0) {
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        pstreamOPpause_own_init = 1;
    }
    enter_proc(100);

  LINE(101);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[0];
    if (T_1_1.num == true) {

  LINE(102);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(103);
    {
        {CLUREF T_1_1;
        T_1_1.num = ps.vec->data[3];
        depth.num = T_1_1.num;
        }
        }

  LINE(104);
    {
    err = pstreamOPputs(ps, s);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(105);
    {
    CLUREF T_1_1;
    T_1_1.num = (depth.num == 0)? true : false;
    if (T_1_1.num == true) {

  LINE(106);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = ps.vec->data[10];
        T_2_2.ch = '\n';
        err = streamOPputc(T_2_1, T_2_2);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(107);
        {
        ps.vec->data[5] = 0;
        }

  LINE(108);
        {
        ps.vec->data[9] = 0;
        }

  LINE(109);
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(111);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[4];
    if (T_1_1.num == true) {

  LINE(112);
        {
        err = pstreamOPputs(ps, STR__040);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(113);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = ps.vec->data[10];
        T_2_2.ch = '\n';
        err = streamOPputc(T_2_1, T_2_2);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(114);
        {
        ps.vec->data[5] = 0;
        }

  LINE(115);
        {
        ps.vec->data[9] = 0;
        }

  LINE(116);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = ps.vec->data[1];
        err = arrayOPtop(T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        err = pstreamOPputsp(ps, T_2_2);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(118);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = ps.vec->data[2];
        err = arrayOPtop(T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = T_1_2.num + 1;
         if ((T_1_3.num > 0 && T_1_2.num < 0 && 1 < 0) ||
             (T_1_3.num < 0 && T_1_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        width.num = T_1_3.num;
        }
        }

  LINE(119);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[2];
    {
    if (depth.num < T_1_1.array->ext_low || depth.num > T_1_1.array->ext_high) {
        err = ERR_bounds;
        goto ex_0;}
    T_1_1.array->store->data[depth.num + T_1_1.array->int_low - T_1_1.array->ext_low] = width.num;
    }
    }

  LINE(120);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[8];
    T_1_2.num = (width.num >= T_1_1.num)? true : false;
    if (T_1_2.num == true) {

  LINE(121);
        {
        err = pstreamOPputs(ps, STR__056_056_056);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(122);
        {
        ps.vec->data[0] = true;
        }

  LINE(123);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(125);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE pause ****/


/**** BEGIN PROCEDURE text ****/


errcode
pstreamOPtext(CLUREF ps, CLUREF s, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(128);

  LINE(129);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[0];
    if (T_1_1.num == true) {

  LINE(130);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(131);
    {
    err = pstreamOPputs(ps, s);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(132);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE text ****/


/**** BEGIN PROCEDURE textc ****/


errcode
pstreamOPtextc(CLUREF ps, CLUREF c, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(135);

  LINE(136);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[0];
    if (T_1_1.num == true) {

  LINE(137);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(138);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = '\n';
    T_1_2.num = (c.ch == T_1_1.ch)? true : false;
    if (T_1_2.num == true) {

  LINE(139);
        {
        CLUREF T_2_1;
        T_2_1.num = ps.vec->data[10];
        err = streamOPputc(T_2_1, c);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(140);
        {
        ps.vec->data[5] = 0;
        }

  LINE(141);
        {
        ps.vec->data[9] = 0;
        }
        }
    else {

  LINE(142);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = ps.vec->data[5];
        T_2_2.num = T_2_1.num + 1;
         if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) ||
             (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        ps.vec->data[5] = T_2_2.num;
        }

  LINE(143);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_2.num = ps.vec->data[11];
        T_2_1.num = T_2_2.num;
        if (!T_2_2.num) {
            T_2_3.num = ps.vec->data[9];
            T_2_4.num = ps.vec->data[6];
            T_2_5.num = (T_2_3.num < T_2_4.num)? true : false;
            T_2_1.num = T_2_5.num;
        }
        if (T_2_1.num == true) {

  LINE(144);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = ps.vec->data[9];
            T_3_2.num = ps.vec->data[6];
            T_3_3.num = (T_3_1.num >= T_3_2.num)? true : false;
            if (T_3_3.num == true) {

  LINE(145);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = ps.vec->data[10];
                T_4_2.ch = '\n';
                err = streamOPputc(T_4_1, T_4_2);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(146);
                {
                ps.vec->data[9] = 0;
                }
                }
                }/* end if */

  LINE(148);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = ps.vec->data[9];
            T_3_2.num = T_3_1.num + 1;
             if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) ||
                 (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            ps.vec->data[9] = T_3_2.num;
            }

  LINE(149);
            {
            CLUREF T_3_1;
            T_3_1.num = ps.vec->data[10];
            err = streamOPputc(T_3_1, c);
            if (err != ERR_ok) goto ex_0;
            }
            }
            }/* end if */
        }}/* end if */

  LINE(152);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE textc ****/


/**** BEGIN PROCEDURE putleft ****/


errcode
pstreamOPputleft(CLUREF ps, CLUREF s, CLUREF size, CLUREF *ret_1)
{
    errcode err;
    CLUREF diff;
    CLUREF b;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(155);

  LINE(157);
    {
    CLUREF T_1_1;
    T_1_1.num = (size.num < 0)? true : false;
    if (T_1_1.num == true) {

  LINE(158);
        {
        {signal (ERR_negative_field_width);}}
        }
        }/* end if */

  LINE(159);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = stringOPsize(s, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = size.num - T_1_1.num;
         if ((T_1_2.num >= 0 && size.num < 0 && (-T_1_1.num) < 0) ||
             (T_1_2.num <= 0 && size.num > 0 && (-T_1_1.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        diff.num = T_1_2.num;
        }
        }

  LINE(160);
    {
        {CLUREF T_1_1;
        err = pstreamOPtext(ps, s, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        b.num = T_1_1.num;
        }
        }

  LINE(161);
    {
    CLUREF T_1_1;
    T_1_1.num = (diff.num > 0)? true : false;
    if (T_1_1.num == true) {

  LINE(162);
        {
        CLUREF T_2_1;
        err = pstreamOPputspace(ps, diff, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(163);
    {
    {
    ret_1->num = b.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE putleft ****/


/**** BEGIN PROCEDURE putright ****/


errcode
pstreamOPputright(CLUREF ps, CLUREF s, CLUREF size, CLUREF *ret_1)
{
    errcode err;
    CLUREF diff;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(166);

  LINE(168);
    {
    CLUREF T_1_1;
    T_1_1.num = (size.num < 0)? true : false;
    if (T_1_1.num == true) {

  LINE(169);
        {
        {signal (ERR_negative_field_width);}}
        }
        }/* end if */

  LINE(170);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = stringOPsize(s, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = size.num - T_1_1.num;
         if ((T_1_2.num >= 0 && size.num < 0 && (-T_1_1.num) < 0) ||
             (T_1_2.num <= 0 && size.num > 0 && (-T_1_1.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        diff.num = T_1_2.num;
        }
        }

  LINE(171);
    {
    CLUREF T_1_1;
    T_1_1.num = (diff.num > 0)? true : false;
    if (T_1_1.num == true) {

  LINE(172);
        {
        CLUREF T_2_1;
        err = pstreamOPputspace(ps, diff, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(173);
    {
    {
    CLUREF T_1_1;
    err = pstreamOPtext(ps, s, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE putright ****/


/**** BEGIN PROCEDURE putspace ****/


errcode
pstreamOPputspace(CLUREF ps, CLUREF len, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(176);

  LINE(178);
    {
    CLUREF T_1_1;
    T_1_1.num = (len.num < 0)? true : false;
    if (T_1_1.num == true) {

  LINE(179);
        {
        {signal (ERR_negative_field_width);}}
        }
        }/* end if */

  LINE(180);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[0];
    if (T_1_1.num == true) {

  LINE(181);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(182);
    {
    err = pstreamOPputsp(ps, len);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(183);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE putspace ****/


/**** BEGIN PROCEDURE puts ****/

static errcode pstreamOPputs_IB_1();
typedef struct {
    errcode ecode2;
    errcode err;
    CLUREF len;
    CLUREF c;
    CLUREF ps;
    CLUREF s;
} pstreamOPputs_LOCALS_t;

errcode
pstreamOPputs(CLUREF ps, CLUREF s)
{
    pstreamOPputs_LOCALS_t locals;
    locals.ps = ps;
    locals.s = s;
    if (pstream_own_init == 0) {
        locals.err = pstream_own_init_proc();
        if (locals.err != ERR_ok) goto ex_0;
    }
    enter_proc(186);

  LINE(187);
    {
        {CLUREF T_1_1;
        locals.err = stringOPsize(locals.s, &T_1_1);
        if (locals.err != ERR_ok) goto ex_0;
        locals.len.num = T_1_1.num;
        }
        }

  LINE(188);
    {
    CLUREF T_1_1;
    T_1_1.num = (locals.len.num == 0)? true : false;
    if (T_1_1.num == true) {

  LINE(189);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(190);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.ps.vec->data[5];
    T_1_2.num = T_1_1.num + locals.len.num;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && locals.len.num < 0) ||
         (T_1_2.num < 0 && T_1_1.num > 0 && locals.len.num > 0)) {
        locals.err = ERR_overflow;
        goto ex_0;}
    locals.ps.vec->data[5] = T_1_2.num;
    }

  LINE(191);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    CLUREF T_1_8;
    CLUREF T_1_9;
    CLUREF T_1_10;
    T_1_3.num = locals.ps.vec->data[11];
    T_1_4.num = T_1_3.num ^ 1;
    T_1_2.num = T_1_4.num;
    if (T_1_4.num) {
        T_1_5.num = locals.ps.vec->data[9];
        T_1_6.num = locals.ps.vec->data[6];
        T_1_7.num = (T_1_5.num >= T_1_6.num)? true : false;
        T_1_2.num = T_1_7.num;
    }
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        T_1_8.ch = '\n';
        locals.err = stringOPindexc(T_1_8, locals.s, &T_1_9);
        if (locals.err != ERR_ok) goto ex_0;
        T_1_10.num = (T_1_9.num == 0)? true : false;
        T_1_1.num = T_1_10.num;
    }
    if (T_1_1.num == true) {

  LINE(194);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(195);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.ps.vec->data[9];
    T_1_2.num = T_1_1.num + locals.len.num;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && locals.len.num < 0) ||
         (T_1_2.num < 0 && T_1_1.num > 0 && locals.len.num > 0)) {
        locals.err = ERR_overflow;
        goto ex_0;}
    locals.ps.vec->data[9] = T_1_2.num;
    }

  LINE(196);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    T_1_2.num = locals.ps.vec->data[9];
    T_1_3.num = locals.ps.vec->data[6];
    T_1_4.num = (T_1_2.num <= T_1_3.num)? true : false;
    T_1_1.num = T_1_4.num;
    if (T_1_4.num) {
        T_1_5.ch = '\n';
        locals.err = stringOPindexc(T_1_5, locals.s, &T_1_6);
        if (locals.err != ERR_ok) goto ex_0;
        T_1_7.num = (T_1_6.num == 0)? true : false;
        T_1_1.num = T_1_7.num;
    }
    if (T_1_1.num == true) {

  LINE(197);
        {
        CLUREF T_2_1;
        T_2_1.num = locals.ps.vec->data[10];
        locals.err = streamOPputs(T_2_1, locals.s);
        if (locals.err != ERR_ok) goto ex_0;
        }

  LINE(198);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(200);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.ps.vec->data[5];
    T_1_2.num = T_1_1.num - locals.len.num;
     if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-locals.len.num) < 0) ||
         (T_1_2.num <= 0 && T_1_1.num > 0 && (-locals.len.num) > 0)) {
        locals.err = ERR_overflow;
        goto ex_0;}
    locals.ps.vec->data[5] = T_1_2.num;
    }

  LINE(201);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.ps.vec->data[9];
    T_1_2.num = T_1_1.num - locals.len.num;
     if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-locals.len.num) < 0) ||
         (T_1_2.num <= 0 && T_1_1.num > 0 && (-locals.len.num) > 0)) {
        locals.err = ERR_overflow;
        goto ex_0;}
    locals.ps.vec->data[9] = T_1_2.num;
    }

  LINE(202);
    {
        locals.err = stringOPchars(locals.s, pstreamOPputs_IB_1, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {
            signal(ERR_ok);
        }
        if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
        if (locals.err == ERR_break) locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
        if (locals.err != ERR_ok) goto ex_0;
        }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (locals.err != ERR_failure)
        elist[0] = _pclu_erstr(locals.err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE puts ****/


/**** BEGIN ITERATOR BODIES for puts ****/

static errcode
pstreamOPputs_IB_1(CLUREF iv_1, pstreamOPputs_LOCALS_t *locals, errcode *iecode)
{
    locals->c.num = iv_1.num;
    enter_iter_body_proc(203);

  FB_LINE(203);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = '\n';
    T_1_2.num = (locals->c.ch == T_1_1.ch)? true : false;
    if (T_1_2.num == true) {

  FB_LINE(204);
        {
        CLUREF T_2_1;
        T_2_1.num = locals->ps.vec->data[10];
        locals->err = streamOPputc(T_2_1, locals->c);
        if (locals->err != ERR_ok) goto ex_0;
        }

  FB_LINE(205);
        {
        locals->ps.vec->data[5] = 0;
        }

  FB_LINE(206);
        {
        locals->ps.vec->data[9] = 0;
        }
        }
    else {

  FB_LINE(207);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_2.num = locals->ps.vec->data[11];
        T_2_1.num = T_2_2.num;
        if (T_2_2.num) {
            T_2_3.num = locals->ps.vec->data[9];
            T_2_4.num = locals->ps.vec->data[6];
            T_2_5.num = (T_2_3.num >= T_2_4.num)? true : false;
            T_2_1.num = T_2_5.num;
        }
        if (T_2_1.num == true) {

  FB_LINE(208);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = locals->ps.vec->data[10];
            T_3_2.ch = '\n';
            locals->err = streamOPputc(T_3_1, T_3_2);
            if (locals->err != ERR_ok) goto ex_0;
            }

  FB_LINE(209);
            {
            locals->ps.vec->data[9] = 0;
            }
            }
            }/* end if */

  FB_LINE(211);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = locals->ps.vec->data[9];
        T_2_2.num = locals->ps.vec->data[6];
        T_2_3.num = (T_2_1.num < T_2_2.num)? true : false;
        if (T_2_3.num == true) {

  FB_LINE(212);
            {
            CLUREF T_3_1;
            T_3_1.num = locals->ps.vec->data[10];
            locals->err = streamOPputc(T_3_1, locals->c);
            if (locals->err != ERR_ok) goto ex_0;
            }

  FB_LINE(213);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = locals->ps.vec->data[9];
            T_3_2.num = T_3_1.num + 1;
             if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) ||
                 (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                locals->err = ERR_overflow;
                goto ex_0;}
            locals->ps.vec->data[9] = T_3_2.num;
            }
            }
            }/* end if */

  FB_LINE(215);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = locals->ps.vec->data[5];
        T_2_2.num = T_2_1.num + 1;
         if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) ||
             (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            locals->err = ERR_overflow;
            goto ex_0;}
        locals->ps.vec->data[5] = T_2_2.num;
        }
        }}/* end if */

    signal(ERR_ok);
  ex_0:
    __CLU_EX_HANDLER;
    *iecode = locals->err;
    signal(ERR_iterbodyexit);
  end_0:
    __CLU_END_LABEL;
    signal(ERR_ok);
}

/**** END ITERATOR BODIES for puts ****/


/**** BEGIN PROCEDURE putsp ****/


errcode
pstreamOPputsp(CLUREF ps, CLUREF len)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(220);

  LINE(221);
    {
    CLUREF T_1_1;
    T_1_1.num = (len.num == 0)? true : false;
    if (T_1_1.num == true) {

  LINE(222);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(223);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[5];
    T_1_2.num = T_1_1.num + len.num;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && len.num < 0) ||
         (T_1_2.num < 0 && T_1_1.num > 0 && len.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    ps.vec->data[5] = T_1_2.num;
    }

  LINE(224);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    T_1_2.num = ps.vec->data[11];
    T_1_3.num = T_1_2.num ^ 1;
    T_1_1.num = T_1_3.num;
    if (T_1_3.num) {
        T_1_4.num = ps.vec->data[9];
        T_1_5.num = ps.vec->data[6];
        T_1_6.num = (T_1_4.num >= T_1_5.num)? true : false;
        T_1_1.num = T_1_6.num;
    }
    if (T_1_1.num == true) {

  LINE(225);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(226);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[9];
    T_1_2.num = T_1_1.num + len.num;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && len.num < 0) ||
         (T_1_2.num < 0 && T_1_1.num > 0 && len.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    ps.vec->data[9] = T_1_2.num;
    }

  LINE(227);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = ps.vec->data[9];
    T_1_2.num = ps.vec->data[6];
    T_1_3.num = (T_1_1.num <= T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(228);
        {
        CLUREF T_2_1;
        T_2_1.num = ps.vec->data[10];
        err = streamOPputspace(T_2_1, len);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(229);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(231);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = ps.vec->data[9];
        T_1_2.num = ps.vec->data[6];
        T_1_3.num = (T_1_1.num > T_1_2.num)? true : false;
        if (T_1_3.num != true) { break; }

  LINE(232);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = ps.vec->data[10];
        T_2_2.ch = '\n';
        err = streamOPputc(T_2_1, T_2_2);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(233);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = ps.vec->data[9];
        T_2_2.num = ps.vec->data[6];
        T_2_3.num = T_2_1.num - T_2_2.num;
         if ((T_2_3.num >= 0 && T_2_1.num < 0 && (-T_2_2.num) < 0) ||
             (T_2_3.num <= 0 && T_2_1.num > 0 && (-T_2_2.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        ps.vec->data[9] = T_2_3.num;
        }
        }
        end_while_1:
        __CLU_END_LABEL;

  LINE(235);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[10];
    T_1_2.num = ps.vec->data[9];
    err = streamOPputspace(T_1_1, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE putsp ****/


/**** BEGIN PROCEDURE get_indent ****/


errcode
pstreamOPget_indent(CLUREF ps, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(238);

  LINE(239);
    {
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = ps.vec->data[1];
    err = arrayOPtop(T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    ret_1->num = T_2_2.num;
    }
    {signal (ERR_ok);}}
        goto end_1;
        ex_1:
            __CLU_EX_HANDLER;
            if ((err == ERR_bounds)) {

  LINE(240);
                {
                {
                ret_1->num = 0;
                }
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_indent ****/


/**** BEGIN PROCEDURE set_indent ****/


errcode
pstreamOPset_indent(CLUREF ps, CLUREF indent)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(243);

  LINE(244);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = ps.vec->data[1];
    T_2_2.num = ps.vec->data[3];
    {
    if (T_2_2.num < T_2_1.array->ext_low || T_2_2.num > T_2_1.array->ext_high) {
        err = ERR_bounds;
        goto ex_1;}
    T_2_1.array->store->data[T_2_2.num + T_2_1.array->int_low - T_2_1.array->ext_low] = indent.num;
    }
    }
        goto end_1;
        ex_1:
            __CLU_EX_HANDLER;
            if ((err == ERR_bounds)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_indent ****/


/**** BEGIN PROCEDURE get_max_depth ****/


errcode
pstreamOPget_max_depth(CLUREF ps, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(248);

  LINE(249);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[7];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_max_depth ****/


/**** BEGIN PROCEDURE set_max_depth ****/


errcode
pstreamOPset_max_depth(CLUREF ps, CLUREF depth)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(252);

  LINE(253);
    {
    ps.vec->data[7] = depth.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_max_depth ****/


/**** BEGIN PROCEDURE get_max_width ****/


errcode
pstreamOPget_max_width(CLUREF ps, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(256);

  LINE(257);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[8];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_max_width ****/


/**** BEGIN PROCEDURE set_max_width ****/


errcode
pstreamOPset_max_width(CLUREF ps, CLUREF width)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(260);

  LINE(261);
    {
    ps.vec->data[8] = width.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_max_width ****/


/**** BEGIN PROCEDURE get_flat ****/


errcode
pstreamOPget_flat(CLUREF ps, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(264);

  LINE(265);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[4];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_flat ****/


/**** BEGIN PROCEDURE set_flat ****/


errcode
pstreamOPset_flat(CLUREF ps, CLUREF flat)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(268);

  LINE(269);
    {
    ps.vec->data[4] = flat.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_flat ****/


/**** BEGIN PROCEDURE get_wrap ****/


errcode
pstreamOPget_wrap(CLUREF ps, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(272);

  LINE(273);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[11];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_wrap ****/


/**** BEGIN PROCEDURE set_wrap ****/


errcode
pstreamOPset_wrap(CLUREF ps, CLUREF wrap)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(276);

  LINE(277);
    {
    ps.vec->data[11] = wrap.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_wrap ****/


/**** BEGIN PROCEDURE get_line_length ****/


errcode
pstreamOPget_line_length(CLUREF ps, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(280);

  LINE(281);
    {
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = ps.vec->data[10];
    err = streamOPget_line_length(T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    ret_1->num = T_2_2.num;
    }
    {signal (ERR_ok);}}
    goto end_1;
    ex_1:
        __CLU_EX_HANDLER;
        if (err == ERR_no_limit) {signal(ERR_no_limit);}
        else {
            goto ex_0;}
    end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_line_length ****/


/**** BEGIN PROCEDURE get_page_length ****/


errcode
pstreamOPget_page_length(CLUREF ps, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(285);

  LINE(286);
    {
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = ps.vec->data[10];
    err = streamOPget_page_length(T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    ret_1->num = T_2_2.num;
    }
    {signal (ERR_ok);}}
    goto end_1;
    ex_1:
        __CLU_EX_HANDLER;
        if (err == ERR_no_limit) {signal(ERR_no_limit);}
        else {
            goto ex_0;}
    end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_page_length ****/


/**** BEGIN PROCEDURE equal ****/


errcode
pstreamOPequal(CLUREF x, CLUREF y, CLUREF *ret_1)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(290);

  LINE(291);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = (x.num == y.num)? true : false;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE equal ****/


/**** BEGIN PROCEDURE reset ****/


errcode
pstreamOPreset(CLUREF ps)
{
    errcode err;
    if (pstream_own_init == 0) {
        err = pstream_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(294);

  LINE(295);
    {
    ps.vec->data[5] = 0;
    }

  LINE(296);
    {
    ps.vec->data[9] = 0;
    }

  LINE(297);
    {
    ps.vec->data[0] = false;
    }

  LINE(298);
    {
    ps.vec->data[3] = 0;
    }

  LINE(299);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[1];
    err = arrayOPtrim(T_1_1, CLU_1, CLU_0);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(300);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[2];
    err = arrayOPtrim(T_1_1, CLU_1, CLU_0);
    if (err != ERR_ok) goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE reset ****/


/**** BEGIN PROCEDURE print ****/

static int pstreamOPprint_own_init = 0;

errcode
pstreamOPprint(CLUREF ps1, CLUREF ps2)
{
    errcode err;
    if (pstreamOPprint_own_init == 0) {
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        pstreamOPprint_own_init = 1;
    }
    enter_proc(303);

  LINE(304);
    {
    CLUREF T_1_1;
    err = pstreamOPtext(ps2, STR_pstream_133, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(305);
    {
    CLUREF T_1_1;
    T_1_1.num = ps1.vec->data[7];
    err = intOPprint(T_1_1, ps2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(306);
    {
    CLUREF T_1_1;
    err = pstreamOPtext(ps2, STR_d_040, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(307);
    {
    CLUREF T_1_1;
    T_1_1.num = ps1.vec->data[8];
    err = intOPprint(T_1_1, ps2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(308);
    {
    CLUREF T_1_1;
    T_1_1.num = ps1.vec->data[4];
    if (T_1_1.num == true) {

  LINE(309);
        {
        CLUREF T_2_1;
        err = pstreamOPtext(ps2, STR_w_040f_040, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(310);
        {
        CLUREF T_2_1;
        err = pstreamOPtext(ps2, STR_w_040i_040, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(312);
    {
    CLUREF T_1_1;
    T_1_1.num = ps1.vec->data[11];
    if (T_1_1.num == true) {

  LINE(313);
        {
        CLUREF T_2_1;
        err = pstreamOPtext(ps2, STR_m_040, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(314);
        {
        CLUREF T_2_1;
        err = pstreamOPtext(ps2, STR_s_040, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(316);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = ps1.vec->data[10];
    err = streamOPget_name(T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    err = file_nameOPprint(T_2_2, ps2);
    if (err != ERR_ok) goto ex_1;
    }
        goto end_1;
        ex_1:
            __CLU_EX_HANDLER;
            if ((err == ERR_not_possible)) {

  LINE(317);
                {
                CLUREF T_2_1;
                err = pstreamOPtext(ps2, STR__050internal_051, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(318);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = ']';
    err = pstreamOPtextc(ps2, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE print ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[27];
} pstream_OPS;

static CLU_proc pstream_oe_create = { .proc = pstreamOPcreate };
static CLU_proc pstream_oe_equal = { .proc = pstreamOPequal };
static CLU_proc pstream_oe_get_depth = { .proc = pstreamOPget_depth };
static CLU_proc pstream_oe_get_flat = { .proc = pstreamOPget_flat };
static CLU_proc pstream_oe_get_hpos = { .proc = pstreamOPget_hpos };
static CLU_proc pstream_oe_get_indent = { .proc = pstreamOPget_indent };
static CLU_proc pstream_oe_get_line_length = { .proc = pstreamOPget_line_length };
static CLU_proc pstream_oe_get_max_depth = { .proc = pstreamOPget_max_depth };
static CLU_proc pstream_oe_get_max_width = { .proc = pstreamOPget_max_width };
static CLU_proc pstream_oe_get_page_length = { .proc = pstreamOPget_page_length };
static CLU_proc pstream_oe_get_wrap = { .proc = pstreamOPget_wrap };
static CLU_proc pstream_oe_pause = { .proc = pstreamOPpause };
static CLU_proc pstream_oe_primary_output = { .proc = pstreamOPprimary_output };
static CLU_proc pstream_oe_print = { .proc = pstreamOPprint };
static CLU_proc pstream_oe_putleft = { .proc = pstreamOPputleft };
static CLU_proc pstream_oe_putright = { .proc = pstreamOPputright };
static CLU_proc pstream_oe_putspace = { .proc = pstreamOPputspace };
static CLU_proc pstream_oe_reset = { .proc = pstreamOPreset };
static CLU_proc pstream_oe_set_flat = { .proc = pstreamOPset_flat };
static CLU_proc pstream_oe_set_indent = { .proc = pstreamOPset_indent };
static CLU_proc pstream_oe_set_max_depth = { .proc = pstreamOPset_max_depth };
static CLU_proc pstream_oe_set_max_width = { .proc = pstreamOPset_max_width };
static CLU_proc pstream_oe_set_wrap = { .proc = pstreamOPset_wrap };
static CLU_proc pstream_oe_start = { .proc = pstreamOPstart };
static CLU_proc pstream_oe_stop = { .proc = pstreamOPstop };
static CLU_proc pstream_oe_text = { .proc = pstreamOPtext };
static CLU_proc pstream_oe_textc = { .proc = pstreamOPtextc };

static pstream_OPS pstream_ops_actual = {27, (OWNPTR)&pstream_own_init, (OWNPTR)&pstream_own_init, {
    {&pstream_oe_create, "create"},
    {&pstream_oe_equal, "equal"},
    {&pstream_oe_get_depth, "get_depth"},
    {&pstream_oe_get_flat, "get_flat"},
    {&pstream_oe_get_hpos, "get_hpos"},
    {&pstream_oe_get_indent, "get_indent"},
    {&pstream_oe_get_line_length, "get_line_length"},
    {&pstream_oe_get_max_depth, "get_max_depth"},
    {&pstream_oe_get_max_width, "get_max_width"},
    {&pstream_oe_get_page_length, "get_page_length"},
    {&pstream_oe_get_wrap, "get_wrap"},
    {&pstream_oe_pause, "pause"},
    {&pstream_oe_primary_output, "primary_output"},
    {&pstream_oe_print, "print"},
    {&pstream_oe_putleft, "putleft"},
    {&pstream_oe_putright, "putright"},
    {&pstream_oe_putspace, "putspace"},
    {&pstream_oe_reset, "reset"},
    {&pstream_oe_set_flat, "set_flat"},
    {&pstream_oe_set_indent, "set_indent"},
    {&pstream_oe_set_max_depth, "set_max_depth"},
    {&pstream_oe_set_max_width, "set_max_width"},
    {&pstream_oe_set_wrap, "set_wrap"},
    {&pstream_oe_start, "start"},
    {&pstream_oe_stop, "stop"},
    {&pstream_oe_text, "text"},
    {&pstream_oe_textc, "textc"}}};

struct OPS *pstream_ops = (struct OPS *)&pstream_ops_actual;

/**** END CLUSTER pstream ****/
