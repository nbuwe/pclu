
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER pstream ****/

extern errcode pstreamOPcreate();
extern errcode streamOPprimary_output();
extern errcode boolOPnot();
extern errcode streamOPcan_write();
extern errcode arrayOPnew();
extern errcode recordOPset_7();
extern errcode streamOPget_line_length();
extern errcode recordOPset_12();
extern errcode recordOPget_4();
extern errcode recordOPget_6();
extern errcode intOPadd();
extern errcode recordOPset_4();
extern errcode recordOPget_1();
extern errcode pstreamOPputs();
extern errcode arrayOPaddh();
extern errcode recordOPget_3();
extern errcode recordOPget_2();
extern errcode intOPgt();
extern errcode recordOPget_8();
extern errcode recordOPset_1();
extern errcode intOPsub();
extern errcode intOPge();
extern errcode arrayOPsize();
extern errcode arrayOPremh();
extern errcode intOPequal();
extern errcode streamOPputc();
extern errcode recordOPget_11();
extern errcode recordOPset_6();
extern errcode recordOPset_10();
extern errcode recordOPget_5();
extern errcode pstreamOPputsp();
extern errcode arrayOPtop();
extern errcode arrayOPstore();
extern errcode recordOPget_9();
extern errcode charOPequal();
extern errcode recordOPget_12();
extern errcode intOPlt();
extern errcode recordOPget_10();
extern errcode recordOPget_7();
extern errcode stringOPsize();
extern errcode pstreamOPtext();
extern errcode pstreamOPputspace();
extern errcode stringOPindexc();
extern errcode intOPle();
extern errcode streamOPputs();
extern errcode stringOPchars();
extern errcode streamOPputspace();
extern errcode recordOPset_8();
extern errcode recordOPset_9();
extern errcode recordOPset_5();
extern errcode streamOPget_page_length();
extern errcode recordOPequal();
extern errcode arrayOPtrim();
extern errcode intOPprint();
extern errcode file_nameOPprint();
extern errcode streamOPget_name();
extern errcode pstreamOPtextc();
extern errcode pstream_IB_1();
CLUREF STR__056_056_056;
CLUREF STR__040;
CLUREF STR_pstream_133;
CLUREF STR_d_040;
CLUREF STR_w_040f_040;
CLUREF STR_w_040i_040;
CLUREF STR_m_040;
CLUREF STR_s_040;
CLUREF STR__050internal_051;
static int pstream_own_init = 0;
OWN_req pstream_ownreqs = {0,0};
errcode pstream_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (pstream_own_init == 0) {
        stringOPcons("...", CLU_1, CLU_3, &STR__056_056_056);
        stringOPcons(" ", CLU_1, CLU_1, &STR__040);
        stringOPcons("pstream[", CLU_1, CLU_8, &STR_pstream_133);
        stringOPcons("d ", CLU_1, CLU_2, &STR_d_040);
        stringOPcons("w f ", CLU_1, CLU_4, &STR_w_040f_040);
        stringOPcons("w i ", CLU_1, CLU_4, &STR_w_040i_040);
        stringOPcons("m ", CLU_1, CLU_2, &STR_m_040);
        stringOPcons("s ", CLU_1, CLU_2, &STR_s_040);
        stringOPcons("(internal)", CLU_1, CLU_10, &STR__050internal_051);
        pstream_own_init = 1;
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }

static int pstreamOPprimary_output_own_init = 0;
CLUREF pstreamOPprimary_outputOPpo;

/**** BEGIN PROCEDURE primary_output ****/

errcode pstreamOPprimary_output(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstreamOPprimary_output_own_init == 0) {
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        pstreamOPprimary_output_own_init = 1;
        {
            {CLUREF T_0_1;
            CLUREF T_0_2;
            err = streamOPprimary_output(&T_0_1);
            if (err != ERR_ok) goto ex_0;
            err = pstreamOPcreate(T_0_1, CLU_4, CLU_4, &T_0_2);
            if (err != ERR_ok) goto ex_0;
            pstreamOPprimary_outputOPpo.num = T_0_2.num;
            }
            }
    }
    enter_proc(30);

  LINE(32);
    {
    {
    ret_1->num = pstreamOPprimary_outputOPpo.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE primary_output ****/


/**** BEGIN PROCEDURE create ****/

errcode pstreamOPcreate(st, max_depth, max_width, ret_1)
CLUREF st;
CLUREF max_depth;
CLUREF max_width;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ps;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(35);

  LINE(37);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = streamOPcan_write(st, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(38);
        {
        {signal (ERR_illegal_stream);}}
        }
        }/* end if */

  LINE(39);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        RecordAlloc(12, T_1_1);
        T_1_1.vec->data[10]  = st.num;
        T_1_1.vec->data[4]  = false;
        T_1_1.vec->data[11]  = true;
        T_1_1.vec->data[0]  = false;
        T_1_1.vec->data[7]  = max_depth.num;
        T_1_1.vec->data[8]  = max_width.num;
        T_1_1.vec->data[3]  = 0;
        T_1_1.vec->data[5]  = 0;
        T_1_1.vec->data[9]  = 0;
        T_1_1.vec->data[6]  = 1073741823;
        err = arrayOPnew(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[2]  = T_1_2.num;
        err = arrayOPnew(&T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1]  = T_1_3.num;
        ps.num = T_1_1.num;
        }
        }

  LINE(51);
    {
    CLUREF T_2_1;
    err = streamOPget_line_length(st, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    ps.vec->data[6]  = T_2_1.num;
    }
        goto end_1;
        ex_1:
            if ((err == ERR_no_limit)) {

  LINE(52);
                {
                ps.vec->data[11]  = false;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(53);
    {
    {
    ret_1->num = ps.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE create ****/


/**** BEGIN PROCEDURE get_depth ****/

errcode pstreamOPget_depth(x, ret_1)
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(56);

  LINE(57);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = x.vec->data[3];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_depth ****/


/**** BEGIN PROCEDURE get_hpos ****/

errcode pstreamOPget_hpos(x, ret_1)
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(60);

  LINE(61);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = x.vec->data[5];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_hpos ****/

static int pstreamOPstart_own_init = 0;

/**** BEGIN PROCEDURE start ****/

errcode pstreamOPstart(ps, s, ret_1)
CLUREF ps;
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF depth;
        if (pstreamOPstart_own_init == 0) {
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        pstreamOPstart_own_init = 1;
    }
    enter_proc(72);

  LINE(73);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = ps.vec->data[3];
        T_1_2.num = T_1_1.num + 1;
         if ((T_1_2.num > 0 && T_1_1.num < 0 && 1 < 0) || 
             (T_1_2.num < 0 && T_1_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        depth.num = T_1_2.num;
        }
        }

  LINE(74);
    {
    ps.vec->data[3]  = depth.num;
    }

  LINE(75);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[0];
    if (T_1_1.num == true) {

  LINE(76);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(77);
    {
    err = pstreamOPputs(ps, s);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(78);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[2];
    {
    if ((T_1_1.array->int_low + T_1_1.array->ext_size + 1) < T_1_1.array->int_size) {
        T_1_1.array->store->data[T_1_1.array->int_low + T_1_1.array->ext_size] = 0;
        T_1_1.array->ext_size++; T_1_1.array->ext_high++;}
    else {
        err = arrayOPaddh(T_1_1, CLU_0);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(79);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[1];
    T_1_2.num = ps.vec->data[5];
    {
    if ((T_1_1.array->int_low + T_1_1.array->ext_size + 1) < T_1_1.array->int_size) {
        T_1_1.array->store->data[T_1_1.array->int_low + T_1_1.array->ext_size] = T_1_2.num;
        T_1_1.array->ext_size++; T_1_1.array->ext_high++;}
    else {
        err = arrayOPaddh(T_1_1, T_1_2);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(80);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[7];
    T_1_2.num = (depth.num > T_1_1.num)? true : false;
    if (T_1_2.num == true) {

  LINE(81);
        {
        err = pstreamOPputs(ps, STR__056_056_056);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(82);
        {
        ps.vec->data[0]  = true;
        }

  LINE(83);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(85);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE start ****/


/**** BEGIN PROCEDURE stop ****/

errcode pstreamOPstop(ps, s, ret_1)
CLUREF ps;
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF depth;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(88);

  LINE(89);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = ps.vec->data[3];
        T_1_2.num = T_1_1.num - 1;
         if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-1) < 0) || 
             (T_1_2.num <= 0 && T_1_1.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        depth.num = T_1_2.num;
        }
        }

  LINE(90);
    {
    ps.vec->data[3]  = depth.num;
    }

  LINE(91);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = ps.vec->data[1];
    T_1_2.num = T_1_1.array->ext_size;
    T_1_3.num = (depth.num >= T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(92);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(93);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[1];
    err = arrayOPremh(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(94);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[2];
    err = arrayOPremh(T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(95);
    {
    ps.vec->data[0]  = false;
    }

  LINE(96);
    {
    err = pstreamOPputs(ps, s);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(97);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE stop ****/

static int pstreamOPpause_own_init = 0;

/**** BEGIN PROCEDURE pause ****/

errcode pstreamOPpause(ps, s, ret_1)
CLUREF ps;
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF depth;
    CLUREF width;
        if (pstreamOPpause_own_init == 0) {
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        pstreamOPpause_own_init = 1;
    }
    enter_proc(100);

  LINE(101);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[0];
    if (T_1_1.num == true) {

  LINE(102);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(103);
    {
        {CLUREF T_1_1;
        T_1_1.num = ps.vec->data[3];
        depth.num = T_1_1.num;
        }
        }

  LINE(104);
    {
    err = pstreamOPputs(ps, s);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(105);
    {
    CLUREF T_1_1;
    T_1_1.num = (depth.num == 0)? true : false;
    if (T_1_1.num == true) {

  LINE(106);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = ps.vec->data[10];
        T_2_2.ch = '\n';
        err = streamOPputc(T_2_1, T_2_2);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(107);
        {
        ps.vec->data[5]  = 0;
        }

  LINE(108);
        {
        ps.vec->data[9]  = 0;
        }

  LINE(109);
        {
        {
        ret_1->tf = true;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(111);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[4];
    if (T_1_1.num == true) {

  LINE(112);
        {
        err = pstreamOPputs(ps, STR__040);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(113);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = ps.vec->data[10];
        T_2_2.ch = '\n';
        err = streamOPputc(T_2_1, T_2_2);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(114);
        {
        ps.vec->data[5]  = 0;
        }

  LINE(115);
        {
        ps.vec->data[9]  = 0;
        }

  LINE(116);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = ps.vec->data[1];
        err = arrayOPtop(T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        err = pstreamOPputsp(ps, T_2_2);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(118);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = ps.vec->data[2];
        err = arrayOPtop(T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = T_1_2.num + 1;
         if ((T_1_3.num > 0 && T_1_2.num < 0 && 1 < 0) || 
             (T_1_3.num < 0 && T_1_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        width.num = T_1_3.num;
        }
        }

  LINE(119);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[2];
    {
    if (depth.num < T_1_1.array->ext_low || depth.num > T_1_1.array->ext_high) {
        err = ERR_bounds;
        goto ex_0;}
    T_1_1.array->store->data[depth.num + T_1_1.array->int_low - T_1_1.array->ext_low] = width.num;
    }
    }

  LINE(120);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[8];
    T_1_2.num = (width.num >= T_1_1.num)? true : false;
    if (T_1_2.num == true) {

  LINE(121);
        {
        err = pstreamOPputs(ps, STR__056_056_056);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(122);
        {
        ps.vec->data[0]  = true;
        }

  LINE(123);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(125);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE pause ****/


/**** BEGIN PROCEDURE text ****/

errcode pstreamOPtext(ps, s, ret_1)
CLUREF ps;
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(128);

  LINE(129);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[0];
    if (T_1_1.num == true) {

  LINE(130);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(131);
    {
    err = pstreamOPputs(ps, s);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(132);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE text ****/


/**** BEGIN PROCEDURE textc ****/

errcode pstreamOPtextc(ps, c, ret_1)
CLUREF ps;
CLUREF c;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(135);

  LINE(136);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[0];
    if (T_1_1.num == true) {

  LINE(137);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(138);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = '\n';
    T_1_2.num = (c.ch == T_1_1.ch)? true : false;
    if (T_1_2.num == true) {

  LINE(139);
        {
        CLUREF T_2_1;
        T_2_1.num = ps.vec->data[10];
        err = streamOPputc(T_2_1, c);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(140);
        {
        ps.vec->data[5]  = 0;
        }

  LINE(141);
        {
        ps.vec->data[9]  = 0;
        }
        }
    else {

  LINE(142);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = ps.vec->data[5];
        T_2_2.num = T_2_1.num + 1;
         if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
             (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        ps.vec->data[5]  = T_2_2.num;
        }

  LINE(143);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_2.num = ps.vec->data[11];
        T_2_1.num = T_2_2.num;
        if (!T_2_2.num) {
            T_2_3.num = ps.vec->data[9];
            T_2_4.num = ps.vec->data[6];
            T_2_5.num = (T_2_3.num < T_2_4.num)? true : false;
            T_2_1.num = T_2_5.num;
        }
        if (T_2_1.num == true) {

  LINE(144);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = ps.vec->data[9];
            T_3_2.num = ps.vec->data[6];
            T_3_3.num = (T_3_1.num >= T_3_2.num)? true : false;
            if (T_3_3.num == true) {

  LINE(145);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = ps.vec->data[10];
                T_4_2.ch = '\n';
                err = streamOPputc(T_4_1, T_4_2);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(146);
                {
                ps.vec->data[9]  = 0;
                }
                }
                }/* end if */

  LINE(148);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = ps.vec->data[9];
            T_3_2.num = T_3_1.num + 1;
             if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) || 
                 (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            ps.vec->data[9]  = T_3_2.num;
            }

  LINE(149);
            {
            CLUREF T_3_1;
            T_3_1.num = ps.vec->data[10];
            err = streamOPputc(T_3_1, c);
            if (err != ERR_ok) goto ex_0;
            }
            }
            }/* end if */
        }}/* end if */

  LINE(152);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE textc ****/


/**** BEGIN PROCEDURE putleft ****/

errcode pstreamOPputleft(ps, s, size, ret_1)
CLUREF ps;
CLUREF s;
CLUREF size;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF diff;
    CLUREF b;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(155);

  LINE(157);
    {
    CLUREF T_1_1;
    T_1_1.num = (size.num < 0)? true : false;
    if (T_1_1.num == true) {

  LINE(158);
        {
        {signal (ERR_negative_field_width);}}
        }
        }/* end if */

  LINE(159);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = stringOPsize(s, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = size.num - T_1_1.num;
         if ((T_1_2.num >= 0 && size.num < 0 && (-T_1_1.num) < 0) || 
             (T_1_2.num <= 0 && size.num > 0 && (-T_1_1.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        diff.num = T_1_2.num;
        }
        }

  LINE(160);
    {
        {CLUREF T_1_1;
        err = pstreamOPtext(ps, s, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        b.num = T_1_1.num;
        }
        }

  LINE(161);
    {
    CLUREF T_1_1;
    T_1_1.num = (diff.num > 0)? true : false;
    if (T_1_1.num == true) {

  LINE(162);
        {
        CLUREF T_2_1;
        err = pstreamOPputspace(ps, diff, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(163);
    {
    {
    ret_1->num = b.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE putleft ****/


/**** BEGIN PROCEDURE putright ****/

errcode pstreamOPputright(ps, s, size, ret_1)
CLUREF ps;
CLUREF s;
CLUREF size;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF diff;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(166);

  LINE(168);
    {
    CLUREF T_1_1;
    T_1_1.num = (size.num < 0)? true : false;
    if (T_1_1.num == true) {

  LINE(169);
        {
        {signal (ERR_negative_field_width);}}
        }
        }/* end if */

  LINE(170);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = stringOPsize(s, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = size.num - T_1_1.num;
         if ((T_1_2.num >= 0 && size.num < 0 && (-T_1_1.num) < 0) || 
             (T_1_2.num <= 0 && size.num > 0 && (-T_1_1.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        diff.num = T_1_2.num;
        }
        }

  LINE(171);
    {
    CLUREF T_1_1;
    T_1_1.num = (diff.num > 0)? true : false;
    if (T_1_1.num == true) {

  LINE(172);
        {
        CLUREF T_2_1;
        err = pstreamOPputspace(ps, diff, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
        }/* end if */

  LINE(173);
    {
    {
    CLUREF T_1_1;
    err = pstreamOPtext(ps, s, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE putright ****/


/**** BEGIN PROCEDURE putspace ****/

errcode pstreamOPputspace(ps, len, ret_1)
CLUREF ps;
CLUREF len;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(176);

  LINE(178);
    {
    CLUREF T_1_1;
    T_1_1.num = (len.num < 0)? true : false;
    if (T_1_1.num == true) {

  LINE(179);
        {
        {signal (ERR_negative_field_width);}}
        }
        }/* end if */

  LINE(180);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[0];
    if (T_1_1.num == true) {

  LINE(181);
        {
        {
        ret_1->tf = false;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(182);
    {
    err = pstreamOPputsp(ps, len);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(183);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE putspace ****/

extern errcode pstreamOPputs_IB_1();

/**** BEGIN PROCEDURE puts ****/

errcode pstreamOPputs(ps, s)
CLUREF ps;
CLUREF s;
    {
    struct {
        errcode err;
        errcode ecode2;
        CLUREF len;
        CLUREF c;
        CLUREF ps;
        CLUREF s;
        } locals;
    locals.ps = ps;
    locals.s = s;
        if (pstream_own_init == 0) {
            locals.err = pstream_own_init_proc();
            if (locals.err != ERR_ok) goto ex_0;
            }
    enter_proc(186);

  LINE(187);
    {
        {CLUREF T_1_1;
        locals.err = stringOPsize(locals.s, &T_1_1);
        if (locals.err != ERR_ok) goto ex_0;
        locals.len.num = T_1_1.num;
        }
        }

  LINE(188);
    {
    CLUREF T_1_1;
    T_1_1.num = (locals.len.num == 0)? true : false;
    if (T_1_1.num == true) {

  LINE(189);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(190);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.ps.vec->data[5];
    T_1_2.num = T_1_1.num + locals.len.num;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && locals.len.num < 0) || 
         (T_1_2.num < 0 && T_1_1.num > 0 && locals.len.num > 0)) {
        locals.err = ERR_overflow;
        goto ex_0;}
    locals.ps.vec->data[5]  = T_1_2.num;
    }

  LINE(191);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    CLUREF T_1_8;
    CLUREF T_1_9;
    CLUREF T_1_10;
    T_1_3.num = locals.ps.vec->data[11];
    T_1_4.num = T_1_3.num ^ 1;
    T_1_2.num = T_1_4.num;
    if (T_1_4.num) {
        T_1_5.num = locals.ps.vec->data[9];
        T_1_6.num = locals.ps.vec->data[6];
        T_1_7.num = (T_1_5.num >= T_1_6.num)? true : false;
        T_1_2.num = T_1_7.num;
    }
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        T_1_8.ch = '\n';
        locals.err = stringOPindexc(T_1_8, locals.s, &T_1_9);
        if (locals.err != ERR_ok) goto ex_0;
        T_1_10.num = (T_1_9.num == 0)? true : false;
        T_1_1.num = T_1_10.num;
    }
    if (T_1_1.num == true) {

  LINE(194);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(195);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.ps.vec->data[9];
    T_1_2.num = T_1_1.num + locals.len.num;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && locals.len.num < 0) || 
         (T_1_2.num < 0 && T_1_1.num > 0 && locals.len.num > 0)) {
        locals.err = ERR_overflow;
        goto ex_0;}
    locals.ps.vec->data[9]  = T_1_2.num;
    }

  LINE(196);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    T_1_2.num = locals.ps.vec->data[9];
    T_1_3.num = locals.ps.vec->data[6];
    T_1_4.num = (T_1_2.num <= T_1_3.num)? true : false;
    T_1_1.num = T_1_4.num;
    if (T_1_4.num) {
        T_1_5.ch = '\n';
        locals.err = stringOPindexc(T_1_5, locals.s, &T_1_6);
        if (locals.err != ERR_ok) goto ex_0;
        T_1_7.num = (T_1_6.num == 0)? true : false;
        T_1_1.num = T_1_7.num;
    }
    if (T_1_1.num == true) {

  LINE(197);
        {
        CLUREF T_2_1;
        T_2_1.num = locals.ps.vec->data[10];
        locals.err = streamOPputs(T_2_1, locals.s);
        if (locals.err != ERR_ok) goto ex_0;
        }

  LINE(198);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(200);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.ps.vec->data[5];
    T_1_2.num = T_1_1.num - locals.len.num;
     if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-locals.len.num) < 0) || 
         (T_1_2.num <= 0 && T_1_1.num > 0 && (-locals.len.num) > 0)) {
        locals.err = ERR_overflow;
        goto ex_0;}
    locals.ps.vec->data[5]  = T_1_2.num;
    }

  LINE(201);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = locals.ps.vec->data[9];
    T_1_2.num = T_1_1.num - locals.len.num;
     if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-locals.len.num) < 0) || 
         (T_1_2.num <= 0 && T_1_1.num > 0 && (-locals.len.num) > 0)) {
        locals.err = ERR_overflow;
        goto ex_0;}
    locals.ps.vec->data[9]  = T_1_2.num;
    }

  LINE(202);
    {
        locals.err = stringOPchars(locals.s, pstreamOPputs_IB_1, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {
        signal(ERR_ok);}
        if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
        if (locals.err == ERR_break) locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
        if (locals.err != ERR_ok) goto ex_0;
        }
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE puts ****/


/**** BEGIN ITERATOR BODIES for puts ****/

errcode pstreamOPputs_IB_1(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    errcode err;
    errcode ecode2;
    CLUREF len;
    CLUREF c;
    CLUREF ps;
    CLUREF s;
    } *locals;
{
    locals->c.num = iv_1.num;
    enter_iter_body_proc(203);

  FB_LINE(203);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = '\n';
    T_1_2.num = (locals->c.ch == T_1_1.ch)? true : false;
    if (T_1_2.num == true) {

  FB_LINE(204);
        {
        CLUREF T_2_1;
        T_2_1.num = locals->ps.vec->data[10];
        locals->err = streamOPputc(T_2_1, locals->c);
        if (locals->err != ERR_ok) goto ex_0;
        }

  FB_LINE(205);
        {
        locals->ps.vec->data[5]  = 0;
        }

  FB_LINE(206);
        {
        locals->ps.vec->data[9]  = 0;
        }
        }
    else {

  FB_LINE(207);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_2.num = locals->ps.vec->data[11];
        T_2_1.num = T_2_2.num;
        if (T_2_2.num) {
            T_2_3.num = locals->ps.vec->data[9];
            T_2_4.num = locals->ps.vec->data[6];
            T_2_5.num = (T_2_3.num >= T_2_4.num)? true : false;
            T_2_1.num = T_2_5.num;
        }
        if (T_2_1.num == true) {

  FB_LINE(208);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = locals->ps.vec->data[10];
            T_3_2.ch = '\n';
            locals->err = streamOPputc(T_3_1, T_3_2);
            if (locals->err != ERR_ok) goto ex_0;
            }

  FB_LINE(209);
            {
            locals->ps.vec->data[9]  = 0;
            }
            }
            }/* end if */

  FB_LINE(211);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = locals->ps.vec->data[9];
        T_2_2.num = locals->ps.vec->data[6];
        T_2_3.num = (T_2_1.num < T_2_2.num)? true : false;
        if (T_2_3.num == true) {

  FB_LINE(212);
            {
            CLUREF T_3_1;
            T_3_1.num = locals->ps.vec->data[10];
            locals->err = streamOPputc(T_3_1, locals->c);
            if (locals->err != ERR_ok) goto ex_0;
            }

  FB_LINE(213);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = locals->ps.vec->data[9];
            T_3_2.num = T_3_1.num + 1;
             if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) || 
                 (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                locals->err = ERR_overflow;
                goto ex_0;}
            locals->ps.vec->data[9]  = T_3_2.num;
            }
            }
            }/* end if */

  FB_LINE(215);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = locals->ps.vec->data[5];
        T_2_2.num = T_2_1.num + 1;
         if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
             (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            locals->err = ERR_overflow;
            goto ex_0;}
        locals->ps.vec->data[5]  = T_2_2.num;
        }
        }}/* end if */
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end pstreamOPputs_IB_1 */

/**** END ITERATOR BODIES for puts ****/


/**** BEGIN PROCEDURE putsp ****/

errcode pstreamOPputsp(ps, len)
CLUREF ps;
CLUREF len;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(220);

  LINE(221);
    {
    CLUREF T_1_1;
    T_1_1.num = (len.num == 0)? true : false;
    if (T_1_1.num == true) {

  LINE(222);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(223);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[5];
    T_1_2.num = T_1_1.num + len.num;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && len.num < 0) || 
         (T_1_2.num < 0 && T_1_1.num > 0 && len.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    ps.vec->data[5]  = T_1_2.num;
    }

  LINE(224);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    T_1_2.num = ps.vec->data[11];
    T_1_3.num = T_1_2.num ^ 1;
    T_1_1.num = T_1_3.num;
    if (T_1_3.num) {
        T_1_4.num = ps.vec->data[9];
        T_1_5.num = ps.vec->data[6];
        T_1_6.num = (T_1_4.num >= T_1_5.num)? true : false;
        T_1_1.num = T_1_6.num;
    }
    if (T_1_1.num == true) {

  LINE(225);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(226);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[9];
    T_1_2.num = T_1_1.num + len.num;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && len.num < 0) || 
         (T_1_2.num < 0 && T_1_1.num > 0 && len.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    ps.vec->data[9]  = T_1_2.num;
    }

  LINE(227);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = ps.vec->data[9];
    T_1_2.num = ps.vec->data[6];
    T_1_3.num = (T_1_1.num <= T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(228);
        {
        CLUREF T_2_1;
        T_2_1.num = ps.vec->data[10];
        err = streamOPputspace(T_2_1, len);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(229);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(231);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = ps.vec->data[9];
        T_1_2.num = ps.vec->data[6];
        T_1_3.num = (T_1_1.num > T_1_2.num)? true : false;
        if (T_1_3.num != true) { break; }

  LINE(232);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = ps.vec->data[10];
        T_2_2.ch = '\n';
        err = streamOPputc(T_2_1, T_2_2);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(233);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = ps.vec->data[9];
        T_2_2.num = ps.vec->data[6];
        T_2_3.num = T_2_1.num - T_2_2.num;
         if ((T_2_3.num >= 0 && T_2_1.num < 0 && (-T_2_2.num) < 0) || 
             (T_2_3.num <= 0 && T_2_1.num > 0 && (-T_2_2.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        ps.vec->data[9]  = T_2_3.num;
        }
        }
        end_while_1:;

  LINE(235);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ps.vec->data[10];
    T_1_2.num = ps.vec->data[9];
    err = streamOPputspace(T_1_1, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE putsp ****/


/**** BEGIN PROCEDURE get_indent ****/

errcode pstreamOPget_indent(ps, ret_1)
CLUREF ps;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(238);

  LINE(239);
    {
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = ps.vec->data[1];
    err = arrayOPtop(T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    ret_1->num = T_2_2.num;
    }
    {signal (ERR_ok);}}
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {

  LINE(240);
                {
                {
                ret_1->num = 0;
                }
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_indent ****/


/**** BEGIN PROCEDURE set_indent ****/

errcode pstreamOPset_indent(ps, indent)
CLUREF ps;
CLUREF indent;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(243);

  LINE(244);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = ps.vec->data[1];
    T_2_2.num = ps.vec->data[3];
    {
    if (T_2_2.num < T_2_1.array->ext_low || T_2_2.num > T_2_1.array->ext_high) {
        err = ERR_bounds;
        goto ex_1;}
    T_2_1.array->store->data[T_2_2.num + T_2_1.array->int_low - T_2_1.array->ext_low] = indent.num;
    }
    }
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_indent ****/


/**** BEGIN PROCEDURE get_max_depth ****/

errcode pstreamOPget_max_depth(ps, ret_1)
CLUREF ps;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(248);

  LINE(249);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[7];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_max_depth ****/


/**** BEGIN PROCEDURE set_max_depth ****/

errcode pstreamOPset_max_depth(ps, depth)
CLUREF ps;
CLUREF depth;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(252);

  LINE(253);
    {
    ps.vec->data[7]  = depth.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_max_depth ****/


/**** BEGIN PROCEDURE get_max_width ****/

errcode pstreamOPget_max_width(ps, ret_1)
CLUREF ps;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(256);

  LINE(257);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[8];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_max_width ****/


/**** BEGIN PROCEDURE set_max_width ****/

errcode pstreamOPset_max_width(ps, width)
CLUREF ps;
CLUREF width;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(260);

  LINE(261);
    {
    ps.vec->data[8]  = width.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_max_width ****/


/**** BEGIN PROCEDURE get_flat ****/

errcode pstreamOPget_flat(ps, ret_1)
CLUREF ps;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(264);

  LINE(265);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[4];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_flat ****/


/**** BEGIN PROCEDURE set_flat ****/

errcode pstreamOPset_flat(ps, flat)
CLUREF ps;
CLUREF flat;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(268);

  LINE(269);
    {
    ps.vec->data[4]  = flat.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_flat ****/


/**** BEGIN PROCEDURE get_wrap ****/

errcode pstreamOPget_wrap(ps, ret_1)
CLUREF ps;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(272);

  LINE(273);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[11];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_wrap ****/


/**** BEGIN PROCEDURE set_wrap ****/

errcode pstreamOPset_wrap(ps, wrap)
CLUREF ps;
CLUREF wrap;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(276);

  LINE(277);
    {
    ps.vec->data[11]  = wrap.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_wrap ****/


/**** BEGIN PROCEDURE get_line_length ****/

errcode pstreamOPget_line_length(ps, ret_1)
CLUREF ps;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(280);

  LINE(281);
    {
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = ps.vec->data[10];
    err = streamOPget_line_length(T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    ret_1->num = T_2_2.num;
    }
    {signal (ERR_ok);}}
    goto end_1;
    ex_1:
        if (err == ERR_no_limit) {signal(ERR_no_limit);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_line_length ****/


/**** BEGIN PROCEDURE get_page_length ****/

errcode pstreamOPget_page_length(ps, ret_1)
CLUREF ps;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(285);

  LINE(286);
    {
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = ps.vec->data[10];
    err = streamOPget_page_length(T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    ret_1->num = T_2_2.num;
    }
    {signal (ERR_ok);}}
    goto end_1;
    ex_1:
        if (err == ERR_no_limit) {signal(ERR_no_limit);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_page_length ****/


/**** BEGIN PROCEDURE equal ****/

errcode pstreamOPequal(x, y, ret_1)
CLUREF x;
CLUREF y;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(290);

  LINE(291);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = (x.num == y.num)? true : false;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE equal ****/


/**** BEGIN PROCEDURE reset ****/

errcode pstreamOPreset(ps)
CLUREF ps;
    {
    errcode err;
    errcode ecode2;
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(294);

  LINE(295);
    {
    ps.vec->data[5]  = 0;
    }

  LINE(296);
    {
    ps.vec->data[9]  = 0;
    }

  LINE(297);
    {
    ps.vec->data[0]  = false;
    }

  LINE(298);
    {
    ps.vec->data[3]  = 0;
    }

  LINE(299);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[1];
    err = arrayOPtrim(T_1_1, CLU_1, CLU_0);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(300);
    {
    CLUREF T_1_1;
    T_1_1.num = ps.vec->data[2];
    err = arrayOPtrim(T_1_1, CLU_1, CLU_0);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE reset ****/

static int pstreamOPprint_own_init = 0;

/**** BEGIN PROCEDURE print ****/

errcode pstreamOPprint(ps1, ps2)
CLUREF ps1;
CLUREF ps2;
    {
    errcode err;
    errcode ecode2;
        if (pstreamOPprint_own_init == 0) {
        if (pstream_own_init == 0) {
            err = pstream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        pstreamOPprint_own_init = 1;
    }
    enter_proc(303);

  LINE(304);
    {
    CLUREF T_1_1;
    err = pstreamOPtext(ps2, STR_pstream_133, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(305);
    {
    CLUREF T_1_1;
    T_1_1.num = ps1.vec->data[7];
    err = intOPprint(T_1_1, ps2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(306);
    {
    CLUREF T_1_1;
    err = pstreamOPtext(ps2, STR_d_040, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(307);
    {
    CLUREF T_1_1;
    T_1_1.num = ps1.vec->data[8];
    err = intOPprint(T_1_1, ps2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(308);
    {
    CLUREF T_1_1;
    T_1_1.num = ps1.vec->data[4];
    if (T_1_1.num == true) {

  LINE(309);
        {
        CLUREF T_2_1;
        err = pstreamOPtext(ps2, STR_w_040f_040, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(310);
        {
        CLUREF T_2_1;
        err = pstreamOPtext(ps2, STR_w_040i_040, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(312);
    {
    CLUREF T_1_1;
    T_1_1.num = ps1.vec->data[11];
    if (T_1_1.num == true) {

  LINE(313);
        {
        CLUREF T_2_1;
        err = pstreamOPtext(ps2, STR_m_040, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(314);
        {
        CLUREF T_2_1;
        err = pstreamOPtext(ps2, STR_s_040, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(316);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = ps1.vec->data[10];
    err = streamOPget_name(T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    err = file_nameOPprint(T_2_2, ps2);
    if (err != ERR_ok) goto ex_1;
    }
        goto end_1;
        ex_1:
            if ((err == ERR_not_possible)) {

  LINE(317);
                {
                CLUREF T_2_1;
                err = pstreamOPtext(ps2, STR__050internal_051, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(318);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.ch = ']';
    err = pstreamOPtextc(ps2, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE print ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[27];
} pstream_OPS;

CLU_proc pstream_oe_create = {{0,0,0,0}, pstreamOPcreate, 0};
CLU_proc pstream_oe_equal = {{0,0,0,0}, pstreamOPequal, 0};
CLU_proc pstream_oe_get_depth = {{0,0,0,0}, pstreamOPget_depth, 0};
CLU_proc pstream_oe_get_flat = {{0,0,0,0}, pstreamOPget_flat, 0};
CLU_proc pstream_oe_get_hpos = {{0,0,0,0}, pstreamOPget_hpos, 0};
CLU_proc pstream_oe_get_indent = {{0,0,0,0}, pstreamOPget_indent, 0};
CLU_proc pstream_oe_get_line_length = {{0,0,0,0}, pstreamOPget_line_length, 0};
CLU_proc pstream_oe_get_max_depth = {{0,0,0,0}, pstreamOPget_max_depth, 0};
CLU_proc pstream_oe_get_max_width = {{0,0,0,0}, pstreamOPget_max_width, 0};
CLU_proc pstream_oe_get_page_length = {{0,0,0,0}, pstreamOPget_page_length, 0};
CLU_proc pstream_oe_get_wrap = {{0,0,0,0}, pstreamOPget_wrap, 0};
CLU_proc pstream_oe_pause = {{0,0,0,0}, pstreamOPpause, 0};
CLU_proc pstream_oe_primary_output = {{0,0,0,0}, pstreamOPprimary_output, 0};
CLU_proc pstream_oe_print = {{0,0,0,0}, pstreamOPprint, 0};
CLU_proc pstream_oe_putleft = {{0,0,0,0}, pstreamOPputleft, 0};
CLU_proc pstream_oe_putright = {{0,0,0,0}, pstreamOPputright, 0};
CLU_proc pstream_oe_putspace = {{0,0,0,0}, pstreamOPputspace, 0};
CLU_proc pstream_oe_reset = {{0,0,0,0}, pstreamOPreset, 0};
CLU_proc pstream_oe_set_flat = {{0,0,0,0}, pstreamOPset_flat, 0};
CLU_proc pstream_oe_set_indent = {{0,0,0,0}, pstreamOPset_indent, 0};
CLU_proc pstream_oe_set_max_depth = {{0,0,0,0}, pstreamOPset_max_depth, 0};
CLU_proc pstream_oe_set_max_width = {{0,0,0,0}, pstreamOPset_max_width, 0};
CLU_proc pstream_oe_set_wrap = {{0,0,0,0}, pstreamOPset_wrap, 0};
CLU_proc pstream_oe_start = {{0,0,0,0}, pstreamOPstart, 0};
CLU_proc pstream_oe_stop = {{0,0,0,0}, pstreamOPstop, 0};
CLU_proc pstream_oe_text = {{0,0,0,0}, pstreamOPtext, 0};
CLU_proc pstream_oe_textc = {{0,0,0,0}, pstreamOPtextc, 0};

pstream_OPS pstream_ops_actual = {27, (OWNPTR)&pstream_own_init, (OWNPTR)&pstream_own_init, {
    {&pstream_oe_create, "create"},
    {&pstream_oe_equal, "equal"},
    {&pstream_oe_get_depth, "get_depth"},
    {&pstream_oe_get_flat, "get_flat"},
    {&pstream_oe_get_hpos, "get_hpos"},
    {&pstream_oe_get_indent, "get_indent"},
    {&pstream_oe_get_line_length, "get_line_length"},
    {&pstream_oe_get_max_depth, "get_max_depth"},
    {&pstream_oe_get_max_width, "get_max_width"},
    {&pstream_oe_get_page_length, "get_page_length"},
    {&pstream_oe_get_wrap, "get_wrap"},
    {&pstream_oe_pause, "pause"},
    {&pstream_oe_primary_output, "primary_output"},
    {&pstream_oe_print, "print"},
    {&pstream_oe_putleft, "putleft"},
    {&pstream_oe_putright, "putright"},
    {&pstream_oe_putspace, "putspace"},
    {&pstream_oe_reset, "reset"},
    {&pstream_oe_set_flat, "set_flat"},
    {&pstream_oe_set_indent, "set_indent"},
    {&pstream_oe_set_max_depth, "set_max_depth"},
    {&pstream_oe_set_max_width, "set_max_width"},
    {&pstream_oe_set_wrap, "set_wrap"},
    {&pstream_oe_start, "start"},
    {&pstream_oe_stop, "stop"},
    {&pstream_oe_text, "text"},
    {&pstream_oe_textc, "textc"}}};

struct OPS *pstream_ops = (struct OPS *)&pstream_ops_actual;

/**** END CLUSTER pstream ****/
