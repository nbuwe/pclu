
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


extern errcode _case();

/**** BEGIN PROCEDURE lower_case ****/

errcode lower_case(s, ret_1)
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    enter_proc(4);

  LINE(5);
    {
    {
    CLUREF T_1_1;
    err = _case(s, CLU_0, CLU_0, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE lower_case ****/



/**** BEGIN PROCEDURE upper_case ****/

errcode upper_case(s, ret_1)
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    enter_proc(8);

  LINE(9);
    {
    {
    CLUREF T_1_1;
    err = _case(s, CLU_1, CLU_1, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE upper_case ****/



/**** BEGIN PROCEDURE capitalize ****/

errcode capitalize(s, ret_1)
CLUREF s;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    enter_proc(12);

  LINE(13);
    {
    {
    CLUREF T_1_1;
    err = _case(s, CLU_1, CLU_0, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE capitalize ****/


extern errcode arrayOPnew();
extern errcode stringOPchars();
extern errcode charOPge();
extern errcode charOPle();
extern errcode boolOPnot();
extern errcode intOPadd();
extern errcode intOPge();
extern errcode charOPi2c();
extern errcode intOPsub();
extern errcode charOPc2i();
extern errcode arrayOPaddh();
extern errcode stringOPac2s();
extern errcode arrayOPtrim();
extern errcode _case_IB_1();
extern errcode _case_IB_2();
static int _case_own_init = 0;
CLUREF _caseOPbuf;

/**** BEGIN PROCEDURE _case ****/

errcode _case(s, first, rest, ret_1)
CLUREF s;
CLUREF first;
CLUREF rest;
CLUREF *ret_1;
    {
    struct {
        errcode err;
        errcode ecode2;
        CLUREF pos;
        CLUREF upper;
        CLUREF c;
        CLUREF npos;
        CLUREF s;
        CLUREF first;
        CLUREF rest;
        } locals;
    locals.s = s;
    locals.first = first;
    locals.rest = rest;
        if (_case_own_init == 0) {
        _case_own_init = 1;
        {
            {CLUREF T_0_1;
            locals.err = arrayOPnew(&T_0_1);
            if (locals.err != ERR_ok) goto ex_0;
            _caseOPbuf.num = T_0_1.num;
            }
            }
    }
    enter_proc(16);

  LINE(19);
    {
        {locals.pos.num = 1;
        }
        }

  LINE(20);
    {
        {locals.upper.num = locals.first.num;
        }
        }

  LINE(21);
    {
        locals.err = stringOPchars(locals.s, _case_IB_1, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {
        ret_1->num = elist[0].num;
        signal(ERR_ok);}
        if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
        if (locals.err == ERR_break) locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
        if (locals.err != ERR_ok) goto ex_1;
        }
        goto end_1;
        ex_1:
            if ((locals.err == ERR_change)) {

  LINE(30);
                {
                    {locals.npos.num = 1;
                    }
                    }

  LINE(31);
                {
                locals.upper.num = locals.first.num;
                }

  LINE(32);
                {
                    locals.err = stringOPchars(locals.s, _case_IB_2, &locals, &locals.ecode2);
                    if (locals.err == ERR_iterbodyreturn) {
                    ret_1->num = elist[0].num;
                    signal(ERR_ok);}
                    if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
                    if (locals.err == ERR_break) locals.err = ERR_ok;
                    if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
                    if (locals.err != ERR_ok) goto ex_0;
                    }

  LINE(44);
                {
                CLUREF T_2_1;
                locals.err = stringOPac2s(_caseOPbuf, &T_2_1);
                if (locals.err != ERR_ok) goto ex_0;
                locals.s.num = T_2_1.num;
                }

  LINE(45);
                {
                locals.err = arrayOPtrim(_caseOPbuf, CLU_1, CLU_0);
                if (locals.err != ERR_ok) goto ex_0;
                }
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(47);
    {
    {
    ret_1->num = locals.s.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE _case ****/


/**** BEGIN ITERATOR BODIES for _case ****/

errcode _case_IB_1(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    errcode err;
    errcode ecode2;
    CLUREF pos;
    CLUREF upper;
    CLUREF c;
    CLUREF npos;
    CLUREF s;
    CLUREF first;
    CLUREF rest;
    } *locals;
{
    locals->c.num = iv_1.num;
    enter_iter_body_proc(22);

  FB_LINE(22);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    CLUREF T_1_8;
    CLUREF T_1_9;
    CLUREF T_1_10;
    CLUREF T_1_11;
    CLUREF T_1_12;
    CLUREF T_1_13;
    CLUREF T_1_14;
    T_1_3.num = locals->upper.num;
    if (locals->upper.num) {
        T_1_4.ch = 'a';
        locals->err = charOPge(locals->c, T_1_4, &T_1_5);
        if (locals->err != ERR_ok) goto ex_0;
        T_1_3.num = T_1_5.num;
    }
    T_1_2.num = T_1_3.num;
    if (T_1_3.num) {
        T_1_6.ch = 'z';
        locals->err = charOPle(locals->c, T_1_6, &T_1_7);
        if (locals->err != ERR_ok) goto ex_0;
        T_1_2.num = T_1_7.num;
    }
    T_1_1.num = T_1_2.num;
    if (!T_1_2.num) {
        T_1_10.num = locals->upper.num ^ 1;
        T_1_9.num = T_1_10.num;
        if (T_1_10.num) {
            T_1_11.ch = 'A';
            locals->err = charOPge(locals->c, T_1_11, &T_1_12);
            if (locals->err != ERR_ok) goto ex_0;
            T_1_9.num = T_1_12.num;
        }
        T_1_8.num = T_1_9.num;
        if (T_1_9.num) {
            T_1_13.ch = 'Z';
            locals->err = charOPle(locals->c, T_1_13, &T_1_14);
            if (locals->err != ERR_ok) goto ex_0;
            T_1_8.num = T_1_14.num;
        }
        T_1_1.num = T_1_8.num;
    }
    if (T_1_1.num == true) {

  FB_LINE(24);
        {
            locals->err = ERR_change;
            goto ex_0;
            }
        }
        }/* end if */

  FB_LINE(26);
    {
    CLUREF T_1_1;
    T_1_1.num = locals->pos.num + 1;
     if ((T_1_1.num > 0 && locals->pos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && locals->pos.num > 0 && 1 > 0)) {
        locals->err = ERR_overflow;
        goto ex_0;}
    locals->pos.num = T_1_1.num;
    }

  FB_LINE(27);
    {
    locals->upper.num = locals->rest.num;
    }
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end _case_IB_1 */
errcode _case_IB_2(iv_1, locals, iecode)
errcode *iecode;
CLUREF iv_1;
struct {
    errcode err;
    errcode ecode2;
    CLUREF pos;
    CLUREF upper;
    CLUREF c;
    CLUREF npos;
    CLUREF s;
    CLUREF first;
    CLUREF rest;
    } *locals;
{
    locals->c.num = iv_1.num;
    enter_iter_body_proc(33);

  FB_LINE(33);
    {
    CLUREF T_1_1;
    T_1_1.num = (locals->npos.num >= locals->pos.num)? true : false;
    if (T_1_1.num == true) {

  FB_LINE(34);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        CLUREF T_2_6;
        T_2_2.num = locals->upper.num;
        if (locals->upper.num) {
            T_2_3.ch = 'a';
            locals->err = charOPge(locals->c, T_2_3, &T_2_4);
            if (locals->err != ERR_ok) goto ex_0;
            T_2_2.num = T_2_4.num;
        }
        T_2_1.num = T_2_2.num;
        if (T_2_2.num) {
            T_2_5.ch = 'z';
            locals->err = charOPle(locals->c, T_2_5, &T_2_6);
            if (locals->err != ERR_ok) goto ex_0;
            T_2_1.num = T_2_6.num;
        }
        if (T_2_1.num == true) {

  FB_LINE(35);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = (long)(locals->c.ch & 0xff);
            T_3_2.num = T_3_1.num - 32;
             if ((T_3_2.num >= 0 && T_3_1.num < 0 && (-32) < 0) || 
                 (T_3_2.num <= 0 && T_3_1.num > 0 && (-32) > 0)) {
                locals->err = ERR_overflow;
                goto ex_0;}
            locals->err = charOPi2c(T_3_2, &T_3_3);
            if (locals->err != ERR_ok) goto ex_0;
            locals->c.num = T_3_3.num;
            }
            }
        else {
        CLUREF T_2_7;
        CLUREF T_2_8;
        CLUREF T_2_9;
        CLUREF T_2_10;
        CLUREF T_2_11;
        CLUREF T_2_12;
        CLUREF T_2_13;
        T_2_9.num = locals->upper.num ^ 1;
        T_2_8.num = T_2_9.num;
        if (T_2_9.num) {
            T_2_10.ch = 'A';
            locals->err = charOPge(locals->c, T_2_10, &T_2_11);
            if (locals->err != ERR_ok) goto ex_0;
            T_2_8.num = T_2_11.num;
        }
        T_2_7.num = T_2_8.num;
        if (T_2_8.num) {
            T_2_12.ch = 'Z';
            locals->err = charOPle(locals->c, T_2_12, &T_2_13);
            if (locals->err != ERR_ok) goto ex_0;
            T_2_7.num = T_2_13.num;
        }
        if (T_2_7.num == true) {

  FB_LINE(37);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = (long)(locals->c.ch & 0xff);
            T_3_2.num = T_3_1.num + 32;
             if ((T_3_2.num > 0 && T_3_1.num < 0 && 32 < 0) || 
                 (T_3_2.num < 0 && T_3_1.num > 0 && 32 > 0)) {
                locals->err = ERR_overflow;
                goto ex_0;}
            locals->err = charOPi2c(T_3_2, &T_3_3);
            if (locals->err != ERR_ok) goto ex_0;
            locals->c.num = T_3_3.num;
            }
            }
            }}/* end if */
        }
        }/* end if */

  FB_LINE(40);
    {
    {
    if ((_caseOPbuf.array->int_low + _caseOPbuf.array->ext_size + 1) < _caseOPbuf.array->int_size) {
        _caseOPbuf.array->store->data[_caseOPbuf.array->int_low + _caseOPbuf.array->ext_size] = locals->c.num;
        _caseOPbuf.array->ext_size++; _caseOPbuf.array->ext_high++;}
    else {
        locals->err = arrayOPaddh(_caseOPbuf, locals->c);
        if (locals->err != ERR_ok) goto ex_0;}
    }
    }

  FB_LINE(41);
    {
    CLUREF T_1_1;
    T_1_1.num = locals->npos.num + 1;
     if ((T_1_1.num > 0 && locals->npos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && locals->npos.num > 0 && 1 > 0)) {
        locals->err = ERR_overflow;
        goto ex_0;}
    locals->npos.num = T_1_1.num;
    }

  FB_LINE(42);
    {
    locals->upper.num = locals->rest.num;
    }
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end _case_IB_2 */

/**** END ITERATOR BODIES for _case ****/

