
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"



typedef struct {
long count;
} gc_copy_of_t_REQS;

gc_copy_of_t_REQS gc_copy_of_t_reqs_actual = {0};

struct REQS * gc_copy_of_t_reqs = (struct REQS *)&gc_copy_of_t_reqs_actual;


typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    } gc_copy_of_t_OPS;

extern errcode _eventOPdefer();
extern errcode _cvt();
extern errcode _gc_copy();
extern errcode tableOPcreate();
extern errcode hash_obj();
extern errcode _objOPequal();
extern errcode _gcOPcount();
extern errcode _eventOPundefer();
extern struct REQS *table_of_key_reqs;
extern struct OPS *_obj_ops;
extern struct REQS *table_of_val_reqs;
extern OWN_req table_ownreqs;
extern struct OPS *table_ops;
struct OPS *table_of__obj_table;
struct OPS *table_of__obj_table;
struct OPS *table_of__obj__obj_ops;
struct OPS *table_of__obj__obj_ops;
OWNPTR table_of__obj__obj_owns;

typedef struct {
    long gc_copy_own_init;
    gc_copy_of_t_OPS *t_ops;
    } gc_copy_OWN_DEFN;
OWN_req gc_copy_ownreqs = {sizeof(gc_copy_OWN_DEFN), 1};


/**** BEGIN PROCEDURE gc_copy ****/

errcode gc_copy(x, ret_1)
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    gc_copy_OWN_DEFN *op_own_ptr;
    op_own_ptr = (gc_copy_OWN_DEFN*) CUR_PROC_VAR.proc->op_owns;
        if (op_own_ptr->gc_copy_own_init == 0) {
        add_parm_info_type(0, _obj_ops, table_of_key_reqs);
        add_parm_info_type(1, _obj_ops, table_of_val_reqs);
        find_type_instance(table_ops, 2, &table_ownreqs, &(table_of__obj__obj_ops));
        }
        if (op_own_ptr->gc_copy_own_init == 0) {
        op_own_ptr->gc_copy_own_init = 1;
    }
    enter_proc(12);

  LINE(13);
    {
    err = _eventOPdefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(14);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    CLUREF T_1_8;
    CLUREF T_1_9;
    RecordAlloc(2, T_1_1);
    T_1_2.num = 500;
    err = proctypeOPnew(CLU_0, &T_1_3.proc);
    if (err!= ERR_ok) goto ex_0;
    T_1_3.proc->type_owns = 0;
    T_1_3.proc->op_owns = 0;
    T_1_3.proc->proc = hash_obj;
    err = proctypeOPnew(CLU_0, &T_1_4.proc);
    if (err!= ERR_ok) goto ex_0;
    T_1_4.proc->proc = _objOPequal;
    generic_CLU_proc.type_owns = table_of__obj__obj_ops->type_owns;
    generic_CLU_proc.proc = tableOPcreate;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPcreate(T_1_2, T_1_3, T_1_4, &T_1_5);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[1]  = T_1_5.num;
    err = _gcOPcount(&T_1_6);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[0]  = T_1_6.num;
    T_1_7.num = x.num;
    err = _gc_copy(T_1_1, T_1_7, &T_1_8);
    if (err != ERR_ok) goto ex_0;
    T_1_9.num = T_1_8.num;
    x.num = T_1_9.num;
    }

  LINE(19);
    {
    err = _eventOPundefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(20);
    {
    {
    ret_1->num = x.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE gc_copy ****/



typedef struct {
long count;
} gc_copy_to_of_t_REQS;

gc_copy_to_of_t_REQS gc_copy_to_of_t_reqs_actual = {0};

struct REQS * gc_copy_to_of_t_reqs = (struct REQS *)&gc_copy_to_of_t_reqs_actual;


typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    } gc_copy_to_of_t_OPS;

extern errcode arrayOPelements();
extern errcode tableOPalter();
struct OPS *table_of__obj_table;
struct OPS *table_of__obj_table;
struct OPS *table_of__obj__obj_ops;
struct OPS *table_of__obj__obj_ops;
OWNPTR table_of__obj__obj_owns;

typedef struct {
    long gc_copy_to_own_init;
    gc_copy_to_of_t_OPS *t_ops;
    } gc_copy_to_OWN_DEFN;
OWN_req gc_copy_to_ownreqs = {sizeof(gc_copy_to_OWN_DEFN), 1};


/**** BEGIN PROCEDURE gc_copy_to ****/

errcode gc_copy_to(x, leaves, ret_1)
CLUREF x;
CLUREF leaves;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    gc_copy_to_OWN_DEFN *op_own_ptr;
    CLUREF tb;
    CLUREF y;
    op_own_ptr = (gc_copy_to_OWN_DEFN*) CUR_PROC_VAR.proc->op_owns;
        if (op_own_ptr->gc_copy_to_own_init == 0) {
        add_parm_info_type(0, _obj_ops, table_of_key_reqs);
        add_parm_info_type(1, _obj_ops, table_of_val_reqs);
        find_type_instance(table_ops, 2, &table_ownreqs, &(table_of__obj__obj_ops));
        }
        if (op_own_ptr->gc_copy_to_own_init == 0) {
        op_own_ptr->gc_copy_to_own_init = 1;
    }
    enter_proc(23);

  LINE(24);
    {
    err = _eventOPdefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(25);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        T_1_1.num = 500;
        err = proctypeOPnew(CLU_0, &T_1_2.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_2.proc->type_owns = 0;
        T_1_2.proc->op_owns = 0;
        T_1_2.proc->proc = hash_obj;
        err = proctypeOPnew(CLU_0, &T_1_3.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_3.proc->proc = _objOPequal;
        generic_CLU_proc.type_owns = table_of__obj__obj_ops->type_owns;
        generic_CLU_proc.proc = tableOPcreate;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = tableOPcreate(T_1_1, T_1_2, T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        tb.num = T_1_4.num;
        }
        }

  LINE(26);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = leaves.array->ext_high; 
        T_1_3 = leaves;
        for (T_1_1.num = leaves.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            y.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(27);
            {
            generic_CLU_proc.type_owns = table_of__obj__obj_ops->type_owns;
            generic_CLU_proc.proc = tableOPalter;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = tableOPalter(tb, y, y);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;

  LINE(29);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[1]  = tb.num;
    err = _gcOPcount(&T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[0]  = T_1_2.num;
    T_1_3.num = x.num;
    err = _gc_copy(T_1_1, T_1_3, &T_1_4);
    if (err != ERR_ok) goto ex_0;
    T_1_5.num = T_1_4.num;
    x.num = T_1_5.num;
    }

  LINE(32);
    {
    err = _eventOPundefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(33);
    {
    {
    ret_1->num = x.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE gc_copy_to ****/


extern errcode boolOPnot();
extern errcode _objOPis_ref();
extern errcode intOPequal();
extern errcode recordOPget_1();
extern errcode recordOPset_1();
extern errcode tableOPrehash();
extern errcode recordOPget_2();
extern errcode tableOPlookup();
extern errcode _objOPis_vec();
extern errcode _vecOPcopy();
extern errcode intOPfrom_to_by();
extern errcode _vecOPsize();
extern errcode _vecOPstore();
extern errcode _vecOPfetch();
extern errcode _objOPis_bvec();
extern errcode _bytevecOPcopy();
extern errcode _objOPis_adv();
extern errcode arrayOPcopy1();
extern errcode arrayOPindexes();
extern errcode arrayOPstore();
extern errcode arrayOPfetch();
extern errcode _objOPis_cell();
extern errcode _objOPis_anyize();
extern errcode _tagcellOPcopy();
extern errcode _tagcellOPget();
extern errcode _tagcellOPset_value();
struct OPS *table_of__obj_table;
struct OPS *table_of__obj_table;
struct OPS *table_of__obj__obj_ops;
struct OPS *table_of__obj__obj_ops;
OWNPTR table_of__obj__obj_owns;
extern struct REQS *_tagcell_of_t_reqs;
extern OWN_req _tagcell_ownreqs;
extern struct OPS *_tagcell_ops;
struct OPS *_tagcell_of__obj_table;
struct OPS *_tagcell_of__obj_ops;
struct OPS *_tagcell_of__obj_ops;
OWNPTR _tagcell_of__obj_owns;
static int _gc_copy_own_init = 0;

/**** BEGIN PROCEDURE _gc_copy ****/

errcode _gc_copy(t, x, ret_1)
CLUREF t;
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF nx;
    CLUREF xx;
    CLUREF i;
    CLUREF tg;
    CLUREF val;
        if (_gc_copy_own_init == 0) {
        add_parm_info_type(0, _obj_ops, table_of_key_reqs);
        add_parm_info_type(1, _obj_ops, table_of_val_reqs);
        find_type_instance(table_ops, 2, &table_ownreqs, &(table_of__obj__obj_ops));
        add_parm_info_type(0, _obj_ops, _tagcell_of_t_reqs);
        find_type_instance(_tagcell_ops, 1, &_tagcell_ownreqs, &(_tagcell_of__obj_ops));
        _gc_copy_own_init = 1;
    }
    enter_proc(36);

  LINE(37);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = _objOPis_ref(x, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {

  LINE(38);
        {
        {
        ret_1->num = x.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(39);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        T_1_1.num = t.vec->data[0];
        err = _gcOPcount(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
        T_1_4.num = T_1_3.num ^ 1;
        if (T_1_4.num != true) { break; }

  LINE(40);
        {
        CLUREF T_2_1;
        err = _gcOPcount(&T_2_1);
        if (err != ERR_ok) goto ex_0;
        t.vec->data[0]  = T_2_1.num;
        }

  LINE(41);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = t.vec->data[1];
        err = proctypeOPnew(CLU_0, &T_2_2.proc);
        if (err!= ERR_ok) goto ex_0;
        T_2_2.proc->type_owns = 0;
        T_2_2.proc->op_owns = 0;
        T_2_2.proc->proc = hash_obj;
        generic_CLU_proc.type_owns = table_of__obj__obj_ops->type_owns;
        generic_CLU_proc.proc = tableOPrehash;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = tableOPrehash(T_2_1, T_2_2);
        if (err != ERR_ok) goto ex_0;
        }
        }
        end_while_1:;

  LINE(43);
    {
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = t.vec->data[1];
    generic_CLU_proc.type_owns = table_of__obj__obj_ops->type_owns;
    generic_CLU_proc.proc = tableOPlookup;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = tableOPlookup(T_2_1, x, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    ret_1->num = T_2_2.num;
    }
    {signal (ERR_ok);}}
        goto end_1;
        ex_1:
            if ((err == ERR_not_found)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(46);
    {
    CLUREF T_1_1;
    err = _objOPis_vec(x, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    if (T_1_1.num == true) {

  LINE(47);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = x.num;
            err = _vecOPcopy(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            xx.num = T_2_2.num;
            }
            }

  LINE(48);
        {
        CLUREF T_2_1;
        T_2_1.num = xx.num;
        nx.num = T_2_1.num;
        }

  LINE(49);
        {
        CLUREF T_2_1;
        T_2_1.num = t.vec->data[1];
        generic_CLU_proc.type_owns = table_of__obj__obj_ops->type_owns;
        generic_CLU_proc.proc = tableOPalter;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = tableOPalter(T_2_1, x, nx);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(50);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
            err = _vecOPsize(xx, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            T_2_3.num = 1;
            T_2_4.num = -1;
            for (T_2_2.num = T_2_1.num; ((T_2_4.num == 0) || ((T_2_4.num > 0)? (T_2_2.num <= T_2_3.num) : (T_2_2.num >= T_2_3.num))); T_2_2.num += T_2_4.num) {
                i.num = T_2_2.num;

  LINE(51);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                if (i.num < 1 || i.num > xx.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_3_1.num = xx.vec->data[i.num - 1];
                err = _gc_copy(t, T_3_1, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                err = _vecOPstore(xx, i, T_3_2);
                if (err != ERR_ok) goto ex_0;
                }
            }
        }
        end_inline_for_1:;
        }
    else {
    CLUREF T_1_2;
    err = _objOPis_bvec(x, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    if (T_1_2.num == true) {

  LINE(54);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = x.num;
        err = _bytevecOPcopy(T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_3.num = T_2_2.num;
        nx.num = T_2_3.num;
        }

  LINE(55);
        {
        CLUREF T_2_1;
        T_2_1.num = t.vec->data[1];
        generic_CLU_proc.type_owns = table_of__obj__obj_ops->type_owns;
        generic_CLU_proc.proc = tableOPalter;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = tableOPalter(T_2_1, x, nx);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {
    CLUREF T_1_3;
    err = _objOPis_adv(x, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    if (T_1_3.num == true) {

  LINE(57);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = x.num;
            err = arrayOPcopy1(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            xx.num = T_2_2.num;
            }
            }

  LINE(58);
        {
        CLUREF T_2_1;
        T_2_1.num = xx.num;
        nx.num = T_2_1.num;
        }

  LINE(59);
        {
        CLUREF T_2_1;
        T_2_1.num = t.vec->data[1];
        generic_CLU_proc.type_owns = table_of__obj__obj_ops->type_owns;
        generic_CLU_proc.proc = tableOPalter;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = tableOPalter(T_2_1, x, nx);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(60);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
            T_2_2.num = xx.array->ext_high; 
            for (T_2_1.num = xx.array->ext_low; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                i.num = T_2_1.num;

  LINE(61);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                if (i.num < xx.array->ext_low || i.num > xx.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_3_1.num = xx.array->store->data[i.num - xx.array->ext_low + xx.array->int_low];
                err = _gc_copy(t, T_3_1, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                {
                if (i.num < xx.array->ext_low || i.num > xx.array->ext_high) {
                    err = ERR_bounds;
                    goto ex_0;}
                xx.array->store->data[i.num + xx.array->int_low - xx.array->ext_low] = T_3_2.num;
                }
                }
            }
        }
        end_inline_for_2:;
        }
    else {
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    err = _objOPis_cell(x, &T_1_5);
    if (err != ERR_ok) goto ex_0;
    T_1_4.num = T_1_5.num;
    if (!T_1_5.num) {
        err = _objOPis_anyize(x, &T_1_6);
        if (err != ERR_ok) goto ex_0;
        T_1_4.num = T_1_6.num;
    }
    if (T_1_4.num == true) {

  LINE(64);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = x.num;
            generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
            generic_CLU_proc.proc = _tagcellOPcopy;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = _tagcellOPcopy(T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            xx.num = T_2_2.num;
            }
            }

  LINE(65);
        {
        CLUREF T_2_1;
        T_2_1.num = xx.num;
        nx.num = T_2_1.num;
        }

  LINE(66);
        {
        CLUREF T_2_1;
        T_2_1.num = t.vec->data[1];
        generic_CLU_proc.type_owns = table_of__obj__obj_ops->type_owns;
        generic_CLU_proc.proc = tableOPalter;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = tableOPalter(T_2_1, x, nx);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(67);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
            generic_CLU_proc.proc = _tagcellOPget;
            CUR_PROC_VAR.proc = &generic_CLU_proc;
            err = _tagcellOPget(xx, &T_2_1, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            tg.num = T_2_1.num;
            val.num = T_2_2.num;
            }
            }

  LINE(68);
        {
        CLUREF T_2_1;
        err = _gc_copy(t, val, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
        generic_CLU_proc.proc = _tagcellOPset_value;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = _tagcellOPset_value(xx, T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(69);
        {
        nx.num = x.num;
        }
        }}}}}/* end if */

  LINE(71);
    {
    {
    ret_1->num = nx.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE _gc_copy ****/

