
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER table ****/


typedef struct {
long count;
} table_of_key_REQS;

table_of_key_REQS table_of_key_reqs_actual = {0};

struct REQS * table_of_key_reqs = (struct REQS *)&table_of_key_reqs_actual;


typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    } table_of_key_OPS;


typedef struct {
long count;
} table_of_val_REQS;

table_of_val_REQS table_of_val_reqs_actual = {0};

struct REQS * table_of_val_reqs = (struct REQS *)&table_of_val_reqs_actual;


typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    } table_of_val_OPS;

extern errcode intOPlt();
extern errcode _objOPequal();
extern errcode _cvt();
extern errcode _vecOPcreate();
extern errcode recordOPset_5();
extern errcode recordOPget_1();
extern errcode intOPfrom_to();
extern errcode recordOPget_7();
extern errcode _vecOPstore();
extern errcode _vecOPfetch();
extern errcode boolOPnot();
extern errcode recordOPget_2();
extern errcode recordOPget_3();
extern errcode recordOPset_2();
extern errcode recordOPget_5();
extern errcode recordOPset_4();
extern errcode intOPadd();
extern errcode recordOPget_6();
extern errcode recordOPget_4();
extern errcode recordOPset_6();
extern errcode recordOPset_3();
extern errcode arrayOPcreate();
extern errcode arrayOPstore();
extern errcode arrayOPfetch();
extern errcode arrayOPsize();
extern errcode arrayOPaddh();

OWN_ptr table_own_init; /* dummy */
typedef struct {
    long table_own_init;
    CLUREF unique;
    long create_own_init;
    long flush_own_init;
    long cond_flush_own_init;
    long bind_own_init;
    long mbind_own_init;
    long alter_own_init;
    long lookup_own_init;
    long mlookup_own_init;
    long get_pair_own_init;
    long exists_own_init;
    long remove_own_init;
    long delete_own_init;
    long rehash_own_init;
    long elements_own_init;
    long count_own_init;
    long empty_own_init;
    long sizes_own_init;
    table_of_key_OPS *key_ops;
    table_of_val_OPS *val_ops;
} table_OWN_DEFN;

OWN_req table_ownreqs = {sizeof(table_OWN_DEFN), 19};

errcode table_own_init_proc()
{
errcode err;
table_OWN_DEFN *type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;

enter_own_init_proc();
    if (type_own_ptr->table_own_init == 0) {
    type_own_ptr->table_own_init = 1;
    {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
}
}


/**** BEGIN PROCEDURE create ****/

errcode tableOPcreate(size, hasher, comper, ret_1)
CLUREF size;
CLUREF hasher;
CLUREF comper;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->create_own_init == 0) {
        type_own_ptr->create_own_init = 1;
    }
    enter_proc(42);

  LINE(44);
    {
    CLUREF T_1_1;
    T_1_1.num = (size.num < 1)? true : false;
    if (T_1_1.num == true) {

  LINE(45);
        {
        {signal (ERR_bad_size);}}
        }
        }/* end if */

  LINE(46);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = nil;
    T_1_2.num = (type_own_ptr->unique.num == T_1_1.num)? true : false;
    if (T_1_2.num == true) {

  LINE(47);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = _vecOPcreate(CLU_0, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        T_2_2.num = T_2_1.num;
        type_own_ptr->unique.num = T_2_2.num;
        }
        }
        }/* end if */

  LINE(48);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(7, T_1_1);
    T_1_1.vec->data[6]  = size.num;
    T_1_1.vec->data[2]  = hasher.num;
    T_1_1.vec->data[1]  = comper.num;
    T_1_1.vec->data[4]  = type_own_ptr->unique.num;
    T_1_1.vec->data[3]  = 0;
    T_1_1.vec->data[5]  = type_own_ptr->unique.num;
    err = _vecOPcreate(size, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[0]  = T_1_2.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE create ****/


/**** BEGIN PROCEDURE flush ****/

errcode tableOPflush(t)
CLUREF t;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF bucks;
    CLUREF i;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->flush_own_init == 0) {
        type_own_ptr->flush_own_init = 1;
    }
    enter_proc(59);

  LINE(60);
    {
    t.vec->data[4]  = type_own_ptr->unique.num;
    }

  LINE(61);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[0];
        bucks.num = T_1_1.num;
        }
        }

  LINE(62);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_1.num = t.vec->data[6];
        T_1_3.num = T_1_1.num;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            i.num = T_1_2.num;

  LINE(63);
            {
            CLUREF T_2_1;
            T_2_1.num = nil;
            err = _vecOPstore(bucks, i, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE flush ****/


/**** BEGIN PROCEDURE cond_flush ****/

errcode tableOPcond_flush(t, pred)
CLUREF t;
CLUREF pred;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF bucks;
    CLUREF i;
    CLUREF lbuck;
    CLUREF isprev;
    CLUREF mb;
    CLUREF buck;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->cond_flush_own_init == 0) {
        type_own_ptr->cond_flush_own_init = 1;
    }
    enter_proc(69);

  LINE(70);
    {
    t.vec->data[4]  = type_own_ptr->unique.num;
    }

  LINE(71);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[0];
        bucks.num = T_1_1.num;
        }
        }

  LINE(72);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_1.num = t.vec->data[6];
        T_1_3.num = T_1_1.num;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            i.num = T_1_2.num;

  LINE(74);
            {
                {isprev.tf = false;
                }
                }

  LINE(75);
            {
                {CLUREF T_2_1;
                if (i.num < 1 || i.num > bucks.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = bucks.vec->data[i.num - 1];
                mb.num = T_2_1.num;
                }
                }

  LINE(76);
            for (;;) {
                CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                T_2_1.num = nil;
                T_2_2.num = (mb.num == T_2_1.num)? true : false;
                T_2_3.num = T_2_2.num ^ 1;
                if (T_2_3.num != true) { break; }

  LINE(77);
                {
                    {CLUREF T_3_1;
                    T_3_1.num = mb.num;
                    buck.num = T_3_1.num;
                    }
                    }

  LINE(78);
                {
                CLUREF T_3_1;
                T_3_1.num = buck.vec->data[1];
                mb.num = T_3_1.num;
                }

  LINE(79);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = buck.vec->data[2];
                CUR_PROC_VAR = pred;
                err = pred.proc->proc(T_3_1, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                if (T_3_2.num == true) {

  LINE(80);
                    {
                    if (isprev.num == true) {

  LINE(81);
                        {
                        lbuck.vec->data[1]  = mb.num;
                        }
                        }
                    else {

  LINE(82);
                        {
                        err = _vecOPstore(bucks, i, mb);
                        if (err != ERR_ok) goto ex_0;
                        }
                        }}/* end if */
                    }
                else {

  LINE(84);
                    {
                    lbuck.num = buck.num;
                    }

  LINE(85);
                    {
                    isprev.tf = true;
                    }
                    }}/* end if */
                }
                end_while_1:;
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE cond_flush ****/


typedef struct {
long count;
} table_op_pcond_flush_of_u_REQS;

table_op_pcond_flush_of_u_REQS table_op_pcond_flush_of_u_reqs_actual = {0};

struct REQS * table_op_pcond_flush_of_u_reqs = (struct REQS *)&table_op_pcond_flush_of_u_reqs_actual;


typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    } table_op_pcond_flush_of_u_OPS;


typedef struct {
    long pcond_flush_own_init;
    table_op_pcond_flush_of_u_OPS *u_ops;
    } table_op_pcond_flush_OWN_DEFN;
OWN_req table_op_pcond_flush_ownreqs = {sizeof(table_op_pcond_flush_OWN_DEFN), 1};


/**** BEGIN PROCEDURE pcond_flush ****/

errcode tableOPpcond_flush(t, pred, thing)
CLUREF t;
CLUREF pred;
CLUREF thing;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    table_op_pcond_flush_OWN_DEFN *op_own_ptr;
    CLUREF bucks;
    CLUREF i;
    CLUREF lbuck;
    CLUREF isprev;
    CLUREF mb;
    CLUREF buck;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
    op_own_ptr = (table_op_pcond_flush_OWN_DEFN*) CUR_PROC_VAR.proc->op_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (op_own_ptr->pcond_flush_own_init == 0) {
        op_own_ptr->pcond_flush_own_init = 1;
    }
    enter_proc(93);

  LINE(95);
    {
    t.vec->data[4]  = type_own_ptr->unique.num;
    }

  LINE(96);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[0];
        bucks.num = T_1_1.num;
        }
        }

  LINE(97);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_1.num = t.vec->data[6];
        T_1_3.num = T_1_1.num;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            i.num = T_1_2.num;

  LINE(99);
            {
                {isprev.tf = false;
                }
                }

  LINE(100);
            {
                {CLUREF T_2_1;
                if (i.num < 1 || i.num > bucks.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = bucks.vec->data[i.num - 1];
                mb.num = T_2_1.num;
                }
                }

  LINE(101);
            for (;;) {
                CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                T_2_1.num = nil;
                T_2_2.num = (mb.num == T_2_1.num)? true : false;
                T_2_3.num = T_2_2.num ^ 1;
                if (T_2_3.num != true) { break; }

  LINE(102);
                {
                    {CLUREF T_3_1;
                    T_3_1.num = mb.num;
                    buck.num = T_3_1.num;
                    }
                    }

  LINE(103);
                {
                CLUREF T_3_1;
                T_3_1.num = buck.vec->data[1];
                mb.num = T_3_1.num;
                }

  LINE(104);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = buck.vec->data[2];
                CUR_PROC_VAR = pred;
                err = pred.proc->proc(T_3_1, thing, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                if (T_3_2.num == true) {

  LINE(105);
                    {
                    if (isprev.num == true) {

  LINE(106);
                        {
                        lbuck.vec->data[1]  = mb.num;
                        }
                        }
                    else {

  LINE(107);
                        {
                        err = _vecOPstore(bucks, i, mb);
                        if (err != ERR_ok) goto ex_0;
                        }
                        }}/* end if */
                    }
                else {

  LINE(109);
                    {
                    lbuck.num = buck.num;
                    }

  LINE(110);
                    {
                    isprev.tf = true;
                    }
                    }}/* end if */
                }
                end_while_1:;
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE pcond_flush ****/


/**** BEGIN PROCEDURE bind ****/

errcode tableOPbind(t, k, v)
CLUREF t;
CLUREF k;
CLUREF v;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF comper;
    CLUREF xmb;
    CLUREF mb;
    CLUREF buck;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->bind_own_init == 0) {
        type_own_ptr->bind_own_init = 1;
    }
    enter_proc(118);

  LINE(119);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = t.vec->data[4];
    T_1_2.num = k.num;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {

  LINE(120);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.num = t.vec->data[6];
        T_2_3.num = t.vec->data[2];
        CUR_PROC_VAR = T_2_3;
        err = T_2_3.proc->proc(k, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_4.num = T_2_2.num + 1;
         if ((T_2_4.num > 0 && T_2_2.num < 0 && 1 < 0) || 
             (T_2_4.num < 0 && T_2_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        t.vec->data[3]  = T_2_4.num;
        }
        }
    else {
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    T_1_5.num = t.vec->data[5];
    T_1_6.num = (T_1_5.num == type_own_ptr->unique.num)? true : false;
    T_1_7.num = T_1_6.num ^ 1;
    if (T_1_7.num == true) {

  LINE(122);
        {
        {signal (ERR_exists);}}
        }
        }}/* end if */

  LINE(123);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[1];
        comper.num = T_1_1.num;
        }
        }

  LINE(124);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = t.vec->data[0];
        T_1_2.num = t.vec->data[3];
        if (T_1_2.num < 1 || T_1_2.num > T_1_1.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_3.num = T_1_1.vec->data[T_1_2.num - 1];
        xmb.num = T_1_3.num;
        }
        }

  LINE(125);
    {
        {mb.num = xmb.num;
        }
        }

  LINE(126);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = nil;
        T_1_2.num = (mb.num == T_1_1.num)? true : false;
        T_1_3.num = T_1_2.num ^ 1;
        if (T_1_3.num != true) { break; }

  LINE(127);
        {
            {CLUREF T_2_1;
            T_2_1.num = mb.num;
            buck.num = T_2_1.num;
            }
            }

  LINE(128);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = buck.vec->data[0];
        CUR_PROC_VAR = comper;
        err = comper.proc->proc(k, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        if (T_2_2.num == true) {

  LINE(129);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[0];
            T_3_2.num = T_3_1.num;
            t.vec->data[4]  = T_3_2.num;
            }

  LINE(130);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[2];
            T_3_2.num = T_3_1.num;
            t.vec->data[5]  = T_3_2.num;
            }

  LINE(131);
            {
            {signal (ERR_exists);}}
            }
            }/* end if */

  LINE(133);
        {
        CLUREF T_2_1;
        T_2_1.num = buck.vec->data[1];
        mb.num = T_2_1.num;
        }
        }
        end_while_1:;

  LINE(135);
    {
    CLUREF T_1_1;
    T_1_1.num = k.num;
    t.vec->data[4]  = T_1_1.num;
    }

  LINE(136);
    {
    CLUREF T_1_1;
    T_1_1.num = v.num;
    t.vec->data[5]  = T_1_1.num;
    }

  LINE(137);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = t.vec->data[0];
    T_1_2.num = t.vec->data[3];
    RecordAlloc(3, T_1_3);
    T_1_3.vec->data[0]  = k.num;
    T_1_3.vec->data[2]  = v.num;
    T_1_3.vec->data[1]  = xmb.num;
    T_1_4.num = T_1_3.num;
    err = _vecOPstore(T_1_1, T_1_2, T_1_4);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE bind ****/


/**** BEGIN PROCEDURE mbind ****/

errcode tableOPmbind(t, k, v, ret_1)
CLUREF t;
CLUREF k;
CLUREF v;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF comper;
    CLUREF xmb;
    CLUREF mb;
    CLUREF buck;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->mbind_own_init == 0) {
        type_own_ptr->mbind_own_init = 1;
    }
    enter_proc(144);

  LINE(145);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = t.vec->data[4];
    T_1_2.num = k.num;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {

  LINE(146);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.num = t.vec->data[6];
        T_2_3.num = t.vec->data[2];
        CUR_PROC_VAR = T_2_3;
        err = T_2_3.proc->proc(k, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_4.num = T_2_2.num + 1;
         if ((T_2_4.num > 0 && T_2_2.num < 0 && 1 < 0) || 
             (T_2_4.num < 0 && T_2_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        t.vec->data[3]  = T_2_4.num;
        }
        }
    else {
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    T_1_5.num = t.vec->data[5];
    T_1_6.num = (T_1_5.num == type_own_ptr->unique.num)? true : false;
    T_1_7.num = T_1_6.num ^ 1;
    if (T_1_7.num == true) {

  LINE(148);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = t.vec->data[5];
        T_2_2.num = T_2_1.num;
        ret_1->num = T_2_2.num;
        }
        {signal (ERR_ok);}}
        }
        }}/* end if */

  LINE(149);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[1];
        comper.num = T_1_1.num;
        }
        }

  LINE(150);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = t.vec->data[0];
        T_1_2.num = t.vec->data[3];
        if (T_1_2.num < 1 || T_1_2.num > T_1_1.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_3.num = T_1_1.vec->data[T_1_2.num - 1];
        xmb.num = T_1_3.num;
        }
        }

  LINE(151);
    {
        {mb.num = xmb.num;
        }
        }

  LINE(152);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = nil;
        T_1_2.num = (mb.num == T_1_1.num)? true : false;
        T_1_3.num = T_1_2.num ^ 1;
        if (T_1_3.num != true) { break; }

  LINE(153);
        {
            {CLUREF T_2_1;
            T_2_1.num = mb.num;
            buck.num = T_2_1.num;
            }
            }

  LINE(154);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = buck.vec->data[0];
        CUR_PROC_VAR = comper;
        err = comper.proc->proc(k, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        if (T_2_2.num == true) {

  LINE(155);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[0];
            T_3_2.num = T_3_1.num;
            t.vec->data[4]  = T_3_2.num;
            }

  LINE(156);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[2];
            T_3_2.num = T_3_1.num;
            t.vec->data[5]  = T_3_2.num;
            }

  LINE(157);
            {
            {
            CLUREF T_3_1;
            T_3_1.num = buck.vec->data[2];
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(159);
        {
        CLUREF T_2_1;
        T_2_1.num = buck.vec->data[1];
        mb.num = T_2_1.num;
        }
        }
        end_while_1:;

  LINE(161);
    {
    CLUREF T_1_1;
    T_1_1.num = k.num;
    t.vec->data[4]  = T_1_1.num;
    }

  LINE(162);
    {
    CLUREF T_1_1;
    T_1_1.num = v.num;
    t.vec->data[5]  = T_1_1.num;
    }

  LINE(163);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = t.vec->data[0];
    T_1_2.num = t.vec->data[3];
    RecordAlloc(3, T_1_3);
    T_1_3.vec->data[0]  = k.num;
    T_1_3.vec->data[2]  = v.num;
    T_1_3.vec->data[1]  = xmb.num;
    T_1_4.num = T_1_3.num;
    err = _vecOPstore(T_1_1, T_1_2, T_1_4);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(166);
    {
    {
    ret_1->num = v.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE mbind ****/


/**** BEGIN PROCEDURE alter ****/

errcode tableOPalter(t, k, v)
CLUREF t;
CLUREF k;
CLUREF v;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF comper;
    CLUREF xmb;
    CLUREF mb;
    CLUREF buck;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->alter_own_init == 0) {
        type_own_ptr->alter_own_init = 1;
    }
    enter_proc(171);

  LINE(172);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = t.vec->data[4];
    T_1_2.num = k.num;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    T_1_4.num = T_1_3.num ^ 1;
    if (T_1_4.num == true) {

  LINE(173);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_1.num = t.vec->data[6];
        T_2_3.num = t.vec->data[2];
        CUR_PROC_VAR = T_2_3;
        err = T_2_3.proc->proc(k, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_4.num = T_2_2.num + 1;
         if ((T_2_4.num > 0 && T_2_2.num < 0 && 1 < 0) || 
             (T_2_4.num < 0 && T_2_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        t.vec->data[3]  = T_2_4.num;
        }
        }
        }/* end if */

  LINE(174);
    {
    CLUREF T_1_1;
    T_1_1.num = v.num;
    t.vec->data[5]  = T_1_1.num;
    }

  LINE(175);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[1];
        comper.num = T_1_1.num;
        }
        }

  LINE(176);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = t.vec->data[0];
        T_1_2.num = t.vec->data[3];
        if (T_1_2.num < 1 || T_1_2.num > T_1_1.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_3.num = T_1_1.vec->data[T_1_2.num - 1];
        xmb.num = T_1_3.num;
        }
        }

  LINE(177);
    {
        {mb.num = xmb.num;
        }
        }

  LINE(178);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = nil;
        T_1_2.num = (mb.num == T_1_1.num)? true : false;
        T_1_3.num = T_1_2.num ^ 1;
        if (T_1_3.num != true) { break; }

  LINE(179);
        {
            {CLUREF T_2_1;
            T_2_1.num = mb.num;
            buck.num = T_2_1.num;
            }
            }

  LINE(180);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = buck.vec->data[0];
        CUR_PROC_VAR = comper;
        err = comper.proc->proc(k, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        if (T_2_2.num == true) {

  LINE(181);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[0];
            T_3_2.num = T_3_1.num;
            t.vec->data[4]  = T_3_2.num;
            }

  LINE(182);
            {
            buck.vec->data[2]  = v.num;
            }

  LINE(183);
            {
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(185);
        {
        CLUREF T_2_1;
        T_2_1.num = buck.vec->data[1];
        mb.num = T_2_1.num;
        }
        }
        end_while_1:;

  LINE(187);
    {
    CLUREF T_1_1;
    T_1_1.num = k.num;
    t.vec->data[4]  = T_1_1.num;
    }

  LINE(188);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = t.vec->data[0];
    T_1_2.num = t.vec->data[3];
    RecordAlloc(3, T_1_3);
    T_1_3.vec->data[0]  = k.num;
    T_1_3.vec->data[2]  = v.num;
    T_1_3.vec->data[1]  = xmb.num;
    T_1_4.num = T_1_3.num;
    err = _vecOPstore(T_1_1, T_1_2, T_1_4);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE alter ****/


/**** BEGIN PROCEDURE lookup ****/

errcode tableOPlookup(t, k, ret_1)
CLUREF t;
CLUREF k;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF comper;
    CLUREF mb;
    CLUREF buck;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->lookup_own_init == 0) {
        type_own_ptr->lookup_own_init = 1;
    }
    enter_proc(195);

  LINE(196);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = t.vec->data[4];
    T_1_2.num = k.num;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(197);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = t.vec->data[5];
        T_2_2.num = (T_2_1.num == type_own_ptr->unique.num)? true : false;
        if (T_2_2.num == true) {

  LINE(198);
            {
            {signal (ERR_not_found);}}
            }
            }/* end if */

  LINE(199);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = t.vec->data[5];
        T_2_2.num = T_2_1.num;
        ret_1->num = T_2_2.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(201);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = t.vec->data[6];
    T_1_3.num = t.vec->data[2];
    CUR_PROC_VAR = T_1_3;
    err = T_1_3.proc->proc(k, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_4.num = T_1_2.num + 1;
     if ((T_1_4.num > 0 && T_1_2.num < 0 && 1 < 0) || 
         (T_1_4.num < 0 && T_1_2.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    t.vec->data[3]  = T_1_4.num;
    }

  LINE(202);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[1];
        comper.num = T_1_1.num;
        }
        }

  LINE(203);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = t.vec->data[0];
        T_1_2.num = t.vec->data[3];
        if (T_1_2.num < 1 || T_1_2.num > T_1_1.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_3.num = T_1_1.vec->data[T_1_2.num - 1];
        mb.num = T_1_3.num;
        }
        }

  LINE(204);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = nil;
        T_1_2.num = (mb.num == T_1_1.num)? true : false;
        T_1_3.num = T_1_2.num ^ 1;
        if (T_1_3.num != true) { break; }

  LINE(205);
        {
            {CLUREF T_2_1;
            T_2_1.num = mb.num;
            buck.num = T_2_1.num;
            }
            }

  LINE(206);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = buck.vec->data[0];
        CUR_PROC_VAR = comper;
        err = comper.proc->proc(k, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        if (T_2_2.num == true) {

  LINE(207);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[0];
            T_3_2.num = T_3_1.num;
            t.vec->data[4]  = T_3_2.num;
            }

  LINE(208);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[2];
            T_3_2.num = T_3_1.num;
            t.vec->data[5]  = T_3_2.num;
            }

  LINE(209);
            {
            {
            CLUREF T_3_1;
            T_3_1.num = buck.vec->data[2];
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(211);
        {
        CLUREF T_2_1;
        T_2_1.num = buck.vec->data[1];
        mb.num = T_2_1.num;
        }
        }
        end_while_1:;

  LINE(213);
    {
    CLUREF T_1_1;
    T_1_1.num = k.num;
    t.vec->data[4]  = T_1_1.num;
    }

  LINE(214);
    {
    t.vec->data[5]  = type_own_ptr->unique.num;
    }

  LINE(215);
    {
    {signal (ERR_not_found);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE lookup ****/


/**** BEGIN PROCEDURE mlookup ****/

errcode tableOPmlookup(t, k, defv, ret_1)
CLUREF t;
CLUREF k;
CLUREF defv;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF comper;
    CLUREF mb;
    CLUREF buck;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->mlookup_own_init == 0) {
        type_own_ptr->mlookup_own_init = 1;
    }
    enter_proc(220);

  LINE(221);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = t.vec->data[4];
    T_1_2.num = k.num;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(222);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = t.vec->data[5];
        T_2_2.num = (T_2_1.num == type_own_ptr->unique.num)? true : false;
        T_2_3.num = T_2_2.num ^ 1;
        if (T_2_3.num == true) {

  LINE(223);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = t.vec->data[5];
            T_3_2.num = T_3_1.num;
            defv.num = T_3_2.num;
            }
            }
            }/* end if */

  LINE(224);
        {
        {
        ret_1->num = defv.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(226);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = t.vec->data[6];
    T_1_3.num = t.vec->data[2];
    CUR_PROC_VAR = T_1_3;
    err = T_1_3.proc->proc(k, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_4.num = T_1_2.num + 1;
     if ((T_1_4.num > 0 && T_1_2.num < 0 && 1 < 0) || 
         (T_1_4.num < 0 && T_1_2.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    t.vec->data[3]  = T_1_4.num;
    }

  LINE(227);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[1];
        comper.num = T_1_1.num;
        }
        }

  LINE(228);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = t.vec->data[0];
        T_1_2.num = t.vec->data[3];
        if (T_1_2.num < 1 || T_1_2.num > T_1_1.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_3.num = T_1_1.vec->data[T_1_2.num - 1];
        mb.num = T_1_3.num;
        }
        }

  LINE(229);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = nil;
        T_1_2.num = (mb.num == T_1_1.num)? true : false;
        T_1_3.num = T_1_2.num ^ 1;
        if (T_1_3.num != true) { break; }

  LINE(230);
        {
            {CLUREF T_2_1;
            T_2_1.num = mb.num;
            buck.num = T_2_1.num;
            }
            }

  LINE(231);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = buck.vec->data[0];
        CUR_PROC_VAR = comper;
        err = comper.proc->proc(k, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        if (T_2_2.num == true) {

  LINE(232);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[0];
            T_3_2.num = T_3_1.num;
            t.vec->data[4]  = T_3_2.num;
            }

  LINE(233);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[2];
            T_3_2.num = T_3_1.num;
            t.vec->data[5]  = T_3_2.num;
            }

  LINE(234);
            {
            {
            CLUREF T_3_1;
            T_3_1.num = buck.vec->data[2];
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(236);
        {
        CLUREF T_2_1;
        T_2_1.num = buck.vec->data[1];
        mb.num = T_2_1.num;
        }
        }
        end_while_1:;

  LINE(238);
    {
    CLUREF T_1_1;
    T_1_1.num = k.num;
    t.vec->data[4]  = T_1_1.num;
    }

  LINE(239);
    {
    t.vec->data[5]  = type_own_ptr->unique.num;
    }

  LINE(240);
    {
    {
    ret_1->num = defv.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE mlookup ****/


/**** BEGIN PROCEDURE get_pair ****/

errcode tableOPget_pair(t, k, ret_1, ret_2)
CLUREF t;
CLUREF k;
CLUREF *ret_1;
CLUREF *ret_2;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF comper;
    CLUREF mb;
    CLUREF buck;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->get_pair_own_init == 0) {
        type_own_ptr->get_pair_own_init = 1;
    }
    enter_proc(246);

  LINE(247);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = t.vec->data[4];
    T_1_2.num = k.num;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(248);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = t.vec->data[5];
        T_2_2.num = (T_2_1.num == type_own_ptr->unique.num)? true : false;
        if (T_2_2.num == true) {

  LINE(249);
            {
            {signal (ERR_not_found);}}
            }
            }/* end if */

  LINE(250);
        {
        {
        ret_1->num = k.num;
        }
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = t.vec->data[5];
        T_2_2.num = T_2_1.num;
        ret_2->num = T_2_2.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(252);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = t.vec->data[6];
    T_1_3.num = t.vec->data[2];
    CUR_PROC_VAR = T_1_3;
    err = T_1_3.proc->proc(k, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_4.num = T_1_2.num + 1;
     if ((T_1_4.num > 0 && T_1_2.num < 0 && 1 < 0) || 
         (T_1_4.num < 0 && T_1_2.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    t.vec->data[3]  = T_1_4.num;
    }

  LINE(253);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[1];
        comper.num = T_1_1.num;
        }
        }

  LINE(254);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = t.vec->data[0];
        T_1_2.num = t.vec->data[3];
        if (T_1_2.num < 1 || T_1_2.num > T_1_1.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_3.num = T_1_1.vec->data[T_1_2.num - 1];
        mb.num = T_1_3.num;
        }
        }

  LINE(255);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = nil;
        T_1_2.num = (mb.num == T_1_1.num)? true : false;
        T_1_3.num = T_1_2.num ^ 1;
        if (T_1_3.num != true) { break; }

  LINE(256);
        {
            {CLUREF T_2_1;
            T_2_1.num = mb.num;
            buck.num = T_2_1.num;
            }
            }

  LINE(257);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = buck.vec->data[0];
        CUR_PROC_VAR = comper;
        err = comper.proc->proc(k, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        if (T_2_2.num == true) {

  LINE(258);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[0];
            T_3_2.num = T_3_1.num;
            t.vec->data[4]  = T_3_2.num;
            }

  LINE(259);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[2];
            T_3_2.num = T_3_1.num;
            t.vec->data[5]  = T_3_2.num;
            }

  LINE(260);
            {
            {
            CLUREF T_3_1;
            T_3_1.num = buck.vec->data[0];
            ret_1->num = T_3_1.num;
            }
            {
            CLUREF T_3_2;
            T_3_2.num = buck.vec->data[2];
            ret_2->num = T_3_2.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(262);
        {
        CLUREF T_2_1;
        T_2_1.num = buck.vec->data[1];
        mb.num = T_2_1.num;
        }
        }
        end_while_1:;

  LINE(264);
    {
    CLUREF T_1_1;
    T_1_1.num = k.num;
    t.vec->data[4]  = T_1_1.num;
    }

  LINE(265);
    {
    t.vec->data[5]  = type_own_ptr->unique.num;
    }

  LINE(266);
    {
    {signal (ERR_not_found);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_pair ****/


/**** BEGIN PROCEDURE exists ****/

errcode tableOPexists(t, k, ret_1)
CLUREF t;
CLUREF k;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF comper;
    CLUREF mb;
    CLUREF buck;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->exists_own_init == 0) {
        type_own_ptr->exists_own_init = 1;
    }
    enter_proc(271);

  LINE(272);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = t.vec->data[4];
    T_1_2.num = k.num;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(273);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = t.vec->data[5];
        T_2_2.num = (T_2_1.num == type_own_ptr->unique.num)? true : false;
        T_2_3.num = T_2_2.num ^ 1;
        ret_1->num = T_2_3.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(274);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = t.vec->data[6];
    T_1_3.num = t.vec->data[2];
    CUR_PROC_VAR = T_1_3;
    err = T_1_3.proc->proc(k, T_1_1, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_4.num = T_1_2.num + 1;
     if ((T_1_4.num > 0 && T_1_2.num < 0 && 1 < 0) || 
         (T_1_4.num < 0 && T_1_2.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    t.vec->data[3]  = T_1_4.num;
    }

  LINE(275);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[1];
        comper.num = T_1_1.num;
        }
        }

  LINE(276);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = t.vec->data[0];
        T_1_2.num = t.vec->data[3];
        if (T_1_2.num < 1 || T_1_2.num > T_1_1.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_3.num = T_1_1.vec->data[T_1_2.num - 1];
        mb.num = T_1_3.num;
        }
        }

  LINE(277);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = nil;
        T_1_2.num = (mb.num == T_1_1.num)? true : false;
        T_1_3.num = T_1_2.num ^ 1;
        if (T_1_3.num != true) { break; }

  LINE(278);
        {
            {CLUREF T_2_1;
            T_2_1.num = mb.num;
            buck.num = T_2_1.num;
            }
            }

  LINE(279);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = buck.vec->data[0];
        CUR_PROC_VAR = comper;
        err = comper.proc->proc(k, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        if (T_2_2.num == true) {

  LINE(280);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[0];
            T_3_2.num = T_3_1.num;
            t.vec->data[4]  = T_3_2.num;
            }

  LINE(281);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = buck.vec->data[2];
            T_3_2.num = T_3_1.num;
            t.vec->data[5]  = T_3_2.num;
            }

  LINE(282);
            {
            {
            ret_1->tf = true;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(284);
        {
        CLUREF T_2_1;
        T_2_1.num = buck.vec->data[1];
        mb.num = T_2_1.num;
        }
        }
        end_while_1:;

  LINE(286);
    {
    CLUREF T_1_1;
    T_1_1.num = k.num;
    t.vec->data[4]  = T_1_1.num;
    }

  LINE(287);
    {
    t.vec->data[5]  = type_own_ptr->unique.num;
    }

  LINE(288);
    {
    {
    ret_1->tf = false;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE exists ****/


/**** BEGIN PROCEDURE remove ****/

errcode tableOPremove(t, k, ret_1)
CLUREF t;
CLUREF k;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF comper;
    CLUREF i;
    CLUREF mb;
    CLUREF lbuck;
    CLUREF isprev;
    CLUREF buck;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->remove_own_init == 0) {
        type_own_ptr->remove_own_init = 1;
    }
    enter_proc(294);

  LINE(295);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[1];
        comper.num = T_1_1.num;
        }
        }

  LINE(296);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        T_1_1.num = t.vec->data[6];
        T_1_3.num = t.vec->data[2];
        CUR_PROC_VAR = T_1_3;
        err = T_1_3.proc->proc(k, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_4.num = T_1_2.num + 1;
         if ((T_1_4.num > 0 && T_1_2.num < 0 && 1 < 0) || 
             (T_1_4.num < 0 && T_1_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        i.num = T_1_4.num;
        }
        }

  LINE(297);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = t.vec->data[0];
        if (i.num < 1 || i.num > T_1_1.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_2.num = T_1_1.vec->data[i.num - 1];
        mb.num = T_1_2.num;
        }
        }

  LINE(299);
    {
        {isprev.tf = false;
        }
        }

  LINE(300);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = nil;
        T_1_2.num = (mb.num == T_1_1.num)? true : false;
        T_1_3.num = T_1_2.num ^ 1;
        if (T_1_3.num != true) { break; }

  LINE(301);
        {
            {CLUREF T_2_1;
            T_2_1.num = mb.num;
            buck.num = T_2_1.num;
            }
            }

  LINE(302);
        {
        CLUREF T_2_1;
        T_2_1.num = buck.vec->data[1];
        mb.num = T_2_1.num;
        }

  LINE(303);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = buck.vec->data[0];
        CUR_PROC_VAR = comper;
        err = comper.proc->proc(k, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        if (T_2_2.num == true) {

  LINE(304);
            {
            if (isprev.num == true) {

  LINE(305);
                {
                lbuck.vec->data[1]  = mb.num;
                }
                }
            else {

  LINE(306);
                {
                CLUREF T_4_1;
                T_4_1.num = t.vec->data[0];
                err = _vecOPstore(T_4_1, i, mb);
                if (err != ERR_ok) goto ex_0;
                }
                }}/* end if */

  LINE(308);
            {
            t.vec->data[4]  = type_own_ptr->unique.num;
            }

  LINE(309);
            {
            {
            CLUREF T_3_1;
            T_3_1.num = buck.vec->data[2];
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(311);
        {
        lbuck.num = buck.num;
        }

  LINE(312);
        {
        isprev.tf = true;
        }
        }
        end_while_1:;

  LINE(314);
    {
    {signal (ERR_not_found);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE remove ****/


/**** BEGIN PROCEDURE delete ****/

errcode tableOPdelete(t, k)
CLUREF t;
CLUREF k;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF comper;
    CLUREF i;
    CLUREF mb;
    CLUREF lbuck;
    CLUREF isprev;
    CLUREF buck;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->delete_own_init == 0) {
        type_own_ptr->delete_own_init = 1;
    }
    enter_proc(319);

  LINE(320);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[1];
        comper.num = T_1_1.num;
        }
        }

  LINE(321);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        T_1_1.num = t.vec->data[6];
        T_1_3.num = t.vec->data[2];
        CUR_PROC_VAR = T_1_3;
        err = T_1_3.proc->proc(k, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_4.num = T_1_2.num + 1;
         if ((T_1_4.num > 0 && T_1_2.num < 0 && 1 < 0) || 
             (T_1_4.num < 0 && T_1_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        i.num = T_1_4.num;
        }
        }

  LINE(322);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = t.vec->data[0];
        if (i.num < 1 || i.num > T_1_1.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_2.num = T_1_1.vec->data[i.num - 1];
        mb.num = T_1_2.num;
        }
        }

  LINE(324);
    {
        {isprev.tf = false;
        }
        }

  LINE(325);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = nil;
        T_1_2.num = (mb.num == T_1_1.num)? true : false;
        T_1_3.num = T_1_2.num ^ 1;
        if (T_1_3.num != true) { break; }

  LINE(326);
        {
            {CLUREF T_2_1;
            T_2_1.num = mb.num;
            buck.num = T_2_1.num;
            }
            }

  LINE(327);
        {
        CLUREF T_2_1;
        T_2_1.num = buck.vec->data[1];
        mb.num = T_2_1.num;
        }

  LINE(328);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = buck.vec->data[0];
        CUR_PROC_VAR = comper;
        err = comper.proc->proc(k, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        if (T_2_2.num == true) {

  LINE(329);
            {
            if (isprev.num == true) {

  LINE(330);
                {
                lbuck.vec->data[1]  = mb.num;
                }
                }
            else {

  LINE(331);
                {
                CLUREF T_4_1;
                T_4_1.num = t.vec->data[0];
                err = _vecOPstore(T_4_1, i, mb);
                if (err != ERR_ok) goto ex_0;
                }
                }}/* end if */

  LINE(333);
            {
            t.vec->data[4]  = type_own_ptr->unique.num;
            }

  LINE(334);
            {
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(336);
        {
        lbuck.num = buck.num;
        }

  LINE(337);
        {
        isprev.tf = true;
        }
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE delete ****/


/**** BEGIN PROCEDURE rehash ****/

errcode tableOPrehash(t, hasher)
CLUREF t;
CLUREF hasher;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF bucks;
    CLUREF size;
    CLUREF chain;
    CLUREF i;
    CLUREF nchain;
    CLUREF buck;
    CLUREF hash;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->rehash_own_init == 0) {
        type_own_ptr->rehash_own_init = 1;
    }
    enter_proc(343);

  LINE(344);
    {
    t.vec->data[2]  = hasher.num;
    }

  LINE(345);
    {
    t.vec->data[4]  = type_own_ptr->unique.num;
    }

  LINE(346);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[0];
        bucks.num = T_1_1.num;
        }
        }

  LINE(347);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[6];
        size.num = T_1_1.num;
        }
        }

  LINE(348);
    {
        {CLUREF T_1_1;
        T_1_1.num = nil;
        chain.num = T_1_1.num;
        }
        }

  LINE(349);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = size.num;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(350);
            {
                {CLUREF T_2_1;
                if (i.num < 1 || i.num > bucks.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = bucks.vec->data[i.num - 1];
                nchain.num = T_2_1.num;
                }
                }

  LINE(351);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = nil;
            T_2_2.num = (nchain.num == T_2_1.num)? true : false;
            if (T_2_2.num == true) {

  LINE(352);
                continue;
                }
                }/* end if */

  LINE(353);
            {
            CLUREF T_2_1;
            T_2_1.num = nil;
            err = _vecOPstore(bucks, i, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }

  LINE(354);
            {
                {CLUREF T_2_1;
                T_2_1.num = nchain.num;
                buck.num = T_2_1.num;
                }
                }

  LINE(355);
            for (;;) {
                CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                CLUREF T_2_4;
                T_2_1.num = buck.vec->data[1];
                T_2_2.num = nil;
                T_2_3.num = (T_2_1.num == T_2_2.num)? true : false;
                T_2_4.num = T_2_3.num ^ 1;
                if (T_2_4.num != true) { break; }

  LINE(356);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = buck.vec->data[1];
                T_3_2.num = T_3_1.num;
                buck.num = T_3_2.num;
                }
                }
                end_while_1:;

  LINE(358);
            {
            buck.vec->data[1]  = chain.num;
            }

  LINE(359);
            {
            chain.num = nchain.num;
            }
        }
    }
    end_inline_for_1:;

  LINE(361);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = nil;
        T_1_2.num = (chain.num == T_1_1.num)? true : false;
        T_1_3.num = T_1_2.num ^ 1;
        if (T_1_3.num != true) { break; }

  LINE(362);
        {
            {CLUREF T_2_1;
            T_2_1.num = chain.num;
            buck.num = T_2_1.num;
            }
            }

  LINE(363);
        {
            {CLUREF T_2_1;
            T_2_1.num = buck.vec->data[1];
            nchain.num = T_2_1.num;
            }
            }

  LINE(364);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            T_2_1.num = buck.vec->data[0];
            CUR_PROC_VAR = hasher;
            err = hasher.proc->proc(T_2_1, size, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            T_2_3.num = T_2_2.num + 1;
             if ((T_2_3.num > 0 && T_2_2.num < 0 && 1 < 0) || 
                 (T_2_3.num < 0 && T_2_2.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            hash.num = T_2_3.num;
            }
            }

  LINE(365);
        {
        CLUREF T_2_1;
        if (hash.num < 1 || hash.num > bucks.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_2_1.num = bucks.vec->data[hash.num - 1];
        buck.vec->data[1]  = T_2_1.num;
        }

  LINE(366);
        {
        err = _vecOPstore(bucks, hash, chain);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(367);
        {
        chain.num = nchain.num;
        }
        }
        end_while_2:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE rehash ****/


/**** BEGIN ITERATOR elements ****/

errcode tableOPelements(t, proc, user_locals, iecode)
CLUREF t;
errcode (*proc)();
char **user_locals;
errcode *iecode;
    {
    errcode ecode;
    errcode err;
    errcode ecode2;
    bool body_ctrl_req;
    table_OWN_DEFN *type_own_ptr;
    CLUREF bucks;
    CLUREF i;
    CLUREF mb;
    CLUREF buck;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->elements_own_init == 0) {
        type_own_ptr->elements_own_init = 1;
    }
    enter_proc(373);

  LINE(374);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[0];
        bucks.num = T_1_1.num;
        }
        }

  LINE(375);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_1.num = t.vec->data[6];
        T_1_3.num = T_1_1.num;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            i.num = T_1_2.num;

  LINE(376);
            {
                {CLUREF T_2_1;
                if (i.num < 1 || i.num > bucks.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = bucks.vec->data[i.num - 1];
                mb.num = T_2_1.num;
                }
                }

  LINE(377);
            for (;;) {
                CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                T_2_1.num = nil;
                T_2_2.num = (mb.num == T_2_1.num)? true : false;
                T_2_3.num = T_2_2.num ^ 1;
                if (T_2_3.num != true) { break; }

  LINE(378);
                {
                    {CLUREF T_3_1;
                    T_3_1.num = mb.num;
                    buck.num = T_3_1.num;
                    }
                    }

  LINE(379);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = buck.vec->data[0];
                T_3_2.num = buck.vec->data[2];
                err = proc(T_3_1, T_3_2, user_locals, iecode);
                if (err != ERR_ok) {
                if (err == ERR_break) {signal(ERR_break);}
                if (err == ERR_iterbodyreturn) {signal(ERR_iterbodyreturn);}
                if (err == ERR_iterbodyexit) {signal(ERR_iterbodyexit);}
                if (err == ERR_iterbodysignal) {signal(ERR_iterbodysignal);}
                {signal(err);
                    }}
                }

  LINE(380);
                {
                CLUREF T_3_1;
                T_3_1.num = buck.vec->data[1];
                mb.num = T_3_1.num;
                }
                }
                end_while_1:;
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END ITERATOR elements ****/


/**** BEGIN PROCEDURE count ****/

errcode tableOPcount(t, ret_1)
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF cnt;
    CLUREF bucks;
    CLUREF i;
    CLUREF mb;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->count_own_init == 0) {
        type_own_ptr->count_own_init = 1;
    }
    enter_proc(387);

  LINE(388);
    {
        {cnt.num = 0;
        }
        }

  LINE(389);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[0];
        bucks.num = T_1_1.num;
        }
        }

  LINE(390);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_1.num = t.vec->data[6];
        T_1_3.num = T_1_1.num;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            i.num = T_1_2.num;

  LINE(391);
            {
                {CLUREF T_2_1;
                if (i.num < 1 || i.num > bucks.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = bucks.vec->data[i.num - 1];
                mb.num = T_2_1.num;
                }
                }

  LINE(392);
            for (;;) {
                CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                T_2_1.num = nil;
                T_2_2.num = (mb.num == T_2_1.num)? true : false;
                T_2_3.num = T_2_2.num ^ 1;
                if (T_2_3.num != true) { break; }

  LINE(393);
                {
                CLUREF T_3_1;
                T_3_1.num = cnt.num + 1;
                 if ((T_3_1.num > 0 && cnt.num < 0 && 1 < 0) || 
                     (T_3_1.num < 0 && cnt.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                cnt.num = T_3_1.num;
                }

  LINE(394);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = mb.num;
                T_3_2.num = T_3_1.vec->data[1];
                mb.num = T_3_2.num;
                }
                }
                end_while_1:;
        }
    }
    end_inline_for_1:;

  LINE(397);
    {
    {
    ret_1->num = cnt.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE count ****/


/**** BEGIN PROCEDURE empty ****/

errcode tableOPempty(t, ret_1)
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF bucks;
    CLUREF i;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->empty_own_init == 0) {
        type_own_ptr->empty_own_init = 1;
    }
    enter_proc(402);

  LINE(403);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[0];
        bucks.num = T_1_1.num;
        }
        }

  LINE(404);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_1.num = t.vec->data[6];
        T_1_3.num = T_1_1.num;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            i.num = T_1_2.num;

  LINE(405);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            if (i.num < 1 || i.num > bucks.vec->size ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = bucks.vec->data[i.num - 1];
            T_2_2.num = nil;
            T_2_3.num = (T_2_1.num == T_2_2.num)? true : false;
            T_2_4.num = T_2_3.num ^ 1;
            if (T_2_4.num == true) {

  LINE(406);
                {
                {
                ret_1->tf = false;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */
        }
    }
    end_inline_for_1:;

  LINE(408);
    {
    {
    ret_1->tf = true;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE empty ****/


/**** BEGIN PROCEDURE sizes ****/

errcode tableOPsizes(t, ret_1)
CLUREF t;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    table_OWN_DEFN *type_own_ptr;
    CLUREF z;
    CLUREF bucks;
    CLUREF i;
    CLUREF cnt;
    CLUREF mb;
    type_own_ptr = (table_OWN_DEFN *) CUR_PROC_VAR.proc->type_owns;
            if (type_own_ptr->table_own_init == 0) {
            generic_CLU_proc.type_owns = (OWNPTR)type_own_ptr;
            generic_CLU_proc.op_owns = 0;
            generic_CLU_proc.proc = table_own_init_proc;
            err = generic_CLU_proc.proc();
            if (err != ERR_ok) goto ex_0;
            }
        if (type_own_ptr->sizes_own_init == 0) {
        type_own_ptr->sizes_own_init = 1;
    }
    enter_proc(414);

  LINE(416);
    {
        {CLUREF T_1_1;
        err = arrayOPcreate(CLU_0, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        z.num = T_1_1.num;
        }
        }

  LINE(417);
    {
        {CLUREF T_1_1;
        T_1_1.num = t.vec->data[0];
        bucks.num = T_1_1.num;
        }
        }

  LINE(418);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_1.num = t.vec->data[6];
        T_1_3.num = T_1_1.num;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            i.num = T_1_2.num;

  LINE(419);
            {
                {cnt.num = 0;
                }
                }

  LINE(420);
            {
                {CLUREF T_2_1;
                if (i.num < 1 || i.num > bucks.vec->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.num = bucks.vec->data[i.num - 1];
                mb.num = T_2_1.num;
                }
                }

  LINE(421);
            for (;;) {
                CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                T_2_1.num = nil;
                T_2_2.num = (mb.num == T_2_1.num)? true : false;
                T_2_3.num = T_2_2.num ^ 1;
                if (T_2_3.num != true) { break; }

  LINE(422);
                {
                CLUREF T_3_1;
                T_3_1.num = cnt.num + 1;
                 if ((T_3_1.num > 0 && cnt.num < 0 && 1 < 0) || 
                     (T_3_1.num < 0 && cnt.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                cnt.num = T_3_1.num;
                }

  LINE(423);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = mb.num;
                T_3_2.num = T_3_1.vec->data[1];
                mb.num = T_3_2.num;
                }
                }
                end_while_1:;

  LINE(425);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            if (cnt.num < z.array->ext_low || cnt.num > z.array->ext_high ) {
                err = ERR_bounds;
                goto ex_1;}
            T_3_1.num = z.array->store->data[cnt.num - z.array->ext_low + z.array->int_low];
            T_3_2.num = T_3_1.num + 1;
             if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) || 
                 (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            {
            if (cnt.num < z.array->ext_low || cnt.num > z.array->ext_high) {
                err = ERR_bounds;
                goto ex_1;}
            z.array->store->data[cnt.num + z.array->int_low - z.array->ext_low] = T_3_2.num;
            }
            }
                goto end_1;
                ex_1:
                    if ((err == ERR_bounds)) {

  LINE(427);
                        for (;;) {
                            CLUREF T_3_1;
                            CLUREF T_3_2;
                            T_3_1.num = z.array->ext_size;
                            T_3_2.num = (T_3_1.num < cnt.num)? true : false;
                            if (T_3_2.num != true) { break; }

  LINE(428);
                            {
                            {
                            if ((z.array->int_low + z.array->ext_size + 1) < z.array->int_size) {
                                z.array->store->data[z.array->int_low + z.array->ext_size] = 0;
                                z.array->ext_size++; z.array->ext_high++;}
                            else {
                                err = arrayOPaddh(z, CLU_0);
                                if (err != ERR_ok) goto ex_0;}
                            }
                            }
                            }
                            end_while_2:;

  LINE(430);
                        {
                        {
                        if ((z.array->int_low + z.array->ext_size + 1) < z.array->int_size) {
                            z.array->store->data[z.array->int_low + z.array->ext_size] = 1;
                            z.array->ext_size++; z.array->ext_high++;}
                        else {
                            err = arrayOPaddh(z, CLU_1);
                            if (err != ERR_ok) goto ex_0;}
                        }
                        }
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;
        }
    }
    end_inline_for_1:;

  LINE(433);
    {
    {
    ret_1->num = z.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE sizes ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[18];
} table_OPS;

CLU_proc table_oe_alter = {{0,0,0,0}, tableOPalter, 0};
CLU_proc table_oe_bind = {{0,0,0,0}, tableOPbind, 0};
CLU_proc table_oe_cond_flush = {{0,0,0,0}, tableOPcond_flush, 0};
CLU_proc table_oe_count = {{0,0,0,0}, tableOPcount, 0};
CLU_proc table_oe_create = {{0,0,0,0}, tableOPcreate, 0};
CLU_proc table_oe_delete = {{0,0,0,0}, tableOPdelete, 0};
CLU_proc table_oe_elements = {{0,0,0,0}, tableOPelements, 0};
CLU_proc table_oe_empty = {{0,0,0,0}, tableOPempty, 0};
CLU_proc table_oe_exists = {{0,0,0,0}, tableOPexists, 0};
CLU_proc table_oe_flush = {{0,0,0,0}, tableOPflush, 0};
CLU_proc table_oe_get_pair = {{0,0,0,0}, tableOPget_pair, 0};
CLU_proc table_oe_lookup = {{0,0,0,0}, tableOPlookup, 0};
CLU_proc table_oe_mbind = {{0,0,0,0}, tableOPmbind, 0};
CLU_proc table_oe_mlookup = {{0,0,0,0}, tableOPmlookup, 0};
CLU_proc table_oe_pcond_flush = {{0,0,0,0}, tableOPpcond_flush, 0};
CLU_proc table_oe_rehash = {{0,0,0,0}, tableOPrehash, 0};
CLU_proc table_oe_remove = {{0,0,0,0}, tableOPremove, 0};
CLU_proc table_oe_sizes = {{0,0,0,0}, tableOPsizes, 0};

table_OPS table_ops_actual = {18, (OWNPTR)&table_own_init, (OWNPTR)&table_own_init, {
    {&table_oe_alter, "alter"},
    {&table_oe_bind, "bind"},
    {&table_oe_cond_flush, "cond_flush"},
    {&table_oe_count, "count"},
    {&table_oe_create, "create"},
    {&table_oe_delete, "delete"},
    {&table_oe_elements, "elements"},
    {&table_oe_empty, "empty"},
    {&table_oe_exists, "exists"},
    {&table_oe_flush, "flush"},
    {&table_oe_get_pair, "get_pair"},
    {&table_oe_lookup, "lookup"},
    {&table_oe_mbind, "mbind"},
    {&table_oe_mlookup, "mlookup"},
    {&table_oe_pcond_flush, "pcond_flush"},
    {&table_oe_rehash, "rehash"},
    {&table_oe_remove, "remove"},
    {&table_oe_sizes, "sizes"}}};

struct OPS *table_ops = (struct OPS *)&table_ops_actual;

/**** END CLUSTER table ****/
