
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"



typedef struct {
long count;
    char *_gcd_name;
} gc_dump_of_t_REQS;

gc_dump_of_t_REQS gc_dump_of_t_reqs_actual = {1,
    "_gcd"};

struct REQS * gc_dump_of_t_reqs = (struct REQS *)&gc_dump_of_t_reqs_actual;

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY _gcd;
} gc_dump_of_t_OPS;
extern errcode gcd_tabOPgrind();
extern OWN_req gcd_tab_ownreqs;
extern struct OPS *gcd_tab_ops;
extern struct REQS *gcd_tab_op_grind_of_t_reqs;
extern OWN_req gcd_tab_op_grind_ownreqs;

typedef struct {
    long gc_dump_own_init;
    gc_dump_of_t_OPS *t_ops;
    struct OPS *gcd_tab_op_grind_of_t_table;
    struct OPS *gcd_tab_op_grind_of_t_ops;
    OWNPTR gcd_tab_op_grind_of_t_owns;
    } gc_dump_OWN_DEFN;
OWN_req gc_dump_ownreqs = {sizeof(gc_dump_OWN_DEFN), 1};


/**** BEGIN PROCEDURE gc_dump ****/

errcode gc_dump(x, fn, ret_1)
CLUREF x;
CLUREF fn;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    gc_dump_OWN_DEFN *op_own_ptr;
    op_own_ptr = (gc_dump_OWN_DEFN*) CUR_PROC_VAR.proc->op_owns;
        if (op_own_ptr->gc_dump_own_init == 0) {
        add_parm_info_type(0, op_own_ptr->t_ops, gcd_tab_op_grind_of_t_reqs);
        find_typeop_instance(gcd_tab_ops, gcd_tabOPgrind, 1, 0, &gcd_tab_op_grind_ownreqs, &gcd_tab_ownreqs, &(op_own_ptr->gcd_tab_op_grind_of_t_ops));
        }
        if (op_own_ptr->gc_dump_own_init == 0) {
        op_own_ptr->gc_dump_own_init = 1;
    }
    enter_proc(8);

  LINE(11);
    {
    {
    CLUREF T_2_1;
    generic_CLU_proc.type_owns = 0;
    generic_CLU_proc.op_owns = op_own_ptr->gcd_tab_op_grind_of_t_ops->op_owns;
    generic_CLU_proc.proc = gcd_tabOPgrind;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = gcd_tabOPgrind(x, fn, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    ret_1->num = T_2_1.num;
    }
    {signal (ERR_ok);}}
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE gc_dump ****/

