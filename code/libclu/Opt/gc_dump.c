
/* This file was automatically generated by pclu. */

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN PROCEDURE gc_dump ****/


static const struct /* REQS */ {
    long count;
    const struct REQ_ENTRY entry[1];
} gc_dump_of_t_reqs_actual = {
    1, {
        { "_gcd" },
    }
};

const struct REQS * const gc_dump_of_t_reqs
    = (const struct REQS *)&gc_dump_of_t_reqs_actual;

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY _gcd;
} gc_dump_of_t_OPS;
extern errcode gcd_tabOPgrind();
extern const OWN_req gcd_tab_ownreqs;
extern struct OPS *gcd_tab_ops;
extern const struct REQS * const gcd_tab_op_grind_of_t_reqs;
extern const OWN_req gcd_tab_op_grind_ownreqs;

typedef struct {
    long gc_dump_own_init;
    const gc_dump_of_t_OPS * const t_ops;
    struct OPS *gcd_tab_op_grind_of_t_ops;
} gc_dump_OWN_DEFN;
const OWN_req gc_dump_ownreqs = { sizeof(gc_dump_OWN_DEFN), 1 };


errcode
gc_dump(CLUREF x, CLUREF fn, CLUREF *ret_1)
{
    errcode err;
    gc_dump_OWN_DEFN *op_own_ptr;
    op_own_ptr = (gc_dump_OWN_DEFN *)CUR_PROC_VAR.proc->op_owns;
    if (op_own_ptr->gc_dump_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)op_own_ptr->t_ops, gcd_tab_op_grind_of_t_reqs);
        find_typeop_instance(gcd_tab_ops, gcd_tabOPgrind, 1, 0, &gcd_tab_op_grind_ownreqs, &gcd_tab_ownreqs, &(op_own_ptr->gcd_tab_op_grind_of_t_ops));
    }
    if (op_own_ptr->gc_dump_own_init == 0) {
        op_own_ptr->gc_dump_own_init = 1;
        /* no own vars to init */
    }
    enter_proc(8);

  LINE(11);
    { /* return */
    {
    CLUREF T_2_1;
    generic_CLU_proc.type_owns = NULL;
    generic_CLU_proc.op_owns = op_own_ptr->gcd_tab_op_grind_of_t_ops->op_owns;
    generic_CLU_proc.proc = gcd_tabOPgrind;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = gcd_tabOPgrind(x, fn, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    ret_1->num = T_2_1.num;
    }
    signal (ERR_ok);
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE gc_dump ****/

