
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


typedef struct {
long count;
} gc_read_of_t_REQS;

gc_read_of_t_REQS gc_read_of_t_reqs_actual = {0};

struct REQS * gc_read_of_t_reqs = (struct REQS *)&gc_read_of_t_reqs_actual;


typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    } gc_read_of_t_OPS;

extern errcode gcbOPinit();
extern errcode gcoOPinit();
extern errcode _chanOPopen();
extern errcode _bytevecOPcreate();
extern errcode _cvt();
extern errcode _chanOPgetb();
extern errcode boolOPnot();
extern errcode charOPequal();
extern errcode _bytevecOPfetch();
extern errcode intOPequal();
extern errcode _wordvecOPfetch();
extern errcode gcrOPpass1();
extern errcode _chanOPclose();
extern errcode gcrOPpass2();
extern errcode gcoOPget_obj();
extern errcode gcoOPreset();
CLUREF STR_read;
CLUREF STR_bad_040file_040format;

typedef struct {
    long gc_read_own_init;
    gc_read_of_t_OPS *t_ops;
    } gc_read_OWN_DEFN;
OWN_req gc_read_ownreqs = {sizeof(gc_read_OWN_DEFN), 1};


/**** BEGIN PROCEDURE gc_read ****/

errcode gc_read(fn, ret_1)
CLUREF fn;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    gc_read_OWN_DEFN *op_own_ptr;
    CLUREF ch;
    CLUREF why;
    CLUREF bv8;
    CLUREF wv2;
    CLUREF result;
    op_own_ptr = (gc_read_OWN_DEFN*) CUR_PROC_VAR.proc->op_owns;
        if (op_own_ptr->gc_read_own_init == 0) {
        stringOPcons("read", CLU_1, CLU_4, &STR_read);
        stringOPcons("bad file format", CLU_1, CLU_15, &STR_bad_040file_040format);
        }
        if (op_own_ptr->gc_read_own_init == 0) {
        op_own_ptr->gc_read_own_init = 1;
    }
    enter_proc(3);

  LINE(11);
    {

  LINE(12);
        {
        err = gcbOPinit();
        if (err != ERR_ok) goto ex_1;
        }

  LINE(13);
        {
        err = gcoOPinit();
        if (err != ERR_ok) goto ex_1;
        }

  LINE(14);
        {
        CLUREF T_4_1;
        err = _chanOPopen(fn, STR_read, CLU_0, &T_4_1);
        if (err != ERR_ok) goto ex_2;
        ch.num = T_4_1.num;
        }
            goto end_2;
            ex_2:
                if ((err == ERR_not_possible)) {
                CLUREF why;
                why.num = elist[0].num;

  LINE(16);
                    {
                    elist[0] = why;
                    {signal (ERR_not_possible);}}
                }
                else {
                    goto ex_1;
                }
            end_2:;

  LINE(18);
        {
            {CLUREF T_3_1;
            err = _bytevecOPcreate(CLU_8, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            bv8.num = T_3_1.num;
            }
            }

  LINE(19);
        {
            {CLUREF T_3_1;
            T_3_1.num = bv8.num;
            wv2.num = T_3_1.num;
            }
            }

  LINE(22);
        {
        CLUREF T_3_1;
        err = _chanOPgetb(ch, bv8, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(27);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        CLUREF T_3_7;
        CLUREF T_3_8;
        CLUREF T_3_9;
        CLUREF T_3_10;
        CLUREF T_3_11;
        CLUREF T_3_12;
        CLUREF T_3_13;
        CLUREF T_3_14;
        CLUREF T_3_15;
        CLUREF T_3_16;
        CLUREF T_3_17;
        CLUREF T_3_18;
        CLUREF T_3_19;
        if (1 < 1 || 1 > bv8.str->size ) {
            err = ERR_bounds;
            goto ex_1;}
        T_3_4.ch = bv8.str->data[1 - 1];
        T_3_5.ch = 'D';
        T_3_6.num = (T_3_4.ch == T_3_5.ch)? true : false;
        T_3_7.num = T_3_6.num ^ 1;
        T_3_3.num = T_3_7.num;
        if (!T_3_7.num) {
            if (2 < 1 || 2 > bv8.str->size ) {
                err = ERR_bounds;
                goto ex_1;}
            T_3_8.ch = bv8.str->data[2 - 1];
            T_3_9.ch = 'W';
            T_3_10.num = (T_3_8.ch == T_3_9.ch)? true : false;
            T_3_11.num = T_3_10.num ^ 1;
            T_3_3.num = T_3_11.num;
        }
        T_3_2.num = T_3_3.num;
        if (!T_3_3.num) {
            if (3 < 1 || 3 > bv8.str->size ) {
                err = ERR_bounds;
                goto ex_1;}
            T_3_12.ch = bv8.str->data[3 - 1];
            T_3_13.ch = 'C';
            T_3_14.num = (T_3_12.ch == T_3_13.ch)? true : false;
            T_3_15.num = T_3_14.num ^ 1;
            T_3_2.num = T_3_15.num;
        }
        T_3_1.num = T_3_2.num;
        if (!T_3_2.num) {
            if (4 < 1 || 4 > bv8.str->size ) {
                err = ERR_bounds;
                goto ex_1;}
            T_3_16.ch = bv8.str->data[4 - 1];
            T_3_17.ch = '1';
            T_3_18.num = (T_3_16.ch == T_3_17.ch)? true : false;
            T_3_19.num = T_3_18.num ^ 1;
            T_3_1.num = T_3_19.num;
        }
        if (T_3_1.num == true) {

  LINE(32);
            {
            elist[0] = STR_bad_040file_040format;
            {signal (ERR_not_possible);}}
            }
            }/* end if */

  LINE(36);
        {
        CLUREF T_3_1;
        err = _chanOPgetb(ch, bv8, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(40);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        if (1 < 1 || (1<<2) > (wv2.str->size)) {
            err = ERR_bounds;
            goto ex_1;}
        T_3_1.num = wv2.vec->data[1 - 1];
        T_3_2.num = (T_3_1.num == 32)? true : false;
        if (T_3_2.num == true) {

  LINE(43);
            {
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            if (2 < 1 || (2<<2) > (wv2.str->size)) {
                err = ERR_bounds;
                goto ex_1;}
            T_4_1.num = wv2.vec->data[2 - 1];
            T_4_2.num = T_4_1.num;
            ret_1->num = T_4_2.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(48);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        if (1 < 1 || (1<<2) > (wv2.str->size)) {
            err = ERR_bounds;
            goto ex_1;}
        T_3_1.num = wv2.vec->data[1 - 1];
        T_3_2.num = (T_3_1.num == 33)? true : false;
        T_3_3.num = T_3_2.num ^ 1;
        if (T_3_3.num == true) {

  LINE(51);
            {
            elist[0] = STR_bad_040file_040format;
            {signal (ERR_not_possible);}}
            }
            }/* end if */

  LINE(53);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        if (2 < 1 || (2<<2) > (wv2.str->size)) {
            err = ERR_bounds;
            goto ex_1;}
        T_3_1.num = wv2.vec->data[2 - 1];
        T_3_2.num = (T_3_1.num == 0)? true : false;
        T_3_3.num = T_3_2.num ^ 1;
        if (T_3_3.num == true) {

  LINE(56);
            {
            elist[0] = STR_bad_040file_040format;
            {signal (ERR_not_possible);}}
            }
            }/* end if */

  LINE(62);
        {
        err = gcrOPpass1(ch);
        if (err != ERR_ok) goto ex_3;
        }
        goto end_3;
        ex_3:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_1;}
        end_3:;

  LINE(64);
        {
        err = _chanOPclose(ch);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(67);
        {
        CLUREF T_3_1;
        err = _chanOPopen(fn, STR_read, CLU_0, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        ch.num = T_3_1.num;
        }

  LINE(68);
        {
        CLUREF T_3_1;
        err = _chanOPgetb(ch, bv8, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(69);
        {
        CLUREF T_4_1;
        err = _chanOPgetb(ch, bv8, &T_4_1);
        if (err != ERR_ok) goto ex_4;
        }
        goto end_4;
        ex_4:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_1;}
        end_4:;

  LINE(74);
        {
        err = gcbOPinit();
        if (err != ERR_ok) goto ex_1;
        }

  LINE(75);
        {
        err = gcrOPpass2(ch);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(76);
        {
        err = _chanOPclose(ch);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(79);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            err = gcoOPget_obj(CLU_0, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            T_3_2.num = T_3_1.num;
            result.num = T_3_2.num;
            }
            }

  LINE(80);
        {
        err = gcoOPreset();
        if (err != ERR_ok) goto ex_1;
        }

  LINE(81);
        {
        {
        ret_1->num = result.num;
        }
        {signal (ERR_ok);}}
        }
        goto end_1;
        ex_1:
            {

  LINE(84);
                {
                err = _chanOPclose(ch);
                if (err != ERR_ok) goto ex_0;
                }

  LINE(85);
                {
                elist[0] = STR_bad_040file_040format;
                {signal (ERR_not_possible);}}
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE gc_read ****/


/**** BEGIN CLUSTER gcr ****/

extern errcode gcbOPget_next_hdr();
extern errcode gcrOPmake_bvec1();
extern errcode gcrOPmake_vec1();
extern errcode gcrOPmake_cell1();
extern errcode gcrOPmake_adv1();
extern errcode gcoOPsave_new_obj();
extern errcode gcbOPget_size();
extern errcode gcbOPgetb();
extern errcode intOPfrom_to();
extern errcode _vecOPcreate();
extern errcode gcbOPskip_obj();
extern errcode _tagcellOPcreate();
extern errcode gcbOPgeti();
extern errcode gcbOPget_array_info();
extern errcode arrayOPpredict();
extern errcode gcrOPmake_bvec2();
extern errcode gcrOPmake_vec2();
extern errcode gcrOPmake_cell2();
extern errcode gcrOPmake_adv2();
extern errcode gcbOPskip();
extern errcode intOPdiv();
extern errcode intOPadd();
extern errcode _vecOPstore();
extern errcode gcbOPget_next_obj();
extern errcode _tagcellOPset();
extern errcode intOPsub();
extern errcode _advOPset_vector();
extern errcode _advOPset_start();
extern errcode _advOPset_size();
extern struct REQS *_tagcell_of_t_reqs;
extern struct OPS *_obj_ops;
extern OWN_req _tagcell_ownreqs;
extern struct OPS *_tagcell_ops;
struct OPS *_tagcell_of__obj_table;
struct OPS *_tagcell_of__obj_ops;
struct OPS *_tagcell_of__obj_ops;
OWNPTR _tagcell_of__obj_owns;
extern struct REQS *_adv_of_t_reqs;
extern OWN_req _adv_ownreqs;
extern struct OPS *_adv_ops;
struct OPS *_adv_of__obj_table;
struct OPS *_adv_of__obj_ops;
struct OPS *_adv_of__obj_ops;
OWNPTR _adv_of__obj_owns;
static int gcr_own_init = 0;
OWN_req gcr_ownreqs = {0,0};
errcode gcr_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (gcr_own_init == 0) {
        add_parm_info_type(0, _obj_ops, _tagcell_of_t_reqs);
        find_type_instance(_tagcell_ops, 1, &_tagcell_ownreqs, &(_tagcell_of__obj_ops));
        add_parm_info_type(0, _obj_ops, _adv_of_t_reqs);
        find_type_instance(_adv_ops, 1, &_adv_ownreqs, &(_adv_of__obj_ops));
        stringOPcons("bad file format", CLU_1, CLU_15, &STR_bad_040file_040format);
        gcr_own_init = 1;
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }

static int gcrOPpass1_own_init = 0;

/**** BEGIN PROCEDURE pass1 ****/

errcode gcrOPpass1(ch)
CLUREF ch;
    {
    errcode err;
    errcode ecode2;
    CLUREF hdr;
    CLUREF id;
    CLUREF o;
        if (gcrOPpass1_own_init == 0) {
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        gcrOPpass1_own_init = 1;
    }
    enter_proc(93);

  LINE(95);
    for (;;) {
        if (true != true) { break; }

  LINE(96);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            err = gcbOPget_next_hdr(ch, &T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            hdr.num = T_3_1.num;
            id.num = T_3_2.num;
            }
            }
            goto end_1;
            ex_1:
                if ((err == ERR_none)) {

  LINE(97);
                    {
                    {signal (ERR_ok);}}
                }
                else {
                    goto ex_0;
                }
            end_1:;

  LINE(98);
        {
        if (true == true) {
            }
            }/* end if */

  LINE(102);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 8192;
        T_2_2.num = (hdr.num == T_2_1.num)? true : false;
        if (T_2_2.num == true) {

  LINE(104);
            {
            if (true == true) {
                }
                }/* end if */

  LINE(107);
            {
            CLUREF T_3_1;
            err = gcrOPmake_bvec1(ch, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            o.num = T_3_1.num;
            }
            }
        else {
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_3.num = 4096;
        T_2_4.num = (hdr.num == T_2_3.num)? true : false;
        if (T_2_4.num == true) {

  LINE(110);
            {
            if (true == true) {
                }
                }/* end if */

  LINE(113);
            {
            CLUREF T_3_1;
            err = gcrOPmake_vec1(ch, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            o.num = T_3_1.num;
            }
            }
        else {
        CLUREF T_2_5;
        CLUREF T_2_6;
        T_2_5.num = 16384;
        T_2_6.num = (hdr.num == T_2_5.num)? true : false;
        if (T_2_6.num == true) {

  LINE(116);
            {
            if (true == true) {
                }
                }/* end if */

  LINE(119);
            {
            CLUREF T_3_1;
            err = gcrOPmake_cell1(ch, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            o.num = T_3_1.num;
            }
            }
        else {
        CLUREF T_2_7;
        CLUREF T_2_8;
        T_2_7.num = 24576;
        T_2_8.num = (hdr.num == T_2_7.num)? true : false;
        if (T_2_8.num == true) {

  LINE(122);
            {
            if (true == true) {

  LINE(125);
                {
                CLUREF T_4_1;
                err = gcrOPmake_adv1(ch, &T_4_1);
                if (err != ERR_ok) goto ex_0;
                o.num = T_4_1.num;
                }
                }
                }/* end if */
            }
        else {

  LINE(128);
            {
            elist[0] = STR_bad_040file_040format;
            {signal (ERR_not_possible);}}
            }}}}}/* end if */

  LINE(130);
        {
        err = gcoOPsave_new_obj(id, o);
        if (err != ERR_ok) goto ex_0;
        }
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE pass1 ****/


/**** BEGIN PROCEDURE make_bvec1 ****/

errcode gcrOPmake_bvec1(ch, ret_1)
CLUREF ch;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF size;
    CLUREF bv;
    CLUREF i;
    CLUREF why;
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(135);

  LINE(136);
    {
        {CLUREF T_1_1;
        err = gcbOPget_size(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        size.num = T_1_1.num;
        }
        }

  LINE(138);
    {
        {CLUREF T_1_1;
        err = _bytevecOPcreate(size, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        bv.num = T_1_1.num;
        }
        }

  LINE(139);
    {

  LINE(140);
        {
        err = gcbOPgetb(ch, bv);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(141);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
            T_3_2.num = size.num;
            for (T_3_1.num = 1; T_3_1.num <= T_3_2.num; T_3_1.num++) {
                i.num = T_3_1.num;
            }
        }
        end_inline_for_1:;
            goto end_1;
            ex_1:
                if ((err == ERR_end_of_file)) {
                }
                else if ((err == ERR_not_possible)) {
                CLUREF why;
                why.num = elist[0].num;
                }
                else {
                    goto ex_0;
                }
            end_1:;
        }

  LINE(150);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = bv.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE make_bvec1 ****/


/**** BEGIN PROCEDURE make_vec1 ****/

errcode gcrOPmake_vec1(ch, ret_1)
CLUREF ch;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF size;
    CLUREF v;
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(153);

  LINE(154);
    {
        {CLUREF T_1_1;
        err = gcbOPget_size(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        size.num = T_1_1.num;
        }
        }

  LINE(155);
    {
        {CLUREF T_1_1;
        err = _vecOPcreate(size, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        v.num = T_1_1.num;
        }
        }

  LINE(156);
    {
    err = gcbOPskip_obj(ch, size);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(157);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = v.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE make_vec1 ****/

struct OPS *_tagcell_of__obj_table;
struct OPS *_tagcell_of__obj_ops;
struct OPS *_tagcell_of__obj_ops;
OWNPTR _tagcell_of__obj_owns;
static int gcrOPmake_cell1_own_init = 0;

/**** BEGIN PROCEDURE make_cell1 ****/

errcode gcrOPmake_cell1(ch, ret_1)
CLUREF ch;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF t;
        if (gcrOPmake_cell1_own_init == 0) {
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        gcrOPmake_cell1_own_init = 1;
    }
    enter_proc(160);

  LINE(161);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = 0;
        generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
        generic_CLU_proc.proc = _tagcellOPcreate;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = _tagcellOPcreate(CLU_0, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        t.num = T_1_2.num;
        }
        }

  LINE(162);
    {
    CLUREF T_1_1;
    err = gcbOPgeti(ch, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(163);
    {
    err = gcbOPskip_obj(ch, CLU_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(164);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = t.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE make_cell1 ****/


/**** BEGIN PROCEDURE make_adv1 ****/

errcode gcrOPmake_adv1(ch, ret_1)
CLUREF ch;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF size;
    CLUREF ext_size;
    CLUREF ext_low;
    CLUREF int_low;
    CLUREF int_size;
    CLUREF a;
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(167);

  LINE(168);
    {
        {CLUREF T_1_1;
        err = gcbOPget_size(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        size.num = T_1_1.num;
        }
        }

  LINE(169);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        err = gcbOPget_array_info(ch, &T_1_1, &T_1_2, &T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        ext_size.num = T_1_1.num;
        ext_low.num = T_1_2.num;
        int_low.num = T_1_3.num;
        int_size.num = T_1_4.num;
        }
        }

  LINE(170);
    {
        {CLUREF T_1_1;
        err = arrayOPpredict(ext_low, int_size, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        a.num = T_1_1.num;
        }
        }

  LINE(171);
    {
    err = gcbOPskip_obj(ch, CLU_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(172);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = a.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE make_adv1 ****/

static int gcrOPpass2_own_init = 0;

/**** BEGIN PROCEDURE pass2 ****/

errcode gcrOPpass2(ch)
CLUREF ch;
    {
    errcode err;
    errcode ecode2;
    CLUREF hdr;
    CLUREF id;
    CLUREF o;
        if (gcrOPpass2_own_init == 0) {
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        gcrOPpass2_own_init = 1;
    }
    enter_proc(175);

  LINE(177);
    for (;;) {
        if (true != true) { break; }

  LINE(178);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            err = gcbOPget_next_hdr(ch, &T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            hdr.num = T_3_1.num;
            id.num = T_3_2.num;
            }
            }
            goto end_1;
            ex_1:
                if ((err == ERR_none)) {

  LINE(179);
                    {
                    {signal (ERR_ok);}}
                }
                else {
                    goto ex_0;
                }
            end_1:;

  LINE(181);
        {
            {CLUREF T_2_1;
            err = gcoOPget_obj(id, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            o.num = T_2_1.num;
            }
            }

  LINE(182);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 8192;
        T_2_2.num = (hdr.num == T_2_1.num)? true : false;
        if (T_2_2.num == true) {

  LINE(185);
            {
            err = gcrOPmake_bvec2(ch, o);
            if (err != ERR_ok) goto ex_0;
            }
            }
        else {
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_3.num = 4096;
        T_2_4.num = (hdr.num == T_2_3.num)? true : false;
        if (T_2_4.num == true) {

  LINE(188);
            {
            err = gcrOPmake_vec2(ch, o);
            if (err != ERR_ok) goto ex_0;
            }
            }
        else {
        CLUREF T_2_5;
        CLUREF T_2_6;
        T_2_5.num = 16384;
        T_2_6.num = (hdr.num == T_2_5.num)? true : false;
        if (T_2_6.num == true) {

  LINE(191);
            {
            err = gcrOPmake_cell2(ch, o);
            if (err != ERR_ok) goto ex_0;
            }
            }
        else {
        CLUREF T_2_7;
        CLUREF T_2_8;
        T_2_7.num = 24576;
        T_2_8.num = (hdr.num == T_2_7.num)? true : false;
        if (T_2_8.num == true) {

  LINE(194);
            {
            err = gcrOPmake_adv2(ch, o);
            if (err != ERR_ok) goto ex_0;
            }
            }
        else {

  LINE(196);
            {
            elist[0] = STR_bad_040file_040format;
            {signal (ERR_not_possible);}}
            }}}}}/* end if */
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE pass2 ****/


/**** BEGIN PROCEDURE make_bvec2 ****/

errcode gcrOPmake_bvec2(ch, o)
CLUREF ch;
CLUREF o;
    {
    errcode err;
    errcode ecode2;
    CLUREF size;
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(202);

  LINE(203);
    {
        {CLUREF T_1_1;
        err = gcbOPget_size(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        size.num = T_1_1.num;
        }
        }

  LINE(204);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = size.num + 4;
     if ((T_1_1.num > 0 && size.num < 0 && 4 < 0) || 
         (T_1_1.num < 0 && size.num > 0 && 4 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    err = intOPdiv(T_1_1, CLU_4, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    err = gcbOPskip(ch, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE make_bvec2 ****/


/**** BEGIN PROCEDURE make_vec2 ****/

errcode gcrOPmake_vec2(ch, o)
CLUREF ch;
CLUREF o;
    {
    errcode err;
    errcode ecode2;
    CLUREF size;
    CLUREF v;
    CLUREF i;
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(207);

  LINE(208);
    {
        {CLUREF T_1_1;
        err = gcbOPget_size(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        size.num = T_1_1.num;
        }
        }

  LINE(209);
    {
        {CLUREF T_1_1;
        T_1_1.num = o.num;
        v.num = T_1_1.num;
        }
        }

  LINE(210);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = size.num;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(211);
            {
            CLUREF T_2_1;
            err = gcbOPget_next_obj(ch, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            err = _vecOPstore(v, i, T_2_1);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE make_vec2 ****/

struct OPS *_tagcell_of__obj_table;
struct OPS *_tagcell_of__obj_ops;
struct OPS *_tagcell_of__obj_ops;
OWNPTR _tagcell_of__obj_owns;
static int gcrOPmake_cell2_own_init = 0;

/**** BEGIN PROCEDURE make_cell2 ****/

errcode gcrOPmake_cell2(ch, o)
CLUREF ch;
CLUREF o;
    {
    errcode err;
    errcode ecode2;
    CLUREF t;
    CLUREF tg;
        if (gcrOPmake_cell2_own_init == 0) {
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        gcrOPmake_cell2_own_init = 1;
    }
    enter_proc(215);

  LINE(216);
    {
        {CLUREF T_1_1;
        T_1_1.num = o.num;
        t.num = T_1_1.num;
        }
        }

  LINE(217);
    {
        {CLUREF T_1_1;
        err = gcbOPgeti(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        tg.num = T_1_1.num;
        }
        }

  LINE(218);
    {
    CLUREF T_1_1;
    err = gcbOPget_next_obj(ch, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _tagcellOPset;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _tagcellOPset(t, tg, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE make_cell2 ****/

struct OPS *_adv_of__obj_table;
struct OPS *_adv_of__obj_ops;
struct OPS *_adv_of__obj_ops;
OWNPTR _adv_of__obj_owns;
static int gcrOPmake_adv2_own_init = 0;

/**** BEGIN PROCEDURE make_adv2 ****/

errcode gcrOPmake_adv2(ch, o)
CLUREF ch;
CLUREF o;
    {
    errcode err;
    errcode ecode2;
    CLUREF size;
    CLUREF a;
    CLUREF j1;
    CLUREF j2;
    CLUREF j3;
    CLUREF j4;
    CLUREF v;
        if (gcrOPmake_adv2_own_init == 0) {
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        gcrOPmake_adv2_own_init = 1;
    }
    enter_proc(221);

  LINE(222);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = gcbOPget_size(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = T_1_1.num - 8;
         if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-8) < 0) || 
             (T_1_2.num <= 0 && T_1_1.num > 0 && (-8) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        size.num = T_1_2.num;
        }
        }

  LINE(224);
    {
        {CLUREF T_1_1;
        T_1_1.num = o.num;
        a.num = T_1_1.num;
        }
        }

  LINE(225);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        err = gcbOPget_array_info(ch, &T_1_1, &T_1_2, &T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        j1.num = T_1_1.num;
        j2.num = T_1_2.num;
        j3.num = T_1_3.num;
        j4.num = T_1_4.num;
        }
        }

  LINE(231);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        err = gcbOPget_next_obj(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_2.num = T_1_1.num;
        v.num = T_1_2.num;
        }
        }

  LINE(233);
    {
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPset_vector;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPset_vector(a, v);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(235);
    {
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPset_start;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPset_start(a, j3);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(236);
    {
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPset_size;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPset_size(a, j1);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE make_adv2 ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[2];
} gcr_OPS;

CLU_proc gcr_oe_pass1 = {{0,0,0,0}, gcrOPpass1, 0};
CLU_proc gcr_oe_pass2 = {{0,0,0,0}, gcrOPpass2, 0};

gcr_OPS gcr_ops_actual = {2, (OWNPTR)&gcr_own_init, (OWNPTR)&gcr_own_init, {
    {&gcr_oe_pass1, "pass1"},
    {&gcr_oe_pass2, "pass2"}}};

struct OPS *gcr_ops = (struct OPS *)&gcr_ops_actual;

/**** END CLUSTER gcr ****/

/**** BEGIN CLUSTER gcb ****/

extern errcode _wordvecOPcreate();
extern errcode _chanOPgetw();
extern errcode _bytevecOPsize();
extern errcode intOPmul();
extern errcode intOPlt();
extern errcode intOPmin();
extern errcode _wordvecOPmove_w2b();
CLUREF STR_bad_040format_040file;
static int gcb_own_init = 0;
OWN_req gcb_ownreqs = {0,0};
CLUREF gcbOPlookahead;
CLUREF gcbOPlook_index;
CLUREF gcbOPlook_count;
CLUREF gcbOPscratch;
CLUREF gcbOPobj_addr;
CLUREF gcbOPwv1;
errcode gcb_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (gcb_own_init == 0) {
        stringOPcons("bad format file", CLU_1, CLU_15, &STR_bad_040format_040file);
        gcb_own_init = 1;
        {
            {CLUREF T_0_1;
            CLUREF T_0_2;
            T_0_1.num = 4096;
            err = _wordvecOPcreate(T_0_1, &T_0_2);
            if (err != ERR_ok) goto ex_0;
            gcbOPlookahead.num = T_0_2.num;
            }
            }
        {
            {gcbOPlook_index.num = 0;
            }
            }
        {
            {gcbOPlook_count.num = 0;
            }
            }
        {
            {CLUREF T_0_3;
            CLUREF T_0_4;
            T_0_3.num = 4096;
            err = _bytevecOPcreate(T_0_3, &T_0_4);
            if (err != ERR_ok) goto ex_0;
            gcbOPscratch.num = T_0_4.num;
            }
            }
        {
            {gcbOPobj_addr.num = 0;
            }
            }
        {
            {CLUREF T_0_5;
            err = _wordvecOPcreate(CLU_1, &T_0_5);
            if (err != ERR_ok) goto ex_0;
            gcbOPwv1.num = T_0_5.num;
            }
            }
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE init ****/

errcode gcbOPinit()
    {
    errcode err;
    errcode ecode2;
        if (gcb_own_init == 0) {
            err = gcb_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(253);

  LINE(254);
    {
    gcbOPobj_addr.num = 0;
    }

  LINE(255);
    {
    gcbOPlook_index.num = 0;
    }

  LINE(256);
    {
    gcbOPlook_count.num = 0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE init ****/


/**** BEGIN PROCEDURE get_next_hdr ****/

errcode gcbOPget_next_hdr(ch, ret_1, ret_2)
CLUREF ch;
CLUREF *ret_1;
CLUREF *ret_2;
    {
    errcode err;
    errcode ecode2;
    CLUREF this_addr;
    CLUREF hdr;
        if (gcb_own_init == 0) {
            err = gcb_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(259);

  LINE(261);
    {
        {this_addr.num = gcbOPobj_addr.num;
        }
        }

  LINE(262);
    {
        {CLUREF T_2_1;
        err = gcbOPgeti(ch, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        hdr.num = T_2_1.num;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_end_of_file)) {

  LINE(263);
                {
                {signal (ERR_none);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(264);
    {
    {
    ret_1->num = hdr.num;
    }
    {
    ret_2->num = this_addr.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_next_hdr ****/


/**** BEGIN PROCEDURE get_size ****/

errcode gcbOPget_size(ch, ret_1)
CLUREF ch;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF size;
        if (gcb_own_init == 0) {
            err = gcb_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(267);

  LINE(268);
    {
        {CLUREF T_1_1;
        err = gcbOPgeti(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        size.num = T_1_1.num;
        }
        }

  LINE(269);
    {
    {
    ret_1->num = size.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_size ****/


/**** BEGIN PROCEDURE get_array_info ****/

errcode gcbOPget_array_info(ch, ret_1, ret_2, ret_3, ret_4)
CLUREF ch;
CLUREF *ret_1;
CLUREF *ret_2;
CLUREF *ret_3;
CLUREF *ret_4;
    {
    errcode err;
    errcode ecode2;
    CLUREF size;
    CLUREF low;
    CLUREF start;
    CLUREF predict;
        if (gcb_own_init == 0) {
            err = gcb_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(272);

  LINE(273);
    {
        {CLUREF T_1_1;
        err = gcbOPgeti(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        size.num = T_1_1.num;
        }
        }

  LINE(274);
    {
        {CLUREF T_1_1;
        err = gcbOPgeti(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        low.num = T_1_1.num;
        }
        }

  LINE(275);
    {
        {CLUREF T_1_1;
        err = gcbOPgeti(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        start.num = T_1_1.num;
        }
        }

  LINE(276);
    {
        {CLUREF T_1_1;
        err = gcbOPgeti(ch, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        predict.num = T_1_1.num;
        }
        }

  LINE(277);
    {
    {
    ret_1->num = size.num;
    }
    {
    ret_2->num = low.num;
    }
    {
    ret_3->num = start.num;
    }
    {
    ret_4->num = predict.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_array_info ****/

static int gcbOPget_next_obj_own_init = 0;

/**** BEGIN PROCEDURE get_next_obj ****/

errcode gcbOPget_next_obj(ch, ret_1)
CLUREF ch;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ty;
    CLUREF val;
        if (gcbOPget_next_obj_own_init == 0) {
        if (gcb_own_init == 0) {
            err = gcb_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        gcbOPget_next_obj_own_init = 1;
    }
    enter_proc(280);

  LINE(282);
    for (;;) {
        if (true != true) { break; }

  LINE(284);
        {
        CLUREF T_3_1;
        err = gcbOPgeti(ch, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        ty.num = T_3_1.num;
        }
            goto end_1;
            ex_1:
                if ((err == ERR_end_of_file)) {

  LINE(285);
                    {
                    {signal (ERR_none);}}
                }
                else {
                    goto ex_0;
                }
            end_1:;

  LINE(286);
        {
        CLUREF T_3_1;
        err = gcbOPgeti(ch, &T_3_1);
        if (err != ERR_ok) goto ex_2;
        val.num = T_3_1.num;
        }
            goto end_2;
            ex_2:
                if ((err == ERR_end_of_file)) {

  LINE(288);
                    {
                    elist[0] = STR_bad_040format_040file;
                    {signal (ERR_not_possible);}}
                }
                else {
                    goto ex_0;
                }
            end_2:;

  LINE(289);
        {
        CLUREF T_2_1;
        T_2_1.num = (ty.num == 32)? true : false;
        if (T_2_1.num == true) {

  LINE(291);
            {
            {
            CLUREF T_3_1;
            T_3_1.num = val.num;
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            }
        else {
        CLUREF T_2_2;
        T_2_2.num = (ty.num == 33)? true : false;
        if (T_2_2.num == true) {

  LINE(294);
            {
            {
            CLUREF T_3_1;
            err = gcoOPget_obj(val, &T_3_1);
            if (err != ERR_ok) goto ex_0;
            ret_1->num = T_3_1.num;
            }
            {signal (ERR_ok);}}
            }
        else {

  LINE(296);
            {
            elist[0] = STR_bad_040format_040file;
            {signal (ERR_not_possible);}}
            }}}/* end if */
        }
        end_while_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_next_obj ****/

static int gcbOPskip_obj_own_init = 0;

/**** BEGIN PROCEDURE skip_obj ****/

errcode gcbOPskip_obj(ch, count)
CLUREF ch;
CLUREF count;
    {
    errcode err;
    errcode ecode2;
    CLUREF i;
    CLUREF ty;
    CLUREF val;
        if (gcbOPskip_obj_own_init == 0) {
        if (gcb_own_init == 0) {
            err = gcb_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        gcbOPskip_obj_own_init = 1;
    }
    enter_proc(301);

  LINE(302);
    {
    CLUREF T_1_1;
    T_1_1.num = (count.num == 0)? true : false;
    if (T_1_1.num == true) {
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(303);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
        T_1_2.num = count.num;
        for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            i.num = T_1_1.num;

  LINE(304);
            {
                {CLUREF T_3_1;
                err = gcbOPgeti(ch, &T_3_1);
                if (err != ERR_ok) goto ex_1;
                ty.num = T_3_1.num;
                }
                }
                goto end_1;
                ex_1:
                    if ((err == ERR_end_of_file)) {

  LINE(305);
                        {
                        {signal (ERR_none);}}
                    }
                    else {
                        goto ex_0;
                    }
                end_1:;

  LINE(306);
            {
                {CLUREF T_3_1;
                err = gcbOPgeti(ch, &T_3_1);
                if (err != ERR_ok) goto ex_2;
                val.num = T_3_1.num;
                }
                }
                goto end_2;
                ex_2:
                    if ((err == ERR_end_of_file)) {

  LINE(308);
                        {
                        elist[0] = STR_bad_040format_040file;
                        {signal (ERR_not_possible);}}
                    }
                    else {
                        goto ex_0;
                    }
                end_2:;

  LINE(309);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            T_2_2.num = (ty.num == 32)? true : false;
            T_2_3.num = T_2_2.num ^ 1;
            T_2_1.num = T_2_3.num;
            if (T_2_3.num) {
                T_2_4.num = (ty.num == 33)? true : false;
                T_2_5.num = T_2_4.num ^ 1;
                T_2_1.num = T_2_5.num;
            }
            if (T_2_1.num == true) {

  LINE(311);
                {
                elist[0] = STR_bad_040format_040file;
                {signal (ERR_not_possible);}}
                }
                }/* end if */
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE skip_obj ****/


/**** BEGIN PROCEDURE geti ****/

errcode gcbOPgeti(ch, ret_1)
CLUREF ch;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ans;
        if (gcb_own_init == 0) {
            err = gcb_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(316);

  LINE(318);
    {
    CLUREF T_1_1;
    T_1_1.num = (gcbOPlook_count.num == 0)? true : false;
    if (T_1_1.num == true) {

  LINE(319);
        {
        CLUREF T_3_1;
        err = _chanOPgetw(ch, gcbOPlookahead, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        gcbOPlook_count.num = T_3_1.num;
        }
        goto end_1;
        ex_1:
            if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
            else {
                goto ex_0;}
        end_1:;

  LINE(321);
        {
        gcbOPlook_index.num = 1;
        }
        }
        }/* end if */

  LINE(323);
    {
        {CLUREF T_1_1;
        if (gcbOPlook_index.num < 1 || (gcbOPlook_index.num<<2) > (gcbOPlookahead.str->size)) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_1.num = gcbOPlookahead.vec->data[gcbOPlook_index.num - 1];
        ans.num = T_1_1.num;
        }
        }

  LINE(324);
    {
    CLUREF T_1_1;
    T_1_1.num = gcbOPlook_count.num - 4;
     if ((T_1_1.num >= 0 && gcbOPlook_count.num < 0 && (-4) < 0) || 
         (T_1_1.num <= 0 && gcbOPlook_count.num > 0 && (-4) > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcbOPlook_count.num = T_1_1.num;
    }

  LINE(325);
    {
    CLUREF T_1_1;
    T_1_1.num = gcbOPlook_index.num + 1;
     if ((T_1_1.num > 0 && gcbOPlook_index.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcbOPlook_index.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcbOPlook_index.num = T_1_1.num;
    }

  LINE(326);
    {
    CLUREF T_1_1;
    T_1_1.num = gcbOPobj_addr.num + 4;
     if ((T_1_1.num > 0 && gcbOPobj_addr.num < 0 && 4 < 0) || 
         (T_1_1.num < 0 && gcbOPobj_addr.num > 0 && 4 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcbOPobj_addr.num = T_1_1.num;
    }

  LINE(327);
    {
    {
    ret_1->num = ans.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE geti ****/


/**** BEGIN PROCEDURE getb ****/

errcode gcbOPgetb(ch, b)
CLUREF ch;
CLUREF b;
    {
    errcode err;
    errcode ecode2;
    CLUREF copied;
    CLUREF data_count;
    CLUREF pad_count;
    CLUREF b_index;
    CLUREF count;
        if (gcb_own_init == 0) {
            err = gcb_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(330);

  LINE(332);
    {
        {copied.num = 0;
        }
        }

  LINE(333);
    {
        {CLUREF T_1_1;
        err = _bytevecOPsize(b, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        data_count.num = T_1_1.num;
        }
        }

  LINE(334);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        T_1_1.num = data_count.num + 4;
         if ((T_1_1.num > 0 && data_count.num < 0 && 4 < 0) || 
             (T_1_1.num < 0 && data_count.num > 0 && 4 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = intOPdiv(T_1_1, CLU_4, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        err = intOPmul(T_1_2, CLU_4, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_4.num = T_1_3.num - data_count.num;
         if ((T_1_4.num >= 0 && T_1_3.num < 0 && (-data_count.num) < 0) || 
             (T_1_4.num <= 0 && T_1_3.num > 0 && (-data_count.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        pad_count.num = T_1_4.num;
        }
        }

  LINE(335);
    {
        {b_index.num = 1;
        }
        }

  LINE(336);
    for (;;) {
        CLUREF T_1_1;
        T_1_1.num = (copied.num < data_count.num)? true : false;
        if (T_1_1.num != true) { break; }

  LINE(337);
        {
        CLUREF T_2_1;
        T_2_1.num = (gcbOPlook_count.num == 0)? true : false;
        if (T_2_1.num == true) {

  LINE(338);
            {
            CLUREF T_4_1;
            err = _chanOPgetw(ch, gcbOPlookahead, &T_4_1);
            if (err != ERR_ok) goto ex_1;
            gcbOPlook_count.num = T_4_1.num;
            }
            goto end_1;
            ex_1:
                if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
                else {
                    goto ex_0;}
            end_1:;

  LINE(340);
            {
            gcbOPlook_index.num = 1;
            }
            }
            }/* end if */

  LINE(342);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            T_2_1.num = data_count.num - b_index.num;
             if ((T_2_1.num >= 0 && data_count.num < 0 && (-b_index.num) < 0) || 
                 (T_2_1.num <= 0 && data_count.num > 0 && (-b_index.num) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            T_2_2.num = T_2_1.num + 1;
             if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) || 
                 (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            err = intOPmin(T_2_2, gcbOPlook_count, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            count.num = T_2_3.num;
            }
            }

  LINE(343);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = gcbOPlook_index.num - 1;
         if ((T_2_1.num >= 0 && gcbOPlook_index.num < 0 && (-1) < 0) || 
             (T_2_1.num <= 0 && gcbOPlook_index.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = intOPmul(T_2_1, CLU_4, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        T_2_3.num = T_2_2.num + 1;
         if ((T_2_3.num > 0 && T_2_2.num < 0 && 1 < 0) || 
             (T_2_3.num < 0 && T_2_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = _wordvecOPmove_w2b(gcbOPlookahead, T_2_3, b, b_index, count);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(344);
        {
        CLUREF T_2_1;
        T_2_1.num = gcbOPlook_count.num - count.num;
         if ((T_2_1.num >= 0 && gcbOPlook_count.num < 0 && (-count.num) < 0) || 
             (T_2_1.num <= 0 && gcbOPlook_count.num > 0 && (-count.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        gcbOPlook_count.num = T_2_1.num;
        }

  LINE(345);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = intOPdiv(count, CLU_4, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        T_2_2.num = gcbOPlook_index.num + T_2_1.num;
         if ((T_2_2.num > 0 && gcbOPlook_index.num < 0 && T_2_1.num < 0) || 
             (T_2_2.num < 0 && gcbOPlook_index.num > 0 && T_2_1.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        gcbOPlook_index.num = T_2_2.num;
        }

  LINE(346);
        {
        CLUREF T_2_1;
        T_2_1.num = b_index.num + count.num;
         if ((T_2_1.num > 0 && b_index.num < 0 && count.num < 0) || 
             (T_2_1.num < 0 && b_index.num > 0 && count.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        b_index.num = T_2_1.num;
        }

  LINE(347);
        {
        CLUREF T_2_1;
        T_2_1.num = copied.num + count.num;
         if ((T_2_1.num > 0 && copied.num < 0 && count.num < 0) || 
             (T_2_1.num < 0 && copied.num > 0 && count.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        copied.num = T_2_1.num;
        }
        }
        end_while_1:;

  LINE(349);
    {
    CLUREF T_1_1;
    T_1_1.num = (gcbOPlook_count.num == 0)? true : false;
    if (T_1_1.num == true) {

  LINE(350);
        {
        CLUREF T_3_1;
        err = _chanOPgetw(ch, gcbOPlookahead, &T_3_1);
        if (err != ERR_ok) goto ex_2;
        gcbOPlook_count.num = T_3_1.num;
        }
        goto end_2;
        ex_2:
            if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
            else {
                goto ex_0;}
        end_2:;

  LINE(352);
        {
        gcbOPlook_index.num = 1;
        }
        }
        }/* end if */

  LINE(354);
    {
    CLUREF T_1_1;
    T_1_1.num = gcbOPlook_count.num - pad_count.num;
     if ((T_1_1.num >= 0 && gcbOPlook_count.num < 0 && (-pad_count.num) < 0) || 
         (T_1_1.num <= 0 && gcbOPlook_count.num > 0 && (-pad_count.num) > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcbOPlook_count.num = T_1_1.num;
    }

  LINE(355);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = (pad_count.num == 0)? true : false;
    T_1_2.num = T_1_1.num ^ 1;
    if (T_1_2.num == true) {
        {
        CLUREF T_2_1;
        T_2_1.num = gcbOPlook_index.num + 1;
         if ((T_2_1.num > 0 && gcbOPlook_index.num < 0 && 1 < 0) || 
             (T_2_1.num < 0 && gcbOPlook_index.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        gcbOPlook_index.num = T_2_1.num;
        }
        }
        }/* end if */

  LINE(356);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = gcbOPobj_addr.num + data_count.num;
     if ((T_1_1.num > 0 && gcbOPobj_addr.num < 0 && data_count.num < 0) || 
         (T_1_1.num < 0 && gcbOPobj_addr.num > 0 && data_count.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    T_1_2.num = T_1_1.num + pad_count.num;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && pad_count.num < 0) || 
         (T_1_2.num < 0 && T_1_1.num > 0 && pad_count.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcbOPobj_addr.num = T_1_2.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE getb ****/


/**** BEGIN PROCEDURE skip ****/

errcode gcbOPskip(ch, i)
CLUREF ch;
CLUREF i;
    {
    errcode err;
    errcode ecode2;
    CLUREF i4;
    CLUREF skipped;
    CLUREF count;
        if (gcb_own_init == 0) {
            err = gcb_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(359);

  LINE(361);
    {
        {CLUREF T_1_1;
        err = intOPmul(i, CLU_4, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        i4.num = T_1_1.num;
        }
        }

  LINE(362);
    {
        {skipped.num = 0;
        }
        }

  LINE(363);
    for (;;) {
        CLUREF T_1_1;
        T_1_1.num = (skipped.num < i4.num)? true : false;
        if (T_1_1.num != true) { break; }

  LINE(364);
        {
        CLUREF T_2_1;
        T_2_1.num = (gcbOPlook_count.num == 0)? true : false;
        if (T_2_1.num == true) {

  LINE(365);
            {
            CLUREF T_4_1;
            err = _chanOPgetw(ch, gcbOPlookahead, &T_4_1);
            if (err != ERR_ok) goto ex_1;
            gcbOPlook_count.num = T_4_1.num;
            }
            goto end_1;
            ex_1:
                if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
                else {
                    goto ex_0;}
            end_1:;

  LINE(367);
            {
            gcbOPlook_index.num = 1;
            }
            }
            }/* end if */

  LINE(369);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = i4.num - skipped.num;
             if ((T_2_1.num >= 0 && i4.num < 0 && (-skipped.num) < 0) || 
                 (T_2_1.num <= 0 && i4.num > 0 && (-skipped.num) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            err = intOPmin(T_2_1, gcbOPlook_count, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            count.num = T_2_2.num;
            }
            }

  LINE(370);
        {
        CLUREF T_2_1;
        T_2_1.num = gcbOPlook_count.num - count.num;
         if ((T_2_1.num >= 0 && gcbOPlook_count.num < 0 && (-count.num) < 0) || 
             (T_2_1.num <= 0 && gcbOPlook_count.num > 0 && (-count.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        gcbOPlook_count.num = T_2_1.num;
        }

  LINE(371);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = intOPdiv(count, CLU_4, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        T_2_2.num = gcbOPlook_index.num + T_2_1.num;
         if ((T_2_2.num > 0 && gcbOPlook_index.num < 0 && T_2_1.num < 0) || 
             (T_2_2.num < 0 && gcbOPlook_index.num > 0 && T_2_1.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        gcbOPlook_index.num = T_2_2.num;
        }

  LINE(372);
        {
        CLUREF T_2_1;
        T_2_1.num = skipped.num + count.num;
         if ((T_2_1.num > 0 && skipped.num < 0 && count.num < 0) || 
             (T_2_1.num < 0 && skipped.num > 0 && count.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        skipped.num = T_2_1.num;
        }
        }
        end_while_1:;

  LINE(374);
    {
    CLUREF T_1_1;
    T_1_1.num = gcbOPobj_addr.num + i4.num;
     if ((T_1_1.num > 0 && gcbOPobj_addr.num < 0 && i4.num < 0) || 
         (T_1_1.num < 0 && gcbOPobj_addr.num > 0 && i4.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcbOPobj_addr.num = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE skip ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[9];
} gcb_OPS;

CLU_proc gcb_oe_get_array_info = {{0,0,0,0}, gcbOPget_array_info, 0};
CLU_proc gcb_oe_get_next_hdr = {{0,0,0,0}, gcbOPget_next_hdr, 0};
CLU_proc gcb_oe_get_next_obj = {{0,0,0,0}, gcbOPget_next_obj, 0};
CLU_proc gcb_oe_get_size = {{0,0,0,0}, gcbOPget_size, 0};
CLU_proc gcb_oe_getb = {{0,0,0,0}, gcbOPgetb, 0};
CLU_proc gcb_oe_geti = {{0,0,0,0}, gcbOPgeti, 0};
CLU_proc gcb_oe_init = {{0,0,0,0}, gcbOPinit, 0};
CLU_proc gcb_oe_skip = {{0,0,0,0}, gcbOPskip, 0};
CLU_proc gcb_oe_skip_obj = {{0,0,0,0}, gcbOPskip_obj, 0};

gcb_OPS gcb_ops_actual = {9, (OWNPTR)&gcb_own_init, (OWNPTR)&gcb_own_init, {
    {&gcb_oe_get_array_info, "get_array_info"},
    {&gcb_oe_get_next_hdr, "get_next_hdr"},
    {&gcb_oe_get_next_obj, "get_next_obj"},
    {&gcb_oe_get_size, "get_size"},
    {&gcb_oe_getb, "getb"},
    {&gcb_oe_geti, "geti"},
    {&gcb_oe_init, "init"},
    {&gcb_oe_skip, "skip"},
    {&gcb_oe_skip_obj, "skip_obj"}}};

struct OPS *gcb_ops = (struct OPS *)&gcb_ops_actual;

/**** END CLUSTER gcb ****/

/**** BEGIN CLUSTER gco ****/

extern errcode arrayOPfill();
extern errcode hash_int();
extern errcode arrayOPfetch();
extern errcode _objOPequal();
extern errcode recordOPget_1();
extern errcode recordOPget_2();
extern errcode recordOPget_3();
extern errcode arrayOPstore();
extern errcode arrayOPnew();
static int gco_own_init = 1;
OWN_req gco_ownreqs = {0,0};
CLUREF gcoOPobj_store;

/**** BEGIN PROCEDURE init ****/

errcode gcoOPinit()
    {
    errcode err;
    errcode ecode2;
    CLUREF no_bucket;
    enter_proc(390);

  LINE(391);
    {
        {CLUREF T_1_1;
        T_1_1.num = nil;
        no_bucket.num = T_1_1.num;
        }
        }

  LINE(392);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = 50000;
    err = arrayOPfill(CLU_1, T_1_1, no_bucket, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    gcoOPobj_store.num = T_1_2.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE init ****/


/**** BEGIN PROCEDURE get_obj ****/

errcode gcoOPget_obj(i, ret_1)
CLUREF i;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF k;
    CLUREF this_buck;
    enter_proc(395);

  LINE(397);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = 50000;
        err = hash_int(i, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = T_1_2.num + 1;
         if ((T_1_3.num > 0 && T_1_2.num < 0 && 1 < 0) || 
             (T_1_3.num < 0 && T_1_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        k.num = T_1_3.num;
        }
        }

  LINE(398);
    {
        {CLUREF T_1_1;
        if (k.num < gcoOPobj_store.array->ext_low || k.num > gcoOPobj_store.array->ext_high ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_1.num = gcoOPobj_store.array->store->data[k.num - gcoOPobj_store.array->ext_low + gcoOPobj_store.array->int_low];
        this_buck.num = T_1_1.num;
        }
        }

  LINE(399);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        CLUREF T_1_6;
        CLUREF T_1_7;
        CLUREF T_1_8;
        T_1_2.num = this_buck.num;
        T_1_3.num = nil;
        T_1_4.num = (T_1_2.num == T_1_3.num)? true : false;
        T_1_5.num = T_1_4.num ^ 1;
        T_1_1.num = T_1_5.num;
        if (T_1_5.num) {
            T_1_6.num = this_buck.vec->data[0];
            T_1_7.num = (T_1_6.num == i.num)? true : false;
            T_1_8.num = T_1_7.num ^ 1;
            T_1_1.num = T_1_8.num;
        }
        if (T_1_1.num != true) { break; }

  LINE(400);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = this_buck.vec->data[1];
        T_2_2.num = T_2_1.num;
        this_buck.num = T_2_2.num;
        }
        }
        end_while_1:;

  LINE(402);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = this_buck.num;
    T_1_2.num = nil;
    T_1_3.num = (T_1_1.num == T_1_2.num)? true : false;
    if (T_1_3.num == true) {
        {
        {signal (ERR_not_found);}}
        }
        }/* end if */

  LINE(403);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = this_buck.vec->data[2];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_obj ****/


/**** BEGIN PROCEDURE save_new_obj ****/

errcode gcoOPsave_new_obj(i, o)
CLUREF i;
CLUREF o;
    {
    errcode err;
    errcode ecode2;
    CLUREF k;
    CLUREF this_buck;
    enter_proc(406);

  LINE(407);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = 50000;
        err = hash_int(i, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = T_1_2.num + 1;
         if ((T_1_3.num > 0 && T_1_2.num < 0 && 1 < 0) || 
             (T_1_3.num < 0 && T_1_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        k.num = T_1_3.num;
        }
        }

  LINE(408);
    {
        {CLUREF T_1_1;
        if (k.num < gcoOPobj_store.array->ext_low || k.num > gcoOPobj_store.array->ext_high ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_1.num = gcoOPobj_store.array->store->data[k.num - gcoOPobj_store.array->ext_low + gcoOPobj_store.array->int_low];
        this_buck.num = T_1_1.num;
        }
        }

  LINE(409);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(3, T_1_1);
    T_1_1.vec->data[0]  = i.num;
    T_1_1.vec->data[2]  = o.num;
    T_1_2.num = this_buck.num;
    T_1_1.vec->data[1]  = T_1_2.num;
    {
    if (k.num < gcoOPobj_store.array->ext_low || k.num > gcoOPobj_store.array->ext_high) {
        err = ERR_bounds;
        goto ex_0;}
    gcoOPobj_store.array->store->data[k.num + gcoOPobj_store.array->int_low - gcoOPobj_store.array->ext_low] = T_1_1.num;
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE save_new_obj ****/


/**** BEGIN PROCEDURE reset ****/

errcode gcoOPreset()
    {
    errcode err;
    errcode ecode2;
    enter_proc(412);

  LINE(413);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok) goto ex_0;
    gcoOPobj_store.num = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE reset ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[4];
} gco_OPS;

CLU_proc gco_oe_get_obj = {{0,0,0,0}, gcoOPget_obj, 0};
CLU_proc gco_oe_init = {{0,0,0,0}, gcoOPinit, 0};
CLU_proc gco_oe_reset = {{0,0,0,0}, gcoOPreset, 0};
CLU_proc gco_oe_save_new_obj = {{0,0,0,0}, gcoOPsave_new_obj, 0};

gco_OPS gco_ops_actual = {4, (OWNPTR)&gco_own_init, (OWNPTR)&gco_own_init, {
    {&gco_oe_get_obj, "get_obj"},
    {&gco_oe_init, "init"},
    {&gco_oe_reset, "reset"},
    {&gco_oe_save_new_obj, "save_new_obj"}}};

struct OPS *gco_ops = (struct OPS *)&gco_ops_actual;

/**** END CLUSTER gco ****/

extern errcode logit();
extern errcode stringOPconcat();
extern errcode intOPunparse();
extern errcode charOPc2i();
extern errcode charOPle();
extern errcode stringOPc2s();
CLUREF STR_gc_137read_072_040next_040_137bytevec;
CLUREF STR__040_040;
CLUREF STR__072_040;
CLUREF STR__054_040_047;
CLUREF STR__047;
static int log_bytevec_own_init = 0;

/**** BEGIN PROCEDURE log_bytevec ****/

errcode log_bytevec(bv)
CLUREF bv;
    {
    errcode err;
    errcode ecode2;
    CLUREF i;
    CLUREF c;
    CLUREF s;
        if (log_bytevec_own_init == 0) {
        stringOPcons("gc_read: next _bytevec", CLU_1, CLU_22, &STR_gc_137read_072_040next_040_137bytevec);
        stringOPcons("  ", CLU_1, CLU_2, &STR__040_040);
        stringOPcons(": ", CLU_1, CLU_2, &STR__072_040);
        stringOPcons(", \'", CLU_1, CLU_3, &STR__054_040_047);
        stringOPcons("\'", CLU_1, CLU_1, &STR__047);
        log_bytevec_own_init = 1;
    }
    enter_proc(468);

  LINE(469);
    {
    err = logit(STR_gc_137read_072_040next_040_137bytevec);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(470);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        err = _bytevecOPsize(bv, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = T_1_1.num;
        for (T_1_2.num = 1; T_1_2.num <= T_1_3.num; T_1_2.num++) {
            i.num = T_1_2.num;

  LINE(471);
            {
                {CLUREF T_2_1;
                if (i.num < 1 || i.num > bv.str->size ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_2_1.ch = bv.str->data[i.num - 1];
                c.num = T_2_1.num;
                }
                }

  LINE(472);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                CLUREF T_2_3;
                CLUREF T_2_4;
                CLUREF T_2_5;
                CLUREF T_2_6;
                err = intOPunparse(i, &T_2_1);
                if (err != ERR_ok) goto ex_0;
                err = stringOPconcat(STR__040_040, T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                err = stringOPconcat(T_2_2, STR__072_040, &T_2_3);
                if (err != ERR_ok) goto ex_0;
                T_2_4.num = (long)(c.ch & 0xff);
                err = intOPunparse(T_2_4, &T_2_5);
                if (err != ERR_ok) goto ex_0;
                err = stringOPconcat(T_2_3, T_2_5, &T_2_6);
                if (err != ERR_ok) goto ex_0;
                s.num = T_2_6.num;
                }
                }

  LINE(473);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
            CLUREF T_2_5;
            T_2_2.ch = ' ';
            err = charOPle(T_2_2, c, &T_2_3);
            if (err != ERR_ok) goto ex_0;
            T_2_1.num = T_2_3.num;
            if (T_2_3.num) {
                T_2_4.ch = 'z';
                err = charOPle(c, T_2_4, &T_2_5);
                if (err != ERR_ok) goto ex_0;
                T_2_1.num = T_2_5.num;
            }
            if (T_2_1.num == true) {
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                CLUREF T_3_4;
                err = stringOPconcat(s, STR__054_040_047, &T_3_1);
                if (err != ERR_ok) goto ex_0;
                err = stringOPc2s(c, &T_3_2);
                if (err != ERR_ok) goto ex_0;
                err = stringOPconcat(T_3_1, T_3_2, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                err = stringOPconcat(T_3_3, STR__047, &T_3_4);
                if (err != ERR_ok) goto ex_0;
                s.num = T_3_4.num;
                }
                }
                }/* end if */

  LINE(474);
            {
            err = logit(s);
            if (err != ERR_ok) goto ex_0;
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE log_bytevec ****/

