
/* This file was automatically generated by pclu. */

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN PROCEDURE gc_read ****/


static const struct /* REQS */ {
    long count;
} gc_read_of_t_reqs_actual = { 0 };

const struct REQS * const gc_read_of_t_reqs
    = (const struct REQS *)&gc_read_of_t_reqs_actual;


typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    } gc_read_of_t_OPS;

extern errcode gcbOPinit();
extern errcode gcoOPinit();
extern errcode _chanOPopen();
extern errcode _wordvecOPcreate();
extern errcode _cvt();
extern errcode _chanOPgetb();
extern errcode boolOPnot();
extern errcode charOPequal();
extern errcode _bytevecOPfetch();
extern errcode intOPequal();
extern errcode _wordvecOPfetch();
extern errcode gcrOPpass1();
extern errcode _chanOPclose();
extern errcode gcrOPpass2();
extern errcode gcoOPget_obj();
extern errcode gcoOPreset();
static CLUREF STR_read;
static CLUREF STR_bad_040file_040format;

typedef struct {
    long gc_read_own_init;
    const gc_read_of_t_OPS * const t_ops;
} gc_read_OWN_DEFN;
const OWN_req gc_read_ownreqs = { sizeof(gc_read_OWN_DEFN), 1 };


errcode
gc_read(CLUREF fn, CLUREF *ret_1)
{
    errcode err;
    gc_read_OWN_DEFN *op_own_ptr;
    CLUREF ch;
    CLUREF why;
    CLUREF wv2;
    CLUREF buf;
    CLUREF result;
    op_own_ptr = (gc_read_OWN_DEFN *)CUR_PROC_VAR.proc->op_owns;
    if (op_own_ptr->gc_read_own_init == 0) {
        stringOPcons("read", CLU_1, CLUREF_make_num(4), &STR_read);
        stringOPcons("bad file format", CLU_1, CLUREF_make_num(15), &STR_bad_040file_040format);
    }
    if (op_own_ptr->gc_read_own_init == 0) {
        op_own_ptr->gc_read_own_init = 1;
        /* no own vars to init */
    }
    enter_proc(3);

  LINE(9);
    { /* begin */

  LINE(10);
        {
        err = gcbOPinit();
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(11);
        {
        err = gcoOPinit();
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(12);
        {
        CLUREF T_4_1;
        err = _chanOPopen(fn, STR_read, CLU_0, &T_4_1);
        if (err != ERR_ok)
            goto ex_2;
        ch.num = T_4_1.num;
        }
        goto end_2;
      ex_2: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_not_possible) {
            why.num = elist[0].num;

  LINE(14);
            { /* signal */
                elist[0] = why;
                signal(ERR_not_possible);
            }
        }
        else { /* not handled */
            goto ex_1;
        }
      end_2:;

  LINE(17);
        {
        CLUREF T_3_1;
        err = _wordvecOPcreate(CLU_2, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        wv2.num = T_3_1.num;
        }

  LINE(18);
        {
        CLUREF T_3_1;
        T_3_1.num = (long)wv2.num;
        buf.num = T_3_1.num;
        }

  LINE(21);
        {
        CLUREF T_3_1;
        err = _chanOPgetb(ch, buf, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(26);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        CLUREF T_3_5;
        CLUREF T_3_6;
        CLUREF T_3_7;
        CLUREF T_3_8;
        CLUREF T_3_9;
        CLUREF T_3_10;
        CLUREF T_3_11;
        CLUREF T_3_12;
        CLUREF T_3_13;
        CLUREF T_3_14;
        CLUREF T_3_15;
        CLUREF T_3_16;
        CLUREF T_3_17;
        CLUREF T_3_18;
        CLUREF T_3_19;
        if (1 < 1 || 1 > buf.str->size) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_4.ch = buf.str->data[1 - 1];
        T_3_5.ch = 'D';
        T_3_6.num = (T_3_4.ch == T_3_5.ch);
        T_3_7.num = !T_3_6.num;
        T_3_3.num = T_3_7.num;
        if (!T_3_7.num) {
            if (2 < 1 || 2 > buf.str->size) {
                err = ERR_bounds;
                goto ex_1;
            }
            T_3_8.ch = buf.str->data[2 - 1];
            T_3_9.ch = 'W';
            T_3_10.num = (T_3_8.ch == T_3_9.ch);
            T_3_11.num = !T_3_10.num;
            T_3_3.num = T_3_11.num;
        }
        T_3_2.num = T_3_3.num;
        if (!T_3_3.num) {
            if (3 < 1 || 3 > buf.str->size) {
                err = ERR_bounds;
                goto ex_1;
            }
            T_3_12.ch = buf.str->data[3 - 1];
            T_3_13.ch = 'C';
            T_3_14.num = (T_3_12.ch == T_3_13.ch);
            T_3_15.num = !T_3_14.num;
            T_3_2.num = T_3_15.num;
        }
        T_3_1.num = T_3_2.num;
        if (!T_3_2.num) {
            if (4 < 1 || 4 > buf.str->size) {
                err = ERR_bounds;
                goto ex_1;
            }
            T_3_16.ch = buf.str->data[4 - 1];
            T_3_17.ch = '1';
            T_3_18.num = (T_3_16.ch == T_3_17.ch);
            T_3_19.num = !T_3_18.num;
            T_3_1.num = T_3_19.num;
        }
        if (T_3_1.num == true) { /* if */

  LINE(31);
            { /* signal */
                elist[0] = STR_bad_040file_040format;
                signal(ERR_not_possible);
            }
        }
        } /* end if */

  LINE(35);
        {
        CLUREF T_3_1;
        err = _chanOPgetb(ch, buf, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(39);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        if (1 < 1 || (1 * CLUREFSZ) > (size_t)(wv2.str->size)) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_1.num = wv2.vec->data[1 - 1];
        T_3_2.num = (T_3_1.num == 32);
        if (T_3_2.num == true) { /* if */

  LINE(42);
            { /* return */
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            if (2 < 1 || (2 * CLUREFSZ) > (size_t)(wv2.str->size)) {
                err = ERR_bounds;
                goto ex_1;
            }
            T_4_1.num = wv2.vec->data[2 - 1];
            T_4_2.num = (long)T_4_1.num;
            ret_1->num = T_4_2.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(47);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        if (1 < 1 || (1 * CLUREFSZ) > (size_t)(wv2.str->size)) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_1.num = wv2.vec->data[1 - 1];
        T_3_2.num = (T_3_1.num == 33);
        T_3_3.num = !T_3_2.num;
        if (T_3_3.num == true) { /* if */

  LINE(50);
            { /* signal */
                elist[0] = STR_bad_040file_040format;
                signal(ERR_not_possible);
            }
        }
        } /* end if */

  LINE(52);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        if (2 < 1 || (2 * CLUREFSZ) > (size_t)(wv2.str->size)) {
            err = ERR_bounds;
            goto ex_1;
        }
        T_3_1.num = wv2.vec->data[2 - 1];
        T_3_2.num = (T_3_1.num == 0);
        T_3_3.num = !T_3_2.num;
        if (T_3_3.num == true) { /* if */

  LINE(55);
            { /* signal */
                elist[0] = STR_bad_040file_040format;
                signal(ERR_not_possible);
            }
        }
        } /* end if */

  LINE(61);
        {
        err = gcrOPpass1(ch);
        if (err != ERR_ok)
            goto ex_3;
        }
        goto end_3;
      ex_3: /* resignal */
        __CLU_EX_HANDLER;
        if (err == ERR_not_possible)
            signal(err);
        else
            goto ex_1;
      end_3:;

  LINE(63);
        {
        err = _chanOPclose(ch);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(66);
        {
        CLUREF T_3_1;
        err = _chanOPopen(fn, STR_read, CLU_0, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        ch.num = T_3_1.num;
        }

  LINE(67);
        {
        CLUREF T_3_1;
        err = _chanOPgetb(ch, buf, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(68);
        {
        CLUREF T_4_1;
        err = _chanOPgetb(ch, buf, &T_4_1);
        if (err != ERR_ok)
            goto ex_4;
        }
        goto end_4;
      ex_4: /* resignal */
        __CLU_EX_HANDLER;
        if (err == ERR_not_possible)
            signal(err);
        else
            goto ex_1;
      end_4:;

  LINE(73);
        {
        err = gcbOPinit();
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(74);
        {
        err = gcrOPpass2(ch);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(75);
        {
        err = _chanOPclose(ch);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(78);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = gcoOPget_obj(CLU_0, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        T_3_2.num = (long)T_3_1.num;
        result.num = T_3_2.num;
        }

  LINE(79);
        {
        err = gcoOPreset();
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(80);
        { /* return */
        {
        ret_1->num = result.num;
        }
        signal (ERR_ok);
        }
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    { /* others */

  LINE(83);
        {
        err = _chanOPclose(ch);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(84);
        { /* signal */
            elist[0] = STR_bad_040file_040format;
            signal(ERR_not_possible);
        }
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE gc_read ****/


/**** BEGIN CLUSTER gcr ****/

extern errcode _wordvecOPbytes_per_word();
extern errcode gcbOPget_next_hdr();
extern errcode gcrOPmake_bvec1();
extern errcode gcrOPmake_vec1();
extern errcode gcrOPmake_cell1();
extern errcode gcrOPmake_adv1();
extern errcode gcoOPsave_new_obj();
extern errcode gcbOPget_size();
extern errcode _bytevecOPcreate();
extern errcode gcbOPgetb();
extern errcode intOPfrom_to();
extern errcode _vecOPcreate();
extern errcode gcbOPskip_obj();
extern errcode _tagcellOPcreate();
extern errcode gcbOPgeti();
extern errcode gcbOPget_array_info();
extern errcode arrayOPpredict();
extern errcode gcrOPmake_bvec2();
extern errcode gcrOPmake_vec2();
extern errcode gcrOPmake_cell2();
extern errcode gcrOPmake_adv2();
extern errcode gcbOPskip();
extern errcode intOPdiv();
extern errcode intOPadd();
extern errcode _vecOPstore();
extern errcode gcbOPget_next_obj();
extern errcode _tagcellOPset();
extern errcode intOPsub();
extern errcode intOPmul();
extern errcode _advOPset_vector();
extern errcode _advOPset_start();
extern errcode _advOPset_size();
extern const struct REQS * const _tagcell_of_t_reqs;
extern struct OPS *_obj_ops;
extern const OWN_req _tagcell_ownreqs;
extern struct OPS *_tagcell_ops;
struct OPS *_tagcell_of__obj_ops __CLU_COMMON;
extern const struct REQS * const _adv_of_t_reqs;
extern const OWN_req _adv_ownreqs;
extern struct OPS *_adv_ops;
struct OPS *_adv_of__obj_ops __CLU_COMMON;
static int gcr_own_init = 0;
const OWN_req gcr_ownreqs = { 0, 0 };
CLUREF gcrOPclurefsz;

errcode
gcr_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (gcr_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)_obj_ops, _tagcell_of_t_reqs);
        find_type_instance(_tagcell_ops, 1, &_tagcell_ownreqs, &(_tagcell_of__obj_ops));
        add_parm_info_type(0, (const struct OPS *)_obj_ops, _adv_of_t_reqs);
        find_type_instance(_adv_ops, 1, &_adv_ownreqs, &(_adv_of__obj_ops));
        stringOPcons("bad file format", CLU_1, CLUREF_make_num(15), &STR_bad_040file_040format);
        gcr_own_init = 1;
        {
        CLUREF T_0_1;
        err = _wordvecOPbytes_per_word(&T_0_1);
        if (err != ERR_ok)
            goto ex_0;
        gcrOPclurefsz.num = T_0_1.num;
        }
        signal(ERR_ok);
      ex_0:
        __CLU_EX_HANDLER;
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE pass1 ****/

static int gcrOPpass1_own_init = 0;

errcode
gcrOPpass1(CLUREF ch)
{
    errcode err;
    CLUREF hdr;
    CLUREF id;
    CLUREF o;
    if (gcrOPpass1_own_init == 0) {
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        gcrOPpass1_own_init = 1;
    }
    enter_proc(94);

  LINE(96);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(97);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = gcbOPget_next_hdr(ch, &T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        hdr.num = T_3_1.num;
        id.num = T_3_2.num;
        }
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_none) {

  LINE(98);
            { /* return */
            signal (ERR_ok);
            }
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;

  LINE(99);
        { /* if */
        if (true == true) { /* if */
        }
        } /* end if */

  LINE(103);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 8192;
        T_2_2.num = (hdr.num == T_2_1.num);
        if (T_2_2.num == true) { /* if */

  LINE(105);
            { /* if */
            if (true == true) { /* if */
            }
            } /* end if */

  LINE(108);
            {
            CLUREF T_3_1;
            err = gcrOPmake_bvec1(ch, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            o.num = T_3_1.num;
            }
        }
        else {

  LINE(109);
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_3.num = 4096;
        T_2_4.num = (hdr.num == T_2_3.num);
        if (T_2_4.num == true) { /* elseif */

  LINE(111);
            { /* if */
            if (true == true) { /* if */
            }
            } /* end if */

  LINE(114);
            {
            CLUREF T_3_1;
            err = gcrOPmake_vec1(ch, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            o.num = T_3_1.num;
            }
        }
        else {

  LINE(115);
        CLUREF T_2_5;
        CLUREF T_2_6;
        T_2_5.num = 16384;
        T_2_6.num = (hdr.num == T_2_5.num);
        if (T_2_6.num == true) { /* elseif */

  LINE(117);
            { /* if */
            if (true == true) { /* if */
            }
            } /* end if */

  LINE(120);
            {
            CLUREF T_3_1;
            err = gcrOPmake_cell1(ch, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            o.num = T_3_1.num;
            }
        }
        else {

  LINE(121);
        CLUREF T_2_7;
        CLUREF T_2_8;
        T_2_7.num = 24576;
        T_2_8.num = (hdr.num == T_2_7.num);
        if (T_2_8.num == true) { /* elseif */

  LINE(123);
            { /* if */
            if (true == true) { /* if */

  LINE(126);
                {
                CLUREF T_4_1;
                err = gcrOPmake_adv1(ch, &T_4_1);
                if (err != ERR_ok)
                    goto ex_0;
                o.num = T_4_1.num;
                }
            }
            } /* end if */
        }
        else { /* else */

  LINE(129);
            { /* signal */
                elist[0] = STR_bad_040file_040format;
                signal(ERR_not_possible);
            }
        }}}}} /* end if */

  LINE(131);
        {
        err = gcoOPsave_new_obj(id, o);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    end_while_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE pass1 ****/


/**** BEGIN PROCEDURE make_bvec1 ****/


errcode
gcrOPmake_bvec1(CLUREF ch, CLUREF *ret_1)
{
    errcode err;
    CLUREF size;
    CLUREF bv;
    CLUREF i;
    CLUREF why;
    if (gcr_own_init == 0) {
        err = gcr_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(136);

  LINE(137);
    {
    CLUREF T_1_1;
    err = gcbOPget_size(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    size.num = T_1_1.num;
    }

  LINE(139);
    {
    CLUREF T_1_1;
    err = _bytevecOPcreate(size, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    bv.num = T_1_1.num;
    }

  LINE(140);
    { /* begin */

  LINE(141);
        {
        err = gcbOPgetb(ch, bv);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(142);
        { /* for int$from_to */
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_2.num = size.num;
        for (T_3_1.num = 1; T_3_1.num <= T_3_2.num; T_3_1.num++
        ) {
            i.num = T_3_1.num;
        }
        }
        end_inline_for_1:
        __CLU_END_LABEL;
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_end_of_file) {
        }
        else if (err == ERR_not_possible) {
            why.num = elist[0].num;
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;
    }

  LINE(151);
    { /* return */
    {
    CLUREF T_1_1;
    T_1_1.num = (long)bv.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE make_bvec1 ****/


/**** BEGIN PROCEDURE make_vec1 ****/


errcode
gcrOPmake_vec1(CLUREF ch, CLUREF *ret_1)
{
    errcode err;
    CLUREF size;
    CLUREF v;
    if (gcr_own_init == 0) {
        err = gcr_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(154);

  LINE(155);
    {
    CLUREF T_1_1;
    err = gcbOPget_size(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    size.num = T_1_1.num;
    }

  LINE(156);
    {
    CLUREF T_1_1;
    err = _vecOPcreate(size, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    v.num = T_1_1.num;
    }

  LINE(157);
    {
    err = gcbOPskip_obj(ch, size);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(158);
    { /* return */
    {
    CLUREF T_1_1;
    T_1_1.num = (long)v.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE make_vec1 ****/


/**** BEGIN PROCEDURE make_cell1 ****/

struct OPS *_tagcell_of__obj_ops __CLU_COMMON;
static int gcrOPmake_cell1_own_init = 0;

errcode
gcrOPmake_cell1(CLUREF ch, CLUREF *ret_1)
{
    errcode err;
    CLUREF t;
    if (gcrOPmake_cell1_own_init == 0) {
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        gcrOPmake_cell1_own_init = 1;
    }
    enter_proc(161);

  LINE(162);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = (long)0;
    generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _tagcellOPcreate;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _tagcellOPcreate(CLU_0, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    t.num = T_1_2.num;
    }

  LINE(163);
    {
    CLUREF T_1_1;
    err = gcbOPgeti(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(164);
    {
    err = gcbOPskip_obj(ch, CLU_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(165);
    { /* return */
    {
    CLUREF T_1_1;
    T_1_1.num = (long)t.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE make_cell1 ****/


/**** BEGIN PROCEDURE make_adv1 ****/


errcode
gcrOPmake_adv1(CLUREF ch, CLUREF *ret_1)
{
    errcode err;
    CLUREF size;
    CLUREF ext_size;
    CLUREF ext_low;
    CLUREF int_low;
    CLUREF int_size;
    CLUREF a;
    if (gcr_own_init == 0) {
        err = gcr_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(168);

  LINE(169);
    {
    CLUREF T_1_1;
    err = gcbOPget_size(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    size.num = T_1_1.num;
    }

  LINE(170);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    err = gcbOPget_array_info(ch, &T_1_1, &T_1_2, &T_1_3, &T_1_4);
    if (err != ERR_ok)
        goto ex_0;
    ext_size.num = T_1_1.num;
    ext_low.num = T_1_2.num;
    int_low.num = T_1_3.num;
    int_size.num = T_1_4.num;
    }

  LINE(171);
    {
    CLUREF T_1_1;
    err = arrayOPpredict(ext_low, int_size, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    a.num = T_1_1.num;
    }

  LINE(172);
    {
    err = gcbOPskip_obj(ch, CLU_1);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(173);
    { /* return */
    {
    CLUREF T_1_1;
    T_1_1.num = (long)a.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE make_adv1 ****/


/**** BEGIN PROCEDURE pass2 ****/

static int gcrOPpass2_own_init = 0;

errcode
gcrOPpass2(CLUREF ch)
{
    errcode err;
    CLUREF hdr;
    CLUREF id;
    CLUREF o;
    if (gcrOPpass2_own_init == 0) {
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        gcrOPpass2_own_init = 1;
    }
    enter_proc(176);

  LINE(178);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(179);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = gcbOPget_next_hdr(ch, &T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        hdr.num = T_3_1.num;
        id.num = T_3_2.num;
        }
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_none) {

  LINE(180);
            { /* return */
            signal (ERR_ok);
            }
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;

  LINE(182);
        {
        CLUREF T_2_1;
        err = gcoOPget_obj(id, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        o.num = T_2_1.num;
        }

  LINE(183);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 8192;
        T_2_2.num = (hdr.num == T_2_1.num);
        if (T_2_2.num == true) { /* if */

  LINE(186);
            {
            err = gcrOPmake_bvec2(ch, o);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        else {

  LINE(187);
        CLUREF T_2_3;
        CLUREF T_2_4;
        T_2_3.num = 4096;
        T_2_4.num = (hdr.num == T_2_3.num);
        if (T_2_4.num == true) { /* elseif */

  LINE(189);
            {
            err = gcrOPmake_vec2(ch, o);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        else {

  LINE(190);
        CLUREF T_2_5;
        CLUREF T_2_6;
        T_2_5.num = 16384;
        T_2_6.num = (hdr.num == T_2_5.num);
        if (T_2_6.num == true) { /* elseif */

  LINE(192);
            {
            err = gcrOPmake_cell2(ch, o);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        else {

  LINE(193);
        CLUREF T_2_7;
        CLUREF T_2_8;
        T_2_7.num = 24576;
        T_2_8.num = (hdr.num == T_2_7.num);
        if (T_2_8.num == true) { /* elseif */

  LINE(195);
            {
            err = gcrOPmake_adv2(ch, o);
            if (err != ERR_ok)
                goto ex_0;
            }
        }
        else { /* else */

  LINE(197);
            { /* signal */
                elist[0] = STR_bad_040file_040format;
                signal(ERR_not_possible);
            }
        }}}}} /* end if */
    }
    end_while_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE pass2 ****/


/**** BEGIN PROCEDURE make_bvec2 ****/


errcode
gcrOPmake_bvec2(CLUREF ch, CLUREF o)
{
    errcode err;
    CLUREF size;
    if (gcr_own_init == 0) {
        err = gcr_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(203);

  LINE(204);
    {
    CLUREF T_1_1;
    err = gcbOPget_size(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    size.num = T_1_1.num;
    }

  LINE(205);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = size.num + gcrOPclurefsz.num;
    if ((T_1_1.num > 0 && size.num < 0 && gcrOPclurefsz.num < 0) ||
        (T_1_1.num < 0 && size.num > 0 && gcrOPclurefsz.num > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    err = intOPdiv(T_1_1, gcrOPclurefsz, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    err = gcbOPskip(ch, T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE make_bvec2 ****/


/**** BEGIN PROCEDURE make_vec2 ****/


errcode
gcrOPmake_vec2(CLUREF ch, CLUREF o)
{
    errcode err;
    CLUREF size;
    CLUREF v;
    CLUREF i;
    if (gcr_own_init == 0) {
        err = gcr_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(208);

  LINE(209);
    {
    CLUREF T_1_1;
    err = gcbOPget_size(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    size.num = T_1_1.num;
    }

  LINE(210);
    {
    CLUREF T_1_1;
    T_1_1.num = (long)o.num;
    v.num = T_1_1.num;
    }

  LINE(211);
    { /* for int$from_to */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = size.num;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++
    ) {
        i.num = T_1_1.num;

  LINE(212);
        {
        CLUREF T_2_1;
        err = gcbOPget_next_obj(ch, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        err = _vecOPstore(v, i, T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        }
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE make_vec2 ****/


/**** BEGIN PROCEDURE make_cell2 ****/

struct OPS *_tagcell_of__obj_ops __CLU_COMMON;
static int gcrOPmake_cell2_own_init = 0;

errcode
gcrOPmake_cell2(CLUREF ch, CLUREF o)
{
    errcode err;
    CLUREF t;
    CLUREF tg;
    if (gcrOPmake_cell2_own_init == 0) {
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        gcrOPmake_cell2_own_init = 1;
    }
    enter_proc(216);

  LINE(217);
    {
    CLUREF T_1_1;
    T_1_1.num = (long)o.num;
    t.num = T_1_1.num;
    }

  LINE(218);
    {
    CLUREF T_1_1;
    err = gcbOPgeti(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    tg.num = T_1_1.num;
    }

  LINE(219);
    {
    CLUREF T_1_1;
    err = gcbOPget_next_obj(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _tagcellOPset;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _tagcellOPset(t, tg, T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE make_cell2 ****/


/**** BEGIN PROCEDURE make_adv2 ****/

struct OPS *_adv_of__obj_ops __CLU_COMMON;
static int gcrOPmake_adv2_own_init = 0;

errcode
gcrOPmake_adv2(CLUREF ch, CLUREF o)
{
    errcode err;
    CLUREF size;
    CLUREF a;
    CLUREF j1;
    CLUREF j2;
    CLUREF j3;
    CLUREF j4;
    CLUREF v;
    if (gcrOPmake_adv2_own_init == 0) {
        if (gcr_own_init == 0) {
            err = gcr_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        gcrOPmake_adv2_own_init = 1;
    }
    enter_proc(222);

  LINE(223);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = gcbOPget_size(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    err = intOPmul(CLU_2, gcrOPclurefsz, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_3.num = T_1_1.num - T_1_2.num;
    if ((T_1_3.num >= 0 && T_1_1.num < 0 && (-T_1_2.num) < 0) ||
        (T_1_3.num <= 0 && T_1_1.num > 0 && (-T_1_2.num) > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    size.num = T_1_3.num;
    }

  LINE(225);
    {
    CLUREF T_1_1;
    T_1_1.num = (long)o.num;
    a.num = T_1_1.num;
    }

  LINE(226);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    err = gcbOPget_array_info(ch, &T_1_1, &T_1_2, &T_1_3, &T_1_4);
    if (err != ERR_ok)
        goto ex_0;
    j1.num = T_1_1.num;
    j2.num = T_1_2.num;
    j3.num = T_1_3.num;
    j4.num = T_1_4.num;
    }

  LINE(232);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = gcbOPget_next_obj(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    T_1_2.num = (long)T_1_1.num;
    v.num = T_1_2.num;
    }

  LINE(234);
    {
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPset_vector;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPset_vector(a, v);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(236);
    {
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPset_start;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPset_start(a, j3);
    if (err != ERR_ok)
        goto ex_0;
    }

  LINE(237);
    {
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPset_size;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPset_size(a, j1);
    if (err != ERR_ok)
        goto ex_0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE make_adv2 ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[2];
} gcr_OPS;

static CLU_proc gcr_oe_pass1 = { .proc = gcrOPpass1 };
static CLU_proc gcr_oe_pass2 = { .proc = gcrOPpass2 };

static gcr_OPS gcr_ops_actual = {2, (OWNPTR)&gcr_own_init, (OWNPTR)&gcr_own_init, {
    {&gcr_oe_pass1, "pass1"},
    {&gcr_oe_pass2, "pass2"}}};

struct OPS *gcr_ops = (struct OPS *)&gcr_ops_actual;

/**** END CLUSTER gcr ****/

/**** BEGIN CLUSTER gcb ****/

extern errcode _chanOPgetw();
extern errcode _bytevecOPsize();
extern errcode intOPlt();
extern errcode intOPmin();
extern errcode _wordvecOPmove_w2b();
static CLUREF STR_bad_040format_040file;
static int gcb_own_init = 0;
const OWN_req gcb_ownreqs = { 0, 0 };
CLUREF gcbOPclurefsz;
CLUREF gcbOPbpagesz;
CLUREF gcbOPlookahead;
CLUREF gcbOPlook_index;
CLUREF gcbOPlook_count;
CLUREF gcbOPscratch;
CLUREF gcbOPobj_addr;
CLUREF gcbOPwv1;

errcode
gcb_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (gcb_own_init == 0) {
        stringOPcons("bad format file", CLU_1, CLUREF_make_num(15), &STR_bad_040format_040file);
        gcb_own_init = 1;
        {
        CLUREF T_0_1;
        err = _wordvecOPbytes_per_word(&T_0_1);
        if (err != ERR_ok)
            goto ex_0;
        gcbOPclurefsz.num = T_0_1.num;
        }
        {
        CLUREF T_0_2;
        CLUREF T_0_3;
        T_0_2.num = 1024;
        err = intOPmul(T_0_2, gcbOPclurefsz, &T_0_3);
        if (err != ERR_ok)
            goto ex_0;
        gcbOPbpagesz.num = T_0_3.num;
        }
        {
        CLUREF T_0_4;
        err = _wordvecOPcreate(gcbOPbpagesz, &T_0_4);
        if (err != ERR_ok)
            goto ex_0;
        gcbOPlookahead.num = T_0_4.num;
        }
        {
        gcbOPlook_index.num = 0;
        }
        {
        gcbOPlook_count.num = 0;
        }
        {
        CLUREF T_0_5;
        err = _bytevecOPcreate(gcbOPbpagesz, &T_0_5);
        if (err != ERR_ok)
            goto ex_0;
        gcbOPscratch.num = T_0_5.num;
        }
        {
        gcbOPobj_addr.num = 0;
        }
        {
        CLUREF T_0_6;
        err = _wordvecOPcreate(CLU_1, &T_0_6);
        if (err != ERR_ok)
            goto ex_0;
        gcbOPwv1.num = T_0_6.num;
        }
        signal(ERR_ok);
      ex_0:
        __CLU_EX_HANDLER;
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE init ****/


errcode
gcbOPinit(void)
{
    errcode err;
    if (gcb_own_init == 0) {
        err = gcb_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(257);

  LINE(258);
    {
    gcbOPobj_addr.num = 0;
    }

  LINE(259);
    {
    gcbOPlook_index.num = 0;
    }

  LINE(260);
    {
    gcbOPlook_count.num = 0;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE init ****/


/**** BEGIN PROCEDURE get_next_hdr ****/


errcode
gcbOPget_next_hdr(CLUREF ch, CLUREF *ret_1, CLUREF *ret_2)
{
    errcode err;
    CLUREF this_addr;
    CLUREF hdr;
    if (gcb_own_init == 0) {
        err = gcb_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(263);

  LINE(265);
    {
    this_addr.num = gcbOPobj_addr.num;
    }

  LINE(266);
    {
    CLUREF T_2_1;
    err = gcbOPgeti(ch, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    hdr.num = T_2_1.num;
    }
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file) {

  LINE(267);
        { /* signal */
            signal(ERR_none);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(268);
    { /* return */
    {
    ret_1->num = hdr.num;
    }
    {
    ret_2->num = this_addr.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_next_hdr ****/


/**** BEGIN PROCEDURE get_size ****/


errcode
gcbOPget_size(CLUREF ch, CLUREF *ret_1)
{
    errcode err;
    CLUREF size;
    if (gcb_own_init == 0) {
        err = gcb_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(271);

  LINE(272);
    {
    CLUREF T_1_1;
    err = gcbOPgeti(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    size.num = T_1_1.num;
    }

  LINE(273);
    { /* return */
    {
    ret_1->num = size.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_size ****/


/**** BEGIN PROCEDURE get_array_info ****/


errcode
gcbOPget_array_info(CLUREF ch, CLUREF *ret_1, CLUREF *ret_2, CLUREF *ret_3, CLUREF *ret_4)
{
    errcode err;
    CLUREF size;
    CLUREF low;
    CLUREF start;
    CLUREF predict;
    if (gcb_own_init == 0) {
        err = gcb_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(276);

  LINE(277);
    {
    CLUREF T_1_1;
    err = gcbOPgeti(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    size.num = T_1_1.num;
    }

  LINE(278);
    {
    CLUREF T_1_1;
    err = gcbOPgeti(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    low.num = T_1_1.num;
    }

  LINE(279);
    {
    CLUREF T_1_1;
    err = gcbOPgeti(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    start.num = T_1_1.num;
    }

  LINE(280);
    {
    CLUREF T_1_1;
    err = gcbOPgeti(ch, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    predict.num = T_1_1.num;
    }

  LINE(281);
    { /* return */
    {
    ret_1->num = size.num;
    }
    {
    ret_2->num = low.num;
    }
    {
    ret_3->num = start.num;
    }
    {
    ret_4->num = predict.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_array_info ****/


/**** BEGIN PROCEDURE get_next_obj ****/

static int gcbOPget_next_obj_own_init = 0;

errcode
gcbOPget_next_obj(CLUREF ch, CLUREF *ret_1)
{
    errcode err;
    CLUREF ty;
    CLUREF val;
    if (gcbOPget_next_obj_own_init == 0) {
        if (gcb_own_init == 0) {
            err = gcb_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        gcbOPget_next_obj_own_init = 1;
    }
    enter_proc(284);

  LINE(286);
    for (;;) { /* while */
        if (true != true)
            break;

  LINE(288);
        {
        CLUREF T_3_1;
        err = gcbOPgeti(ch, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        ty.num = T_3_1.num;
        }
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_end_of_file) {

  LINE(289);
            { /* signal */
                signal(ERR_none);
            }
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;

  LINE(290);
        {
        CLUREF T_3_1;
        err = gcbOPgeti(ch, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        val.num = T_3_1.num;
        }
        goto end_2;
      ex_2: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_end_of_file) {

  LINE(292);
            { /* signal */
                elist[0] = STR_bad_040format_040file;
                signal(ERR_not_possible);
            }
        }
        else { /* not handled */
            goto ex_0;
        }
      end_2:;

  LINE(293);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = (ty.num == 32);
        if (T_2_1.num == true) { /* if */

  LINE(295);
            { /* return */
            {
            CLUREF T_3_1;
            T_3_1.num = (long)val.num;
            ret_1->num = T_3_1.num;
            }
            signal (ERR_ok);
            }
        }
        else {

  LINE(296);
        CLUREF T_2_2;
        T_2_2.num = (ty.num == 33);
        if (T_2_2.num == true) { /* elseif */

  LINE(298);
            { /* return */
            {
            CLUREF T_3_1;
            err = gcoOPget_obj(val, &T_3_1);
            if (err != ERR_ok)
                goto ex_0;
            ret_1->num = T_3_1.num;
            }
            signal (ERR_ok);
            }
        }
        else { /* else */

  LINE(300);
            { /* signal */
                elist[0] = STR_bad_040format_040file;
                signal(ERR_not_possible);
            }
        }}} /* end if */
    }
    end_while_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_next_obj ****/


/**** BEGIN PROCEDURE skip_obj ****/

static int gcbOPskip_obj_own_init = 0;

errcode
gcbOPskip_obj(CLUREF ch, CLUREF count)
{
    errcode err;
    CLUREF i;
    CLUREF ty;
    CLUREF val;
    if (gcbOPskip_obj_own_init == 0) {
        if (gcb_own_init == 0) {
            err = gcb_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        gcbOPskip_obj_own_init = 1;
    }
    enter_proc(305);

  LINE(306);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (count.num == 0);
    if (T_1_1.num == true) { /* if */
        { /* return */
        signal (ERR_ok);
        }
    }
    } /* end if */

  LINE(307);
    { /* for int$from_to */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.num = count.num;
    for (T_1_1.num = 1; T_1_1.num <= T_1_2.num; T_1_1.num++
    ) {
        i.num = T_1_1.num;

  LINE(308);
        {
        CLUREF T_3_1;
        err = gcbOPgeti(ch, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        ty.num = T_3_1.num;
        }
        goto end_1;
      ex_1: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_end_of_file) {

  LINE(309);
            { /* signal */
                signal(ERR_none);
            }
        }
        else { /* not handled */
            goto ex_0;
        }
      end_1:;

  LINE(310);
        {
        CLUREF T_3_1;
        err = gcbOPgeti(ch, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        val.num = T_3_1.num;
        }
        goto end_2;
      ex_2: /* except */
        __CLU_EX_HANDLER;
        if (err == ERR_end_of_file) {

  LINE(312);
            { /* signal */
                elist[0] = STR_bad_040format_040file;
                signal(ERR_not_possible);
            }
        }
        else { /* not handled */
            goto ex_0;
        }
      end_2:;

  LINE(313);
        { /* if */
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
        CLUREF T_2_5;
        T_2_2.num = (ty.num == 32);
        T_2_3.num = !T_2_2.num;
        T_2_1.num = T_2_3.num;
        if (T_2_3.num) {
            T_2_4.num = (ty.num == 33);
            T_2_5.num = !T_2_4.num;
            T_2_1.num = T_2_5.num;
        }
        if (T_2_1.num == true) { /* if */

  LINE(315);
            { /* signal */
                elist[0] = STR_bad_040format_040file;
                signal(ERR_not_possible);
            }
        }
        } /* end if */
    }
    }
    end_inline_for_1:
    __CLU_END_LABEL;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE skip_obj ****/


/**** BEGIN PROCEDURE geti ****/


errcode
gcbOPgeti(CLUREF ch, CLUREF *ret_1)
{
    errcode err;
    CLUREF ans;
    if (gcb_own_init == 0) {
        err = gcb_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(320);

  LINE(322);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (gcbOPlook_count.num == 0);
    if (T_1_1.num == true) { /* if */

  LINE(323);
        {
        CLUREF T_3_1;
        err = _chanOPgetw(ch, gcbOPlookahead, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        gcbOPlook_count.num = T_3_1.num;
        }
        goto end_1;
      ex_1: /* resignal */
        __CLU_EX_HANDLER;
        if (err == ERR_end_of_file)
            signal(err);
        else
            goto ex_0;
      end_1:;

  LINE(325);
        {
        gcbOPlook_index.num = 1;
        }
    }
    } /* end if */

  LINE(327);
    {
    CLUREF T_1_1;
    if (gcbOPlook_index.num < 1 || (gcbOPlook_index.num * CLUREFSZ) > (size_t)(gcbOPlookahead.str->size)) {
        err = ERR_bounds;
        goto ex_0;
    }
    T_1_1.num = gcbOPlookahead.vec->data[gcbOPlook_index.num - 1];
    ans.num = T_1_1.num;
    }

  LINE(328);
    {
    CLUREF T_1_1;
    T_1_1.num = gcbOPlook_count.num - gcbOPclurefsz.num;
    if ((T_1_1.num >= 0 && gcbOPlook_count.num < 0 && (-gcbOPclurefsz.num) < 0) ||
        (T_1_1.num <= 0 && gcbOPlook_count.num > 0 && (-gcbOPclurefsz.num) > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    gcbOPlook_count.num = T_1_1.num;
    }

  LINE(329);
    {
    CLUREF T_1_1;
    T_1_1.num = gcbOPlook_index.num + 1;
    if ((T_1_1.num > 0 && gcbOPlook_index.num < 0 && 1 < 0) ||
        (T_1_1.num < 0 && gcbOPlook_index.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    gcbOPlook_index.num = T_1_1.num;
    }

  LINE(330);
    {
    CLUREF T_1_1;
    T_1_1.num = gcbOPobj_addr.num + gcbOPclurefsz.num;
    if ((T_1_1.num > 0 && gcbOPobj_addr.num < 0 && gcbOPclurefsz.num < 0) ||
        (T_1_1.num < 0 && gcbOPobj_addr.num > 0 && gcbOPclurefsz.num > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    gcbOPobj_addr.num = T_1_1.num;
    }

  LINE(331);
    { /* return */
    {
    ret_1->num = ans.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE geti ****/


/**** BEGIN PROCEDURE getb ****/


errcode
gcbOPgetb(CLUREF ch, CLUREF b)
{
    errcode err;
    CLUREF copied;
    CLUREF data_count;
    CLUREF pad_count;
    CLUREF b_index;
    CLUREF count;
    if (gcb_own_init == 0) {
        err = gcb_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(334);

  LINE(336);
    {
    copied.num = 0;
    }

  LINE(337);
    {
    CLUREF T_1_1;
    err = _bytevecOPsize(b, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    data_count.num = T_1_1.num;
    }

  LINE(338);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = data_count.num + gcbOPclurefsz.num;
    if ((T_1_1.num > 0 && data_count.num < 0 && gcbOPclurefsz.num < 0) ||
        (T_1_1.num < 0 && data_count.num > 0 && gcbOPclurefsz.num > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    err = intOPdiv(T_1_1, gcbOPclurefsz, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    err = intOPmul(T_1_2, gcbOPclurefsz, &T_1_3);
    if (err != ERR_ok)
        goto ex_0;
    T_1_4.num = T_1_3.num - data_count.num;
    if ((T_1_4.num >= 0 && T_1_3.num < 0 && (-data_count.num) < 0) ||
        (T_1_4.num <= 0 && T_1_3.num > 0 && (-data_count.num) > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    pad_count.num = T_1_4.num;
    }

  LINE(339);
    {
    b_index.num = 1;
    }

  LINE(340);
    for (;;) { /* while */
        CLUREF T_1_1;
        T_1_1.num = (copied.num < data_count.num);
        if (T_1_1.num != true)
            break;

  LINE(341);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = (gcbOPlook_count.num == 0);
        if (T_2_1.num == true) { /* if */

  LINE(342);
            {
            CLUREF T_4_1;
            err = _chanOPgetw(ch, gcbOPlookahead, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            gcbOPlook_count.num = T_4_1.num;
            }
            goto end_1;
          ex_1: /* resignal */
            __CLU_EX_HANDLER;
            if (err == ERR_end_of_file)
                signal(err);
            else
                goto ex_0;
          end_1:;

  LINE(344);
            {
            gcbOPlook_index.num = 1;
            }
        }
        } /* end if */

  LINE(346);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = data_count.num - b_index.num;
        if ((T_2_1.num >= 0 && data_count.num < 0 && (-b_index.num) < 0) ||
            (T_2_1.num <= 0 && data_count.num > 0 && (-b_index.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        T_2_2.num = T_2_1.num + 1;
        if ((T_2_2.num > 0 && T_2_1.num < 0 && 1 < 0) ||
            (T_2_2.num < 0 && T_2_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        err = intOPmin(T_2_2, gcbOPlook_count, &T_2_3);
        if (err != ERR_ok)
            goto ex_0;
        count.num = T_2_3.num;
        }

  LINE(347);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = gcbOPlook_index.num - 1;
        if ((T_2_1.num >= 0 && gcbOPlook_index.num < 0 && (-1) < 0) ||
            (T_2_1.num <= 0 && gcbOPlook_index.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        err = intOPmul(T_2_1, gcbOPclurefsz, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        T_2_3.num = T_2_2.num + 1;
        if ((T_2_3.num > 0 && T_2_2.num < 0 && 1 < 0) ||
            (T_2_3.num < 0 && T_2_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        err = _wordvecOPmove_w2b(gcbOPlookahead, T_2_3, b, b_index, count);
        if (err != ERR_ok)
            goto ex_0;
        }

  LINE(348);
        {
        CLUREF T_2_1;
        T_2_1.num = gcbOPlook_count.num - count.num;
        if ((T_2_1.num >= 0 && gcbOPlook_count.num < 0 && (-count.num) < 0) ||
            (T_2_1.num <= 0 && gcbOPlook_count.num > 0 && (-count.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        gcbOPlook_count.num = T_2_1.num;
        }

  LINE(349);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = intOPdiv(count, gcbOPclurefsz, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        T_2_2.num = gcbOPlook_index.num + T_2_1.num;
        if ((T_2_2.num > 0 && gcbOPlook_index.num < 0 && T_2_1.num < 0) ||
            (T_2_2.num < 0 && gcbOPlook_index.num > 0 && T_2_1.num > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        gcbOPlook_index.num = T_2_2.num;
        }

  LINE(350);
        {
        CLUREF T_2_1;
        T_2_1.num = b_index.num + count.num;
        if ((T_2_1.num > 0 && b_index.num < 0 && count.num < 0) ||
            (T_2_1.num < 0 && b_index.num > 0 && count.num > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        b_index.num = T_2_1.num;
        }

  LINE(351);
        {
        CLUREF T_2_1;
        T_2_1.num = copied.num + count.num;
        if ((T_2_1.num > 0 && copied.num < 0 && count.num < 0) ||
            (T_2_1.num < 0 && copied.num > 0 && count.num > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        copied.num = T_2_1.num;
        }
    }
    end_while_1:
    __CLU_END_LABEL;

  LINE(353);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = (gcbOPlook_count.num == 0);
    if (T_1_1.num == true) { /* if */

  LINE(354);
        {
        CLUREF T_3_1;
        err = _chanOPgetw(ch, gcbOPlookahead, &T_3_1);
        if (err != ERR_ok)
            goto ex_2;
        gcbOPlook_count.num = T_3_1.num;
        }
        goto end_2;
      ex_2: /* resignal */
        __CLU_EX_HANDLER;
        if (err == ERR_end_of_file)
            signal(err);
        else
            goto ex_0;
      end_2:;

  LINE(356);
        {
        gcbOPlook_index.num = 1;
        }
    }
    } /* end if */

  LINE(358);
    {
    CLUREF T_1_1;
    T_1_1.num = gcbOPlook_count.num - pad_count.num;
    if ((T_1_1.num >= 0 && gcbOPlook_count.num < 0 && (-pad_count.num) < 0) ||
        (T_1_1.num <= 0 && gcbOPlook_count.num > 0 && (-pad_count.num) > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    gcbOPlook_count.num = T_1_1.num;
    }

  LINE(359);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = (pad_count.num == 0);
    T_1_2.num = !T_1_1.num;
    if (T_1_2.num == true) { /* if */
        {
        CLUREF T_2_1;
        T_2_1.num = gcbOPlook_index.num + 1;
        if ((T_2_1.num > 0 && gcbOPlook_index.num < 0 && 1 < 0) ||
            (T_2_1.num < 0 && gcbOPlook_index.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        gcbOPlook_index.num = T_2_1.num;
        }
    }
    } /* end if */

  LINE(360);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = gcbOPobj_addr.num + data_count.num;
    if ((T_1_1.num > 0 && gcbOPobj_addr.num < 0 && data_count.num < 0) ||
        (T_1_1.num < 0 && gcbOPobj_addr.num > 0 && data_count.num > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    T_1_2.num = T_1_1.num + pad_count.num;
    if ((T_1_2.num > 0 && T_1_1.num < 0 && pad_count.num < 0) ||
        (T_1_2.num < 0 && T_1_1.num > 0 && pad_count.num > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    gcbOPobj_addr.num = T_1_2.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE getb ****/


/**** BEGIN PROCEDURE skip ****/


errcode
gcbOPskip(CLUREF ch, CLUREF i)
{
    errcode err;
    CLUREF i4;
    CLUREF skipped;
    CLUREF count;
    if (gcb_own_init == 0) {
        err = gcb_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(363);

  LINE(365);
    {
    CLUREF T_1_1;
    err = intOPmul(i, gcbOPclurefsz, &T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    i4.num = T_1_1.num;
    }

  LINE(366);
    {
    skipped.num = 0;
    }

  LINE(367);
    for (;;) { /* while */
        CLUREF T_1_1;
        T_1_1.num = (skipped.num < i4.num);
        if (T_1_1.num != true)
            break;

  LINE(368);
        { /* if */
        CLUREF T_2_1;
        T_2_1.num = (gcbOPlook_count.num == 0);
        if (T_2_1.num == true) { /* if */

  LINE(369);
            {
            CLUREF T_4_1;
            err = _chanOPgetw(ch, gcbOPlookahead, &T_4_1);
            if (err != ERR_ok)
                goto ex_1;
            gcbOPlook_count.num = T_4_1.num;
            }
            goto end_1;
          ex_1: /* resignal */
            __CLU_EX_HANDLER;
            if (err == ERR_end_of_file)
                signal(err);
            else
                goto ex_0;
          end_1:;

  LINE(371);
            {
            gcbOPlook_index.num = 1;
            }
        }
        } /* end if */

  LINE(373);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = i4.num - skipped.num;
        if ((T_2_1.num >= 0 && i4.num < 0 && (-skipped.num) < 0) ||
            (T_2_1.num <= 0 && i4.num > 0 && (-skipped.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        err = intOPmin(T_2_1, gcbOPlook_count, &T_2_2);
        if (err != ERR_ok)
            goto ex_0;
        count.num = T_2_2.num;
        }

  LINE(374);
        {
        CLUREF T_2_1;
        T_2_1.num = gcbOPlook_count.num - count.num;
        if ((T_2_1.num >= 0 && gcbOPlook_count.num < 0 && (-count.num) < 0) ||
            (T_2_1.num <= 0 && gcbOPlook_count.num > 0 && (-count.num) > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        gcbOPlook_count.num = T_2_1.num;
        }

  LINE(375);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        err = intOPdiv(count, gcbOPclurefsz, &T_2_1);
        if (err != ERR_ok)
            goto ex_0;
        T_2_2.num = gcbOPlook_index.num + T_2_1.num;
        if ((T_2_2.num > 0 && gcbOPlook_index.num < 0 && T_2_1.num < 0) ||
            (T_2_2.num < 0 && gcbOPlook_index.num > 0 && T_2_1.num > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        gcbOPlook_index.num = T_2_2.num;
        }

  LINE(376);
        {
        CLUREF T_2_1;
        T_2_1.num = skipped.num + count.num;
        if ((T_2_1.num > 0 && skipped.num < 0 && count.num < 0) ||
            (T_2_1.num < 0 && skipped.num > 0 && count.num > 0)) {
            err = ERR_overflow;
            goto ex_0;
        }
        skipped.num = T_2_1.num;
        }
    }
    end_while_1:
    __CLU_END_LABEL;

  LINE(378);
    {
    CLUREF T_1_1;
    T_1_1.num = gcbOPobj_addr.num + i4.num;
    if ((T_1_1.num > 0 && gcbOPobj_addr.num < 0 && i4.num < 0) ||
        (T_1_1.num < 0 && gcbOPobj_addr.num > 0 && i4.num > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    gcbOPobj_addr.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE skip ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[9];
} gcb_OPS;

static CLU_proc gcb_oe_get_array_info = { .proc = gcbOPget_array_info };
static CLU_proc gcb_oe_get_next_hdr = { .proc = gcbOPget_next_hdr };
static CLU_proc gcb_oe_get_next_obj = { .proc = gcbOPget_next_obj };
static CLU_proc gcb_oe_get_size = { .proc = gcbOPget_size };
static CLU_proc gcb_oe_getb = { .proc = gcbOPgetb };
static CLU_proc gcb_oe_geti = { .proc = gcbOPgeti };
static CLU_proc gcb_oe_init = { .proc = gcbOPinit };
static CLU_proc gcb_oe_skip = { .proc = gcbOPskip };
static CLU_proc gcb_oe_skip_obj = { .proc = gcbOPskip_obj };

static gcb_OPS gcb_ops_actual = {9, (OWNPTR)&gcb_own_init, (OWNPTR)&gcb_own_init, {
    {&gcb_oe_get_array_info, "get_array_info"},
    {&gcb_oe_get_next_hdr, "get_next_hdr"},
    {&gcb_oe_get_next_obj, "get_next_obj"},
    {&gcb_oe_get_size, "get_size"},
    {&gcb_oe_getb, "getb"},
    {&gcb_oe_geti, "geti"},
    {&gcb_oe_init, "init"},
    {&gcb_oe_skip, "skip"},
    {&gcb_oe_skip_obj, "skip_obj"}}};

struct OPS *gcb_ops = (struct OPS *)&gcb_ops_actual;

/**** END CLUSTER gcb ****/

/**** BEGIN CLUSTER gco ****/

extern errcode arrayOPfill();
extern errcode hash_int();
extern errcode arrayOPfetch();
extern errcode _objOPequal();
extern errcode recordOPget_1();
extern errcode recordOPget_2();
extern errcode recordOPget_3();
extern errcode arrayOPstore();
extern errcode arrayOPnew();
static int gco_own_init = 1;
const OWN_req gco_ownreqs = { 0, 0 };
CLUREF gcoOPobj_store;

/**** BEGIN PROCEDURE init ****/


errcode
gcoOPinit(void)
{
    errcode err;
    CLUREF no_bucket;
    enter_proc(394);

  LINE(395);
    {
    CLUREF T_1_1;
    T_1_1.num = (long)nil;
    no_bucket.num = T_1_1.num;
    }

  LINE(396);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = 50000;
    err = arrayOPfill(CLU_1, T_1_1, no_bucket, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    gcoOPobj_store.num = T_1_2.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE init ****/


/**** BEGIN PROCEDURE get_obj ****/


errcode
gcoOPget_obj(CLUREF i, CLUREF *ret_1)
{
    errcode err;
    CLUREF k;
    CLUREF this_buck;
    enter_proc(399);

  LINE(401);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = 50000;
    err = hash_int(i, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_3.num = T_1_2.num + 1;
    if ((T_1_3.num > 0 && T_1_2.num < 0 && 1 < 0) ||
        (T_1_3.num < 0 && T_1_2.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    k.num = T_1_3.num;
    }

  LINE(402);
    {
    CLUREF T_1_1;
    if (k.num < gcoOPobj_store.array->ext_low || k.num > gcoOPobj_store.array->ext_high) {
        err = ERR_bounds;
        goto ex_0;
    }
    T_1_1.num = gcoOPobj_store.array->store->data[k.num - gcoOPobj_store.array->ext_low + gcoOPobj_store.array->int_low];
    this_buck.num = T_1_1.num;
    }

  LINE(403);
    for (;;) { /* while */
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        CLUREF T_1_6;
        CLUREF T_1_7;
        CLUREF T_1_8;
        T_1_2.num = (long)this_buck.num;
        T_1_3.num = (long)nil;
        T_1_4.num = (T_1_2.num == T_1_3.num);
        T_1_5.num = !T_1_4.num;
        T_1_1.num = T_1_5.num;
        if (T_1_5.num) {
            T_1_6.num = this_buck.vec->data[0];
            T_1_7.num = (T_1_6.num == i.num);
            T_1_8.num = !T_1_7.num;
            T_1_1.num = T_1_8.num;
        }
        if (T_1_1.num != true)
            break;

  LINE(404);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = this_buck.vec->data[1];
        T_2_2.num = (long)T_2_1.num;
        this_buck.num = T_2_2.num;
        }
    }
    end_while_1:
    __CLU_END_LABEL;

  LINE(406);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = (long)this_buck.num;
    T_1_2.num = (long)nil;
    T_1_3.num = (T_1_1.num == T_1_2.num);
    if (T_1_3.num == true) { /* if */
        { /* signal */
            signal(ERR_not_found);
        }
    }
    } /* end if */

  LINE(407);
    { /* return */
    {
    CLUREF T_1_1;
    T_1_1.num = this_buck.vec->data[2];
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_obj ****/


/**** BEGIN PROCEDURE save_new_obj ****/


errcode
gcoOPsave_new_obj(CLUREF i, CLUREF o)
{
    errcode err;
    CLUREF k;
    CLUREF this_buck;
    enter_proc(410);

  LINE(411);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = 50000;
    err = hash_int(i, T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_3.num = T_1_2.num + 1;
    if ((T_1_3.num > 0 && T_1_2.num < 0 && 1 < 0) ||
        (T_1_3.num < 0 && T_1_2.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;
    }
    k.num = T_1_3.num;
    }

  LINE(412);
    {
    CLUREF T_1_1;
    if (k.num < gcoOPobj_store.array->ext_low || k.num > gcoOPobj_store.array->ext_high) {
        err = ERR_bounds;
        goto ex_0;
    }
    T_1_1.num = gcoOPobj_store.array->store->data[k.num - gcoOPobj_store.array->ext_low + gcoOPobj_store.array->int_low];
    this_buck.num = T_1_1.num;
    }

  LINE(413);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(3, T_1_1);
    T_1_1.vec->data[0] = i.num;
    T_1_1.vec->data[2] = o.num;
    T_1_2.num = (long)this_buck.num;
    T_1_1.vec->data[1] = T_1_2.num;
    {
    if (k.num < gcoOPobj_store.array->ext_low || k.num > gcoOPobj_store.array->ext_high) {
        err = ERR_bounds;
        goto ex_0;
    }
    gcoOPobj_store.array->store->data[k.num + gcoOPobj_store.array->int_low - gcoOPobj_store.array->ext_low] = T_1_1.num;
    }
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE save_new_obj ****/


/**** BEGIN PROCEDURE reset ****/


errcode
gcoOPreset(void)
{
    errcode err;
    enter_proc(416);

  LINE(417);
    {
    CLUREF T_1_1;
    err = arrayOPnew(&T_1_1);
    if (err != ERR_ok)
        goto ex_0;
    gcoOPobj_store.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE reset ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[4];
} gco_OPS;

static CLU_proc gco_oe_get_obj = { .proc = gcoOPget_obj };
static CLU_proc gco_oe_init = { .proc = gcoOPinit };
static CLU_proc gco_oe_reset = { .proc = gcoOPreset };
static CLU_proc gco_oe_save_new_obj = { .proc = gcoOPsave_new_obj };

static gco_OPS gco_ops_actual = {4, (OWNPTR)&gco_own_init, (OWNPTR)&gco_own_init, {
    {&gco_oe_get_obj, "get_obj"},
    {&gco_oe_init, "init"},
    {&gco_oe_reset, "reset"},
    {&gco_oe_save_new_obj, "save_new_obj"}}};

struct OPS *gco_ops = (struct OPS *)&gco_ops_actual;

/**** END CLUSTER gco ****/
