
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER gcd_tab ****/


typedef struct {
long count;
    char *_gcd_name;
} gcd_tab_op_grind_of_t_REQS;

gcd_tab_op_grind_of_t_REQS gcd_tab_op_grind_of_t_reqs_actual = {1,
    "_gcd"};

struct REQS * gcd_tab_op_grind_of_t_reqs = (struct REQS *)&gcd_tab_op_grind_of_t_reqs_actual;

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY _gcd;
} gcd_tab_op_grind_of_t_OPS;

typedef struct {
long count;
    char *_gcd_name;
} gcd_tab_op_grindc_of_t_REQS;

gcd_tab_op_grindc_of_t_REQS gcd_tab_op_grindc_of_t_reqs_actual = {1,
    "_gcd"};

struct REQS * gcd_tab_op_grindc_of_t_reqs = (struct REQS *)&gcd_tab_op_grindc_of_t_reqs_actual;

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY _gcd;
} gcd_tab_op_grindc_of_t_OPS;

typedef struct {
long count;
    char *_gcd_name;
} gcd_tab_op_grindp_of_t_REQS;

gcd_tab_op_grindp_of_t_REQS gcd_tab_op_grindp_of_t_reqs_actual = {1,
    "_gcd"};

struct REQS * gcd_tab_op_grindp_of_t_reqs = (struct REQS *)&gcd_tab_op_grindp_of_t_reqs_actual;

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY _gcd;
} gcd_tab_op_grindp_of_t_OPS;

typedef struct {
long count;
    char *_gcd_name;
} gcd_tab_op_pgrind_of_t_REQS;

gcd_tab_op_pgrind_of_t_REQS gcd_tab_op_pgrind_of_t_reqs_actual = {1,
    "_gcd"};

struct REQS * gcd_tab_op_pgrind_of_t_reqs = (struct REQS *)&gcd_tab_op_pgrind_of_t_reqs_actual;

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY _gcd;
} gcd_tab_op_pgrind_of_t_OPS;

typedef struct {
long count;
    char *_gcd_name;
} gcd_tab_op_mgrind_of_t_REQS;

gcd_tab_op_mgrind_of_t_REQS gcd_tab_op_mgrind_of_t_reqs_actual = {1,
    "_gcd"};

struct REQS * gcd_tab_op_mgrind_of_t_reqs = (struct REQS *)&gcd_tab_op_mgrind_of_t_reqs_actual;

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY _gcd;
} gcd_tab_op_mgrind_of_t_OPS;
extern errcode _chanOPopen();
extern errcode _chanOPget_name();
extern errcode _gcOPcount();
extern errcode arrayOPpredict();
extern errcode _vecOPcreate();
extern errcode _wordvecOPcreate();
extern errcode _eventOPdefer();
extern errcode gcd_tabOPmgrind();
extern errcode _wordvecOPstore();
extern errcode recordOPget_4();
extern errcode _chanOPset_access();
extern errcode _chanOPputw();
extern errcode _eventOPundefer();
extern errcode _chanOPabort();
extern errcode _chanOPclose();
extern errcode arrayOPnew();
extern errcode intOPadd();
extern errcode gcd_tabOPpgrind();
extern errcode recordOPset_4();
extern errcode recordOPget_3();
extern errcode recordOPget_5();
extern errcode arrayOPfetch();
extern errcode _cvt();
extern errcode sequenceOPelements();
extern errcode sequenceOPindexes();
extern errcode sequenceOPfetch();
extern errcode _tagcellOPget();
extern errcode _advOPget_vector();
extern errcode gcd_tabOPinsert();
extern errcode intOPmul();
extern errcode _vecOPsize();
extern errcode boolOPnot();
extern errcode _objOPequal();
extern errcode gcd_storeOPinit();
extern errcode gcd_storeOPstore_id();
extern errcode intOPlt();
extern errcode gcd_storeOPstore_lit();
extern errcode gcd_storeOPstore_ref();
extern errcode arrayOPreml();
extern errcode _bytevecOPsize();
extern errcode gcd_storeOPstore_hdr();
extern errcode gcd_storeOPstore_string();
extern errcode sequenceOPsize();
extern errcode intOPfrom_to();
extern errcode gcd_storeOPstore_array_desc();
extern errcode gcd_storeOPdone();
extern errcode hash_obj();
extern errcode _vecOPfetch();
extern errcode recordOPget_1();
extern errcode recordOPget_2();
extern errcode _vecOPstore();
extern errcode arrayOPaddh();
extern OWN_req gcd_tab_ownreqs;
extern struct OPS *gcd_tab_ops;
extern struct REQS *gcd_tab_op_mgrind_of_t_reqs;
extern OWN_req gcd_tab_op_mgrind_ownreqs;
extern struct REQS *gcd_tab_op_pgrind_of_t_reqs;
extern OWN_req gcd_tab_op_pgrind_ownreqs;
extern struct REQS *_tagcell_of_t_reqs;
extern struct OPS *_obj_ops;
extern OWN_req _tagcell_ownreqs;
extern struct OPS *_tagcell_ops;
struct OPS *_tagcell_of__obj_table;
struct OPS *_tagcell_of__obj_ops;
struct OPS *_tagcell_of__obj_ops;
OWNPTR _tagcell_of__obj_owns;
extern struct REQS *_adv_of_t_reqs;
extern OWN_req _adv_ownreqs;
extern struct OPS *_adv_ops;
struct OPS *_adv_of__obj_table;
struct OPS *_adv_of__obj_ops;
struct OPS *_adv_of__obj_ops;
OWNPTR _adv_of__obj_owns;
CLUREF STR_write;
CLUREF STR_gcd_137tab_072_040array_040store_040not_040a_040ref;
static int gcd_tab_own_init = 0;
OWN_req gcd_tab_ownreqs = {0,0};
errcode gcd_tab_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (gcd_tab_own_init == 0) {
        add_parm_info_type(0, _obj_ops, _tagcell_of_t_reqs);
        find_type_instance(_tagcell_ops, 1, &_tagcell_ownreqs, &(_tagcell_of__obj_ops));
        add_parm_info_type(0, _obj_ops, _adv_of_t_reqs);
        find_type_instance(_adv_ops, 1, &_adv_ownreqs, &(_adv_of__obj_ops));
        stringOPcons("write", CLU_1, CLU_5, &STR_write);
        stringOPcons("gcd_tab: array store not a ref", CLU_1, CLU_30, &STR_gcd_137tab_072_040array_040store_040not_040a_040ref);
        gcd_tab_own_init = 1;
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


typedef struct {
    long grind_own_init;
    gcd_tab_op_grind_of_t_OPS *t_ops;
    struct OPS *gcd_tab_op_mgrind_of_t_table;
    struct OPS *gcd_tab_op_mgrind_of_t_ops;
    OWNPTR gcd_tab_op_mgrind_of_t_owns;
    } gcd_tab_op_grind_OWN_DEFN;
OWN_req gcd_tab_op_grind_ownreqs = {sizeof(gcd_tab_op_grind_OWN_DEFN), 1};


/**** BEGIN PROCEDURE grind ****/

errcode gcd_tabOPgrind(x, fn, ret_1)
CLUREF x;
CLUREF fn;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    gcd_tab_op_grind_OWN_DEFN *op_own_ptr;
    CLUREF ch;
    CLUREF tab;
    CLUREF buf;
    CLUREF why;
    op_own_ptr = (gcd_tab_op_grind_OWN_DEFN*) CUR_PROC_VAR.proc->op_owns;
        if (op_own_ptr->grind_own_init == 0) {
        add_parm_info_type(0, op_own_ptr->t_ops, gcd_tab_op_mgrind_of_t_reqs);
        find_typeop_instance(gcd_tab_ops, gcd_tabOPmgrind, 1, 0, &gcd_tab_op_mgrind_ownreqs, &gcd_tab_ownreqs, &(op_own_ptr->gcd_tab_op_mgrind_of_t_ops));
        stringOPcons("write", CLU_1, CLU_5, &STR_write);
        }
        if (op_own_ptr->grind_own_init == 0) {
        op_own_ptr->grind_own_init = 1;
    }
    enter_proc(44);

  LINE(48);
    {
        {CLUREF T_2_1;
        err = _chanOPopen(fn, STR_write, CLU_0, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        ch.num = T_2_1.num;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(50);
    {
    CLUREF T_1_1;
    err = _chanOPget_name(ch, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    fn.num = T_1_1.num;
    }

  LINE(51);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        CLUREF T_1_6;
        CLUREF T_1_7;
        CLUREF T_1_8;
        RecordAlloc(5, T_1_1);
        T_1_1.vec->data[3]  = 0;
        err = _gcOPcount(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1]  = T_1_2.num;
        T_1_3.num = 300000;
        err = arrayOPpredict(CLU_1, T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[4]  = T_1_4.num;
        T_1_5.num = 300000;
        err = arrayOPpredict(CLU_1, T_1_5, &T_1_6);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[2]  = T_1_6.num;
        T_1_7.num = 50000;
        err = _vecOPcreate(T_1_7, &T_1_8);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_8.num;
        tab.num = T_1_1.num;
        }
        }

  LINE(56);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = 1024;
        err = _wordvecOPcreate(T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        buf.num = T_1_2.num;
        }
        }

  LINE(63);
    {
    err = _eventOPdefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(64);
    {

  LINE(65);
        {
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = op_own_ptr->gcd_tab_op_mgrind_of_t_ops->op_owns;
        generic_CLU_proc.proc = gcd_tabOPmgrind;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = gcd_tabOPmgrind(tab, buf, ch, x);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(66);
        {
        CLUREF T_3_1;
        T_3_1.num = tab.vec->data[3];
        err = _wordvecOPstore(buf, CLU_1, T_3_1);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(67);
        {
        err = _chanOPset_access(ch, CLU_4);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(68);
        {
        err = _chanOPputw(ch, buf, CLU_1, CLU_4, CLU_0);
        if (err != ERR_ok) goto ex_2;
        }
        }
        goto end_2;
        ex_2:
            if ((err == ERR_not_possible)) {
            CLUREF why;
            why.num = elist[0].num;

  LINE(70);
                {
                err = _eventOPundefer();
                if (err != ERR_ok) goto ex_0;
                }

  LINE(71);
                {
                err = _chanOPabort(ch);
                if (err != ERR_ok) goto ex_3;
                }
                    goto end_3;
                    ex_3:
                        if ((err == ERR_not_possible)) {
                        }
                        else {
                            goto ex_0;
                        }
                    end_3:;

  LINE(73);
                {
                elist[0] = why;
                {signal (ERR_not_possible);}}
            }
            else {
                goto ex_0;
            }
        end_2:;

  LINE(75);
    {
    err = _eventOPundefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(77);
    {
    err = _chanOPclose(ch);
    if (err != ERR_ok) goto ex_4;
    }
    goto end_4;
    ex_4:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_4:;

  LINE(79);
    {
    {
    ret_1->num = fn.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE grind ****/


typedef struct {
    long grindc_own_init;
    gcd_tab_op_grindc_of_t_OPS *t_ops;
    struct OPS *gcd_tab_op_mgrind_of_t_table;
    struct OPS *gcd_tab_op_mgrind_of_t_ops;
    OWNPTR gcd_tab_op_mgrind_of_t_owns;
    } gcd_tab_op_grindc_OWN_DEFN;
OWN_req gcd_tab_op_grindc_ownreqs = {sizeof(gcd_tab_op_grindc_OWN_DEFN), 1};


/**** BEGIN PROCEDURE grindc ****/

errcode gcd_tabOPgrindc(x, ch, pos)
CLUREF x;
CLUREF ch;
CLUREF pos;
    {
    errcode err;
    errcode ecode2;
    gcd_tab_op_grindc_OWN_DEFN *op_own_ptr;
    CLUREF tab;
    CLUREF buf;
    CLUREF why;
    op_own_ptr = (gcd_tab_op_grindc_OWN_DEFN*) CUR_PROC_VAR.proc->op_owns;
        if (op_own_ptr->grindc_own_init == 0) {
        add_parm_info_type(0, op_own_ptr->t_ops, gcd_tab_op_mgrind_of_t_reqs);
        find_typeop_instance(gcd_tab_ops, gcd_tabOPmgrind, 1, 0, &gcd_tab_op_mgrind_ownreqs, &gcd_tab_ownreqs, &(op_own_ptr->gcd_tab_op_mgrind_of_t_ops));
        }
        if (op_own_ptr->grindc_own_init == 0) {
        op_own_ptr->grindc_own_init = 1;
    }
    enter_proc(83);

  LINE(86);
    {
    err = _chanOPset_access(ch, pos);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(88);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        CLUREF T_1_6;
        RecordAlloc(5, T_1_1);
        T_1_1.vec->data[3]  = 0;
        err = _gcOPcount(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1]  = T_1_2.num;
        err = arrayOPnew(&T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[4]  = T_1_3.num;
        err = arrayOPnew(&T_1_4);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[2]  = T_1_4.num;
        T_1_5.num = 50000;
        err = _vecOPcreate(T_1_5, &T_1_6);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_6.num;
        tab.num = T_1_1.num;
        }
        }

  LINE(93);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = 1024;
        err = _wordvecOPcreate(T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        buf.num = T_1_2.num;
        }
        }

  LINE(94);
    {
    err = _eventOPdefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(95);
    {

  LINE(96);
        {
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = op_own_ptr->gcd_tab_op_mgrind_of_t_ops->op_owns;
        generic_CLU_proc.proc = gcd_tabOPmgrind;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = gcd_tabOPmgrind(tab, buf, ch, x);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(97);
        {
        CLUREF T_3_1;
        T_3_1.num = tab.vec->data[3];
        err = _wordvecOPstore(buf, CLU_1, T_3_1);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(98);
        {
        CLUREF T_3_1;
        T_3_1.num = pos.num + 4;
         if ((T_3_1.num > 0 && pos.num < 0 && 4 < 0) || 
             (T_3_1.num < 0 && pos.num > 0 && 4 > 0)) {
            err = ERR_overflow;
            goto ex_2;}
        err = _chanOPset_access(ch, T_3_1);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(99);
        {
        err = _chanOPputw(ch, buf, CLU_1, CLU_4, CLU_0);
        if (err != ERR_ok) goto ex_2;
        }
        }
        goto end_2;
        ex_2:
            if ((err == ERR_not_possible)) {
            CLUREF why;
            why.num = elist[0].num;

  LINE(101);
                {
                err = _eventOPundefer();
                if (err != ERR_ok) goto ex_0;
                }

  LINE(102);
                {
                elist[0] = why;
                {signal (ERR_not_possible);}}
            }
            else {
                goto ex_0;
            }
        end_2:;

  LINE(104);
    {
    err = _eventOPundefer();
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE grindc ****/


typedef struct {
    long grindp_own_init;
    gcd_tab_op_grindp_of_t_OPS *t_ops;
    struct OPS *gcd_tab_op_pgrind_of_t_table;
    struct OPS *gcd_tab_op_pgrind_of_t_ops;
    OWNPTR gcd_tab_op_pgrind_of_t_owns;
    struct OPS *gcd_tab_op_mgrind_of_t_table;
    struct OPS *gcd_tab_op_mgrind_of_t_ops;
    OWNPTR gcd_tab_op_mgrind_of_t_owns;
    } gcd_tab_op_grindp_OWN_DEFN;
OWN_req gcd_tab_op_grindp_ownreqs = {sizeof(gcd_tab_op_grindp_OWN_DEFN), 1};


/**** BEGIN PROCEDURE grindp ****/

errcode gcd_tabOPgrindp(x, ch)
CLUREF x;
CLUREF ch;
    {
    errcode err;
    errcode ecode2;
    gcd_tab_op_grindp_OWN_DEFN *op_own_ptr;
    CLUREF tab;
    CLUREF buf;
    CLUREF why;
    op_own_ptr = (gcd_tab_op_grindp_OWN_DEFN*) CUR_PROC_VAR.proc->op_owns;
        if (op_own_ptr->grindp_own_init == 0) {
        add_parm_info_type(0, op_own_ptr->t_ops, gcd_tab_op_pgrind_of_t_reqs);
        find_typeop_instance(gcd_tab_ops, gcd_tabOPpgrind, 1, 0, &gcd_tab_op_pgrind_ownreqs, &gcd_tab_ownreqs, &(op_own_ptr->gcd_tab_op_pgrind_of_t_ops));
        add_parm_info_type(0, op_own_ptr->t_ops, gcd_tab_op_mgrind_of_t_reqs);
        find_typeop_instance(gcd_tab_ops, gcd_tabOPmgrind, 1, 0, &gcd_tab_op_mgrind_ownreqs, &gcd_tab_ownreqs, &(op_own_ptr->gcd_tab_op_mgrind_of_t_ops));
        }
        if (op_own_ptr->grindp_own_init == 0) {
        op_own_ptr->grindp_own_init = 1;
    }
    enter_proc(108);

  LINE(110);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        CLUREF T_1_6;
        RecordAlloc(5, T_1_1);
        T_1_1.vec->data[3]  = 0;
        err = _gcOPcount(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1]  = T_1_2.num;
        err = arrayOPnew(&T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[4]  = T_1_3.num;
        err = arrayOPnew(&T_1_4);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[2]  = T_1_4.num;
        T_1_5.num = 50000;
        err = _vecOPcreate(T_1_5, &T_1_6);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0]  = T_1_6.num;
        tab.num = T_1_1.num;
        }
        }

  LINE(115);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = 1024;
        err = _wordvecOPcreate(T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        buf.num = T_1_2.num;
        }
        }

  LINE(116);
    {
    err = _eventOPdefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(117);
    {

  LINE(118);
        {
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = op_own_ptr->gcd_tab_op_pgrind_of_t_ops->op_owns;
        generic_CLU_proc.proc = gcd_tabOPpgrind;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = gcd_tabOPpgrind(tab, x);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(119);
        {
        CLUREF T_3_1;
        T_3_1.num = tab.vec->data[3];
        err = _wordvecOPstore(buf, CLU_2, T_3_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(120);
        {
        tab.vec->data[3]  = 0;
        }

  LINE(121);
        {
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = op_own_ptr->gcd_tab_op_mgrind_of_t_ops->op_owns;
        generic_CLU_proc.proc = gcd_tabOPmgrind;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = gcd_tabOPmgrind(tab, buf, ch, x);
        if (err != ERR_ok) goto ex_1;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_not_possible)) {
            CLUREF why;
            why.num = elist[0].num;

  LINE(123);
                {
                err = _eventOPundefer();
                if (err != ERR_ok) goto ex_0;
                }

  LINE(124);
                {
                elist[0] = why;
                {signal (ERR_not_possible);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(126);
    {
    err = _eventOPundefer();
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE grindp ****/

struct OPS *_tagcell_of__obj_table;
struct OPS *_tagcell_of__obj_ops;
struct OPS *_tagcell_of__obj_ops;
OWNPTR _tagcell_of__obj_owns;
struct OPS *_adv_of__obj_table;
struct OPS *_adv_of__obj_ops;
struct OPS *_adv_of__obj_ops;
OWNPTR _adv_of__obj_owns;

typedef struct {
    long pgrind_own_init;
    gcd_tab_op_pgrind_of_t_OPS *t_ops;
    } gcd_tab_op_pgrind_OWN_DEFN;
OWN_req gcd_tab_op_pgrind_ownreqs = {sizeof(gcd_tab_op_pgrind_OWN_DEFN), 1};


/**** BEGIN PROCEDURE pgrind ****/

errcode gcd_tabOPpgrind(tab, x)
CLUREF tab;
CLUREF x;
    {
    errcode err;
    errcode ecode2;
    gcd_tab_op_pgrind_OWN_DEFN *op_own_ptr;
    CLUREF iq;
    CLUREF oq;
    CLUREF idx;
    CLUREF p;
    CLUREF v;
    CLUREF e;
    CLUREF l;
    CLUREF i;
    CLUREF inf;
    CLUREF a;
    op_own_ptr = (gcd_tab_op_pgrind_OWN_DEFN*) CUR_PROC_VAR.proc->op_owns;
        if (op_own_ptr->pgrind_own_init == 0) {
        add_parm_info_type(0, _obj_ops, _tagcell_of_t_reqs);
        find_type_instance(_tagcell_ops, 1, &_tagcell_ownreqs, &(_tagcell_of__obj_ops));
        add_parm_info_type(0, _obj_ops, _adv_of_t_reqs);
        find_type_instance(_adv_ops, 1, &_adv_ownreqs, &(_adv_of__obj_ops));
        }
        if (op_own_ptr->pgrind_own_init == 0) {
        op_own_ptr->pgrind_own_init = 1;
    }
    enter_proc(130);

  LINE(132);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.proc = op_own_ptr->t_ops->_gcd.fcn;
    CUR_PROC_VAR = T_1_2;
    err = T_1_2.proc->proc(x, tab, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(133);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.vec->data[2];
        iq.num = T_1_1.num;
        }
        }

  LINE(134);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.vec->data[4];
        oq.num = T_1_1.num;
        }
        }

  LINE(135);
    {
        {idx.num = 0;
        }
        }

  LINE(136);
    for (;;) {
        if (true != true) { break; }

  LINE(137);
        {
        CLUREF T_3_1;
        T_3_1.num = idx.num + 1;
         if ((T_3_1.num > 0 && idx.num < 0 && 1 < 0) || 
             (T_3_1.num < 0 && idx.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        idx.num = T_3_1.num;
        }

  LINE(138);
        {
        CLUREF T_3_1;
        if (idx.num < iq.array->ext_low || idx.num > iq.array->ext_high ) {
            err = ERR_bounds;
            goto ex_1;}
        T_3_1.num = iq.array->store->data[idx.num - iq.array->ext_low + iq.array->int_low];
        switch (T_3_1.cell->tag) {
        case 1: 
             {
                break;
                }
        case 2: 
             {CLUREF T_3_2;
            T_3_2.num = T_3_1.cell->value;
            p.num = T_3_2.num;

  LINE(141);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    if (idx.num < oq.array->ext_low || idx.num > oq.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = oq.array->store->data[idx.num - oq.array->ext_low + oq.array->int_low];
                    T_4_2.num = T_4_1.num;
                    v.num = T_4_2.num;
                    }
                    }

  LINE(142);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                    T_4_2.num = v.vec->size; 
                    T_4_3 = v;
                    for (T_4_1.num = 1; T_4_1.num <= T_4_2.num; T_4_1.num++) {
                        e.num = T_4_3.vec->data[T_4_1.num - 1];

  LINE(143);
                        {
                        CLUREF T_5_1;
                        CUR_PROC_VAR = p;
                        err = p.proc->proc(e, tab, &T_5_1);
                        if (err != ERR_ok) goto ex_1;
                        }
                    }
                }
                end_inline_for_1:;
                break;
                }
        case 3: 
             {CLUREF T_3_3;
            T_3_3.num = T_3_1.cell->value;
            l.num = T_3_3.num;

  LINE(146);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    if (idx.num < oq.array->ext_low || idx.num > oq.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = oq.array->store->data[idx.num - oq.array->ext_low + oq.array->int_low];
                    T_4_2.num = T_4_1.num;
                    v.num = T_4_2.num;
                    }
                    }

  LINE(147);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                    T_4_2.num = v.vec->size; 
                    for (T_4_1.num = 1; T_4_1.num <= T_4_2.num; T_4_1.num++) {
                        i.num = T_4_1.num;

  LINE(148);
                        {
                        CLUREF T_5_1;
                        CLUREF T_5_2;
                        CLUREF T_5_3;
                        if (i.num < 1 || i.num > v.vec->size ) {
                            err = ERR_bounds;
                            goto ex_1;}
                        T_5_1.num = v.vec->data[i.num - 1];
                        if (i.num < 1 || i.num > l.vec->size ) {
                            err = ERR_bounds;
                            goto ex_1;}
                        T_5_3.num = l.vec->data[i.num - 1];
                        CUR_PROC_VAR = T_5_3;
                        err = T_5_3.proc->proc(T_5_1, tab, &T_5_2);
                        if (err != ERR_ok) goto ex_1;
                        }
                    }
                }
                end_inline_for_2:;
                break;
                }
        case 4: 
             {CLUREF T_3_4;
            T_3_4.num = T_3_1.cell->value;
            l.num = T_3_4.num;

  LINE(151);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    CLUREF T_4_3;
                    CLUREF T_4_4;
                    if (idx.num < oq.array->ext_low || idx.num > oq.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = oq.array->store->data[idx.num - oq.array->ext_low + oq.array->int_low];
                    T_4_2.num = T_4_1.num;
                    generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
                    generic_CLU_proc.proc = _tagcellOPget;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = _tagcellOPget(T_4_2, &T_4_3, &T_4_4);
                    if (err != ERR_ok) goto ex_1;
                    i.num = T_4_3.num;
                    e.num = T_4_4.num;
                    }
                    }

  LINE(152);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                if (i.num < 1 || i.num > l.vec->size ) {
                    err = ERR_bounds;
                    goto ex_1;}
                T_4_2.num = l.vec->data[i.num - 1];
                CUR_PROC_VAR = T_4_2;
                err = T_4_2.proc->proc(e, tab, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                }
                break;
                }
        case 5: 
             {CLUREF T_3_5;
            T_3_5.num = T_3_1.cell->value;
            p.num = T_3_5.num;

  LINE(154);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    CLUREF T_4_3;
                    CLUREF T_4_4;
                    if (idx.num < oq.array->ext_low || idx.num > oq.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = oq.array->store->data[idx.num - oq.array->ext_low + oq.array->int_low];
                    T_4_2.num = T_4_1.num;
                    generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
                    generic_CLU_proc.proc = _tagcellOPget;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = _tagcellOPget(T_4_2, &T_4_3, &T_4_4);
                    if (err != ERR_ok) goto ex_1;
                    i.num = T_4_3.num;
                    e.num = T_4_4.num;
                    }
                    }

  LINE(155);
                {
                CLUREF T_4_1;
                CUR_PROC_VAR = p;
                err = p.proc->proc(e, tab, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                }
                break;
                }
        case 6: 
             {CLUREF T_3_6;
            T_3_6.num = T_3_1.cell->value;
            inf.num = T_3_6.num;

  LINE(157);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    if (idx.num < oq.array->ext_low || idx.num > oq.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = oq.array->store->data[idx.num - oq.array->ext_low + oq.array->int_low];
                    T_4_2.num = T_4_1.num;
                    a.num = T_4_2.num;
                    }
                    }

  LINE(158);
                {
                    {CLUREF T_4_1;
                    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
                    generic_CLU_proc.proc = _advOPget_vector;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = _advOPget_vector(a, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    v.num = T_4_1.num;
                    }
                    }

  LINE(159);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                CLUREF T_4_4;
                CLUREF T_4_5;
                CLUREF T_4_6;
                err = _vecOPsize(v, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                T_4_2.num = T_4_1.num + 1;
                 if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) || 
                     (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                err = intOPmul(CLU_4, T_4_2, &T_4_3);
                if (err != ERR_ok) goto ex_1;
                T_4_4.num = inf.num;
                T_4_5.num = v.num;
                err = gcd_tabOPinsert(tab, T_4_3, T_4_4, T_4_5, &T_4_6);
                if (err != ERR_ok) goto ex_1;
                }
                break;
                }
        case 7: 
             {CLUREF T_3_7;
            T_3_7.num = T_3_1.cell->value;
            p.num = T_3_7.num;

  LINE(162);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    if (idx.num < oq.array->ext_low || idx.num > oq.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = oq.array->store->data[idx.num - oq.array->ext_low + oq.array->int_low];
                    T_4_2.num = T_4_1.num;
                    v.num = T_4_2.num;
                    }
                    }

  LINE(163);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                    T_4_2.num = v.vec->size; 
                    T_4_3 = v;
                    for (T_4_1.num = 1; T_4_1.num <= T_4_2.num; T_4_1.num++) {
                        e.num = T_4_3.vec->data[T_4_1.num - 1];

  LINE(164);
                        {
                        CLUREF T_5_1;
                        CLUREF T_5_2;
                        CLUREF T_5_3;
                        T_5_1.num = nil;
                        T_5_2.num = (e.num == T_5_1.num)? true : false;
                        T_5_3.num = T_5_2.num ^ 1;
                        if (T_5_3.num == true) {

  LINE(165);
                            {
                            CLUREF T_6_1;
                            CUR_PROC_VAR = p;
                            err = p.proc->proc(e, tab, &T_6_1);
                            if (err != ERR_ok) goto ex_1;
                            }
                            }
                            }/* end if */
                    }
                }
                end_inline_for_3:;
                break;
                }
        }
        }
        }
        end_while_1:;
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE pgrind ****/

struct OPS *_tagcell_of__obj_table;
struct OPS *_tagcell_of__obj_ops;
struct OPS *_tagcell_of__obj_ops;
OWNPTR _tagcell_of__obj_owns;
struct OPS *_adv_of__obj_table;
struct OPS *_adv_of__obj_ops;
struct OPS *_adv_of__obj_ops;
OWNPTR _adv_of__obj_owns;

typedef struct {
    long mgrind_own_init;
    gcd_tab_op_mgrind_of_t_OPS *t_ops;
    } gcd_tab_op_mgrind_OWN_DEFN;
OWN_req gcd_tab_op_mgrind_ownreqs = {sizeof(gcd_tab_op_mgrind_OWN_DEFN), 1};


/**** BEGIN PROCEDURE mgrind ****/

errcode gcd_tabOPmgrind(tab, buf, ch, x)
CLUREF tab;
CLUREF buf;
CLUREF ch;
CLUREF x;
    {
    errcode err;
    errcode ecode2;
    gcd_tab_op_mgrind_OWN_DEFN *op_own_ptr;
    CLUREF val;
    CLUREF iq;
    CLUREF oq;
    CLUREF b;
    CLUREF z;
    CLUREF p;
    CLUREF v;
    CLUREF e;
    CLUREF l;
    CLUREF i;
    CLUREF inf;
    CLUREF a;
    op_own_ptr = (gcd_tab_op_mgrind_OWN_DEFN*) CUR_PROC_VAR.proc->op_owns;
        if (op_own_ptr->mgrind_own_init == 0) {
        add_parm_info_type(0, _obj_ops, _tagcell_of_t_reqs);
        find_type_instance(_tagcell_ops, 1, &_tagcell_ownreqs, &(_tagcell_of__obj_ops));
        add_parm_info_type(0, _obj_ops, _adv_of_t_reqs);
        find_type_instance(_adv_ops, 1, &_adv_ownreqs, &(_adv_of__obj_ops));
        stringOPcons("gcd_tab: array store not a ref", CLU_1, CLU_30, &STR_gcd_137tab_072_040array_040store_040not_040a_040ref);
        }
        if (op_own_ptr->mgrind_own_init == 0) {
        op_own_ptr->mgrind_own_init = 1;
    }
    enter_proc(172);

  LINE(176);
    {
    err = gcd_storeOPinit(buf, ch);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(178);
    {
    err = gcd_storeOPstore_id();
    if (err != ERR_ok) goto ex_2;
    }
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_2:;

  LINE(180);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_2.proc = op_own_ptr->t_ops->_gcd.fcn;
        CUR_PROC_VAR = T_1_2;
        err = T_1_2.proc->proc(x, tab, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        val.num = T_1_1.num;
        }
        }

  LINE(182);
    {
    CLUREF T_1_1;
    T_1_1.num = (val.num < 0)? true : false;
    if (T_1_1.num == true) {

  LINE(183);
        {
        CLUREF T_3_1;
        T_3_1.num = x.num;
        err = gcd_storeOPstore_lit(T_3_1);
        if (err != ERR_ok) goto ex_3;
        }
        goto end_3;
        ex_3:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_0;}
        end_3:;
        }
    else {

  LINE(185);
        {
        err = gcd_storeOPstore_ref(val);
        if (err != ERR_ok) goto ex_4;
        }
        goto end_4;
        ex_4:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_0;}
        end_4:;
        }}/* end if */

  LINE(188);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.vec->data[2];
        iq.num = T_1_1.num;
        }
        }

  LINE(189);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.vec->data[4];
        oq.num = T_1_1.num;
        }
        }

  LINE(190);
    for (;;) {
        if (true != true) { break; }

  LINE(191);
        {
        CLUREF T_4_1;
        err = arrayOPreml(iq, &T_4_1);
        if (err != ERR_ok) goto ex_6;
        switch (T_4_1.cell->tag) {
        case 1: 
             {

  LINE(194);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = T_5_1.num;
                    b.num = T_5_2.num;
                    }
                    }

  LINE(195);
                {
                    {CLUREF T_5_1;
                    err = _bytevecOPsize(b, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    z.num = T_5_1.num;
                    }
                    }

  LINE(196);
                {
                CLUREF T_6_1;
                T_6_1.num = 8192;
                err = gcd_storeOPstore_hdr(T_6_1, z);
                if (err != ERR_ok) goto ex_7;
                }
                goto end_7;
                ex_7:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_7:;

  LINE(198);
                {
                err = gcd_storeOPstore_string(b);
                if (err != ERR_ok) goto ex_8;
                }
                goto end_8;
                ex_8:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_8:;
                break;
                }
        case 2: 
             {CLUREF T_4_2;
            T_4_2.num = T_4_1.cell->value;
            p.num = T_4_2.num;

  LINE(202);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = T_5_1.num;
                    v.num = T_5_2.num;
                    }
                    }

  LINE(203);
                {
                CLUREF T_6_1;
                CLUREF T_6_2;
                T_6_1.num = 4096;
                T_6_2.num = v.vec->size;
                err = gcd_storeOPstore_hdr(T_6_1, T_6_2);
                if (err != ERR_ok) goto ex_9;
                }
                goto end_9;
                ex_9:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_9:;

  LINE(205);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                    T_5_2.num = v.vec->size; 
                    T_5_3 = v;
                    for (T_5_1.num = 1; T_5_1.num <= T_5_2.num; T_5_1.num++) {
                        e.num = T_5_3.vec->data[T_5_1.num - 1];

  LINE(206);
                        {
                        CLUREF T_6_1;
                        CUR_PROC_VAR = p;
                        err = p.proc->proc(e, tab, &T_6_1);
                        if (err != ERR_ok) goto ex_6;
                        val.num = T_6_1.num;
                        }

  LINE(207);
                        {
                        CLUREF T_6_1;
                        T_6_1.num = (val.num < 0)? true : false;
                        if (T_6_1.num == true) {

  LINE(208);
                            {
                            CLUREF T_8_1;
                            T_8_1.num = e.num;
                            err = gcd_storeOPstore_lit(T_8_1);
                            if (err != ERR_ok) goto ex_10;
                            }
                            goto end_10;
                            ex_10:
                                if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                else {
                                    goto ex_6;}
                            end_10:;
                            }
                        else {

  LINE(210);
                            {
                            err = gcd_storeOPstore_ref(val);
                            if (err != ERR_ok) goto ex_11;
                            }
                            goto end_11;
                            ex_11:
                                if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                else {
                                    goto ex_6;}
                            end_11:;
                            }}/* end if */
                    }
                }
                end_inline_for_1:;
                break;
                }
        case 3: 
             {CLUREF T_4_3;
            T_4_3.num = T_4_1.cell->value;
            l.num = T_4_3.num;

  LINE(216);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = T_5_1.num;
                    v.num = T_5_2.num;
                    }
                    }

  LINE(217);
                {
                    {CLUREF T_5_1;
                    T_5_1.num = v.vec->size;
                    z.num = T_5_1.num;
                    }
                    }

  LINE(218);
                {
                CLUREF T_6_1;
                T_6_1.num = 4096;
                err = gcd_storeOPstore_hdr(T_6_1, z);
                if (err != ERR_ok) goto ex_12;
                }
                goto end_12;
                ex_12:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_12:;

  LINE(220);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                    T_5_2.num = z.num;
                    for (T_5_1.num = 1; T_5_1.num <= T_5_2.num; T_5_1.num++) {
                        i.num = T_5_1.num;

  LINE(221);
                        {
                            {CLUREF T_6_1;
                            if (i.num < 1 || i.num > v.vec->size ) {
                                err = ERR_bounds;
                                goto ex_6;}
                            T_6_1.num = v.vec->data[i.num - 1];
                            e.num = T_6_1.num;
                            }
                            }

  LINE(222);
                        {
                        CLUREF T_6_1;
                        CLUREF T_6_2;
                        if (i.num < 1 || i.num > l.vec->size ) {
                            err = ERR_bounds;
                            goto ex_6;}
                        T_6_2.num = l.vec->data[i.num - 1];
                        CUR_PROC_VAR = T_6_2;
                        err = T_6_2.proc->proc(e, tab, &T_6_1);
                        if (err != ERR_ok) goto ex_6;
                        val.num = T_6_1.num;
                        }

  LINE(223);
                        {
                        CLUREF T_6_1;
                        T_6_1.num = (val.num < 0)? true : false;
                        if (T_6_1.num == true) {

  LINE(224);
                            {
                            CLUREF T_8_1;
                            T_8_1.num = e.num;
                            err = gcd_storeOPstore_lit(T_8_1);
                            if (err != ERR_ok) goto ex_13;
                            }
                            goto end_13;
                            ex_13:
                                if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                else {
                                    goto ex_6;}
                            end_13:;
                            }
                        else {

  LINE(226);
                            {
                            err = gcd_storeOPstore_ref(val);
                            if (err != ERR_ok) goto ex_14;
                            }
                            goto end_14;
                            ex_14:
                                if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                else {
                                    goto ex_6;}
                            end_14:;
                            }}/* end if */
                    }
                }
                end_inline_for_2:;
                break;
                }
        case 4: 
             {CLUREF T_4_4;
            T_4_4.num = T_4_1.cell->value;
            l.num = T_4_4.num;

  LINE(232);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    CLUREF T_5_3;
                    CLUREF T_5_4;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = T_5_1.num;
                    generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
                    generic_CLU_proc.proc = _tagcellOPget;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = _tagcellOPget(T_5_2, &T_5_3, &T_5_4);
                    if (err != ERR_ok) goto ex_6;
                    i.num = T_5_3.num;
                    e.num = T_5_4.num;
                    }
                    }

  LINE(233);
                {
                CLUREF T_6_1;
                T_6_1.num = 16384;
                err = gcd_storeOPstore_hdr(T_6_1, i);
                if (err != ERR_ok) goto ex_15;
                }
                goto end_15;
                ex_15:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_15:;

  LINE(235);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                if (i.num < 1 || i.num > l.vec->size ) {
                    err = ERR_bounds;
                    goto ex_6;}
                T_5_2.num = l.vec->data[i.num - 1];
                CUR_PROC_VAR = T_5_2;
                err = T_5_2.proc->proc(e, tab, &T_5_1);
                if (err != ERR_ok) goto ex_6;
                val.num = T_5_1.num;
                }

  LINE(236);
                {
                CLUREF T_5_1;
                T_5_1.num = (val.num < 0)? true : false;
                if (T_5_1.num == true) {

  LINE(237);
                    {
                    CLUREF T_7_1;
                    T_7_1.num = e.num;
                    err = gcd_storeOPstore_lit(T_7_1);
                    if (err != ERR_ok) goto ex_16;
                    }
                    goto end_16;
                    ex_16:
                        if (err == ERR_not_possible) {signal(ERR_not_possible);}
                        else {
                            goto ex_6;}
                    end_16:;
                    }
                else {

  LINE(239);
                    {
                    err = gcd_storeOPstore_ref(val);
                    if (err != ERR_ok) goto ex_17;
                    }
                    goto end_17;
                    ex_17:
                        if (err == ERR_not_possible) {signal(ERR_not_possible);}
                        else {
                            goto ex_6;}
                    end_17:;
                    }}/* end if */
                break;
                }
        case 5: 
             {CLUREF T_4_5;
            T_4_5.num = T_4_1.cell->value;
            p.num = T_4_5.num;

  LINE(244);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    CLUREF T_5_3;
                    CLUREF T_5_4;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = T_5_1.num;
                    generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
                    generic_CLU_proc.proc = _tagcellOPget;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = _tagcellOPget(T_5_2, &T_5_3, &T_5_4);
                    if (err != ERR_ok) goto ex_6;
                    i.num = T_5_3.num;
                    e.num = T_5_4.num;
                    }
                    }

  LINE(245);
                {
                CLUREF T_6_1;
                T_6_1.num = 16384;
                err = gcd_storeOPstore_hdr(T_6_1, i);
                if (err != ERR_ok) goto ex_18;
                }
                goto end_18;
                ex_18:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_18:;

  LINE(247);
                {
                CLUREF T_5_1;
                CUR_PROC_VAR = p;
                err = p.proc->proc(e, tab, &T_5_1);
                if (err != ERR_ok) goto ex_6;
                val.num = T_5_1.num;
                }

  LINE(248);
                {
                CLUREF T_5_1;
                T_5_1.num = (val.num < 0)? true : false;
                if (T_5_1.num == true) {

  LINE(249);
                    {
                    CLUREF T_7_1;
                    T_7_1.num = e.num;
                    err = gcd_storeOPstore_lit(T_7_1);
                    if (err != ERR_ok) goto ex_19;
                    }
                    goto end_19;
                    ex_19:
                        if (err == ERR_not_possible) {signal(ERR_not_possible);}
                        else {
                            goto ex_6;}
                    end_19:;
                    }
                else {

  LINE(251);
                    {
                    err = gcd_storeOPstore_ref(val);
                    if (err != ERR_ok) goto ex_20;
                    }
                    goto end_20;
                    ex_20:
                        if (err == ERR_not_possible) {signal(ERR_not_possible);}
                        else {
                            goto ex_6;}
                    end_20:;
                    }}/* end if */
                break;
                }
        case 6: 
             {CLUREF T_4_6;
            T_4_6.num = T_4_1.cell->value;
            inf.num = T_4_6.num;

  LINE(256);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = T_5_1.num;
                    a.num = T_5_2.num;
                    }
                    }

  LINE(257);
                {
                    {CLUREF T_5_1;
                    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
                    generic_CLU_proc.proc = _advOPget_vector;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = _advOPget_vector(a, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    v.num = T_5_1.num;
                    }
                    }

  LINE(258);
                {
                    {CLUREF T_5_1;
                    err = _vecOPsize(v, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    z.num = T_5_1.num;
                    }
                    }

  LINE(259);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                CLUREF T_5_4;
                CLUREF T_5_5;
                err = intOPmul(CLU_8, z, &T_5_1);
                if (err != ERR_ok) goto ex_6;
                T_5_2.num = T_5_1.num + 8;
                 if ((T_5_2.num > 0 && T_5_1.num < 0 && 8 < 0) || 
                     (T_5_2.num < 0 && T_5_1.num > 0 && 8 > 0)) {
                    err = ERR_overflow;
                    goto ex_6;}
                T_5_3.num = inf.num;
                T_5_4.num = v.num;
                err = gcd_tabOPinsert(tab, T_5_2, T_5_3, T_5_4, &T_5_5);
                if (err != ERR_ok) goto ex_6;
                val.num = T_5_5.num;
                }

  LINE(262);
                {
                err = gcd_storeOPstore_array_desc(a);
                if (err != ERR_ok) goto ex_21;
                }
                goto end_21;
                ex_21:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_21:;

  LINE(264);
                {
                CLUREF T_5_1;
                T_5_1.num = (val.num < 0)? true : false;
                if (T_5_1.num == true) {

  LINE(266);
                    {
                    elist[0] = STR_gcd_137tab_072_040array_040store_040not_040a_040ref;
                    {signal (ERR_failure);}}
                    }
                else {

  LINE(268);
                    {
                    err = gcd_storeOPstore_ref(val);
                    if (err != ERR_ok) goto ex_22;
                    }
                    goto end_22;
                    ex_22:
                        if (err == ERR_not_possible) {signal(ERR_not_possible);}
                        else {
                            goto ex_6;}
                    end_22:;
                    }}/* end if */
                break;
                }
        case 7: 
             {CLUREF T_4_7;
            T_4_7.num = T_4_1.cell->value;
            p.num = T_4_7.num;

  LINE(273);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = T_5_1.num;
                    v.num = T_5_2.num;
                    }
                    }

  LINE(274);
                {
                CLUREF T_6_1;
                CLUREF T_6_2;
                T_6_1.num = 4096;
                T_6_2.num = v.vec->size;
                err = gcd_storeOPstore_hdr(T_6_1, T_6_2);
                if (err != ERR_ok) goto ex_23;
                }
                goto end_23;
                ex_23:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_23:;

  LINE(276);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                    T_5_2.num = v.vec->size; 
                    T_5_3 = v;
                    for (T_5_1.num = 1; T_5_1.num <= T_5_2.num; T_5_1.num++) {
                        e.num = T_5_3.vec->data[T_5_1.num - 1];

  LINE(277);
                        {
                        CLUREF T_6_1;
                        CLUREF T_6_2;
                        T_6_1.num = nil;
                        T_6_2.num = (e.num == T_6_1.num)? true : false;
                        if (T_6_2.num == true) {

  LINE(279);
                            {
                            err = gcd_storeOPstore_lit(CLU_0);
                            if (err != ERR_ok) goto ex_24;
                            }
                            goto end_24;
                            ex_24:
                                if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                else {
                                    goto ex_6;}
                            end_24:;
                            }
                        else {

  LINE(282);
                            {
                            CLUREF T_7_1;
                            CUR_PROC_VAR = p;
                            err = p.proc->proc(e, tab, &T_7_1);
                            if (err != ERR_ok) goto ex_6;
                            val.num = T_7_1.num;
                            }

  LINE(283);
                            {
                            CLUREF T_7_1;
                            T_7_1.num = (val.num < 0)? true : false;
                            if (T_7_1.num == true) {

  LINE(284);
                                {
                                CLUREF T_9_1;
                                T_9_1.num = e.num;
                                err = gcd_storeOPstore_lit(T_9_1);
                                if (err != ERR_ok) goto ex_25;
                                }
                                goto end_25;
                                ex_25:
                                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                    else {
                                        goto ex_6;}
                                end_25:;
                                }
                            else {

  LINE(286);
                                {
                                err = gcd_storeOPstore_ref(val);
                                if (err != ERR_ok) goto ex_26;
                                }
                                goto end_26;
                                ex_26:
                                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                    else {
                                        goto ex_6;}
                                end_26:;
                                }}/* end if */
                            }}/* end if */
                    }
                }
                end_inline_for_3:;
                break;
                }
        }
        }
        }
        end_while_1:;
    goto end_6;
    ex_6:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_5;}
    end_6:;
        goto end_5;
        ex_5:
            if ((err == ERR_bounds)) {
            }
            else {
                goto ex_0;
            }
        end_5:;

  LINE(295);
    {
    err = gcd_storeOPdone();
    if (err != ERR_ok) goto ex_27;
    }
    goto end_27;
    ex_27:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_27:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE mgrind ****/


/**** BEGIN PROCEDURE insert ****/

errcode gcd_tabOPinsert(tab, z, inf, x, ret_1)
CLUREF tab;
CLUREF z;
CLUREF inf;
CLUREF x;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF i;
    CLUREF xmb;
    CLUREF mb;
    CLUREF addr;
        if (gcd_tab_own_init == 0) {
            err = gcd_tab_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(300);

  LINE(307);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = 50000;
        err = hash_obj(x, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = T_1_2.num + 1;
         if ((T_1_3.num > 0 && T_1_2.num < 0 && 1 < 0) || 
             (T_1_3.num < 0 && T_1_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        i.num = T_1_3.num;
        }
        }

  LINE(308);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = tab.vec->data[0];
        if (i.num < 1 || i.num > T_1_1.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_2.num = T_1_1.vec->data[i.num - 1];
        xmb.num = T_1_2.num;
        }
        }

  LINE(309);
    {
        {mb.num = xmb.num;
        }
        }

  LINE(310);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = nil;
        T_1_2.num = (mb.num == T_1_1.num)? true : false;
        T_1_3.num = T_1_2.num ^ 1;
        if (T_1_3.num != true) { break; }

  LINE(311);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = mb.num;
        T_2_2.num = T_2_1.vec->data[2];
        T_2_3.num = (x.num == T_2_2.num)? true : false;
        if (T_2_3.num == true) {

  LINE(312);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = mb.num;
            T_3_2.num = T_3_1.vec->data[0];
            ret_1->num = T_3_2.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(313);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = mb.num;
        T_2_2.num = T_2_1.vec->data[1];
        mb.num = T_2_2.num;
        }
        }
        end_while_1:;

  LINE(315);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.vec->data[3];
        addr.num = T_1_1.num;
        }
        }

  LINE(316);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = tab.vec->data[0];
    RecordAlloc(3, T_1_2);
    T_1_2.vec->data[2]  = x.num;
    T_1_2.vec->data[0]  = addr.num;
    T_1_2.vec->data[1]  = xmb.num;
    T_1_3.num = T_1_2.num;
    err = _vecOPstore(T_1_1, i, T_1_3);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(319);
    {
    CLUREF T_1_1;
    T_1_1.num = tab.vec->data[4];
    {
    if ((T_1_1.array->int_low + T_1_1.array->ext_size + 1) < T_1_1.array->int_size) {
        T_1_1.array->store->data[T_1_1.array->int_low + T_1_1.array->ext_size] = x.num;
        T_1_1.array->ext_size++; T_1_1.array->ext_high++;}
    else {
        err = arrayOPaddh(T_1_1, x);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(320);
    {
    CLUREF T_1_1;
    T_1_1.num = tab.vec->data[2];
    {
    if ((T_1_1.array->int_low + T_1_1.array->ext_size + 1) < T_1_1.array->int_size) {
        T_1_1.array->store->data[T_1_1.array->int_low + T_1_1.array->ext_size] = inf.num;
        T_1_1.array->ext_size++; T_1_1.array->ext_high++;}
    else {
        err = arrayOPaddh(T_1_1, inf);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(321);
    {
    CLUREF T_1_1;
    T_1_1.num = addr.num + z.num;
     if ((T_1_1.num > 0 && addr.num < 0 && z.num < 0) || 
         (T_1_1.num < 0 && addr.num > 0 && z.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    tab.vec->data[3]  = T_1_1.num;
    }

  LINE(322);
    {
    {
    ret_1->num = addr.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE insert ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[3];
} gcd_tab_OPS;

CLU_proc gcd_tab_oe_grind = {{0,0,0,0}, gcd_tabOPgrind, 0};
CLU_proc gcd_tab_oe_grindc = {{0,0,0,0}, gcd_tabOPgrindc, 0};
CLU_proc gcd_tab_oe_grindp = {{0,0,0,0}, gcd_tabOPgrindp, 0};

gcd_tab_OPS gcd_tab_ops_actual = {3, (OWNPTR)&gcd_tab_own_init, (OWNPTR)&gcd_tab_own_init, {
    {&gcd_tab_oe_grind, "grind"},
    {&gcd_tab_oe_grindc, "grindc"},
    {&gcd_tab_oe_grindp, "grindp"}}};

struct OPS *gcd_tab_ops = (struct OPS *)&gcd_tab_ops_actual;

/**** END CLUSTER gcd_tab ****/

/**** BEGIN CLUSTER gcd_store ****/

extern errcode _bytevecOPstore();
extern errcode gcd_storeOPneed();
extern errcode _advOPget_size();
extern errcode _advOPget_low();
extern errcode _advOPget_start();
extern errcode _advOPget_predict();
extern errcode intOPdiv();
extern errcode intOPsub();
extern errcode intOPmin();
extern errcode _wordvecOPmove_b2w();
extern errcode intOPequal();
extern errcode intOPle();
struct OPS *_adv_of__obj_table;
struct OPS *_adv_of__obj_ops;
struct OPS *_adv_of__obj_ops;
OWNPTR _adv_of__obj_owns;
static int gcd_store_own_init = 0;
OWN_req gcd_store_ownreqs = {0,0};
CLUREF gcd_storeOPpos;
CLUREF gcd_storeOPbuf;
CLUREF gcd_storeOPch;
errcode gcd_store_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (gcd_store_own_init == 0) {
        add_parm_info_type(0, _obj_ops, _adv_of_t_reqs);
        find_type_instance(_adv_ops, 1, &_adv_ownreqs, &(_adv_of__obj_ops));
        gcd_store_own_init = 1;
        {
            {gcd_storeOPpos.num = 1;
            }
            }
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE init ****/

errcode gcd_storeOPinit(w, c)
CLUREF w;
CLUREF c;
    {
    errcode err;
    errcode ecode2;
        if (gcd_store_own_init == 0) {
            err = gcd_store_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(364);

  LINE(365);
    {
    gcd_storeOPbuf.num = w.num;
    }

  LINE(366);
    {
    gcd_storeOPch.num = c.num;
    }

  LINE(367);
    {
    gcd_storeOPpos.num = 1;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE init ****/


/**** BEGIN PROCEDURE store_id ****/

errcode gcd_storeOPstore_id()
    {
    errcode err;
    errcode ecode2;
        if (gcd_store_own_init == 0) {
            err = gcd_store_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(370);

  LINE(378);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = gcd_storeOPbuf.num;
    T_1_2.ch = 'D';
    err = _bytevecOPstore(T_1_1, CLU_1, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(379);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = gcd_storeOPbuf.num;
    T_1_2.ch = 'W';
    err = _bytevecOPstore(T_1_1, CLU_2, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(380);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = gcd_storeOPbuf.num;
    T_1_2.ch = 'C';
    err = _bytevecOPstore(T_1_1, CLU_3, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(381);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = gcd_storeOPbuf.num;
    T_1_2.ch = '1';
    err = _bytevecOPstore(T_1_1, CLU_4, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(382);
    {
    gcd_storeOPpos.num = 3;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE store_id ****/


/**** BEGIN PROCEDURE store_lit ****/

errcode gcd_storeOPstore_lit(i1)
CLUREF i1;
    {
    errcode err;
    errcode ecode2;
        if (gcd_store_own_init == 0) {
            err = gcd_store_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(385);

  LINE(388);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(390);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, CLU_32);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(391);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(392);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_2;
    }
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_2:;

  LINE(394);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, i1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(395);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE store_lit ****/


/**** BEGIN PROCEDURE store_ref ****/

errcode gcd_storeOPstore_ref(i1)
CLUREF i1;
    {
    errcode err;
    errcode ecode2;
        if (gcd_store_own_init == 0) {
            err = gcd_store_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(398);

  LINE(401);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(403);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, CLU_33);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(404);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(405);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_2;
    }
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_2:;

  LINE(407);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, i1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(408);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE store_ref ****/


/**** BEGIN PROCEDURE store_hdr ****/

errcode gcd_storeOPstore_hdr(hid, size)
CLUREF hid;
CLUREF size;
    {
    errcode err;
    errcode ecode2;
        if (gcd_store_own_init == 0) {
            err = gcd_store_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(412);

  LINE(415);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(417);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, hid);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(418);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(419);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_2;
    }
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_2:;

  LINE(421);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, size);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(422);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE store_hdr ****/

struct OPS *_adv_of__obj_table;
struct OPS *_adv_of__obj_ops;
struct OPS *_adv_of__obj_ops;
OWNPTR _adv_of__obj_owns;
static int gcd_storeOPstore_array_desc_own_init = 0;

/**** BEGIN PROCEDURE store_array_desc ****/

errcode gcd_storeOPstore_array_desc(a)
CLUREF a;
    {
    errcode err;
    errcode ecode2;
        if (gcd_storeOPstore_array_desc_own_init == 0) {
        if (gcd_store_own_init == 0) {
            err = gcd_store_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        gcd_storeOPstore_array_desc_own_init = 1;
    }
    enter_proc(427);

  LINE(431);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(433);
    {
    CLUREF T_1_1;
    T_1_1.num = 24576;
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(434);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(436);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_2;
    }
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_2:;

  LINE(438);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, CLU_32);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(439);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(441);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_3;
    }
    goto end_3;
    ex_3:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_3:;

  LINE(443);
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPget_size;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPget_size(a, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(444);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(446);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_4;
    }
    goto end_4;
    ex_4:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_4:;

  LINE(448);
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPget_low;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPget_low(a, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(449);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(451);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_5;
    }
    goto end_5;
    ex_5:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_5:;

  LINE(453);
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPget_start;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPget_start(a, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(454);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(456);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_6;
    }
    goto end_6;
    ex_6:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_6:;

  LINE(458);
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPget_predict;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPget_predict(a, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(459);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE store_array_desc ****/


/**** BEGIN PROCEDURE store_string ****/

errcode gcd_storeOPstore_string(s)
CLUREF s;
    {
    errcode err;
    errcode ecode2;
    CLUREF bsize;
    CLUREF bytes_to_go;
    CLUREF total_bytes;
    CLUREF rounded_longs;
    CLUREF total_longs;
    CLUREF total_output;
    CLUREF i;
    CLUREF avail;
    CLUREF copy_count;
        if (gcd_store_own_init == 0) {
            err = gcd_store_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(464);

  LINE(466);
    {
        {CLUREF T_1_1;
        err = _bytevecOPsize(s, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        bsize.num = T_1_1.num;
        }
        }

  LINE(468);
    {
        {bytes_to_go.num = bsize.num;
        }
        }

  LINE(469);
    {
        {CLUREF T_1_1;
        T_1_1.num = bsize.num + 1;
         if ((T_1_1.num > 0 && bsize.num < 0 && 1 < 0) || 
             (T_1_1.num < 0 && bsize.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        total_bytes.num = T_1_1.num;
        }
        }

  LINE(470);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = total_bytes.num + 4;
         if ((T_1_1.num > 0 && total_bytes.num < 0 && 4 < 0) || 
             (T_1_1.num < 0 && total_bytes.num > 0 && 4 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        T_1_2.num = T_1_1.num - 1;
         if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-1) < 0) || 
             (T_1_2.num <= 0 && T_1_1.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = intOPdiv(T_1_2, CLU_4, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        rounded_longs.num = T_1_3.num;
        }
        }

  LINE(471);
    {
        {total_longs.num = rounded_longs.num;
        }
        }

  LINE(474);
    {
        {total_output.num = 0;
        }
        }

  LINE(475);
    {
        {i.num = 1;
        }
        }

  LINE(476);
    for (;;) {
        if (true != true) { break; }

  LINE(477);
        {
            {CLUREF T_4_1;
            err = gcd_storeOPneed(rounded_longs, &T_4_1);
            if (err != ERR_ok) goto ex_2;
            avail.num = T_4_1.num;
            }
            }
        goto end_2;
        ex_2:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_1;}
        end_2:;

  LINE(479);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            err = intOPmul(avail, CLU_4, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            err = intOPmin(bytes_to_go, T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            copy_count.num = T_3_2.num;
            }
            }

  LINE(480);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = intOPmul(gcd_storeOPpos, CLU_4, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        T_3_2.num = T_3_1.num - 3;
         if ((T_3_2.num >= 0 && T_3_1.num < 0 && (-3) < 0) || 
             (T_3_2.num <= 0 && T_3_1.num > 0 && (-3) > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        err = _wordvecOPmove_b2w(s, i, gcd_storeOPbuf, T_3_2, copy_count);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(485);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = intOPmul(avail, CLU_4, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        T_3_2.num = i.num + T_3_1.num;
         if ((T_3_2.num > 0 && i.num < 0 && T_3_1.num < 0) || 
             (T_3_2.num < 0 && i.num > 0 && T_3_1.num > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        i.num = T_3_2.num;
        }

  LINE(486);
        {
        CLUREF T_3_1;
        T_3_1.num = bytes_to_go.num - copy_count.num;
         if ((T_3_1.num >= 0 && bytes_to_go.num < 0 && (-copy_count.num) < 0) || 
             (T_3_1.num <= 0 && bytes_to_go.num > 0 && (-copy_count.num) > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        bytes_to_go.num = T_3_1.num;
        }

  LINE(487);
        {
        CLUREF T_3_1;
        T_3_1.num = gcd_storeOPpos.num + avail.num;
         if ((T_3_1.num > 0 && gcd_storeOPpos.num < 0 && avail.num < 0) || 
             (T_3_1.num < 0 && gcd_storeOPpos.num > 0 && avail.num > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        gcd_storeOPpos.num = T_3_1.num;
        }

  LINE(488);
        {
        CLUREF T_3_1;
        T_3_1.num = total_output.num + avail.num;
         if ((T_3_1.num > 0 && total_output.num < 0 && avail.num < 0) || 
             (T_3_1.num < 0 && total_output.num > 0 && avail.num > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        total_output.num = T_3_1.num;
        }

  LINE(489);
        {
        CLUREF T_3_1;
        T_3_1.num = (total_output.num == total_longs.num)? true : false;
        if (T_3_1.num == true) {
            {
                err = "ERR_done";
                goto ex_1;
                }
            }
            }/* end if */

  LINE(490);
        {
        CLUREF T_3_1;
        T_3_1.num = rounded_longs.num - avail.num;
         if ((T_3_1.num >= 0 && rounded_longs.num < 0 && (-avail.num) < 0) || 
             (T_3_1.num <= 0 && rounded_longs.num > 0 && (-avail.num) > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        rounded_longs.num = T_3_1.num;
        }
        }
        end_while_1:;
        goto end_1;
        ex_1:
            if (errcmp(err, "ERR_done")) {
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE store_string ****/


/**** BEGIN PROCEDURE done ****/

errcode gcd_storeOPdone()
    {
    errcode err;
    errcode ecode2;
        if (gcd_store_own_init == 0) {
            err = gcd_store_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(495);

  LINE(497);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = gcd_storeOPpos.num - 1;
     if ((T_2_1.num >= 0 && gcd_storeOPpos.num < 0 && (-1) < 0) || 
         (T_2_1.num <= 0 && gcd_storeOPpos.num > 0 && (-1) > 0)) {
        err = ERR_overflow;
        goto ex_1;}
    err = intOPmul(CLU_4, T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    err = _chanOPputw(gcd_storeOPch, gcd_storeOPbuf, CLU_1, T_2_2, CLU_0);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE done ****/


/**** BEGIN PROCEDURE need ****/

errcode gcd_storeOPneed(i, ret_1)
CLUREF i;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (gcd_store_own_init == 0) {
            err = gcd_store_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(501);

  LINE(502);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    T_1_1.num = gcd_storeOPpos.num + i.num;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && i.num < 0) || 
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && i.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    T_1_2.num = T_1_1.num - 1;
     if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-1) < 0) || 
         (T_1_2.num <= 0 && T_1_1.num > 0 && (-1) > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    err = intOPmul(CLU_4, T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_4.num = 4096;
    T_1_5.num = (T_1_3.num <= T_1_4.num)? true : false;
    if (T_1_5.num == true) {
        {
        {
        ret_1->num = i.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(503);
    {
    CLUREF T_1_1;
    T_1_1.num = (i.num == 1)? true : false;
    if (T_1_1.num == true) {

  LINE(507);
        {
        CLUREF T_3_1;
        T_3_1.num = 4096;
        err = _chanOPputw(gcd_storeOPch, gcd_storeOPbuf, CLU_1, T_3_1, CLU_0);
        if (err != ERR_ok) goto ex_1;
        }
        goto end_1;
        ex_1:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_0;}
        end_1:;

  LINE(509);
        {
        gcd_storeOPpos.num = 1;
        }

  LINE(510);
        {
        {
        ret_1->num = i.num;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(512);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 1024;
        T_2_2.num = (gcd_storeOPpos.num <= T_2_1.num)? true : false;
        if (T_2_2.num == true) {
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = 1024;
            T_3_2.num = T_3_1.num - gcd_storeOPpos.num;
             if ((T_3_2.num >= 0 && T_3_1.num < 0 && (-gcd_storeOPpos.num) < 0) || 
                 (T_3_2.num <= 0 && T_3_1.num > 0 && (-gcd_storeOPpos.num) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            T_3_3.num = T_3_2.num + 1;
             if ((T_3_3.num > 0 && T_3_2.num < 0 && 1 < 0) || 
                 (T_3_3.num < 0 && T_3_2.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            ret_1->num = T_3_3.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(514);
        {
        CLUREF T_3_1;
        T_3_1.num = 4096;
        err = _chanOPputw(gcd_storeOPch, gcd_storeOPbuf, CLU_1, T_3_1, CLU_0);
        if (err != ERR_ok) goto ex_2;
        }
        goto end_2;
        ex_2:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_0;}
        end_2:;

  LINE(516);
        {
        gcd_storeOPpos.num = 1;
        }

  LINE(517);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 1024;
        err = intOPmin(i, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_2.num;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE need ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[8];
} gcd_store_OPS;

CLU_proc gcd_store_oe_done = {{0,0,0,0}, gcd_storeOPdone, 0};
CLU_proc gcd_store_oe_init = {{0,0,0,0}, gcd_storeOPinit, 0};
CLU_proc gcd_store_oe_store_array_desc = {{0,0,0,0}, gcd_storeOPstore_array_desc, 0};
CLU_proc gcd_store_oe_store_hdr = {{0,0,0,0}, gcd_storeOPstore_hdr, 0};
CLU_proc gcd_store_oe_store_id = {{0,0,0,0}, gcd_storeOPstore_id, 0};
CLU_proc gcd_store_oe_store_lit = {{0,0,0,0}, gcd_storeOPstore_lit, 0};
CLU_proc gcd_store_oe_store_ref = {{0,0,0,0}, gcd_storeOPstore_ref, 0};
CLU_proc gcd_store_oe_store_string = {{0,0,0,0}, gcd_storeOPstore_string, 0};

gcd_store_OPS gcd_store_ops_actual = {8, (OWNPTR)&gcd_store_own_init, (OWNPTR)&gcd_store_own_init, {
    {&gcd_store_oe_done, "done"},
    {&gcd_store_oe_init, "init"},
    {&gcd_store_oe_store_array_desc, "store_array_desc"},
    {&gcd_store_oe_store_hdr, "store_hdr"},
    {&gcd_store_oe_store_id, "store_id"},
    {&gcd_store_oe_store_lit, "store_lit"},
    {&gcd_store_oe_store_ref, "store_ref"},
    {&gcd_store_oe_store_string, "store_string"}}};

struct OPS *gcd_store_ops = (struct OPS *)&gcd_store_ops_actual;

/**** END CLUSTER gcd_store ****/

extern errcode streamOPerror_output();
extern errcode streamOPputs();
extern errcode stringOPconcat();
CLUREF STR__012;
static int logit_own_init = 0;

/**** BEGIN PROCEDURE logit ****/

errcode logit(s)
CLUREF s;
    {
    errcode err;
    errcode ecode2;
    CLUREF po;
        if (logit_own_init == 0) {
        stringOPcons("\n", CLU_1, CLU_1, &STR__012);
        logit_own_init = 1;
    }
    enter_proc(558);

  LINE(559);
    {
        {CLUREF T_1_1;
        err = streamOPerror_output(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        po.num = T_1_1.num;
        }
        }

  LINE(560);
    {
    CLUREF T_1_1;
    err = stringOPconcat(s, STR__012, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = streamOPputs(po, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE logit ****/

