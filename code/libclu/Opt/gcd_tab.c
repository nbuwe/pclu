
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"

/**** BEGIN CLUSTER gcd_tab ****/


static const struct /* REQS */ {
    long count;
    const struct REQ_ENTRY entry[1];
} gcd_tab_op_grind_of_t_reqs_actual = {
    1, {
        { "_gcd" },
    }
};

const struct REQS * const gcd_tab_op_grind_of_t_reqs
    = (const struct REQS *)&gcd_tab_op_grind_of_t_reqs_actual;

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY _gcd;
} gcd_tab_op_grind_of_t_OPS;

static const struct /* REQS */ {
    long count;
    const struct REQ_ENTRY entry[1];
} gcd_tab_op_grindc_of_t_reqs_actual = {
    1, {
        { "_gcd" },
    }
};

const struct REQS * const gcd_tab_op_grindc_of_t_reqs
    = (const struct REQS *)&gcd_tab_op_grindc_of_t_reqs_actual;

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY _gcd;
} gcd_tab_op_grindc_of_t_OPS;

static const struct /* REQS */ {
    long count;
    const struct REQ_ENTRY entry[1];
} gcd_tab_op_grindp_of_t_reqs_actual = {
    1, {
        { "_gcd" },
    }
};

const struct REQS * const gcd_tab_op_grindp_of_t_reqs
    = (const struct REQS *)&gcd_tab_op_grindp_of_t_reqs_actual;

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY _gcd;
} gcd_tab_op_grindp_of_t_OPS;

static const struct /* REQS */ {
    long count;
    const struct REQ_ENTRY entry[1];
} gcd_tab_op_pgrind_of_t_reqs_actual = {
    1, {
        { "_gcd" },
    }
};

const struct REQS * const gcd_tab_op_pgrind_of_t_reqs
    = (const struct REQS *)&gcd_tab_op_pgrind_of_t_reqs_actual;

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY _gcd;
} gcd_tab_op_pgrind_of_t_OPS;

static const struct /* REQS */ {
    long count;
    const struct REQ_ENTRY entry[1];
} gcd_tab_op_mgrind_of_t_reqs_actual = {
    1, {
        { "_gcd" },
    }
};

const struct REQS * const gcd_tab_op_mgrind_of_t_reqs
    = (const struct REQS *)&gcd_tab_op_mgrind_of_t_reqs_actual;

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY _gcd;
} gcd_tab_op_mgrind_of_t_OPS;
extern errcode _wordvecOPbytes_per_word();
extern errcode intOPmul();
extern errcode _chanOPopen();
extern errcode _chanOPget_name();
extern errcode _gcOPcount();
extern errcode arrayOPpredict();
extern errcode _vecOPcreate();
extern errcode _wordvecOPcreate();
extern errcode _eventOPdefer();
extern errcode gcd_tabOPmgrind();
extern errcode _wordvecOPstore();
extern errcode recordOPget_4();
extern errcode _chanOPset_access();
extern errcode _chanOPputw();
extern errcode _eventOPundefer();
extern errcode _chanOPabort();
extern errcode _chanOPclose();
extern errcode arrayOPnew();
extern errcode intOPadd();
extern errcode gcd_tabOPpgrind();
extern errcode recordOPset_4();
extern errcode recordOPget_3();
extern errcode recordOPget_5();
extern errcode arrayOPfetch();
extern errcode _cvt();
extern errcode sequenceOPelements();
extern errcode sequenceOPindexes();
extern errcode sequenceOPfetch();
extern errcode _tagcellOPget();
extern errcode _advOPget_vector();
extern errcode gcd_tabOPinsert();
extern errcode _vecOPsize();
extern errcode boolOPnot();
extern errcode _objOPequal();
extern errcode gcd_storeOPinit();
extern errcode gcd_storeOPstore_id();
extern errcode intOPlt();
extern errcode gcd_storeOPstore_lit();
extern errcode gcd_storeOPstore_ref();
extern errcode arrayOPreml();
extern errcode _bytevecOPsize();
extern errcode gcd_storeOPstore_hdr();
extern errcode gcd_storeOPstore_string();
extern errcode sequenceOPsize();
extern errcode intOPfrom_to();
extern errcode gcd_storeOPstore_array_desc();
extern errcode gcd_storeOPdone();
extern errcode hash_obj();
extern errcode _vecOPfetch();
extern errcode recordOPget_1();
extern errcode recordOPget_2();
extern errcode _vecOPstore();
extern errcode arrayOPaddh();
extern const OWN_req gcd_tab_ownreqs;
extern struct OPS *gcd_tab_ops;
extern const struct REQS * const gcd_tab_op_mgrind_of_t_reqs;
extern const OWN_req gcd_tab_op_mgrind_ownreqs;
extern const struct REQS * const gcd_tab_op_pgrind_of_t_reqs;
extern const OWN_req gcd_tab_op_pgrind_ownreqs;
extern const struct REQS * const _tagcell_of_t_reqs;
extern struct OPS *_obj_ops;
extern const OWN_req _tagcell_ownreqs;
extern struct OPS *_tagcell_ops;
struct OPS *_tagcell_of__obj_ops;
extern const struct REQS * const _adv_of_t_reqs;
extern const OWN_req _adv_ownreqs;
extern struct OPS *_adv_ops;
struct OPS *_adv_of__obj_ops;
static CLUREF STR_write;
static CLUREF STR_gcd_137tab_072_040array_040store_040not_040a_040ref;
static int gcd_tab_own_init = 0;
const OWN_req gcd_tab_ownreqs = { 0, 0 };
CLUREF gcd_tabOPclurefsz;
CLUREF gcd_tabOPgcd_ref_size;
CLUREF gcd_tabOPbpagesz;

errcode
gcd_tab_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (gcd_tab_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)_obj_ops, _tagcell_of_t_reqs);
        find_type_instance(_tagcell_ops, 1, &_tagcell_ownreqs, &(_tagcell_of__obj_ops));
        add_parm_info_type(0, (const struct OPS *)_obj_ops, _adv_of_t_reqs);
        find_type_instance(_adv_ops, 1, &_adv_ownreqs, &(_adv_of__obj_ops));
        stringOPcons("write", CLU_1, CLUREF_make_num(5), &STR_write);
        stringOPcons("gcd_tab: array store not a ref", CLU_1, CLUREF_make_num(30), &STR_gcd_137tab_072_040array_040store_040not_040a_040ref);
        gcd_tab_own_init = 1;
        {
            {CLUREF T_0_1;
            err = _wordvecOPbytes_per_word(&T_0_1);
            if (err != ERR_ok) goto ex_0;
            gcd_tabOPclurefsz.num = T_0_1.num;
            }
            }
        {
            {CLUREF T_0_2;
            err = intOPmul(gcd_tabOPclurefsz, CLU_2, &T_0_2);
            if (err != ERR_ok) goto ex_0;
            gcd_tabOPgcd_ref_size.num = T_0_2.num;
            }
            }
        {
            {CLUREF T_0_3;
            CLUREF T_0_4;
            T_0_3.num = 1024;
            err = intOPmul(T_0_3, gcd_tabOPclurefsz, &T_0_4);
            if (err != ERR_ok) goto ex_0;
            gcd_tabOPbpagesz.num = T_0_4.num;
            }
            }
        signal(ERR_ok);
      ex_0:
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE grind ****/


typedef struct {
    long grind_own_init;
    const gcd_tab_op_grind_of_t_OPS * const t_ops;
    struct OPS *gcd_tab_op_mgrind_of_t_ops;
} gcd_tab_op_grind_OWN_DEFN;
const OWN_req gcd_tab_op_grind_ownreqs = { sizeof(gcd_tab_op_grind_OWN_DEFN), 1 };


errcode
gcd_tabOPgrind(CLUREF x, CLUREF fn, CLUREF *ret_1)
{
    errcode err;
    gcd_tab_op_grind_OWN_DEFN *op_own_ptr;
    CLUREF ch;
    CLUREF tab;
    CLUREF buf;
    CLUREF why;
    op_own_ptr = (gcd_tab_op_grind_OWN_DEFN *)CUR_PROC_VAR.proc->op_owns;
    if (op_own_ptr->grind_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)op_own_ptr->t_ops, gcd_tab_op_mgrind_of_t_reqs);
        find_typeop_instance(gcd_tab_ops, gcd_tabOPmgrind, 1, 0, &gcd_tab_op_mgrind_ownreqs, &gcd_tab_ownreqs, &(op_own_ptr->gcd_tab_op_mgrind_of_t_ops));
        stringOPcons("write", CLU_1, CLUREF_make_num(5), &STR_write);
    }
    if (gcd_tab_own_init == 0) {
        err = gcd_tab_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    if (op_own_ptr->grind_own_init == 0) {
        op_own_ptr->grind_own_init = 1;
        /* no own vars to init */
    }
    enter_proc(49);

  LINE(53);
    {
        {CLUREF T_2_1;
        err = _chanOPopen(fn, STR_write, CLU_0, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        ch.num = T_2_1.num;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(55);
    {
    CLUREF T_1_1;
    err = _chanOPget_name(ch, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    fn.num = T_1_1.num;
    }

  LINE(56);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        CLUREF T_1_6;
        CLUREF T_1_7;
        CLUREF T_1_8;
        RecordAlloc(5, T_1_1);
        T_1_1.vec->data[3] = 0;
        err = _gcOPcount(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1] = T_1_2.num;
        T_1_3.num = 300000;
        err = arrayOPpredict(CLU_1, T_1_3, &T_1_4);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[4] = T_1_4.num;
        T_1_5.num = 300000;
        err = arrayOPpredict(CLU_1, T_1_5, &T_1_6);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[2] = T_1_6.num;
        T_1_7.num = 50000;
        err = _vecOPcreate(T_1_7, &T_1_8);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0] = T_1_8.num;
        tab.num = T_1_1.num;
        }
        }

  LINE(61);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = 1024;
        err = _wordvecOPcreate(T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        buf.num = T_1_2.num;
        }
        }

  LINE(68);
    {
    err = _eventOPdefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(69);
    {

  LINE(70);
        {
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = op_own_ptr->gcd_tab_op_mgrind_of_t_ops->op_owns;
        generic_CLU_proc.proc = gcd_tabOPmgrind;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = gcd_tabOPmgrind(tab, buf, ch, x);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(71);
        {
        CLUREF T_3_1;
        T_3_1.num = tab.vec->data[3];
        err = _wordvecOPstore(buf, CLU_1, T_3_1);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(72);
        {
        err = _chanOPset_access(ch, CLU_4);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(73);
        {
        err = _chanOPputw(ch, buf, CLU_1, CLU_4, CLU_0);
        if (err != ERR_ok) goto ex_2;
        }
        }
        goto end_2;
        ex_2:
            if ((err == ERR_not_possible)) {
            CLUREF why;
            why.num = elist[0].num;

  LINE(75);
                {
                err = _eventOPundefer();
                if (err != ERR_ok) goto ex_0;
                }

  LINE(76);
                {
                err = _chanOPabort(ch);
                if (err != ERR_ok) goto ex_3;
                }
                    goto end_3;
                    ex_3:
                        if ((err == ERR_not_possible)) {
                        }
                        else {
                            goto ex_0;
                        }
                    end_3:;

  LINE(78);
                {
                elist[0] = why;
                {signal (ERR_not_possible);}}
            }
            else {
                goto ex_0;
            }
        end_2:;

  LINE(80);
    {
    err = _eventOPundefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(82);
    {
    err = _chanOPclose(ch);
    if (err != ERR_ok) goto ex_4;
    }
    goto end_4;
    ex_4:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_4:;

  LINE(84);
    {
    {
    ret_1->num = fn.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE grind ****/


/**** BEGIN PROCEDURE grindc ****/


typedef struct {
    long grindc_own_init;
    const gcd_tab_op_grindc_of_t_OPS * const t_ops;
    struct OPS *gcd_tab_op_mgrind_of_t_ops;
} gcd_tab_op_grindc_OWN_DEFN;
const OWN_req gcd_tab_op_grindc_ownreqs = { sizeof(gcd_tab_op_grindc_OWN_DEFN), 1 };


errcode
gcd_tabOPgrindc(CLUREF x, CLUREF ch, CLUREF pos)
{
    errcode err;
    gcd_tab_op_grindc_OWN_DEFN *op_own_ptr;
    CLUREF tab;
    CLUREF buf;
    CLUREF why;
    op_own_ptr = (gcd_tab_op_grindc_OWN_DEFN *)CUR_PROC_VAR.proc->op_owns;
    if (op_own_ptr->grindc_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)op_own_ptr->t_ops, gcd_tab_op_mgrind_of_t_reqs);
        find_typeop_instance(gcd_tab_ops, gcd_tabOPmgrind, 1, 0, &gcd_tab_op_mgrind_ownreqs, &gcd_tab_ownreqs, &(op_own_ptr->gcd_tab_op_mgrind_of_t_ops));
    }
    if (gcd_tab_own_init == 0) {
        err = gcd_tab_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    if (op_own_ptr->grindc_own_init == 0) {
        op_own_ptr->grindc_own_init = 1;
        /* no own vars to init */
    }
    enter_proc(88);

  LINE(91);
    {
    err = _chanOPset_access(ch, pos);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(93);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        CLUREF T_1_6;
        RecordAlloc(5, T_1_1);
        T_1_1.vec->data[3] = 0;
        err = _gcOPcount(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1] = T_1_2.num;
        err = arrayOPnew(&T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[4] = T_1_3.num;
        err = arrayOPnew(&T_1_4);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[2] = T_1_4.num;
        T_1_5.num = 50000;
        err = _vecOPcreate(T_1_5, &T_1_6);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0] = T_1_6.num;
        tab.num = T_1_1.num;
        }
        }

  LINE(98);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = 1024;
        err = _wordvecOPcreate(T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        buf.num = T_1_2.num;
        }
        }

  LINE(99);
    {
    err = _eventOPdefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(100);
    {

  LINE(101);
        {
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = op_own_ptr->gcd_tab_op_mgrind_of_t_ops->op_owns;
        generic_CLU_proc.proc = gcd_tabOPmgrind;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = gcd_tabOPmgrind(tab, buf, ch, x);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(102);
        {
        CLUREF T_3_1;
        T_3_1.num = tab.vec->data[3];
        err = _wordvecOPstore(buf, CLU_1, T_3_1);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(103);
        {
        CLUREF T_3_1;
        T_3_1.num = pos.num + 4;
         if ((T_3_1.num > 0 && pos.num < 0 && 4 < 0) ||
             (T_3_1.num < 0 && pos.num > 0 && 4 > 0)) {
            err = ERR_overflow;
            goto ex_2;}
        err = _chanOPset_access(ch, T_3_1);
        if (err != ERR_ok) goto ex_2;
        }

  LINE(104);
        {
        err = _chanOPputw(ch, buf, CLU_1, CLU_4, CLU_0);
        if (err != ERR_ok) goto ex_2;
        }
        }
        goto end_2;
        ex_2:
            if ((err == ERR_not_possible)) {
            CLUREF why;
            why.num = elist[0].num;

  LINE(106);
                {
                err = _eventOPundefer();
                if (err != ERR_ok) goto ex_0;
                }

  LINE(107);
                {
                elist[0] = why;
                {signal (ERR_not_possible);}}
            }
            else {
                goto ex_0;
            }
        end_2:;

  LINE(109);
    {
    err = _eventOPundefer();
    if (err != ERR_ok) goto ex_0;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE grindc ****/


/**** BEGIN PROCEDURE grindp ****/


typedef struct {
    long grindp_own_init;
    const gcd_tab_op_grindp_of_t_OPS * const t_ops;
    struct OPS *gcd_tab_op_pgrind_of_t_ops;
    struct OPS *gcd_tab_op_mgrind_of_t_ops;
} gcd_tab_op_grindp_OWN_DEFN;
const OWN_req gcd_tab_op_grindp_ownreqs = { sizeof(gcd_tab_op_grindp_OWN_DEFN), 1 };


errcode
gcd_tabOPgrindp(CLUREF x, CLUREF ch)
{
    errcode err;
    gcd_tab_op_grindp_OWN_DEFN *op_own_ptr;
    CLUREF tab;
    CLUREF buf;
    CLUREF why;
    op_own_ptr = (gcd_tab_op_grindp_OWN_DEFN *)CUR_PROC_VAR.proc->op_owns;
    if (op_own_ptr->grindp_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)op_own_ptr->t_ops, gcd_tab_op_pgrind_of_t_reqs);
        find_typeop_instance(gcd_tab_ops, gcd_tabOPpgrind, 1, 0, &gcd_tab_op_pgrind_ownreqs, &gcd_tab_ownreqs, &(op_own_ptr->gcd_tab_op_pgrind_of_t_ops));
        add_parm_info_type(0, (const struct OPS *)op_own_ptr->t_ops, gcd_tab_op_mgrind_of_t_reqs);
        find_typeop_instance(gcd_tab_ops, gcd_tabOPmgrind, 1, 0, &gcd_tab_op_mgrind_ownreqs, &gcd_tab_ownreqs, &(op_own_ptr->gcd_tab_op_mgrind_of_t_ops));
    }
    if (gcd_tab_own_init == 0) {
        err = gcd_tab_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    if (op_own_ptr->grindp_own_init == 0) {
        op_own_ptr->grindp_own_init = 1;
        /* no own vars to init */
    }
    enter_proc(113);

  LINE(115);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        CLUREF T_1_6;
        RecordAlloc(5, T_1_1);
        T_1_1.vec->data[3] = 0;
        err = _gcOPcount(&T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[1] = T_1_2.num;
        err = arrayOPnew(&T_1_3);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[4] = T_1_3.num;
        err = arrayOPnew(&T_1_4);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[2] = T_1_4.num;
        T_1_5.num = 50000;
        err = _vecOPcreate(T_1_5, &T_1_6);
        if (err != ERR_ok) goto ex_0;
        T_1_1.vec->data[0] = T_1_6.num;
        tab.num = T_1_1.num;
        }
        }

  LINE(120);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = 1024;
        err = _wordvecOPcreate(T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        buf.num = T_1_2.num;
        }
        }

  LINE(121);
    {
    err = _eventOPdefer();
    if (err != ERR_ok) goto ex_0;
    }

  LINE(122);
    {

  LINE(123);
        {
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = op_own_ptr->gcd_tab_op_pgrind_of_t_ops->op_owns;
        generic_CLU_proc.proc = gcd_tabOPpgrind;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = gcd_tabOPpgrind(tab, x);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(124);
        {
        CLUREF T_3_1;
        T_3_1.num = tab.vec->data[3];
        err = _wordvecOPstore(buf, CLU_2, T_3_1);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(125);
        {
        tab.vec->data[3] = 0;
        }

  LINE(126);
        {
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = op_own_ptr->gcd_tab_op_mgrind_of_t_ops->op_owns;
        generic_CLU_proc.proc = gcd_tabOPmgrind;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = gcd_tabOPmgrind(tab, buf, ch, x);
        if (err != ERR_ok) goto ex_1;
        }
        }
        goto end_1;
        ex_1:
            if ((err == ERR_not_possible)) {
            CLUREF why;
            why.num = elist[0].num;

  LINE(128);
                {
                err = _eventOPundefer();
                if (err != ERR_ok) goto ex_0;
                }

  LINE(129);
                {
                elist[0] = why;
                {signal (ERR_not_possible);}}
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(131);
    {
    err = _eventOPundefer();
    if (err != ERR_ok) goto ex_0;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE grindp ****/


/**** BEGIN PROCEDURE pgrind ****/

struct OPS *_tagcell_of__obj_ops;
struct OPS *_adv_of__obj_ops;

typedef struct {
    long pgrind_own_init;
    const gcd_tab_op_pgrind_of_t_OPS * const t_ops;
} gcd_tab_op_pgrind_OWN_DEFN;
const OWN_req gcd_tab_op_pgrind_ownreqs = { sizeof(gcd_tab_op_pgrind_OWN_DEFN), 1 };


errcode
gcd_tabOPpgrind(CLUREF tab, CLUREF x)
{
    errcode err;
    gcd_tab_op_pgrind_OWN_DEFN *op_own_ptr;
    CLUREF iq;
    CLUREF oq;
    CLUREF idx;
    CLUREF p;
    CLUREF v;
    CLUREF e;
    CLUREF l;
    CLUREF i;
    CLUREF inf;
    CLUREF a;
    op_own_ptr = (gcd_tab_op_pgrind_OWN_DEFN *)CUR_PROC_VAR.proc->op_owns;
    if (op_own_ptr->pgrind_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)_obj_ops, _tagcell_of_t_reqs);
        find_type_instance(_tagcell_ops, 1, &_tagcell_ownreqs, &(_tagcell_of__obj_ops));
        add_parm_info_type(0, (const struct OPS *)_obj_ops, _adv_of_t_reqs);
        find_type_instance(_adv_ops, 1, &_adv_ownreqs, &(_adv_of__obj_ops));
    }
    if (gcd_tab_own_init == 0) {
        err = gcd_tab_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    if (op_own_ptr->pgrind_own_init == 0) {
        op_own_ptr->pgrind_own_init = 1;
        /* no own vars to init */
    }
    enter_proc(135);

  LINE(137);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_2.proc = op_own_ptr->t_ops->_gcd.fcn;
    CUR_PROC_VAR = T_1_2;
    err = T_1_2.proc->proc(x, tab, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(138);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.vec->data[2];
        iq.num = T_1_1.num;
        }
        }

  LINE(139);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.vec->data[4];
        oq.num = T_1_1.num;
        }
        }

  LINE(140);
    {
        {idx.num = 0;
        }
        }

  LINE(141);
    for (;;) {
        if (true != true) { break; }

  LINE(142);
        {
        CLUREF T_3_1;
        T_3_1.num = idx.num + 1;
         if ((T_3_1.num > 0 && idx.num < 0 && 1 < 0) ||
             (T_3_1.num < 0 && idx.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        idx.num = T_3_1.num;
        }

  LINE(143);
        {
        CLUREF T_3_1;
        if (idx.num < iq.array->ext_low || idx.num > iq.array->ext_high ) {
            err = ERR_bounds;
            goto ex_1;}
        T_3_1.num = iq.array->store->data[idx.num - iq.array->ext_low + iq.array->int_low];
        switch (T_3_1.cell->tag) {
        case 1:
             {
                break;
                }
        case 2:
             {CLUREF T_3_2;
            T_3_2.num = T_3_1.cell->value;
            p.num = T_3_2.num;

  LINE(146);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    if (idx.num < oq.array->ext_low || idx.num > oq.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = oq.array->store->data[idx.num - oq.array->ext_low + oq.array->int_low];
                    T_4_2.num = (long)T_4_1.num;
                    v.num = T_4_2.num;
                    }
                    }

  LINE(147);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                    T_4_2.num = v.vec->size;
                    T_4_3 = v;
                    for (T_4_1.num = 1; T_4_1.num <= T_4_2.num; T_4_1.num++) {
                        e.num = T_4_3.vec->data[T_4_1.num - 1];

  LINE(148);
                        {
                        CLUREF T_5_1;
                        CUR_PROC_VAR = p;
                        err = p.proc->proc(e, tab, &T_5_1);
                        if (err != ERR_ok) goto ex_1;
                        }
                    }
                }
                end_inline_for_1:;
                break;
                }
        case 3:
             {CLUREF T_3_3;
            T_3_3.num = T_3_1.cell->value;
            l.num = T_3_3.num;

  LINE(151);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    if (idx.num < oq.array->ext_low || idx.num > oq.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = oq.array->store->data[idx.num - oq.array->ext_low + oq.array->int_low];
                    T_4_2.num = (long)T_4_1.num;
                    v.num = T_4_2.num;
                    }
                    }

  LINE(152);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                    T_4_2.num = v.vec->size;
                    for (T_4_1.num = 1; T_4_1.num <= T_4_2.num; T_4_1.num++) {
                        i.num = T_4_1.num;

  LINE(153);
                        {
                        CLUREF T_5_1;
                        CLUREF T_5_2;
                        CLUREF T_5_3;
                        if (i.num < 1 || i.num > v.vec->size ) {
                            err = ERR_bounds;
                            goto ex_1;}
                        T_5_1.num = v.vec->data[i.num - 1];
                        if (i.num < 1 || i.num > l.vec->size ) {
                            err = ERR_bounds;
                            goto ex_1;}
                        T_5_3.num = l.vec->data[i.num - 1];
                        CUR_PROC_VAR = T_5_3;
                        err = T_5_3.proc->proc(T_5_1, tab, &T_5_2);
                        if (err != ERR_ok) goto ex_1;
                        }
                    }
                }
                end_inline_for_2:;
                break;
                }
        case 4:
             {CLUREF T_3_4;
            T_3_4.num = T_3_1.cell->value;
            l.num = T_3_4.num;

  LINE(156);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    CLUREF T_4_3;
                    CLUREF T_4_4;
                    if (idx.num < oq.array->ext_low || idx.num > oq.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = oq.array->store->data[idx.num - oq.array->ext_low + oq.array->int_low];
                    T_4_2.num = (long)T_4_1.num;
                    generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
                    generic_CLU_proc.proc = _tagcellOPget;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = _tagcellOPget(T_4_2, &T_4_3, &T_4_4);
                    if (err != ERR_ok) goto ex_1;
                    i.num = T_4_3.num;
                    e.num = T_4_4.num;
                    }
                    }

  LINE(157);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                if (i.num < 1 || i.num > l.vec->size ) {
                    err = ERR_bounds;
                    goto ex_1;}
                T_4_2.num = l.vec->data[i.num - 1];
                CUR_PROC_VAR = T_4_2;
                err = T_4_2.proc->proc(e, tab, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                }
                break;
                }
        case 5:
             {CLUREF T_3_5;
            T_3_5.num = T_3_1.cell->value;
            p.num = T_3_5.num;

  LINE(159);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    CLUREF T_4_3;
                    CLUREF T_4_4;
                    if (idx.num < oq.array->ext_low || idx.num > oq.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = oq.array->store->data[idx.num - oq.array->ext_low + oq.array->int_low];
                    T_4_2.num = (long)T_4_1.num;
                    generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
                    generic_CLU_proc.proc = _tagcellOPget;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = _tagcellOPget(T_4_2, &T_4_3, &T_4_4);
                    if (err != ERR_ok) goto ex_1;
                    i.num = T_4_3.num;
                    e.num = T_4_4.num;
                    }
                    }

  LINE(160);
                {
                CLUREF T_4_1;
                CUR_PROC_VAR = p;
                err = p.proc->proc(e, tab, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                }
                break;
                }
        case 6:
             {CLUREF T_3_6;
            T_3_6.num = T_3_1.cell->value;
            inf.num = T_3_6.num;

  LINE(162);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    if (idx.num < oq.array->ext_low || idx.num > oq.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = oq.array->store->data[idx.num - oq.array->ext_low + oq.array->int_low];
                    T_4_2.num = (long)T_4_1.num;
                    a.num = T_4_2.num;
                    }
                    }

  LINE(163);
                {
                    {CLUREF T_4_1;
                    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
                    generic_CLU_proc.proc = _advOPget_vector;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = _advOPget_vector(a, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    v.num = T_4_1.num;
                    }
                    }

  LINE(164);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                CLUREF T_4_4;
                CLUREF T_4_5;
                CLUREF T_4_6;
                err = _vecOPsize(v, &T_4_1);
                if (err != ERR_ok) goto ex_1;
                T_4_2.num = T_4_1.num + 1;
                 if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) ||
                     (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                err = intOPmul(gcd_tabOPclurefsz, T_4_2, &T_4_3);
                if (err != ERR_ok) goto ex_1;
                T_4_4.num = (long)inf.num;
                T_4_5.num = (long)v.num;
                err = gcd_tabOPinsert(tab, T_4_3, T_4_4, T_4_5, &T_4_6);
                if (err != ERR_ok) goto ex_1;
                }
                break;
                }
        case 7:
             {CLUREF T_3_7;
            T_3_7.num = T_3_1.cell->value;
            p.num = T_3_7.num;

  LINE(167);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    if (idx.num < oq.array->ext_low || idx.num > oq.array->ext_high ) {
                        err = ERR_bounds;
                        goto ex_1;}
                    T_4_1.num = oq.array->store->data[idx.num - oq.array->ext_low + oq.array->int_low];
                    T_4_2.num = (long)T_4_1.num;
                    v.num = T_4_2.num;
                    }
                    }

  LINE(168);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                    T_4_2.num = v.vec->size;
                    T_4_3 = v;
                    for (T_4_1.num = 1; T_4_1.num <= T_4_2.num; T_4_1.num++) {
                        e.num = T_4_3.vec->data[T_4_1.num - 1];

  LINE(169);
                        {
                        CLUREF T_5_1;
                        CLUREF T_5_2;
                        CLUREF T_5_3;
                        T_5_1.num = (long)nil;
                        T_5_2.num = (e.num == T_5_1.num)? true : false;
                        T_5_3.num = T_5_2.num ^ 1;
                        if (T_5_3.num == true) {

  LINE(170);
                            {
                            CLUREF T_6_1;
                            CUR_PROC_VAR = p;
                            err = p.proc->proc(e, tab, &T_6_1);
                            if (err != ERR_ok) goto ex_1;
                            }
                            }
                            }/* end if */
                    }
                }
                end_inline_for_3:;
                break;
                }
        }
        }
        }
        end_while_1:;
        goto end_1;
        ex_1:
            if ((err == ERR_bounds)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE pgrind ****/


/**** BEGIN PROCEDURE mgrind ****/

struct OPS *_tagcell_of__obj_ops;
struct OPS *_adv_of__obj_ops;

typedef struct {
    long mgrind_own_init;
    const gcd_tab_op_mgrind_of_t_OPS * const t_ops;
} gcd_tab_op_mgrind_OWN_DEFN;
const OWN_req gcd_tab_op_mgrind_ownreqs = { sizeof(gcd_tab_op_mgrind_OWN_DEFN), 1 };


errcode
gcd_tabOPmgrind(CLUREF tab, CLUREF buf, CLUREF ch, CLUREF x)
{
    errcode err;
    gcd_tab_op_mgrind_OWN_DEFN *op_own_ptr;
    CLUREF val;
    CLUREF iq;
    CLUREF oq;
    CLUREF b;
    CLUREF z;
    CLUREF p;
    CLUREF v;
    CLUREF e;
    CLUREF l;
    CLUREF i;
    CLUREF inf;
    CLUREF a;
    op_own_ptr = (gcd_tab_op_mgrind_OWN_DEFN *)CUR_PROC_VAR.proc->op_owns;
    if (op_own_ptr->mgrind_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)_obj_ops, _tagcell_of_t_reqs);
        find_type_instance(_tagcell_ops, 1, &_tagcell_ownreqs, &(_tagcell_of__obj_ops));
        add_parm_info_type(0, (const struct OPS *)_obj_ops, _adv_of_t_reqs);
        find_type_instance(_adv_ops, 1, &_adv_ownreqs, &(_adv_of__obj_ops));
        stringOPcons("gcd_tab: array store not a ref", CLU_1, CLUREF_make_num(30), &STR_gcd_137tab_072_040array_040store_040not_040a_040ref);
    }
    if (gcd_tab_own_init == 0) {
        err = gcd_tab_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    if (op_own_ptr->mgrind_own_init == 0) {
        op_own_ptr->mgrind_own_init = 1;
        /* no own vars to init */
    }
    enter_proc(177);

  LINE(181);
    {
    err = gcd_storeOPinit(buf, ch);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(183);
    {
    err = gcd_storeOPstore_id();
    if (err != ERR_ok) goto ex_2;
    }
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_2:;

  LINE(185);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_2.proc = op_own_ptr->t_ops->_gcd.fcn;
        CUR_PROC_VAR = T_1_2;
        err = T_1_2.proc->proc(x, tab, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        val.num = T_1_1.num;
        }
        }

  LINE(187);
    {
    CLUREF T_1_1;
    T_1_1.num = (val.num < 0)? true : false;
    if (T_1_1.num == true) {

  LINE(188);
        {
        CLUREF T_3_1;
        T_3_1.num = (long)x.num;
        err = gcd_storeOPstore_lit(T_3_1);
        if (err != ERR_ok) goto ex_3;
        }
        goto end_3;
        ex_3:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_0;}
        end_3:;
        }
    else {

  LINE(190);
        {
        err = gcd_storeOPstore_ref(val);
        if (err != ERR_ok) goto ex_4;
        }
        goto end_4;
        ex_4:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_0;}
        end_4:;
        }}/* end if */

  LINE(193);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.vec->data[2];
        iq.num = T_1_1.num;
        }
        }

  LINE(194);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.vec->data[4];
        oq.num = T_1_1.num;
        }
        }

  LINE(195);
    for (;;) {
        if (true != true) { break; }

  LINE(196);
        {
        CLUREF T_4_1;
        err = arrayOPreml(iq, &T_4_1);
        if (err != ERR_ok) goto ex_6;
        switch (T_4_1.cell->tag) {
        case 1:
             {

  LINE(199);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = (long)T_5_1.num;
                    b.num = T_5_2.num;
                    }
                    }

  LINE(200);
                {
                    {CLUREF T_5_1;
                    err = _bytevecOPsize(b, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    z.num = T_5_1.num;
                    }
                    }

  LINE(201);
                {
                CLUREF T_6_1;
                T_6_1.num = 8192;
                err = gcd_storeOPstore_hdr(T_6_1, z);
                if (err != ERR_ok) goto ex_7;
                }
                goto end_7;
                ex_7:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_7:;

  LINE(203);
                {
                err = gcd_storeOPstore_string(b);
                if (err != ERR_ok) goto ex_8;
                }
                goto end_8;
                ex_8:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_8:;
                break;
                }
        case 2:
             {CLUREF T_4_2;
            T_4_2.num = T_4_1.cell->value;
            p.num = T_4_2.num;

  LINE(207);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = (long)T_5_1.num;
                    v.num = T_5_2.num;
                    }
                    }

  LINE(208);
                {
                CLUREF T_6_1;
                CLUREF T_6_2;
                T_6_1.num = 4096;
                T_6_2.num = v.vec->size;
                err = gcd_storeOPstore_hdr(T_6_1, T_6_2);
                if (err != ERR_ok) goto ex_9;
                }
                goto end_9;
                ex_9:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_9:;

  LINE(210);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                    T_5_2.num = v.vec->size;
                    T_5_3 = v;
                    for (T_5_1.num = 1; T_5_1.num <= T_5_2.num; T_5_1.num++) {
                        e.num = T_5_3.vec->data[T_5_1.num - 1];

  LINE(211);
                        {
                        CLUREF T_6_1;
                        CUR_PROC_VAR = p;
                        err = p.proc->proc(e, tab, &T_6_1);
                        if (err != ERR_ok) goto ex_6;
                        val.num = T_6_1.num;
                        }

  LINE(212);
                        {
                        CLUREF T_6_1;
                        T_6_1.num = (val.num < 0)? true : false;
                        if (T_6_1.num == true) {

  LINE(213);
                            {
                            CLUREF T_8_1;
                            T_8_1.num = (long)e.num;
                            err = gcd_storeOPstore_lit(T_8_1);
                            if (err != ERR_ok) goto ex_10;
                            }
                            goto end_10;
                            ex_10:
                                if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                else {
                                    goto ex_6;}
                            end_10:;
                            }
                        else {

  LINE(215);
                            {
                            err = gcd_storeOPstore_ref(val);
                            if (err != ERR_ok) goto ex_11;
                            }
                            goto end_11;
                            ex_11:
                                if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                else {
                                    goto ex_6;}
                            end_11:;
                            }}/* end if */
                    }
                }
                end_inline_for_1:;
                break;
                }
        case 3:
             {CLUREF T_4_3;
            T_4_3.num = T_4_1.cell->value;
            l.num = T_4_3.num;

  LINE(221);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = (long)T_5_1.num;
                    v.num = T_5_2.num;
                    }
                    }

  LINE(222);
                {
                    {CLUREF T_5_1;
                    T_5_1.num = v.vec->size;
                    z.num = T_5_1.num;
                    }
                    }

  LINE(223);
                {
                CLUREF T_6_1;
                T_6_1.num = 4096;
                err = gcd_storeOPstore_hdr(T_6_1, z);
                if (err != ERR_ok) goto ex_12;
                }
                goto end_12;
                ex_12:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_12:;

  LINE(225);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                    T_5_2.num = z.num;
                    for (T_5_1.num = 1; T_5_1.num <= T_5_2.num; T_5_1.num++) {
                        i.num = T_5_1.num;

  LINE(226);
                        {
                            {CLUREF T_6_1;
                            if (i.num < 1 || i.num > v.vec->size ) {
                                err = ERR_bounds;
                                goto ex_6;}
                            T_6_1.num = v.vec->data[i.num - 1];
                            e.num = T_6_1.num;
                            }
                            }

  LINE(227);
                        {
                        CLUREF T_6_1;
                        CLUREF T_6_2;
                        if (i.num < 1 || i.num > l.vec->size ) {
                            err = ERR_bounds;
                            goto ex_6;}
                        T_6_2.num = l.vec->data[i.num - 1];
                        CUR_PROC_VAR = T_6_2;
                        err = T_6_2.proc->proc(e, tab, &T_6_1);
                        if (err != ERR_ok) goto ex_6;
                        val.num = T_6_1.num;
                        }

  LINE(228);
                        {
                        CLUREF T_6_1;
                        T_6_1.num = (val.num < 0)? true : false;
                        if (T_6_1.num == true) {

  LINE(229);
                            {
                            CLUREF T_8_1;
                            T_8_1.num = (long)e.num;
                            err = gcd_storeOPstore_lit(T_8_1);
                            if (err != ERR_ok) goto ex_13;
                            }
                            goto end_13;
                            ex_13:
                                if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                else {
                                    goto ex_6;}
                            end_13:;
                            }
                        else {

  LINE(231);
                            {
                            err = gcd_storeOPstore_ref(val);
                            if (err != ERR_ok) goto ex_14;
                            }
                            goto end_14;
                            ex_14:
                                if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                else {
                                    goto ex_6;}
                            end_14:;
                            }}/* end if */
                    }
                }
                end_inline_for_2:;
                break;
                }
        case 4:
             {CLUREF T_4_4;
            T_4_4.num = T_4_1.cell->value;
            l.num = T_4_4.num;

  LINE(237);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    CLUREF T_5_3;
                    CLUREF T_5_4;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = (long)T_5_1.num;
                    generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
                    generic_CLU_proc.proc = _tagcellOPget;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = _tagcellOPget(T_5_2, &T_5_3, &T_5_4);
                    if (err != ERR_ok) goto ex_6;
                    i.num = T_5_3.num;
                    e.num = T_5_4.num;
                    }
                    }

  LINE(238);
                {
                CLUREF T_6_1;
                T_6_1.num = 16384;
                err = gcd_storeOPstore_hdr(T_6_1, i);
                if (err != ERR_ok) goto ex_15;
                }
                goto end_15;
                ex_15:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_15:;

  LINE(240);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                if (i.num < 1 || i.num > l.vec->size ) {
                    err = ERR_bounds;
                    goto ex_6;}
                T_5_2.num = l.vec->data[i.num - 1];
                CUR_PROC_VAR = T_5_2;
                err = T_5_2.proc->proc(e, tab, &T_5_1);
                if (err != ERR_ok) goto ex_6;
                val.num = T_5_1.num;
                }

  LINE(241);
                {
                CLUREF T_5_1;
                T_5_1.num = (val.num < 0)? true : false;
                if (T_5_1.num == true) {

  LINE(242);
                    {
                    CLUREF T_7_1;
                    T_7_1.num = (long)e.num;
                    err = gcd_storeOPstore_lit(T_7_1);
                    if (err != ERR_ok) goto ex_16;
                    }
                    goto end_16;
                    ex_16:
                        if (err == ERR_not_possible) {signal(ERR_not_possible);}
                        else {
                            goto ex_6;}
                    end_16:;
                    }
                else {

  LINE(244);
                    {
                    err = gcd_storeOPstore_ref(val);
                    if (err != ERR_ok) goto ex_17;
                    }
                    goto end_17;
                    ex_17:
                        if (err == ERR_not_possible) {signal(ERR_not_possible);}
                        else {
                            goto ex_6;}
                    end_17:;
                    }}/* end if */
                break;
                }
        case 5:
             {CLUREF T_4_5;
            T_4_5.num = T_4_1.cell->value;
            p.num = T_4_5.num;

  LINE(249);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    CLUREF T_5_3;
                    CLUREF T_5_4;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = (long)T_5_1.num;
                    generic_CLU_proc.type_owns = _tagcell_of__obj_ops->type_owns;
                    generic_CLU_proc.proc = _tagcellOPget;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = _tagcellOPget(T_5_2, &T_5_3, &T_5_4);
                    if (err != ERR_ok) goto ex_6;
                    i.num = T_5_3.num;
                    e.num = T_5_4.num;
                    }
                    }

  LINE(250);
                {
                CLUREF T_6_1;
                T_6_1.num = 16384;
                err = gcd_storeOPstore_hdr(T_6_1, i);
                if (err != ERR_ok) goto ex_18;
                }
                goto end_18;
                ex_18:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_18:;

  LINE(252);
                {
                CLUREF T_5_1;
                CUR_PROC_VAR = p;
                err = p.proc->proc(e, tab, &T_5_1);
                if (err != ERR_ok) goto ex_6;
                val.num = T_5_1.num;
                }

  LINE(253);
                {
                CLUREF T_5_1;
                T_5_1.num = (val.num < 0)? true : false;
                if (T_5_1.num == true) {

  LINE(254);
                    {
                    CLUREF T_7_1;
                    T_7_1.num = (long)e.num;
                    err = gcd_storeOPstore_lit(T_7_1);
                    if (err != ERR_ok) goto ex_19;
                    }
                    goto end_19;
                    ex_19:
                        if (err == ERR_not_possible) {signal(ERR_not_possible);}
                        else {
                            goto ex_6;}
                    end_19:;
                    }
                else {

  LINE(256);
                    {
                    err = gcd_storeOPstore_ref(val);
                    if (err != ERR_ok) goto ex_20;
                    }
                    goto end_20;
                    ex_20:
                        if (err == ERR_not_possible) {signal(ERR_not_possible);}
                        else {
                            goto ex_6;}
                    end_20:;
                    }}/* end if */
                break;
                }
        case 6:
             {CLUREF T_4_6;
            T_4_6.num = T_4_1.cell->value;
            inf.num = T_4_6.num;

  LINE(261);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = (long)T_5_1.num;
                    a.num = T_5_2.num;
                    }
                    }

  LINE(262);
                {
                    {CLUREF T_5_1;
                    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
                    generic_CLU_proc.proc = _advOPget_vector;
                    CUR_PROC_VAR.proc = &generic_CLU_proc;
                    err = _advOPget_vector(a, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    v.num = T_5_1.num;
                    }
                    }

  LINE(263);
                {
                    {CLUREF T_5_1;
                    err = _vecOPsize(v, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    z.num = T_5_1.num;
                    }
                    }

  LINE(264);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                CLUREF T_5_4;
                CLUREF T_5_5;
                CLUREF T_5_6;
                err = intOPmul(gcd_tabOPgcd_ref_size, z, &T_5_1);
                if (err != ERR_ok) goto ex_6;
                err = intOPmul(CLU_2, gcd_tabOPclurefsz, &T_5_2);
                if (err != ERR_ok) goto ex_6;
                T_5_3.num = T_5_1.num + T_5_2.num;
                 if ((T_5_3.num > 0 && T_5_1.num < 0 && T_5_2.num < 0) ||
                     (T_5_3.num < 0 && T_5_1.num > 0 && T_5_2.num > 0)) {
                    err = ERR_overflow;
                    goto ex_6;}
                T_5_4.num = (long)inf.num;
                T_5_5.num = (long)v.num;
                err = gcd_tabOPinsert(tab, T_5_3, T_5_4, T_5_5, &T_5_6);
                if (err != ERR_ok) goto ex_6;
                val.num = T_5_6.num;
                }

  LINE(267);
                {
                err = gcd_storeOPstore_array_desc(a);
                if (err != ERR_ok) goto ex_21;
                }
                goto end_21;
                ex_21:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_21:;

  LINE(269);
                {
                CLUREF T_5_1;
                T_5_1.num = (val.num < 0)? true : false;
                if (T_5_1.num == true) {

  LINE(271);
                    {
                    elist[0] = STR_gcd_137tab_072_040array_040store_040not_040a_040ref;
                    {signal (ERR_failure);}}
                    }
                else {

  LINE(273);
                    {
                    err = gcd_storeOPstore_ref(val);
                    if (err != ERR_ok) goto ex_22;
                    }
                    goto end_22;
                    ex_22:
                        if (err == ERR_not_possible) {signal(ERR_not_possible);}
                        else {
                            goto ex_6;}
                    end_22:;
                    }}/* end if */
                break;
                }
        case 7:
             {CLUREF T_4_7;
            T_4_7.num = T_4_1.cell->value;
            p.num = T_4_7.num;

  LINE(278);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    err = arrayOPreml(oq, &T_5_1);
                    if (err != ERR_ok) goto ex_6;
                    T_5_2.num = (long)T_5_1.num;
                    v.num = T_5_2.num;
                    }
                    }

  LINE(279);
                {
                CLUREF T_6_1;
                CLUREF T_6_2;
                T_6_1.num = 4096;
                T_6_2.num = v.vec->size;
                err = gcd_storeOPstore_hdr(T_6_1, T_6_2);
                if (err != ERR_ok) goto ex_23;
                }
                goto end_23;
                ex_23:
                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                    else {
                        goto ex_6;}
                end_23:;

  LINE(281);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                    T_5_2.num = v.vec->size;
                    T_5_3 = v;
                    for (T_5_1.num = 1; T_5_1.num <= T_5_2.num; T_5_1.num++) {
                        e.num = T_5_3.vec->data[T_5_1.num - 1];

  LINE(282);
                        {
                        CLUREF T_6_1;
                        CLUREF T_6_2;
                        T_6_1.num = (long)nil;
                        T_6_2.num = (e.num == T_6_1.num)? true : false;
                        if (T_6_2.num == true) {

  LINE(284);
                            {
                            err = gcd_storeOPstore_lit(CLU_0);
                            if (err != ERR_ok) goto ex_24;
                            }
                            goto end_24;
                            ex_24:
                                if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                else {
                                    goto ex_6;}
                            end_24:;
                            }
                        else {

  LINE(287);
                            {
                            CLUREF T_7_1;
                            CUR_PROC_VAR = p;
                            err = p.proc->proc(e, tab, &T_7_1);
                            if (err != ERR_ok) goto ex_6;
                            val.num = T_7_1.num;
                            }

  LINE(288);
                            {
                            CLUREF T_7_1;
                            T_7_1.num = (val.num < 0)? true : false;
                            if (T_7_1.num == true) {

  LINE(289);
                                {
                                CLUREF T_9_1;
                                T_9_1.num = (long)e.num;
                                err = gcd_storeOPstore_lit(T_9_1);
                                if (err != ERR_ok) goto ex_25;
                                }
                                goto end_25;
                                ex_25:
                                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                    else {
                                        goto ex_6;}
                                end_25:;
                                }
                            else {

  LINE(291);
                                {
                                err = gcd_storeOPstore_ref(val);
                                if (err != ERR_ok) goto ex_26;
                                }
                                goto end_26;
                                ex_26:
                                    if (err == ERR_not_possible) {signal(ERR_not_possible);}
                                    else {
                                        goto ex_6;}
                                end_26:;
                                }}/* end if */
                            }}/* end if */
                    }
                }
                end_inline_for_3:;
                break;
                }
        }
        }
        }
        end_while_1:;
    goto end_6;
    ex_6:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_5;}
    end_6:;
        goto end_5;
        ex_5:
            if ((err == ERR_bounds)) {
            }
            else {
                goto ex_0;
            }
        end_5:;

  LINE(300);
    {
    err = gcd_storeOPdone();
    if (err != ERR_ok) goto ex_27;
    }
    goto end_27;
    ex_27:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_27:;

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE mgrind ****/


/**** BEGIN PROCEDURE insert ****/


errcode
gcd_tabOPinsert(CLUREF tab, CLUREF z, CLUREF inf, CLUREF x, CLUREF *ret_1)
{
    errcode err;
    CLUREF i;
    CLUREF xmb;
    CLUREF mb;
    CLUREF addr;
    if (gcd_tab_own_init == 0) {
        err = gcd_tab_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(305);

  LINE(312);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = 50000;
        err = hash_obj(x, T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        T_1_3.num = T_1_2.num + 1;
         if ((T_1_3.num > 0 && T_1_2.num < 0 && 1 < 0) ||
             (T_1_3.num < 0 && T_1_2.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        i.num = T_1_3.num;
        }
        }

  LINE(313);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = tab.vec->data[0];
        if (i.num < 1 || i.num > T_1_1.vec->size ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_2.num = T_1_1.vec->data[i.num - 1];
        xmb.num = T_1_2.num;
        }
        }

  LINE(314);
    {
        {mb.num = xmb.num;
        }
        }

  LINE(315);
    for (;;) {
        CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = (long)nil;
        T_1_2.num = (mb.num == T_1_1.num)? true : false;
        T_1_3.num = T_1_2.num ^ 1;
        if (T_1_3.num != true) { break; }

  LINE(316);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        T_2_1.num = (long)mb.num;
        T_2_2.num = T_2_1.vec->data[2];
        T_2_3.num = (x.num == T_2_2.num)? true : false;
        if (T_2_3.num == true) {

  LINE(317);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = (long)mb.num;
            T_3_2.num = T_3_1.vec->data[0];
            ret_1->num = T_3_2.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(318);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = (long)mb.num;
        T_2_2.num = T_2_1.vec->data[1];
        mb.num = T_2_2.num;
        }
        }
        end_while_1:;

  LINE(320);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.vec->data[3];
        addr.num = T_1_1.num;
        }
        }

  LINE(321);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = tab.vec->data[0];
    RecordAlloc(3, T_1_2);
    T_1_2.vec->data[2] = x.num;
    T_1_2.vec->data[0] = addr.num;
    T_1_2.vec->data[1] = xmb.num;
    T_1_3.num = (long)T_1_2.num;
    err = _vecOPstore(T_1_1, i, T_1_3);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(324);
    {
    CLUREF T_1_1;
    T_1_1.num = tab.vec->data[4];
    {
    if ((T_1_1.array->int_low + T_1_1.array->ext_size + 1) < T_1_1.array->int_size) {
        T_1_1.array->store->data[T_1_1.array->int_low + T_1_1.array->ext_size] = x.num;
        T_1_1.array->ext_size++; T_1_1.array->ext_high++;}
    else {
        err = arrayOPaddh(T_1_1, x);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(325);
    {
    CLUREF T_1_1;
    T_1_1.num = tab.vec->data[2];
    {
    if ((T_1_1.array->int_low + T_1_1.array->ext_size + 1) < T_1_1.array->int_size) {
        T_1_1.array->store->data[T_1_1.array->int_low + T_1_1.array->ext_size] = inf.num;
        T_1_1.array->ext_size++; T_1_1.array->ext_high++;}
    else {
        err = arrayOPaddh(T_1_1, inf);
        if (err != ERR_ok) goto ex_0;}
    }
    }

  LINE(326);
    {
    CLUREF T_1_1;
    T_1_1.num = addr.num + z.num;
     if ((T_1_1.num > 0 && addr.num < 0 && z.num < 0) ||
         (T_1_1.num < 0 && addr.num > 0 && z.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    tab.vec->data[3] = T_1_1.num;
    }

  LINE(327);
    {
    {
    ret_1->num = addr.num;
    }
    {signal (ERR_ok);}}

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE insert ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[3];
} gcd_tab_OPS;

static CLU_proc gcd_tab_oe_grind = { .proc = gcd_tabOPgrind };
static CLU_proc gcd_tab_oe_grindc = { .proc = gcd_tabOPgrindc };
static CLU_proc gcd_tab_oe_grindp = { .proc = gcd_tabOPgrindp };

static gcd_tab_OPS gcd_tab_ops_actual = {3, (OWNPTR)&gcd_tab_own_init, (OWNPTR)&gcd_tab_own_init, {
    {&gcd_tab_oe_grind, "grind"},
    {&gcd_tab_oe_grindc, "grindc"},
    {&gcd_tab_oe_grindp, "grindp"}}};

struct OPS *gcd_tab_ops = (struct OPS *)&gcd_tab_ops_actual;

/**** END CLUSTER gcd_tab ****/

/**** BEGIN CLUSTER gcd_store ****/

extern errcode _bytevecOPstore();
extern errcode gcd_storeOPneed();
extern errcode _advOPget_size();
extern errcode _advOPget_low();
extern errcode _advOPget_start();
extern errcode _advOPget_predict();
extern errcode intOPdiv();
extern errcode intOPsub();
extern errcode intOPmin();
extern errcode _wordvecOPmove_b2w();
extern errcode intOPequal();
extern errcode intOPle();
struct OPS *_adv_of__obj_ops;
static int gcd_store_own_init = 0;
const OWN_req gcd_store_ownreqs = { 0, 0 };
CLUREF gcd_storeOPclurefsz;
CLUREF gcd_storeOPgcd_ref_size;
CLUREF gcd_storeOPbpagesz;
CLUREF gcd_storeOPpos;
CLUREF gcd_storeOPbuf;
CLUREF gcd_storeOPch;

errcode
gcd_store_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (gcd_store_own_init == 0) {
        add_parm_info_type(0, (const struct OPS *)_obj_ops, _adv_of_t_reqs);
        find_type_instance(_adv_ops, 1, &_adv_ownreqs, &(_adv_of__obj_ops));
        gcd_store_own_init = 1;
        {
            {CLUREF T_0_1;
            err = _wordvecOPbytes_per_word(&T_0_1);
            if (err != ERR_ok) goto ex_0;
            gcd_storeOPclurefsz.num = T_0_1.num;
            }
            }
        {
            {CLUREF T_0_2;
            err = intOPmul(gcd_storeOPclurefsz, CLU_2, &T_0_2);
            if (err != ERR_ok) goto ex_0;
            gcd_storeOPgcd_ref_size.num = T_0_2.num;
            }
            }
        {
            {CLUREF T_0_3;
            CLUREF T_0_4;
            T_0_3.num = 1024;
            err = intOPmul(T_0_3, gcd_storeOPclurefsz, &T_0_4);
            if (err != ERR_ok) goto ex_0;
            gcd_storeOPbpagesz.num = T_0_4.num;
            }
            }
        {
            {gcd_storeOPpos.num = 1;
            }
            }
        signal(ERR_ok);
      ex_0:
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE init ****/


errcode
gcd_storeOPinit(CLUREF w, CLUREF c)
{
    errcode err;
    if (gcd_store_own_init == 0) {
        err = gcd_store_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(372);

  LINE(373);
    {
    gcd_storeOPbuf.num = w.num;
    }

  LINE(374);
    {
    gcd_storeOPch.num = c.num;
    }

  LINE(375);
    {
    gcd_storeOPpos.num = 1;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE init ****/


/**** BEGIN PROCEDURE store_id ****/


errcode
gcd_storeOPstore_id()
{
    errcode err;
    if (gcd_store_own_init == 0) {
        err = gcd_store_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(378);

  LINE(386);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = (long)gcd_storeOPbuf.num;
    T_1_2.ch = 'D';
    err = _bytevecOPstore(T_1_1, CLU_1, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(387);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = (long)gcd_storeOPbuf.num;
    T_1_2.ch = 'W';
    err = _bytevecOPstore(T_1_1, CLU_2, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(388);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = (long)gcd_storeOPbuf.num;
    T_1_2.ch = 'C';
    err = _bytevecOPstore(T_1_1, CLU_3, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(389);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = (long)gcd_storeOPbuf.num;
    T_1_2.ch = '1';
    err = _bytevecOPstore(T_1_1, CLU_4, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(390);
    {
    gcd_storeOPpos.num = 3;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE store_id ****/


/**** BEGIN PROCEDURE store_lit ****/


errcode
gcd_storeOPstore_lit(CLUREF i1)
{
    errcode err;
    if (gcd_store_own_init == 0) {
        err = gcd_store_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(393);

  LINE(396);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(398);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, CLU_32);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(399);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(400);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_2;
    }
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_2:;

  LINE(402);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, i1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(403);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE store_lit ****/


/**** BEGIN PROCEDURE store_ref ****/


errcode
gcd_storeOPstore_ref(CLUREF i1)
{
    errcode err;
    if (gcd_store_own_init == 0) {
        err = gcd_store_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(406);

  LINE(409);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(411);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, CLU_33);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(412);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(413);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_2;
    }
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_2:;

  LINE(415);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, i1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(416);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE store_ref ****/


/**** BEGIN PROCEDURE store_hdr ****/


errcode
gcd_storeOPstore_hdr(CLUREF hid, CLUREF size)
{
    errcode err;
    if (gcd_store_own_init == 0) {
        err = gcd_store_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(420);

  LINE(423);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(425);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, hid);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(426);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(427);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_2;
    }
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_2:;

  LINE(429);
    {
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, size);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(430);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE store_hdr ****/


/**** BEGIN PROCEDURE store_array_desc ****/

struct OPS *_adv_of__obj_ops;
static int gcd_storeOPstore_array_desc_own_init = 0;

errcode
gcd_storeOPstore_array_desc(CLUREF a)
{
    errcode err;
    if (gcd_storeOPstore_array_desc_own_init == 0) {
        if (gcd_store_own_init == 0) {
            err = gcd_store_own_init_proc();
            if (err != ERR_ok) goto ex_0;
        }
        gcd_storeOPstore_array_desc_own_init = 1;
    }
    enter_proc(435);

  LINE(439);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(441);
    {
    CLUREF T_1_1;
    T_1_1.num = 24576;
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(442);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(444);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_2;
    }
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_2:;

  LINE(446);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    err = intOPmul(CLU_6, gcd_storeOPclurefsz, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    T_1_2.num = T_1_1.num + gcd_storeOPgcd_ref_size.num;
     if ((T_1_2.num > 0 && T_1_1.num < 0 && gcd_storeOPgcd_ref_size.num < 0) ||
         (T_1_2.num < 0 && T_1_1.num > 0 && gcd_storeOPgcd_ref_size.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, T_1_2);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(447);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(449);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_3;
    }
    goto end_3;
    ex_3:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_3:;

  LINE(451);
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPget_size;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPget_size(a, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(452);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(454);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_4;
    }
    goto end_4;
    ex_4:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_4:;

  LINE(456);
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPget_low;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPget_low(a, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(457);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(459);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_5;
    }
    goto end_5;
    ex_5:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_5:;

  LINE(461);
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPget_start;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPget_start(a, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(462);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

  LINE(464);
    {
    CLUREF T_2_1;
    err = gcd_storeOPneed(CLU_1, &T_2_1);
    if (err != ERR_ok) goto ex_6;
    }
    goto end_6;
    ex_6:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_6:;

  LINE(466);
    {
    CLUREF T_1_1;
    generic_CLU_proc.type_owns = _adv_of__obj_ops->type_owns;
    generic_CLU_proc.proc = _advOPget_predict;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = _advOPget_predict(a, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = _wordvecOPstore(gcd_storeOPbuf, gcd_storeOPpos, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(467);
    {
    CLUREF T_1_1;
    T_1_1.num = gcd_storeOPpos.num + 1;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && 1 < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && 1 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    gcd_storeOPpos.num = T_1_1.num;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE store_array_desc ****/


/**** BEGIN PROCEDURE store_string ****/


errcode
gcd_storeOPstore_string(CLUREF s)
{
    errcode err;
    CLUREF bsize;
    CLUREF bytes_to_go;
    CLUREF total_bytes;
    CLUREF rounded_longs;
    CLUREF total_longs;
    CLUREF total_output;
    CLUREF i;
    CLUREF avail;
    CLUREF copy_count;
    if (gcd_store_own_init == 0) {
        err = gcd_store_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(472);

  LINE(474);
    {
        {CLUREF T_1_1;
        err = _bytevecOPsize(s, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        bsize.num = T_1_1.num;
        }
        }

  LINE(476);
    {
        {bytes_to_go.num = bsize.num;
        }
        }

  LINE(477);
    {
        {CLUREF T_1_1;
        T_1_1.num = bsize.num + 1;
         if ((T_1_1.num > 0 && bsize.num < 0 && 1 < 0) ||
             (T_1_1.num < 0 && bsize.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        total_bytes.num = T_1_1.num;
        }
        }

  LINE(478);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        T_1_1.num = total_bytes.num + gcd_storeOPclurefsz.num;
         if ((T_1_1.num > 0 && total_bytes.num < 0 && gcd_storeOPclurefsz.num < 0) ||
             (T_1_1.num < 0 && total_bytes.num > 0 && gcd_storeOPclurefsz.num > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        T_1_2.num = T_1_1.num - 1;
         if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-1) < 0) ||
             (T_1_2.num <= 0 && T_1_1.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_0;}
        err = intOPdiv(T_1_2, gcd_storeOPclurefsz, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        rounded_longs.num = T_1_3.num;
        }
        }

  LINE(479);
    {
        {total_longs.num = rounded_longs.num;
        }
        }

  LINE(482);
    {
        {total_output.num = 0;
        }
        }

  LINE(483);
    {
        {i.num = 1;
        }
        }

  LINE(484);
    for (;;) {
        if (true != true) { break; }

  LINE(485);
        {
            {CLUREF T_4_1;
            err = gcd_storeOPneed(rounded_longs, &T_4_1);
            if (err != ERR_ok) goto ex_2;
            avail.num = T_4_1.num;
            }
            }
        goto end_2;
        ex_2:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_1;}
        end_2:;

  LINE(487);
        {
            {CLUREF T_3_1;
            CLUREF T_3_2;
            err = intOPmul(avail, gcd_storeOPclurefsz, &T_3_1);
            if (err != ERR_ok) goto ex_1;
            err = intOPmin(bytes_to_go, T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            copy_count.num = T_3_2.num;
            }
            }

  LINE(488);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        err = intOPmul(gcd_storeOPpos, gcd_storeOPclurefsz, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        T_3_2.num = gcd_storeOPclurefsz.num - 1;
         if ((T_3_2.num >= 0 && gcd_storeOPclurefsz.num < 0 && (-1) < 0) ||
             (T_3_2.num <= 0 && gcd_storeOPclurefsz.num > 0 && (-1) > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        T_3_3.num = T_3_1.num - T_3_2.num;
         if ((T_3_3.num >= 0 && T_3_1.num < 0 && (-T_3_2.num) < 0) ||
             (T_3_3.num <= 0 && T_3_1.num > 0 && (-T_3_2.num) > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        err = _wordvecOPmove_b2w(s, i, gcd_storeOPbuf, T_3_3, copy_count);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(493);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        err = intOPmul(avail, gcd_storeOPclurefsz, &T_3_1);
        if (err != ERR_ok) goto ex_1;
        T_3_2.num = i.num + T_3_1.num;
         if ((T_3_2.num > 0 && i.num < 0 && T_3_1.num < 0) ||
             (T_3_2.num < 0 && i.num > 0 && T_3_1.num > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        i.num = T_3_2.num;
        }

  LINE(494);
        {
        CLUREF T_3_1;
        T_3_1.num = bytes_to_go.num - copy_count.num;
         if ((T_3_1.num >= 0 && bytes_to_go.num < 0 && (-copy_count.num) < 0) ||
             (T_3_1.num <= 0 && bytes_to_go.num > 0 && (-copy_count.num) > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        bytes_to_go.num = T_3_1.num;
        }

  LINE(495);
        {
        CLUREF T_3_1;
        T_3_1.num = gcd_storeOPpos.num + avail.num;
         if ((T_3_1.num > 0 && gcd_storeOPpos.num < 0 && avail.num < 0) ||
             (T_3_1.num < 0 && gcd_storeOPpos.num > 0 && avail.num > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        gcd_storeOPpos.num = T_3_1.num;
        }

  LINE(496);
        {
        CLUREF T_3_1;
        T_3_1.num = total_output.num + avail.num;
         if ((T_3_1.num > 0 && total_output.num < 0 && avail.num < 0) ||
             (T_3_1.num < 0 && total_output.num > 0 && avail.num > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        total_output.num = T_3_1.num;
        }

  LINE(497);
        {
        CLUREF T_3_1;
        T_3_1.num = (total_output.num == total_longs.num)? true : false;
        if (T_3_1.num == true) {
            {
                err = (long)"ERR_done";
                goto ex_1;
                }
            }
            }/* end if */

  LINE(498);
        {
        CLUREF T_3_1;
        T_3_1.num = rounded_longs.num - avail.num;
         if ((T_3_1.num >= 0 && rounded_longs.num < 0 && (-avail.num) < 0) ||
             (T_3_1.num <= 0 && rounded_longs.num > 0 && (-avail.num) > 0)) {
            err = ERR_overflow;
            goto ex_1;}
        rounded_longs.num = T_3_1.num;
        }
        }
        end_while_1:;
        goto end_1;
        ex_1:
            if (errcmp(err, "ERR_done")) {
            }
            else {
                goto ex_0;
            }
        end_1:;

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE store_string ****/


/**** BEGIN PROCEDURE done ****/


errcode
gcd_storeOPdone()
{
    errcode err;
    if (gcd_store_own_init == 0) {
        err = gcd_store_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(503);

  LINE(505);
    {
    CLUREF T_2_1;
    CLUREF T_2_2;
    T_2_1.num = gcd_storeOPpos.num - 1;
     if ((T_2_1.num >= 0 && gcd_storeOPpos.num < 0 && (-1) < 0) ||
         (T_2_1.num <= 0 && gcd_storeOPpos.num > 0 && (-1) > 0)) {
        err = ERR_overflow;
        goto ex_1;}
    err = intOPmul(gcd_storeOPclurefsz, T_2_1, &T_2_2);
    if (err != ERR_ok) goto ex_1;
    err = _chanOPputw(gcd_storeOPch, gcd_storeOPbuf, CLU_1, T_2_2, CLU_0);
    if (err != ERR_ok) goto ex_1;
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE done ****/


/**** BEGIN PROCEDURE need ****/


errcode
gcd_storeOPneed(CLUREF i, CLUREF *ret_1)
{
    errcode err;
    if (gcd_store_own_init == 0) {
        err = gcd_store_own_init_proc();
        if (err != ERR_ok) goto ex_0;
    }
    enter_proc(509);

  LINE(510);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    T_1_1.num = gcd_storeOPpos.num + i.num;
     if ((T_1_1.num > 0 && gcd_storeOPpos.num < 0 && i.num < 0) ||
         (T_1_1.num < 0 && gcd_storeOPpos.num > 0 && i.num > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    T_1_2.num = T_1_1.num - 1;
     if ((T_1_2.num >= 0 && T_1_1.num < 0 && (-1) < 0) ||
         (T_1_2.num <= 0 && T_1_1.num > 0 && (-1) > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    err = intOPmul(gcd_storeOPclurefsz, T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    T_1_4.num = (T_1_3.num <= gcd_storeOPbpagesz.num)? true : false;
    if (T_1_4.num == true) {
        {
        {
        ret_1->num = i.num;
        }
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(511);
    {
    CLUREF T_1_1;
    T_1_1.num = (i.num == 1)? true : false;
    if (T_1_1.num == true) {

  LINE(515);
        {
        err = _chanOPputw(gcd_storeOPch, gcd_storeOPbuf, CLU_1, gcd_storeOPbpagesz, CLU_0);
        if (err != ERR_ok) goto ex_1;
        }
        goto end_1;
        ex_1:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_0;}
        end_1:;

  LINE(517);
        {
        gcd_storeOPpos.num = 1;
        }

  LINE(518);
        {
        {
        ret_1->num = i.num;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(520);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 1024;
        T_2_2.num = (gcd_storeOPpos.num <= T_2_1.num)? true : false;
        if (T_2_2.num == true) {
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = 1024;
            T_3_2.num = T_3_1.num - gcd_storeOPpos.num;
             if ((T_3_2.num >= 0 && T_3_1.num < 0 && (-gcd_storeOPpos.num) < 0) ||
                 (T_3_2.num <= 0 && T_3_1.num > 0 && (-gcd_storeOPpos.num) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            T_3_3.num = T_3_2.num + 1;
             if ((T_3_3.num > 0 && T_3_2.num < 0 && 1 < 0) ||
                 (T_3_3.num < 0 && T_3_2.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            ret_1->num = T_3_3.num;
            }
            {signal (ERR_ok);}}
            }
            }/* end if */

  LINE(522);
        {
        err = _chanOPputw(gcd_storeOPch, gcd_storeOPbuf, CLU_1, gcd_storeOPbpagesz, CLU_0);
        if (err != ERR_ok) goto ex_2;
        }
        goto end_2;
        ex_2:
            if (err == ERR_not_possible) {signal(ERR_not_possible);}
            else {
                goto ex_0;}
        end_2:;

  LINE(524);
        {
        gcd_storeOPpos.num = 1;
        }

  LINE(525);
        {
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        T_2_1.num = 1024;
        err = intOPmin(i, T_2_1, &T_2_2);
        if (err != ERR_ok) goto ex_0;
        ret_1->num = T_2_2.num;
        }
        {signal (ERR_ok);}}
        }}/* end if */

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE need ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[8];
} gcd_store_OPS;

static CLU_proc gcd_store_oe_done = { .proc = gcd_storeOPdone };
static CLU_proc gcd_store_oe_init = { .proc = gcd_storeOPinit };
static CLU_proc gcd_store_oe_store_array_desc = { .proc = gcd_storeOPstore_array_desc };
static CLU_proc gcd_store_oe_store_hdr = { .proc = gcd_storeOPstore_hdr };
static CLU_proc gcd_store_oe_store_id = { .proc = gcd_storeOPstore_id };
static CLU_proc gcd_store_oe_store_lit = { .proc = gcd_storeOPstore_lit };
static CLU_proc gcd_store_oe_store_ref = { .proc = gcd_storeOPstore_ref };
static CLU_proc gcd_store_oe_store_string = { .proc = gcd_storeOPstore_string };

static gcd_store_OPS gcd_store_ops_actual = {8, (OWNPTR)&gcd_store_own_init, (OWNPTR)&gcd_store_own_init, {
    {&gcd_store_oe_done, "done"},
    {&gcd_store_oe_init, "init"},
    {&gcd_store_oe_store_array_desc, "store_array_desc"},
    {&gcd_store_oe_store_hdr, "store_hdr"},
    {&gcd_store_oe_store_id, "store_id"},
    {&gcd_store_oe_store_lit, "store_lit"},
    {&gcd_store_oe_store_ref, "store_ref"},
    {&gcd_store_oe_store_string, "store_string"}}};

struct OPS *gcd_store_ops = (struct OPS *)&gcd_store_ops_actual;

/**** END CLUSTER gcd_store ****/


/**** BEGIN PROCEDURE logit ****/

extern errcode streamOPerror_output();
extern errcode streamOPputs();
extern errcode stringOPconcat();
static CLUREF STR__012;
static int logit_own_init = 0;

errcode
logit(CLUREF s)
{
    errcode err;
    CLUREF po;
    if (logit_own_init == 0) {
        stringOPcons("\n", CLU_1, CLUREF_make_num(1), &STR__012);
        logit_own_init = 1;
    }
    enter_proc(566);

  LINE(567);
    {
        {CLUREF T_1_1;
        err = streamOPerror_output(&T_1_1);
        if (err != ERR_ok) goto ex_0;
        po.num = T_1_1.num;
        }
        }

  LINE(568);
    {
    CLUREF T_1_1;
    err = stringOPconcat(s, STR__012, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    err = streamOPputs(po, T_1_1);
    if (err != ERR_ok) goto ex_0;
    }

    goto end_0;
  ex_0:
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE logit ****/

