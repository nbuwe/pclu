
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER xref ****/

extern errcode arrayOPcreate();
extern errcode recordOPget_2();
extern errcode arrayOPfetch();
extern errcode xrefOPfind_index();
extern errcode recordOPget_1();
extern errcode xrefOPentry_maker();
extern errcode arrayOPelements();
extern errcode stringOPequal();
extern errcode stringOPcopy();
extern errcode arrayOPlow();
extern errcode arrayOPhigh();
extern errcode intOPgt();
extern errcode intOPsub();
extern errcode intOPfrom_to();
extern errcode intOPadd();
extern errcode arrayOPstore();
extern errcode arrayOPremh();
extern errcode intOPfrom_to_by();
extern errcode arrayOPreml();
extern errcode intOPle();
extern errcode intOPdiv();
extern errcode stringOPlt();
extern errcode arrayOPaddh();
extern errcode arrayOPaddl();
extern errcode intOPequal();
extern errcode arrayOPsize();
extern errcode stringOPsize();
extern errcode xrefOPputout();
extern errcode streamOPputs();
extern errcode streamOPputleft();
extern errcode streamOPputc();
extern errcode streamOPputspace();
extern errcode xrefOPelements();
extern errcode xrefOPadd_ref();
extern errcode arrayOPset_low();
extern errcode arrayOPtrim();
extern errcode xref_IB_1();
extern struct REQS *array_of_t_reqs;
extern struct OPS *string_ops;
extern OWN_req array_ownreqs;
extern struct OPS *array_ops;
struct OPS *array_of_string_table;
struct OPS *array_of_string_ops;
struct OPS *array_of_string_ops;
OWNPTR array_of_string_owns;
extern struct OPS *array_of_string_ops;
struct OPS  *record_key_users_ops;
extern OWN_req xref_ownreqs;
extern struct OPS *xref_ops;
extern struct REQS *xref_op_find_index_of_etype_reqs;
extern struct OPS *record_key_users_ops;
extern OWN_req xref_op_find_index_ownreqs;
struct OPS *xref_op_find_index_of_record_key_users_table;
struct OPS *xref_op_find_index_of_record_key_users_ops;
OWNPTR xref_op_find_index_of_record_key_users_owns;
struct OPS *xref_op_find_index_of_string_table;
struct OPS *xref_op_find_index_of_string_ops;
OWNPTR xref_op_find_index_of_string_owns;
CLUREF STR__137_137_137_137_137_137_137_137_137_137;
CLUREF STR__012_012;
static int xref_own_init = 0;
OWN_req xref_ownreqs = {0,0};
errcode xref_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (xref_own_init == 0) {
        add_parm_info_type(0, string_ops, array_of_t_reqs);
        find_type_instance(array_ops, 1, &array_ownreqs, &(array_of_string_ops));
        add_selector_info("key", 0, string_ops); 
        add_selector_info("users", 1, array_of_string_ops); 
        find_selector_ops("record", 2, &(record_key_users_ops));
        add_parm_info_type(0, record_key_users_ops, xref_op_find_index_of_etype_reqs);
        find_typeop_instance(xref_ops, xrefOPfind_index, 1, 0, &xref_op_find_index_ownreqs, &xref_ownreqs, &(xref_op_find_index_of_record_key_users_ops));
        add_parm_info_type(0, string_ops, xref_op_find_index_of_etype_reqs);
        find_typeop_instance(xref_ops, xrefOPfind_index, 1, 0, &xref_op_find_index_ownreqs, &xref_ownreqs, &(xref_op_find_index_of_string_ops));
        stringOPcons("__________", CLU_1, CLU_10, &STR__137_137_137_137_137_137_137_137_137_137);
        stringOPcons("\n\n", CLU_1, CLU_2, &STR__012_012);
        xref_own_init = 1;
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }


/**** BEGIN PROCEDURE create ****/

errcode xrefOPcreate(ret_1)
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (xref_own_init == 0) {
            err = xref_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(25);

  LINE(26);
    {
    {
    CLUREF T_1_1;
    err = arrayOPcreate(CLU_0, &T_1_1);
    if (err != ERR_ok) goto ex_0;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE create ****/

struct OPS *array_of_string_table;
struct OPS *array_of_string_ops;
struct OPS *array_of_string_ops;
OWNPTR array_of_string_owns;
struct OPS  *record_key_users_ops;
struct OPS *xref_op_find_index_of_record_key_users_table;
struct OPS *xref_op_find_index_of_record_key_users_ops;
OWNPTR xref_op_find_index_of_record_key_users_owns;
struct OPS *xref_op_find_index_of_string_table;
struct OPS *xref_op_find_index_of_string_ops;
OWNPTR xref_op_find_index_of_string_owns;
static int xrefOPadd_ref_own_init = 0;

/**** BEGIN PROCEDURE add_ref ****/

errcode xrefOPadd_ref(tab, key, user)
CLUREF tab;
CLUREF key;
CLUREF user;
    {
    errcode err;
    errcode ecode2;
    CLUREF musers;
    CLUREF muser;
        if (xrefOPadd_ref_own_init == 0) {
        if (xref_own_init == 0) {
            err = xref_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        xrefOPadd_ref_own_init = 1;
    }
    enter_proc(31);

  LINE(32);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        err = proctypeOPnew(CLU_1, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->proc = recordOPget_1;
        err = proctypeOPnew(CLU_0, &T_1_2.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_2.proc->proc = xrefOPentry_maker;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = xref_op_find_index_of_record_key_users_ops->op_owns;
        generic_CLU_proc.proc = xrefOPfind_index;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = xrefOPfind_index(tab, key, T_1_1, T_1_2, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        if (T_1_3.num < tab.array->ext_low || T_1_3.num > tab.array->ext_high ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_4.num = tab.array->store->data[T_1_3.num - tab.array->ext_low + tab.array->int_low];
        T_1_5.num = T_1_4.vec->data[1];
        musers.num = T_1_5.num;
        }
        }

  LINE(33);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = musers.array->ext_high; 
        T_1_3 = musers;
        for (T_1_1.num = musers.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            muser.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(34);
            {
            CLUREF T_2_1;
            T_2_1.num = ((user.str->size != muser.str->size)? false :
                !(bcmp(user.str->data, muser.str->data, user.str->size)));
            if (T_2_1.num == true) {

  LINE(35);
                {
                {signal (ERR_ok);}}
                }
                }/* end if */
        }
    }
    end_inline_for_1:;

  LINE(37);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    err = proctypeOPnew(CLU_0, &T_1_1.proc);
    if (err!= ERR_ok) goto ex_0;
    T_1_1.proc->proc = stringOPcopy;
    err = proctypeOPnew(CLU_0, &T_1_2.proc);
    if (err!= ERR_ok) goto ex_0;
    T_1_2.proc->proc = stringOPcopy;
    generic_CLU_proc.type_owns = 0;
    generic_CLU_proc.op_owns = xref_op_find_index_of_string_ops->op_owns;
    generic_CLU_proc.proc = xrefOPfind_index;
    CUR_PROC_VAR.proc = &generic_CLU_proc;
    err = xrefOPfind_index(musers, user, T_1_1, T_1_2, &T_1_3);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE add_ref ****/

struct OPS *array_of_string_table;
struct OPS *array_of_string_ops;
struct OPS *array_of_string_ops;
OWNPTR array_of_string_owns;
struct OPS  *record_key_users_ops;
struct OPS *xref_op_find_index_of_record_key_users_table;
struct OPS *xref_op_find_index_of_record_key_users_ops;
OWNPTR xref_op_find_index_of_record_key_users_owns;
struct OPS *xref_op_find_index_of_string_table;
struct OPS *xref_op_find_index_of_string_ops;
OWNPTR xref_op_find_index_of_string_owns;
static int xrefOPadd_refs_own_init = 0;

/**** BEGIN PROCEDURE add_refs ****/

errcode xrefOPadd_refs(tab, key, users)
CLUREF tab;
CLUREF key;
CLUREF users;
    {
    errcode err;
    errcode ecode2;
    CLUREF musers;
    CLUREF user;
    CLUREF new;
    CLUREF muser;
        if (xrefOPadd_refs_own_init == 0) {
        if (xref_own_init == 0) {
            err = xref_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        xrefOPadd_refs_own_init = 1;
    }
    enter_proc(42);

  LINE(43);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        CLUREF T_1_4;
        CLUREF T_1_5;
        err = proctypeOPnew(CLU_1, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->proc = recordOPget_1;
        err = proctypeOPnew(CLU_0, &T_1_2.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_2.proc->proc = xrefOPentry_maker;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = xref_op_find_index_of_record_key_users_ops->op_owns;
        generic_CLU_proc.proc = xrefOPfind_index;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = xrefOPfind_index(tab, key, T_1_1, T_1_2, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        if (T_1_3.num < tab.array->ext_low || T_1_3.num > tab.array->ext_high ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_4.num = tab.array->store->data[T_1_3.num - tab.array->ext_low + tab.array->int_low];
        T_1_5.num = T_1_4.vec->data[1];
        musers.num = T_1_5.num;
        }
        }

  LINE(44);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = users.array->ext_high; 
        T_1_3 = users;
        for (T_1_1.num = users.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            user.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(45);
            {
                {new.tf = true;
                }
                }

  LINE(46);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
                T_2_2.num = musers.array->ext_high; 
                T_2_3 = musers;
                for (T_2_1.num = musers.array->ext_low; T_2_1.num <= T_2_2.num; T_2_1.num++) {
                    if (T_2_1.num > T_2_3.array->ext_high || T_2_1.num < T_2_3.array->ext_low) {
                        err = ERR_failure;
                        elist[0].str = array_bounds_exception_STRING;
                        goto ex_0;}
                    muser.num = T_2_3.array->store->data[T_2_1.num - T_2_3.array->ext_low + T_2_3.array->int_low];

  LINE(47);
                    {
                    CLUREF T_3_1;
                    T_3_1.num = ((user.str->size != muser.str->size)? false :
                        !(bcmp(user.str->data, muser.str->data, user.str->size)));
                    if (T_3_1.num == true) {

  LINE(48);
                        {
                        new.tf = false;
                        }

  LINE(49);
                        goto end_inline_for_2;
                        }
                        }/* end if */
                }
            }
            end_inline_for_2:;

  LINE(52);
            {
            if (new.num == true) {

  LINE(53);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                CLUREF T_3_3;
                err = proctypeOPnew(CLU_0, &T_3_1.proc);
                if (err!= ERR_ok) goto ex_0;
                T_3_1.proc->proc = stringOPcopy;
                err = proctypeOPnew(CLU_0, &T_3_2.proc);
                if (err!= ERR_ok) goto ex_0;
                T_3_2.proc->proc = stringOPcopy;
                generic_CLU_proc.type_owns = 0;
                generic_CLU_proc.op_owns = xref_op_find_index_of_string_ops->op_owns;
                generic_CLU_proc.proc = xrefOPfind_index;
                CUR_PROC_VAR.proc = &generic_CLU_proc;
                err = xrefOPfind_index(musers, user, T_3_1, T_3_2, &T_3_3);
                if (err != ERR_ok) goto ex_0;
                }
                }
                }/* end if */
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE add_refs ****/

struct OPS *array_of_string_table;
struct OPS *array_of_string_ops;
struct OPS *array_of_string_ops;
OWNPTR array_of_string_owns;
struct OPS  *record_key_users_ops;
struct OPS *xref_op_find_index_of_record_key_users_table;
struct OPS *xref_op_find_index_of_record_key_users_ops;
OWNPTR xref_op_find_index_of_record_key_users_owns;
static int xrefOPrem_refs_own_init = 0;

/**** BEGIN PROCEDURE rem_refs ****/

errcode xrefOPrem_refs(tab, key, ret_1)
CLUREF tab;
CLUREF key;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF i;
    CLUREF users;
    CLUREF ll;
    CLUREF hh;
    CLUREF j;
        if (xrefOPrem_refs_own_init == 0) {
        if (xref_own_init == 0) {
            err = xref_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        xrefOPrem_refs_own_init = 1;
    }
    enter_proc(59);

  LINE(60);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        CLUREF T_1_3;
        err = proctypeOPnew(CLU_1, &T_1_1.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_1.proc->proc = recordOPget_1;
        err = proctypeOPnew(CLU_0, &T_1_2.proc);
        if (err!= ERR_ok) goto ex_0;
        T_1_2.proc->proc = xrefOPentry_maker;
        generic_CLU_proc.type_owns = 0;
        generic_CLU_proc.op_owns = xref_op_find_index_of_record_key_users_ops->op_owns;
        generic_CLU_proc.proc = xrefOPfind_index;
        CUR_PROC_VAR.proc = &generic_CLU_proc;
        err = xrefOPfind_index(tab, key, T_1_1, T_1_2, &T_1_3);
        if (err != ERR_ok) goto ex_0;
        i.num = T_1_3.num;
        }
        }

  LINE(61);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        if (i.num < tab.array->ext_low || i.num > tab.array->ext_high ) {
            err = ERR_bounds;
            goto ex_0;}
        T_1_1.num = tab.array->store->data[i.num - tab.array->ext_low + tab.array->int_low];
        T_1_2.num = T_1_1.vec->data[1];
        users.num = T_1_2.num;
        }
        }

  LINE(62);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.array->ext_low;
        ll.num = T_1_1.num;
        }
        }

  LINE(63);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.array->ext_high;
        hh.num = T_1_1.num;
        }
        }

  LINE(64);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = i.num - ll.num;
     if ((T_1_1.num >= 0 && i.num < 0 && (-ll.num) < 0) || 
         (T_1_1.num <= 0 && i.num > 0 && (-ll.num) > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    T_1_2.num = hh.num - i.num;
     if ((T_1_2.num >= 0 && hh.num < 0 && (-i.num) < 0) || 
         (T_1_2.num <= 0 && hh.num > 0 && (-i.num) > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    T_1_3.num = (T_1_1.num > T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(65);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
            T_2_1.num = i.num + 1;
             if ((T_2_1.num > 0 && i.num < 0 && 1 < 0) || 
                 (T_2_1.num < 0 && i.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            T_2_3.num = hh.num;
            for (T_2_2.num = T_2_1.num; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                j.num = T_2_2.num;

  LINE(66);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = j.num - 1;
                 if ((T_3_1.num >= 0 && j.num < 0 && (-1) < 0) || 
                     (T_3_1.num <= 0 && j.num > 0 && (-1) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                if (j.num < tab.array->ext_low || j.num > tab.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_3_2.num = tab.array->store->data[j.num - tab.array->ext_low + tab.array->int_low];
                {
                if (T_3_1.num < tab.array->ext_low || T_3_1.num > tab.array->ext_high) {
                    err = ERR_bounds;
                    goto ex_0;}
                tab.array->store->data[T_3_1.num + tab.array->int_low - tab.array->ext_low] = T_3_2.num;
                }
                }
            }
        }
        end_inline_for_1:;

  LINE(68);
        {
        CLUREF T_2_1;
        err = arrayOPremh(tab, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }
    else {

  LINE(69);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
        CLUREF T_2_4;
            T_2_1.num = i.num - 1;
             if ((T_2_1.num >= 0 && i.num < 0 && (-1) < 0) || 
                 (T_2_1.num <= 0 && i.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            T_2_3.num = ll.num;
            T_2_4.num = -1;
            for (T_2_2.num = T_2_1.num; ((T_2_4.num == 0) || ((T_2_4.num > 0)? (T_2_2.num <= T_2_3.num) : (T_2_2.num >= T_2_3.num))); T_2_2.num += T_2_4.num) {
                j.num = T_2_2.num;

  LINE(70);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = j.num + 1;
                 if ((T_3_1.num > 0 && j.num < 0 && 1 < 0) || 
                     (T_3_1.num < 0 && j.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                if (j.num < tab.array->ext_low || j.num > tab.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_3_2.num = tab.array->store->data[j.num - tab.array->ext_low + tab.array->int_low];
                {
                if (T_3_1.num < tab.array->ext_low || T_3_1.num > tab.array->ext_high) {
                    err = ERR_bounds;
                    goto ex_0;}
                tab.array->store->data[T_3_1.num + tab.array->int_low - tab.array->ext_low] = T_3_2.num;
                }
                }
            }
        }
        end_inline_for_2:;

  LINE(72);
        {
        CLUREF T_2_1;
        err = arrayOPreml(tab, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        }
        }}/* end if */

  LINE(74);
    {
    {
    ret_1->num = users.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE rem_refs ****/


/**** BEGIN PROCEDURE entry_maker ****/

errcode xrefOPentry_maker(key, ret_1)
CLUREF key;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (xref_own_init == 0) {
            err = xref_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(79);

  LINE(80);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[0]  = key.num;
    err = arrayOPcreate(CLU_0, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[1]  = T_1_2.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE entry_maker ****/


typedef struct {
long count;
} xref_op_find_index_of_etype_REQS;

xref_op_find_index_of_etype_REQS xref_op_find_index_of_etype_reqs_actual = {0};

struct REQS * xref_op_find_index_of_etype_reqs = (struct REQS *)&xref_op_find_index_of_etype_reqs_actual;


typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    } xref_op_find_index_of_etype_OPS;


typedef struct {
    long find_index_own_init;
    xref_op_find_index_of_etype_OPS *etype_ops;
    } xref_op_find_index_OWN_DEFN;
OWN_req xref_op_find_index_ownreqs = {sizeof(xref_op_find_index_OWN_DEFN), 1};


/**** BEGIN PROCEDURE find_index ****/

errcode xrefOPfind_index(tab, key, get, cons, ret_1)
CLUREF tab;
CLUREF key;
CLUREF get;
CLUREF cons;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    xref_op_find_index_OWN_DEFN *op_own_ptr;
    CLUREF ll;
    CLUREF hh;
    CLUREF l;
    CLUREF h;
    CLUREF m;
    CLUREF me;
    CLUREF mkey;
    CLUREF ent;
    CLUREF n;
    op_own_ptr = (xref_op_find_index_OWN_DEFN*) CUR_PROC_VAR.proc->op_owns;
        if (op_own_ptr->find_index_own_init == 0) {
        op_own_ptr->find_index_own_init = 1;
    }
    enter_proc(86);

  LINE(91);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.array->ext_low;
        ll.num = T_1_1.num;
        }
        }

  LINE(92);
    {
        {CLUREF T_1_1;
        T_1_1.num = tab.array->ext_high;
        hh.num = T_1_1.num;
        }
        }

  LINE(93);
    {
        {l.num = ll.num;
        }
        }

  LINE(94);
    {
        {h.num = hh.num;
        }
        }

  LINE(95);
    for (;;) {
        CLUREF T_1_1;
        T_1_1.num = (l.num <= h.num)? true : false;
        if (T_1_1.num != true) { break; }

  LINE(96);
        {
            {CLUREF T_2_1;
            CLUREF T_2_2;
            T_2_1.num = l.num + h.num;
             if ((T_2_1.num > 0 && l.num < 0 && h.num < 0) || 
                 (T_2_1.num < 0 && l.num > 0 && h.num > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            err = intOPdiv(T_2_1, CLU_2, &T_2_2);
            if (err != ERR_ok) goto ex_0;
            m.num = T_2_2.num;
            }
            }

  LINE(97);
        {
            {CLUREF T_2_1;
            if (m.num < tab.array->ext_low || m.num > tab.array->ext_high ) {
                err = ERR_bounds;
                goto ex_0;}
            T_2_1.num = tab.array->store->data[m.num - tab.array->ext_low + tab.array->int_low];
            me.num = T_2_1.num;
            }
            }

  LINE(98);
        {
            {CLUREF T_2_1;
            CUR_PROC_VAR = get;
            err = get.proc->proc(me, &T_2_1);
            if (err != ERR_ok) goto ex_0;
            mkey.num = T_2_1.num;
            }
            }

  LINE(99);
        {
        CLUREF T_2_1;
        err = stringOPlt(key, mkey, &T_2_1);
        if (err != ERR_ok) goto ex_0;
        if (T_2_1.num == true) {

  LINE(100);
            {
            CLUREF T_3_1;
            T_3_1.num = m.num - 1;
             if ((T_3_1.num >= 0 && m.num < 0 && (-1) < 0) || 
                 (T_3_1.num <= 0 && m.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            h.num = T_3_1.num;
            }
            }
        else {
        CLUREF T_2_2;
        T_2_2.num = ((key.str->size != mkey.str->size)? false :
            !(bcmp(key.str->data, mkey.str->data, key.str->size)));
        if (T_2_2.num == true) {

  LINE(102);
            {
            {
            ret_1->num = m.num;
            }
            {signal (ERR_ok);}}
            }
        else {

  LINE(103);
            {
            CLUREF T_3_1;
            T_3_1.num = m.num + 1;
             if ((T_3_1.num > 0 && m.num < 0 && 1 < 0) || 
                 (T_3_1.num < 0 && m.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_0;}
            l.num = T_3_1.num;
            }
            }}}/* end if */
        }
        end_while_1:;

  LINE(106);
    {
        {CLUREF T_1_1;
        CUR_PROC_VAR = cons;
        err = cons.proc->proc(key, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        ent.num = T_1_1.num;
        }
        }

  LINE(107);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    T_1_1.num = hh.num - l.num;
     if ((T_1_1.num >= 0 && hh.num < 0 && (-l.num) < 0) || 
         (T_1_1.num <= 0 && hh.num > 0 && (-l.num) > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    T_1_2.num = h.num - ll.num;
     if ((T_1_2.num >= 0 && h.num < 0 && (-ll.num) < 0) || 
         (T_1_2.num <= 0 && h.num > 0 && (-ll.num) > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    T_1_3.num = (T_1_1.num <= T_1_2.num)? true : false;
    if (T_1_3.num == true) {

  LINE(108);
        {
        {
        if ((tab.array->int_low + tab.array->ext_size + 1) < tab.array->int_size) {
            tab.array->store->data[tab.array->int_low + tab.array->ext_size] = ent.num;
            tab.array->ext_size++; tab.array->ext_high++;}
        else {
            err = arrayOPaddh(tab, ent);
            if (err != ERR_ok) goto ex_0;}
        }
        }

  LINE(109);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
            T_2_2.num = l.num;
            T_2_3.num = -1;
            for (T_2_1.num = hh.num; ((T_2_3.num == 0) || ((T_2_3.num > 0)? (T_2_1.num <= T_2_2.num) : (T_2_1.num >= T_2_2.num))); T_2_1.num += T_2_3.num) {
                n.num = T_2_1.num;

  LINE(110);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = n.num + 1;
                 if ((T_3_1.num > 0 && n.num < 0 && 1 < 0) || 
                     (T_3_1.num < 0 && n.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                if (n.num < tab.array->ext_low || n.num > tab.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_3_2.num = tab.array->store->data[n.num - tab.array->ext_low + tab.array->int_low];
                {
                if (T_3_1.num < tab.array->ext_low || T_3_1.num > tab.array->ext_high) {
                    err = ERR_bounds;
                    goto ex_0;}
                tab.array->store->data[T_3_1.num + tab.array->int_low - tab.array->ext_low] = T_3_2.num;
                }
                }
            }
        }
        end_inline_for_1:;

  LINE(112);
        {
        {
        if (l.num < tab.array->ext_low || l.num > tab.array->ext_high) {
            err = ERR_bounds;
            goto ex_0;}
        tab.array->store->data[l.num + tab.array->int_low - tab.array->ext_low] = ent.num;
        }
        }

  LINE(113);
        {
        {
        ret_1->num = l.num;
        }
        {signal (ERR_ok);}}
        }
    else {

  LINE(114);
        {
        err = arrayOPaddl(tab, ent);
        if (err != ERR_ok) goto ex_0;
        }

  LINE(115);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        CLUREF T_2_3;
            T_2_2.num = h.num;
            T_2_3.num = 1;
            for (T_2_1.num = ll.num; ((T_2_3.num == 0) || ((T_2_3.num > 0)? (T_2_1.num <= T_2_2.num) : (T_2_1.num >= T_2_2.num))); T_2_1.num += T_2_3.num) {
                n.num = T_2_1.num;

  LINE(116);
                {
                CLUREF T_3_1;
                CLUREF T_3_2;
                T_3_1.num = n.num - 1;
                 if ((T_3_1.num >= 0 && n.num < 0 && (-1) < 0) || 
                     (T_3_1.num <= 0 && n.num > 0 && (-1) > 0)) {
                    err = ERR_overflow;
                    goto ex_0;}
                if (n.num < tab.array->ext_low || n.num > tab.array->ext_high ) {
                    err = ERR_bounds;
                    goto ex_0;}
                T_3_2.num = tab.array->store->data[n.num - tab.array->ext_low + tab.array->int_low];
                {
                if (T_3_1.num < tab.array->ext_low || T_3_1.num > tab.array->ext_high) {
                    err = ERR_bounds;
                    goto ex_0;}
                tab.array->store->data[T_3_1.num + tab.array->int_low - tab.array->ext_low] = T_3_2.num;
                }
                }
            }
        }
        end_inline_for_2:;

  LINE(118);
        {
        {
        if (h.num < tab.array->ext_low || h.num > tab.array->ext_high) {
            err = ERR_bounds;
            goto ex_0;}
        tab.array->store->data[h.num + tab.array->int_low - tab.array->ext_low] = ent.num;
        }
        }

  LINE(119);
        {
        {
        ret_1->num = h.num;
        }
        {signal (ERR_ok);}}
        }}/* end if */
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE find_index ****/


/**** BEGIN ITERATOR elements ****/

errcode xrefOPelements(tab, proc, user_locals, iecode)
CLUREF tab;
errcode (*proc)();
char **user_locals;
errcode *iecode;
    {
    errcode ecode;
    errcode err;
    errcode ecode2;
    bool body_ctrl_req;
    CLUREF ent;
    CLUREF key;
    CLUREF user;
        if (xref_own_init == 0) {
            err = xref_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(125);

  LINE(126);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = tab.array->ext_high; 
        T_1_3 = tab;
        for (T_1_1.num = tab.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            ent.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(127);
            {
                {CLUREF T_2_1;
                T_2_1.num = ent.vec->data[0];
                key.num = T_2_1.num;
                }
                }

  LINE(128);
            {
            CLUREF T_2_1;
            CLUREF T_2_2;
            CLUREF T_2_3;
            CLUREF T_2_4;
                T_2_1.num = ent.vec->data[1];
                T_2_3.num = T_2_1.array->ext_high; 
                T_2_4 = T_2_1;
                for (T_2_2.num = T_2_1.array->ext_low; T_2_2.num <= T_2_3.num; T_2_2.num++) {
                    if (T_2_2.num > T_2_4.array->ext_high || T_2_2.num < T_2_4.array->ext_low) {
                        err = ERR_failure;
                        elist[0].str = array_bounds_exception_STRING;
                        goto ex_0;}
                    user.num = T_2_4.array->store->data[T_2_2.num - T_2_4.array->ext_low + T_2_4.array->int_low];

  LINE(129);
                    {
                    err = proc(key, user, user_locals, iecode);
                    if (err != ERR_ok) {
                    if (err == ERR_break) {signal(ERR_break);}
                    if (err == ERR_iterbodyreturn) {signal(ERR_iterbodyreturn);}
                    if (err == ERR_iterbodyexit) {signal(ERR_iterbodyexit);}
                    if (err == ERR_iterbodysignal) {signal(ERR_iterbodysignal);}
                    {signal(err);
                        }}
                    }
                }
            }
            end_inline_for_2:;
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END ITERATOR elements ****/


/**** BEGIN ITERATOR keys ****/

errcode xrefOPkeys(tab, proc, user_locals, iecode)
CLUREF tab;
errcode (*proc)();
char **user_locals;
errcode *iecode;
    {
    errcode ecode;
    errcode err;
    errcode ecode2;
    bool body_ctrl_req;
    CLUREF ent;
        if (xref_own_init == 0) {
            err = xref_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(136);

  LINE(137);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = tab.array->ext_high; 
        T_1_3 = tab;
        for (T_1_1.num = tab.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            ent.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(138);
            {
            CLUREF T_2_1;
            T_2_1.num = ent.vec->data[0];
            err = proc(T_2_1, user_locals, iecode);
            if (err != ERR_ok) {
            if (err == ERR_break) {signal(ERR_break);}
            if (err == ERR_iterbodyreturn) {signal(ERR_iterbodyreturn);}
            if (err == ERR_iterbodyexit) {signal(ERR_iterbodyexit);}
            if (err == ERR_iterbodysignal) {signal(ERR_iterbodysignal);}
            {signal(err);
                }}
            }
        }
    }
    end_inline_for_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END ITERATOR keys ****/

static int xrefOPoutput_own_init = 0;

/**** BEGIN PROCEDURE output ****/

errcode xrefOPoutput(tab, lhead, rhead, st)
CLUREF tab;
CLUREF lhead;
CLUREF rhead;
CLUREF st;
    {
    errcode err;
    errcode ecode2;
    CLUREF max;
    CLUREF ent;
    CLUREF n;
    CLUREF i;
        if (xrefOPoutput_own_init == 0) {
        if (xref_own_init == 0) {
            err = xref_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        xrefOPoutput_own_init = 1;
    }
    enter_proc(144);

  LINE(146);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = tab.array->ext_size;
    T_1_2.num = (T_1_1.num == 0)? true : false;
    if (T_1_2.num == true) {

  LINE(147);
        {
        {signal (ERR_ok);}}
        }
        }/* end if */

  LINE(148);
    {
        {CLUREF T_1_1;
        err = stringOPsize(lhead, &T_1_1);
        if (err != ERR_ok) goto ex_0;
        max.num = T_1_1.num;
        }
        }

  LINE(149);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
        T_1_2.num = tab.array->ext_high; 
        T_1_3 = tab;
        for (T_1_1.num = tab.array->ext_low; T_1_1.num <= T_1_2.num; T_1_1.num++) {
            if (T_1_1.num > T_1_3.array->ext_high || T_1_1.num < T_1_3.array->ext_low) {
                err = ERR_failure;
                elist[0].str = array_bounds_exception_STRING;
                goto ex_0;}
            ent.num = T_1_3.array->store->data[T_1_1.num - T_1_3.array->ext_low + T_1_3.array->int_low];

  LINE(150);
            {
                {CLUREF T_2_1;
                CLUREF T_2_2;
                T_2_1.num = ent.vec->data[0];
                err = stringOPsize(T_2_1, &T_2_2);
                if (err != ERR_ok) goto ex_0;
                n.num = T_2_2.num;
                }
                }

  LINE(151);
            {
            CLUREF T_2_1;
            T_2_1.num = (n.num > max.num)? true : false;
            if (T_2_1.num == true) {

  LINE(152);
                {
                max.num = n.num;
                }
                }
                }/* end if */
        }
    }
    end_inline_for_1:;

  LINE(154);
    {
    CLUREF T_1_1;
    T_1_1.num = max.num + 4;
     if ((T_1_1.num > 0 && max.num < 0 && 4 < 0) || 
         (T_1_1.num < 0 && max.num > 0 && 4 > 0)) {
        err = ERR_overflow;
        goto ex_0;}
    max.num = T_1_1.num;
    }

  LINE(155);
    {

  LINE(156);
        {
        CLUREF T_3_1;
        err = arrayOPnew( &T_3_1);
        if (err != ERR_ok) goto ex_1;
        err = arrayOPaddh(T_3_1, rhead);
        if (err != ERR_ok) goto ex_1;
        err = xrefOPputout(st, lhead, T_3_1, max);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(157);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
            T_3_2.num = 7;
            for (T_3_1.num = 1; T_3_1.num <= T_3_2.num; T_3_1.num++) {
                i.num = T_3_1.num;

  LINE(158);
                {
                err = streamOPputs(st, STR__137_137_137_137_137_137_137_137_137_137);
                if (err != ERR_ok) goto ex_1;
                }
            }
        }
        end_inline_for_2:;

  LINE(160);
        {
        err = streamOPputs(st, STR__012_012);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(161);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
            T_3_2.num = tab.array->ext_high; 
            T_3_3 = tab;
            for (T_3_1.num = tab.array->ext_low; T_3_1.num <= T_3_2.num; T_3_1.num++) {
                if (T_3_1.num > T_3_3.array->ext_high || T_3_1.num < T_3_3.array->ext_low) {
                    err = ERR_failure;
                    elist[0].str = array_bounds_exception_STRING;
                    goto ex_1;}
                ent.num = T_3_3.array->store->data[T_3_1.num - T_3_3.array->ext_low + T_3_3.array->int_low];

  LINE(162);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = ent.vec->data[0];
                T_4_2.num = ent.vec->data[1];
                err = xrefOPputout(st, T_4_1, T_4_2, max);
                if (err != ERR_ok) goto ex_1;
                }
            }
        }
        end_inline_for_3:;
        }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE output ****/


/**** BEGIN PROCEDURE putout ****/

errcode xrefOPputout(st, key, users, max)
CLUREF st;
CLUREF key;
CLUREF users;
CLUREF max;
    {
    errcode err;
    errcode ecode2;
    CLUREF pos;
    CLUREF user;
    CLUREF n;
        if (xref_own_init == 0) {
            err = xref_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(169);

  LINE(171);
    {

  LINE(172);
        {
        err = streamOPputleft(st, key, max);
        if (err != ERR_ok) goto ex_1;
        }

  LINE(173);
        {
            {pos.num = max.num;
            }
            }

  LINE(174);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
            T_3_2.num = users.array->ext_high; 
            T_3_3 = users;
            for (T_3_1.num = users.array->ext_low; T_3_1.num <= T_3_2.num; T_3_1.num++) {
                if (T_3_1.num > T_3_3.array->ext_high || T_3_1.num < T_3_3.array->ext_low) {
                    err = ERR_failure;
                    elist[0].str = array_bounds_exception_STRING;
                    goto ex_1;}
                user.num = T_3_3.array->store->data[T_3_1.num - T_3_3.array->ext_low + T_3_3.array->int_low];

  LINE(175);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    err = stringOPsize(user, &T_4_1);
                    if (err != ERR_ok) goto ex_1;
                    T_4_2.num = T_4_1.num + 1;
                     if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) || 
                         (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                        err = ERR_overflow;
                        goto ex_1;}
                    n.num = T_4_2.num;
                    }
                    }

  LINE(176);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                T_4_1.num = pos.num + n.num;
                 if ((T_4_1.num > 0 && pos.num < 0 && n.num < 0) || 
                     (T_4_1.num < 0 && pos.num > 0 && n.num > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                T_4_2.num = 70;
                T_4_3.num = (T_4_1.num > T_4_2.num)? true : false;
                if (T_4_3.num == true) {

  LINE(177);
                    {
                    CLUREF T_5_1;
                    T_5_1.ch = '\n';
                    err = streamOPputc(st, T_5_1);
                    if (err != ERR_ok) goto ex_1;
                    }

  LINE(178);
                    {
                    err = streamOPputspace(st, max);
                    if (err != ERR_ok) goto ex_1;
                    }

  LINE(179);
                    {
                    pos.num = max.num;
                    }
                    }
                    }/* end if */

  LINE(181);
                {
                CLUREF T_4_1;
                T_4_1.ch = ' ';
                err = streamOPputc(st, T_4_1);
                if (err != ERR_ok) goto ex_1;
                }

  LINE(182);
                {
                err = streamOPputs(st, user);
                if (err != ERR_ok) goto ex_1;
                }

  LINE(183);
                {
                CLUREF T_4_1;
                T_4_1.num = pos.num + n.num;
                 if ((T_4_1.num > 0 && pos.num < 0 && n.num < 0) || 
                     (T_4_1.num < 0 && pos.num > 0 && n.num > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                pos.num = T_4_1.num;
                }
            }
        }
        end_inline_for_1:;

  LINE(185);
        {
        CLUREF T_3_1;
        T_3_1.ch = '\n';
        err = streamOPputc(st, T_3_1);
        if (err != ERR_ok) goto ex_1;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE putout ****/

extern errcode xrefOPmerge_IB_1();
static int xrefOPmerge_own_init = 0;

/**** BEGIN PROCEDURE merge ****/

errcode xrefOPmerge(tab1, tab2)
CLUREF tab1;
CLUREF tab2;
    {
    struct {
        errcode err;
        errcode ecode2;
        CLUREF key;
        CLUREF user;
        CLUREF tab1;
        CLUREF tab2;
        } locals;
    locals.tab1 = tab1;
    locals.tab2 = tab2;
        if (xrefOPmerge_own_init == 0) {
        if (xref_own_init == 0) {
            locals.err = xref_own_init_proc();
            if (locals.err != ERR_ok) goto ex_0;
            }
        xrefOPmerge_own_init = 1;
    }
    enter_proc(191);

  LINE(192);
    {
        locals.err = xrefOPelements(locals.tab2, xrefOPmerge_IB_1, &locals, &locals.ecode2);
        if (locals.err == ERR_iterbodyreturn) {
        signal(ERR_ok);}
        if (locals.err == ERR_iterbodysignal) {signal(locals.ecode2);}
        if (locals.err == ERR_break) locals.err = ERR_ok;
        if (locals.err == ERR_iterbodyexit) locals.err = locals.ecode2;
        if (locals.err != ERR_ok) goto ex_0;
        }
    goto end_0;
    ex_0:
        {
            if (locals.err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(locals.err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE merge ****/


/**** BEGIN ITERATOR BODIES for merge ****/

errcode xrefOPmerge_IB_1(iv_1, iv_2, locals, iecode)
errcode *iecode;
CLUREF iv_1;
CLUREF iv_2;
struct {
    errcode err;
    errcode ecode2;
    CLUREF key;
    CLUREF user;
    CLUREF tab1;
    CLUREF tab2;
    } *locals;
{
    locals->key.num = iv_1.num;
    locals->user.num = iv_2.num;
    enter_iter_body_proc(193);

  FB_LINE(193);
    {
    locals->err = xrefOPadd_ref(locals->tab1, locals->key, locals->user);
    if (locals->err != ERR_ok) goto ex_0;
    }
    {signal(ERR_ok);}
    ex_0:
        {
            *iecode = locals->err;
            {signal(ERR_iterbodyexit);}}
    end_0: {signal(ERR_ok);}
    }/* end xrefOPmerge_IB_1 */

/**** END ITERATOR BODIES for merge ****/


/**** BEGIN PROCEDURE flush ****/

errcode xrefOPflush(tab)
CLUREF tab;
    {
    errcode err;
    errcode ecode2;
        if (xref_own_init == 0) {
            err = xref_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(199);

  LINE(200);
    {
    err = arrayOPset_low(tab, CLU_1);
    if (err != ERR_ok) goto ex_0;
    }

  LINE(201);
    {
    err = arrayOPtrim(tab, CLU_1, CLU_0);
    if (err != ERR_ok) goto ex_0;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE flush ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[9];
} xref_OPS;

CLU_proc xref_oe_add_ref = {{0,0,0,0}, xrefOPadd_ref, 0};
CLU_proc xref_oe_add_refs = {{0,0,0,0}, xrefOPadd_refs, 0};
CLU_proc xref_oe_create = {{0,0,0,0}, xrefOPcreate, 0};
CLU_proc xref_oe_elements = {{0,0,0,0}, xrefOPelements, 0};
CLU_proc xref_oe_flush = {{0,0,0,0}, xrefOPflush, 0};
CLU_proc xref_oe_keys = {{0,0,0,0}, xrefOPkeys, 0};
CLU_proc xref_oe_merge = {{0,0,0,0}, xrefOPmerge, 0};
CLU_proc xref_oe_output = {{0,0,0,0}, xrefOPoutput, 0};
CLU_proc xref_oe_rem_refs = {{0,0,0,0}, xrefOPrem_refs, 0};

xref_OPS xref_ops_actual = {9, (OWNPTR)&xref_own_init, (OWNPTR)&xref_own_init, {
    {&xref_oe_add_ref, "add_ref"},
    {&xref_oe_add_refs, "add_refs"},
    {&xref_oe_create, "create"},
    {&xref_oe_elements, "elements"},
    {&xref_oe_flush, "flush"},
    {&xref_oe_keys, "keys"},
    {&xref_oe_merge, "merge"},
    {&xref_oe_output, "output"},
    {&xref_oe_rem_refs, "rem_refs"}}};

struct OPS *xref_ops = (struct OPS *)&xref_ops_actual;

/**** END CLUSTER xref ****/
