
/* This file was automatically generated by pclu. */

#include "pclu_err.h"
#include "pclu_sys.h"

/**** BEGIN CLUSTER istream ****/

extern errcode boolOPnot();
extern errcode stringOPequal();
extern errcode _chanOPopen();
extern errcode _wordvecOPcreate();
extern errcode oneofOPmake_2();
extern errcode oneofOPmake_3();
extern errcode _chanOPget_name();
extern errcode oneofOPis_2();
extern errcode recordOPget_1();
extern errcode oneofOPis_3();
extern errcode intOPgt();
extern errcode recordOPget_2();
extern errcode recordOPget_3();
extern errcode recordOPset_3();
extern errcode intOPdiv();
extern errcode _chanOPgetw();
extern errcode recordOPget_4();
extern errcode recordOPset_2();
extern errcode _chanOPreset();
extern errcode _chanOPputw();
extern errcode intOPmul();
extern errcode _chanOPget_date();
extern errcode _chanOPclose();
extern errcode recordOPset_1();
extern errcode oneofOPmake_1();
extern errcode _chanOPabort();
extern errcode oneofOPis_1();
extern errcode recordOPequal();
extern errcode _wordvecOPfetch();
extern errcode intOPadd();
extern errcode intOPequal();
extern errcode _wordvecOPstore();
extern errcode _cvt();
extern errcode _bytevecOPcreate();
extern errcode intOPsub();
extern errcode intOPlt();
extern errcode _wordvecOPmove_w2b();
extern errcode _bytevecOPsize();
extern errcode _wordvecOPmove_b2w();
static CLUREF STR_read;
static CLUREF STR_write;
static CLUREF STR_append;
static CLUREF STR_bad_040access_040mode;
static CLUREF STR_cannot_040read_040from_040this_040istream;
static CLUREF STR_cannot_040get_040date;
static CLUREF STR_cannot_040set_040date;
static CLUREF STR_no_040channel_040attached_040to_040istream;
static CLUREF STR_bad_040format;
static CLUREF STR_cannot_040write_040to_040this_040istream;
static int istream_own_init = 0;
const OWN_req istream_ownreqs = { 0, 0 };

errcode
istream_own_init_proc(void)
{
    errcode err;
    enter_own_init_proc();
    if (istream_own_init == 0) {
        stringOPcons("read", CLU_1, CLUREF_make_num(4), &STR_read);
        stringOPcons("write", CLU_1, CLUREF_make_num(5), &STR_write);
        stringOPcons("append", CLU_1, CLUREF_make_num(6), &STR_append);
        stringOPcons("bad access mode", CLU_1, CLUREF_make_num(15), &STR_bad_040access_040mode);
        stringOPcons("cannot read from this istream", CLU_1, CLUREF_make_num(29), &STR_cannot_040read_040from_040this_040istream);
        stringOPcons("cannot get date", CLU_1, CLUREF_make_num(15), &STR_cannot_040get_040date);
        stringOPcons("cannot set date", CLU_1, CLUREF_make_num(15), &STR_cannot_040set_040date);
        stringOPcons("no channel attached to istream", CLU_1, CLUREF_make_num(30), &STR_no_040channel_040attached_040to_040istream);
        stringOPcons("bad format", CLU_1, CLUREF_make_num(10), &STR_bad_040format);
        stringOPcons("cannot write to this istream", CLU_1, CLUREF_make_num(28), &STR_cannot_040write_040to_040this_040istream);
        istream_own_init = 1;
        signal(ERR_ok);
      ex_0:
        __CLU_EX_HANDLER;
        pclu_unhandled(err);
        signal(ERR_failure);
    }
    signal(ERR_ok);
}


/**** BEGIN PROCEDURE open ****/

static int istreamOPopen_own_init = 0;

errcode
istreamOPopen(CLUREF f, CLUREF access, CLUREF *ret_1)
{
    errcode err;
    CLUREF ch;
    CLUREF wvec;
    CLUREF b;
    if (istreamOPopen_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        istreamOPopen_own_init = 1;
    }
    enter_proc(29);

  LINE(30);
    { /* if */
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    CLUREF T_1_8;
    T_1_3.num = ((access.str->size != STR_read.str->size)? false :
        !(memcmp(access.str->data, STR_read.str->data, access.str->size)));
    T_1_4.num = !T_1_3.num;
    T_1_2.num = T_1_4.num;
    if (T_1_4.num) {
        T_1_5.num = ((access.str->size != STR_write.str->size)? false :
            !(memcmp(access.str->data, STR_write.str->data, access.str->size)));
        T_1_6.num = !T_1_5.num;
        T_1_2.num = T_1_6.num;
    }
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        T_1_7.num = ((access.str->size != STR_append.str->size)? false :
            !(memcmp(access.str->data, STR_append.str->data, access.str->size)));
        T_1_8.num = !T_1_7.num;
        T_1_1.num = T_1_8.num;
    }
    if (T_1_1.num == true) { /* if */

  LINE(31);
        { /* signal */
            elist[0] = STR_bad_040access_040mode;
            signal(ERR_not_possible);
        }
    }
    } /* end if */

  LINE(32);
    {
    CLUREF T_2_1;
    err = _chanOPopen(f, access, CLU_0, &T_2_1);
    if (err != ERR_ok)
        goto ex_1;
    ch.num = T_2_1.num;
    }
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(34);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = 256;
    err = _wordvecOPcreate(T_1_1, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    wvec.num = T_1_2.num;
    }

  LINE(36);
    { /* if */
    CLUREF T_1_1;
    T_1_1.num = ((access.str->size != STR_read.str->size)? false :
        !(memcmp(access.str->data, STR_read.str->data, access.str->size)));
    if (T_1_1.num == true) { /* if */

  LINE(37);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(4, T_2_1);
        T_2_1.vec->data[0] = ch.num;
        T_2_1.vec->data[3] = wvec.num;
        T_2_1.vec->data[1] = 1;
        T_2_1.vec->data[2] = 0;
        CellAlloc(2, T_2_1.num, T_2_2);
        b.num = T_2_2.num;
        }
    }
    else { /* else */

  LINE(41);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(3, T_2_1);
        T_2_1.vec->data[0] = ch.num;
        T_2_1.vec->data[2] = wvec.num;
        T_2_1.vec->data[1] = 0;
        CellAlloc(3, T_2_1.num, T_2_2);
        b.num = T_2_2.num;
        }
    }} /* end if */

  LINE(45);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[0] = b.num;
    err = _chanOPget_name(ch, &T_1_2);
    if (err != ERR_ok)
        goto ex_0;
    T_1_1.vec->data[1] = T_1_2.num;
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE open ****/


/**** BEGIN PROCEDURE can_read ****/


errcode
istreamOPcan_read(CLUREF ist, CLUREF *ret_1)
{
    errcode err;
    if (istream_own_init == 0) {
        err = istream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(49);

  LINE(50);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ist.vec->data[0];
    if (T_1_1.cell->tag == 2) T_1_2.num = true; else T_1_2.num = false;
    ret_1->num = T_1_2.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE can_read ****/


/**** BEGIN PROCEDURE can_write ****/


errcode
istreamOPcan_write(CLUREF ist, CLUREF *ret_1)
{
    errcode err;
    if (istream_own_init == 0) {
        err = istream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(53);

  LINE(54);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ist.vec->data[0];
    if (T_1_1.cell->tag == 3) T_1_2.num = true; else T_1_2.num = false;
    ret_1->num = T_1_2.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE can_write ****/


/**** BEGIN PROCEDURE empty ****/

static int istreamOPempty_own_init = 0;

errcode
istreamOPempty(CLUREF ist, CLUREF *ret_1)
{
    errcode err;
    CLUREF rb;
    if (istreamOPempty_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        istreamOPempty_own_init = 1;
    }
    enter_proc(57);

  LINE(58);
    { /* qtagcase */
    CLUREF T_3_1;
    T_3_1.num = ist.vec->data[0];
    switch (T_3_1.cell->tag) {
    case 2: /* read */ {
        CLUREF T_3_2;
        T_3_2.num = T_3_1.cell->value;
        rb.num = T_3_2.num;

  LINE(60);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_1.num = rb.vec->data[1];
        T_4_2.num = rb.vec->data[2];
        T_4_3.num = (T_4_1.num > T_4_2.num);
        if (T_4_3.num == true) { /* if */

  LINE(61);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            CLUREF T_5_3;
            CLUREF T_5_4;
            T_5_1.num = rb.vec->data[0];
            T_5_2.num = rb.vec->data[3];
            err = _chanOPgetw(T_5_1, T_5_2, &T_5_3);
            if (err != ERR_ok)
                goto ex_2;
            err = intOPdiv(T_5_3, CLU_8, &T_5_4);
            if (err != ERR_ok)
                goto ex_2;
            rb.vec->data[2] = T_5_4.num;
            }

  LINE(62);
            {
            rb.vec->data[1] = 1;
            }
        }
        } /* end if */

  LINE(64);
        { /* return */
        {
        ret_1->tf = false;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(66);
        { /* signal */
            elist[0] = STR_cannot_040read_040from_040this_040istream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_2;
  ex_2: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_1;
  end_2:;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file) {

  LINE(68);
        { /* return */
        {
        ret_1->tf = true;
        }
        signal (ERR_ok);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE empty ****/


/**** BEGIN PROCEDURE reset ****/


errcode
istreamOPreset(CLUREF ist)
{
    errcode err;
    CLUREF rb;
    CLUREF wb;
    if (istream_own_init == 0) {
        err = istream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(71);

  LINE(72);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 2: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(74);
        {
        CLUREF T_3_1;
        T_3_1.num = rb.vec->data[0];
        err = _chanOPreset(T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(75);
        {
        rb.vec->data[1] = 1;
        }

  LINE(76);
        {
        rb.vec->data[2] = 0;
        }
        break;
    }
    case 3: /* write */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(78);
        {
        CLUREF T_3_1;
        T_3_1.num = wb.vec->data[0];
        err = _chanOPreset(T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(79);
        {
        wb.vec->data[1] = 0;
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE reset ****/


/**** BEGIN PROCEDURE flush ****/


errcode
istreamOPflush(CLUREF ist)
{
    errcode err;
    CLUREF wb;
    if (istream_own_init == 0) {
        err = istream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(84);

  LINE(85);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 3: /* write */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(87);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        T_3_1.num = wb.vec->data[0];
        T_3_2.num = wb.vec->data[2];
        T_3_3.num = wb.vec->data[1];
        err = intOPmul(CLU_8, T_3_3, &T_3_4);
        if (err != ERR_ok)
            goto ex_1;
        err = _chanOPputw(T_3_1, T_3_2, CLU_1, T_3_4, CLU_false);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(88);
        {
        wb.vec->data[1] = 0;
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE flush ****/


/**** BEGIN PROCEDURE get_date ****/

static int istreamOPget_date_own_init = 0;

errcode
istreamOPget_date(CLUREF ist, CLUREF *ret_1)
{
    errcode err;
    CLUREF rb;
    CLUREF wb;
    if (istreamOPget_date_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        istreamOPget_date_own_init = 1;
    }
    enter_proc(93);

  LINE(94);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 2: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(96);
        { /* return */
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = rb.vec->data[0];
        err = _chanOPget_date(T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        ret_1->num = T_3_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 3: /* write */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(98);
        { /* return */
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = wb.vec->data[0];
        err = _chanOPget_date(T_3_1, &T_3_2);
        if (err != ERR_ok)
            goto ex_1;
        ret_1->num = T_3_2.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(100);
        { /* signal */
            elist[0] = STR_cannot_040get_040date;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_date ****/


/**** BEGIN PROCEDURE set_date ****/

static int istreamOPset_date_own_init = 0;

errcode
istreamOPset_date(CLUREF ist, CLUREF new_date)
{
    errcode err;
    if (istreamOPset_date_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        istreamOPset_date_own_init = 1;
    }
    enter_proc(104);

  LINE(105);
    { /* signal */
        elist[0] = STR_cannot_040set_040date;
        signal(ERR_not_possible);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE set_date ****/


/**** BEGIN PROCEDURE get_name ****/


errcode
istreamOPget_name(CLUREF ist, CLUREF *ret_1)
{
    errcode err;
    if (istream_own_init == 0) {
        err = istream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(108);

  LINE(109);
    { /* return */
    {
    CLUREF T_1_1;
    T_1_1.num = ist.vec->data[1];
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_name ****/


/**** BEGIN PROCEDURE close ****/


errcode
istreamOPclose(CLUREF ist)
{
    errcode err;
    CLUREF rb;
    CLUREF wb;
    if (istream_own_init == 0) {
        err = istream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(112);

  LINE(113);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 2: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(115);
        {
        CLUREF T_3_1;
        T_3_1.num = rb.vec->data[0];
        err = _chanOPclose(T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }
        break;
    }
    case 3: /* write */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(117);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        CLUREF T_3_4;
        T_3_1.num = wb.vec->data[0];
        T_3_2.num = wb.vec->data[2];
        T_3_3.num = wb.vec->data[1];
        err = intOPmul(CLU_8, T_3_3, &T_3_4);
        if (err != ERR_ok)
            goto ex_1;
        err = _chanOPputw(T_3_1, T_3_2, CLU_1, T_3_4, CLU_false);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(118);
        {
        wb.vec->data[1] = 0;
        }

  LINE(119);
        {
        CLUREF T_3_1;
        T_3_1.num = wb.vec->data[0];
        err = _chanOPclose(T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

  LINE(122);
    {
    CLUREF T_1_1;
    CellAlloc(1, nil, T_1_1);
    ist.vec->data[0] = T_1_1.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE close ****/


/**** BEGIN PROCEDURE abort ****/


errcode
istreamOPabort(CLUREF ist)
{
    errcode err;
    CLUREF rb;
    CLUREF wb;
    if (istream_own_init == 0) {
        err = istream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(125);

  LINE(126);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 2: /* read */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(128);
        {
        CLUREF T_3_1;
        T_3_1.num = rb.vec->data[0];
        err = _chanOPabort(T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }
        break;
    }
    case 3: /* write */ {
        CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(130);
        {
        CLUREF T_3_1;
        T_3_1.num = wb.vec->data[0];
        err = _chanOPabort(T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible) {
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

  LINE(133);
    {
    CLUREF T_1_1;
    CellAlloc(1, nil, T_1_1);
    ist.vec->data[0] = T_1_1.num;
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE abort ****/


/**** BEGIN PROCEDURE is_closed ****/


errcode
istreamOPis_closed(CLUREF ist, CLUREF *ret_1)
{
    errcode err;
    if (istream_own_init == 0) {
        err = istream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(136);

  LINE(137);
    { /* return */
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ist.vec->data[0];
    if (T_1_1.cell->tag == 1) T_1_2.num = true; else T_1_2.num = false;
    ret_1->num = T_1_2.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE is_closed ****/


/**** BEGIN PROCEDURE equal ****/


errcode
istreamOPequal(CLUREF ist1, CLUREF ist2, CLUREF *ret_1)
{
    errcode err;
    if (istream_own_init == 0) {
        err = istream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(140);

  LINE(141);
    { /* return */
    {
    CLUREF T_1_1;
    T_1_1.num = (ist1.num == ist2.num);
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE equal ****/


/**** BEGIN PROCEDURE similar ****/


errcode
istreamOPsimilar(CLUREF ist1, CLUREF ist2, CLUREF *ret_1)
{
    errcode err;
    if (istream_own_init == 0) {
        err = istream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(144);

  LINE(145);
    { /* return */
    {
    CLUREF T_1_1;
    T_1_1.num = (ist1.num == ist2.num);
    ret_1->num = T_1_1.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE similar ****/


/**** BEGIN PROCEDURE copy ****/


errcode
istreamOPcopy(CLUREF ist, CLUREF *ret_1)
{
    errcode err;
    if (istream_own_init == 0) {
        err = istream_own_init_proc();
        if (err != ERR_ok)
            goto ex_0;
    }
    enter_proc(148);

  LINE(149);
    { /* return */
    {
    ret_1->num = ist.num;
    }
    signal (ERR_ok);
    }

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE copy ****/


/**** BEGIN PROCEDURE get_chan ****/

static int istreamOPget_chan_own_init = 0;

errcode
istreamOPget_chan(CLUREF ist, CLUREF *ret_1)
{
    errcode err;
    CLUREF rb;
    CLUREF wb;
    if (istreamOPget_chan_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        istreamOPget_chan_own_init = 1;
    }
    enter_proc(154);

  LINE(155);
    { /* qtagcase */
    CLUREF T_1_1;
    T_1_1.num = ist.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 2: /* read */ {
        CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        rb.num = T_1_2.num;

  LINE(157);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = rb.vec->data[0];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    case 3: /* write */ {
        CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        wb.num = T_1_3.num;

  LINE(159);
        { /* return */
        {
        CLUREF T_2_1;
        T_2_1.num = wb.vec->data[0];
        ret_1->num = T_2_1.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(161);
        { /* signal */
            elist[0] = STR_no_040channel_040attached_040to_040istream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE get_chan ****/


/**** BEGIN PROCEDURE geti ****/

static int istreamOPgeti_own_init = 0;

errcode
istreamOPgeti(CLUREF ist, CLUREF *ret_1)
{
    errcode err;
    CLUREF rb;
    CLUREF i;
    if (istreamOPgeti_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        istreamOPgeti_own_init = 1;
    }
    enter_proc(165);

  LINE(166);
    { /* qtagcase */
    CLUREF T_3_1;
    T_3_1.num = ist.vec->data[0];
    switch (T_3_1.cell->tag) {
    case 2: /* read */ {
        CLUREF T_3_2;
        T_3_2.num = T_3_1.cell->value;
        rb.num = T_3_2.num;

  LINE(168);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_1.num = rb.vec->data[1];
        T_4_2.num = rb.vec->data[2];
        T_4_3.num = (T_4_1.num > T_4_2.num);
        if (T_4_3.num == true) { /* if */

  LINE(169);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            CLUREF T_5_3;
            CLUREF T_5_4;
            T_5_1.num = rb.vec->data[0];
            T_5_2.num = rb.vec->data[3];
            err = _chanOPgetw(T_5_1, T_5_2, &T_5_3);
            if (err != ERR_ok)
                goto ex_2;
            err = intOPdiv(T_5_3, CLU_8, &T_5_4);
            if (err != ERR_ok)
                goto ex_2;
            rb.vec->data[2] = T_5_4.num;
            }

  LINE(170);
            {
            rb.vec->data[1] = 1;
            }
        }
        } /* end if */

  LINE(172);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_1.num = rb.vec->data[3];
        T_4_2.num = rb.vec->data[1];
        if (T_4_2.num < 1 || (T_4_2.num * CLUREFSZ) > (size_t)(T_4_1.str->size)) {
            err = ERR_bounds;
            goto ex_2;
        }
        T_4_3.num = T_4_1.vec->data[T_4_2.num - 1];
        i.num = T_4_3.num;
        }

  LINE(173);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        T_4_1.num = rb.vec->data[1];
        T_4_2.num = T_4_1.num + 1;
        if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) ||
            (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_2;
        }
        rb.vec->data[1] = T_4_2.num;
        }

  LINE(174);
        { /* return */
        {
        ret_1->num = i.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(176);
        { /* signal */
            elist[0] = STR_cannot_040read_040from_040this_040istream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_2;
  ex_2: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file)
        signal(err);
    else if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_1;
  end_2:;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_overflow) {

  LINE(178);
        { /* signal */
            elist[0] = STR_bad_040format;
            signal(ERR_not_possible);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE geti ****/


/**** BEGIN PROCEDURE puti ****/

static int istreamOPputi_own_init = 0;

errcode
istreamOPputi(CLUREF ist, CLUREF i)
{
    errcode err;
    CLUREF wb;
    if (istreamOPputi_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        istreamOPputi_own_init = 1;
    }
    enter_proc(181);

  LINE(182);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 3: /* write */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(184);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        T_3_1.num = wb.vec->data[1];
        T_3_2.num = 256;
        T_3_3.num = (T_3_1.num == T_3_2.num);
        if (T_3_3.num == true) { /* if */

  LINE(185);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = wb.vec->data[0];
            T_4_2.num = wb.vec->data[2];
            T_4_3.num = 2048;
            err = _chanOPputw(T_4_1, T_4_2, CLU_1, T_4_3, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }

  LINE(186);
            {
            wb.vec->data[1] = 0;
            }
        }
        } /* end if */

  LINE(188);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = wb.vec->data[1];
        T_3_2.num = T_3_1.num + 1;
        if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) ||
            (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        wb.vec->data[1] = T_3_2.num;
        }

  LINE(189);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = wb.vec->data[2];
        T_3_2.num = wb.vec->data[1];
        err = _wordvecOPstore(T_3_1, T_3_2, i);
        if (err != ERR_ok)
            goto ex_1;
        }
        break;
    }
    default: {

  LINE(191);
        { /* signal */
            elist[0] = STR_cannot_040write_040to_040this_040istream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE puti ****/


/**** BEGIN PROCEDURE getbv ****/

static int istreamOPgetbv_own_init = 0;

errcode
istreamOPgetbv(CLUREF ist, CLUREF *ret_1)
{
    errcode err;
    CLUREF rb;
    CLUREF z;
    CLUREF bvec;
    CLUREF i;
    CLUREF bidx;
    CLUREF cnt;
    if (istreamOPgetbv_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        istreamOPgetbv_own_init = 1;
    }
    enter_proc(195);

  LINE(197);
    { /* qtagcase */
    CLUREF T_3_1;
    T_3_1.num = ist.vec->data[0];
    switch (T_3_1.cell->tag) {
    case 2: /* read */ {
        CLUREF T_3_2;
        T_3_2.num = T_3_1.cell->value;
        rb.num = T_3_2.num;

  LINE(199);
        { /* if */
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_1.num = rb.vec->data[1];
        T_4_2.num = rb.vec->data[2];
        T_4_3.num = (T_4_1.num > T_4_2.num);
        if (T_4_3.num == true) { /* if */

  LINE(200);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            CLUREF T_5_3;
            CLUREF T_5_4;
            T_5_1.num = rb.vec->data[0];
            T_5_2.num = rb.vec->data[3];
            err = _chanOPgetw(T_5_1, T_5_2, &T_5_3);
            if (err != ERR_ok)
                goto ex_2;
            err = intOPdiv(T_5_3, CLU_8, &T_5_4);
            if (err != ERR_ok)
                goto ex_2;
            rb.vec->data[2] = T_5_4.num;
            }

  LINE(201);
            {
            rb.vec->data[1] = 1;
            }
        }
        } /* end if */

  LINE(203);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        CLUREF T_4_3;
        T_4_1.num = rb.vec->data[3];
        T_4_2.num = rb.vec->data[1];
        if (T_4_2.num < 1 || (T_4_2.num * CLUREFSZ) > (size_t)(T_4_1.str->size)) {
            err = ERR_bounds;
            goto ex_2;
        }
        T_4_3.num = T_4_1.vec->data[T_4_2.num - 1];
        z.num = T_4_3.num;
        }

  LINE(204);
        {
        CLUREF T_4_1;
        CLUREF T_4_2;
        T_4_1.num = rb.vec->data[1];
        T_4_2.num = T_4_1.num + 1;
        if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) ||
            (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_2;
        }
        rb.vec->data[1] = T_4_2.num;
        }

  LINE(205);
        { /* if */
        CLUREF T_4_1;
        T_4_1.num = (z.num == 0);
        if (T_4_1.num == true) { /* if */

  LINE(206);
            { /* return */
            {
            CLUREF T_5_1;
            T_5_1.num = (long)CLU_empty_string.num;
            ret_1->num = T_5_1.num;
            }
            signal (ERR_ok);
            }
        }
        } /* end if */

  LINE(207);
        {
        CLUREF T_4_1;
        err = _bytevecOPcreate(z, &T_4_1);
        if (err != ERR_ok)
            goto ex_2;
        bvec.num = T_4_1.num;
        }

  LINE(208);
        {
        i.num = 1;
        }

  LINE(209);
        for (;;) { /* while */
            CLUREF T_4_1;
            T_4_1.num = (z.num > 0);
            if (T_4_1.num != true)
                break;

  LINE(210);
            { /* if */
            CLUREF T_5_1;
            CLUREF T_5_2;
            CLUREF T_5_3;
            T_5_1.num = rb.vec->data[1];
            T_5_2.num = rb.vec->data[2];
            T_5_3.num = (T_5_1.num > T_5_2.num);
            if (T_5_3.num == true) { /* if */

  LINE(211);
                {
                CLUREF T_6_1;
                CLUREF T_6_2;
                CLUREF T_6_3;
                CLUREF T_6_4;
                T_6_1.num = rb.vec->data[0];
                T_6_2.num = rb.vec->data[3];
                err = _chanOPgetw(T_6_1, T_6_2, &T_6_3);
                if (err != ERR_ok)
                    goto ex_2;
                err = intOPdiv(T_6_3, CLU_8, &T_6_4);
                if (err != ERR_ok)
                    goto ex_2;
                rb.vec->data[2] = T_6_4.num;
                }

  LINE(212);
                {
                rb.vec->data[1] = 1;
                }
            }
            } /* end if */

  LINE(214);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            CLUREF T_5_3;
            T_5_1.num = rb.vec->data[1];
            T_5_2.num = T_5_1.num - 1;
            if ((T_5_2.num >= 0 && T_5_1.num < 0 && (-1) < 0) ||
                (T_5_2.num <= 0 && T_5_1.num > 0 && (-1) > 0)) {
                err = ERR_overflow;
                goto ex_2;
            }
            err = intOPmul(T_5_2, CLU_8, &T_5_3);
            if (err != ERR_ok)
                goto ex_2;
            bidx.num = T_5_3.num;
            }

  LINE(215);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            CLUREF T_5_3;
            T_5_1.num = rb.vec->data[2];
            err = intOPmul(T_5_1, CLU_8, &T_5_2);
            if (err != ERR_ok)
                goto ex_2;
            T_5_3.num = T_5_2.num - bidx.num;
            if ((T_5_3.num >= 0 && T_5_2.num < 0 && (-bidx.num) < 0) ||
                (T_5_3.num <= 0 && T_5_2.num > 0 && (-bidx.num) > 0)) {
                err = ERR_overflow;
                goto ex_2;
            }
            cnt.num = T_5_3.num;
            }

  LINE(216);
            { /* if */
            CLUREF T_5_1;
            T_5_1.num = (z.num < cnt.num);
            if (T_5_1.num == true) { /* if */

  LINE(217);
                {
                cnt.num = z.num;
                }
            }
            } /* end if */

  LINE(218);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            T_5_1.num = rb.vec->data[3];
            T_5_2.num = bidx.num + 1;
            if ((T_5_2.num > 0 && bidx.num < 0 && 1 < 0) ||
                (T_5_2.num < 0 && bidx.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_2;
            }
            err = _wordvecOPmove_w2b(T_5_1, T_5_2, bvec, i, cnt);
            if (err != ERR_ok)
                goto ex_2;
            }

  LINE(219);
            {
            CLUREF T_5_1;
            T_5_1.num = z.num - cnt.num;
            if ((T_5_1.num >= 0 && z.num < 0 && (-cnt.num) < 0) ||
                (T_5_1.num <= 0 && z.num > 0 && (-cnt.num) > 0)) {
                err = ERR_overflow;
                goto ex_2;
            }
            z.num = T_5_1.num;
            }

  LINE(220);
            {
            CLUREF T_5_1;
            T_5_1.num = i.num + cnt.num;
            if ((T_5_1.num > 0 && i.num < 0 && cnt.num < 0) ||
                (T_5_1.num < 0 && i.num > 0 && cnt.num > 0)) {
                err = ERR_overflow;
                goto ex_2;
            }
            i.num = T_5_1.num;
            }

  LINE(221);
            {
            CLUREF T_5_1;
            CLUREF T_5_2;
            CLUREF T_5_3;
            CLUREF T_5_4;
            T_5_1.num = rb.vec->data[1];
            T_5_2.num = cnt.num + 7;
            if ((T_5_2.num > 0 && cnt.num < 0 && 7 < 0) ||
                (T_5_2.num < 0 && cnt.num > 0 && 7 > 0)) {
                err = ERR_overflow;
                goto ex_2;
            }
            err = intOPdiv(T_5_2, CLU_8, &T_5_3);
            if (err != ERR_ok)
                goto ex_2;
            T_5_4.num = T_5_1.num + T_5_3.num;
            if ((T_5_4.num > 0 && T_5_1.num < 0 && T_5_3.num < 0) ||
                (T_5_4.num < 0 && T_5_1.num > 0 && T_5_3.num > 0)) {
                err = ERR_overflow;
                goto ex_2;
            }
            rb.vec->data[1] = T_5_4.num;
            }
        }
        end_while_1:
        __CLU_END_LABEL;

  LINE(223);
        { /* return */
        {
        ret_1->num = bvec.num;
        }
        signal (ERR_ok);
        }
        break;
    }
    default: {

  LINE(225);
        { /* signal */
            elist[0] = STR_cannot_040read_040from_040this_040istream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_2;
  ex_2: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_end_of_file)
        signal(err);
    else if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_1;
  end_2:;
    goto end_1;
  ex_1: /* except */
    __CLU_EX_HANDLER;
    if (err == ERR_overflow
        || err == ERR_toobig)
    {

  LINE(227);
        { /* signal */
            elist[0] = STR_bad_040format;
            signal(ERR_not_possible);
        }
    }
    else { /* not handled */
        goto ex_0;
    }
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    elist[0] = no_return_values_STRING;
    signal(ERR_failure);
}

/**** END PROCEDURE getbv ****/


/**** BEGIN PROCEDURE putbv ****/

static int istreamOPputbv_own_init = 0;

errcode
istreamOPputbv(CLUREF ist, CLUREF bvec)
{
    errcode err;
    CLUREF wb;
    CLUREF z;
    CLUREF i;
    CLUREF bidx;
    CLUREF cnt;
    if (istreamOPputbv_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok)
                goto ex_0;
        }
        istreamOPputbv_own_init = 1;
    }
    enter_proc(231);

  LINE(232);
    { /* qtagcase */
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 3: /* write */ {
        CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(234);
        {
        CLUREF T_3_1;
        err = _bytevecOPsize(bvec, &T_3_1);
        if (err != ERR_ok)
            goto ex_1;
        z.num = T_3_1.num;
        }

  LINE(235);
        { /* if */
        CLUREF T_3_1;
        CLUREF T_3_2;
        CLUREF T_3_3;
        T_3_1.num = wb.vec->data[1];
        T_3_2.num = 256;
        T_3_3.num = (T_3_1.num == T_3_2.num);
        if (T_3_3.num == true) { /* if */

  LINE(236);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = wb.vec->data[0];
            T_4_2.num = wb.vec->data[2];
            T_4_3.num = 2048;
            err = _chanOPputw(T_4_1, T_4_2, CLU_1, T_4_3, CLU_false);
            if (err != ERR_ok)
                goto ex_1;
            }

  LINE(237);
            {
            wb.vec->data[1] = 0;
            }
        }
        } /* end if */

  LINE(239);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = wb.vec->data[1];
        T_3_2.num = T_3_1.num + 1;
        if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) ||
            (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
            err = ERR_overflow;
            goto ex_1;
        }
        wb.vec->data[1] = T_3_2.num;
        }

  LINE(240);
        {
        CLUREF T_3_1;
        CLUREF T_3_2;
        T_3_1.num = wb.vec->data[2];
        T_3_2.num = wb.vec->data[1];
        err = _wordvecOPstore(T_3_1, T_3_2, z);
        if (err != ERR_ok)
            goto ex_1;
        }

  LINE(241);
        {
        i.num = 1;
        }

  LINE(242);
        for (;;) { /* while */
            CLUREF T_3_1;
            T_3_1.num = (z.num > 0);
            if (T_3_1.num != true)
                break;

  LINE(243);
            { /* if */
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = wb.vec->data[1];
            T_4_2.num = 256;
            T_4_3.num = (T_4_1.num == T_4_2.num);
            if (T_4_3.num == true) { /* if */

  LINE(244);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                T_5_1.num = wb.vec->data[0];
                T_5_2.num = wb.vec->data[2];
                T_5_3.num = 2048;
                err = _chanOPputw(T_5_1, T_5_2, CLU_1, T_5_3, CLU_false);
                if (err != ERR_ok)
                    goto ex_1;
                }

  LINE(245);
                {
                wb.vec->data[1] = 0;
                }
            }
            } /* end if */

  LINE(247);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = wb.vec->data[1];
            err = intOPmul(T_4_1, CLU_8, &T_4_2);
            if (err != ERR_ok)
                goto ex_1;
            bidx.num = T_4_2.num;
            }

  LINE(248);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = 2048;
            T_4_2.num = T_4_1.num - bidx.num;
            if ((T_4_2.num >= 0 && T_4_1.num < 0 && (-bidx.num) < 0) ||
                (T_4_2.num <= 0 && T_4_1.num > 0 && (-bidx.num) > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            cnt.num = T_4_2.num;
            }

  LINE(249);
            { /* if */
            CLUREF T_4_1;
            T_4_1.num = (z.num < cnt.num);
            if (T_4_1.num == true) { /* if */

  LINE(250);
                {
                cnt.num = z.num;
                }
            }
            } /* end if */

  LINE(251);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = wb.vec->data[2];
            T_4_2.num = bidx.num + 1;
            if ((T_4_2.num > 0 && bidx.num < 0 && 1 < 0) ||
                (T_4_2.num < 0 && bidx.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            err = _wordvecOPmove_b2w(bvec, i, T_4_1, T_4_2, cnt);
            if (err != ERR_ok)
                goto ex_1;
            }

  LINE(252);
            {
            CLUREF T_4_1;
            T_4_1.num = z.num - cnt.num;
            if ((T_4_1.num >= 0 && z.num < 0 && (-cnt.num) < 0) ||
                (T_4_1.num <= 0 && z.num > 0 && (-cnt.num) > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            z.num = T_4_1.num;
            }

  LINE(253);
            {
            CLUREF T_4_1;
            T_4_1.num = i.num + cnt.num;
            if ((T_4_1.num > 0 && i.num < 0 && cnt.num < 0) ||
                (T_4_1.num < 0 && i.num > 0 && cnt.num > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            i.num = T_4_1.num;
            }

  LINE(254);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            CLUREF T_4_4;
            T_4_1.num = wb.vec->data[1];
            T_4_2.num = cnt.num + 7;
            if ((T_4_2.num > 0 && cnt.num < 0 && 7 < 0) ||
                (T_4_2.num < 0 && cnt.num > 0 && 7 > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            err = intOPdiv(T_4_2, CLU_8, &T_4_3);
            if (err != ERR_ok)
                goto ex_1;
            T_4_4.num = T_4_1.num + T_4_3.num;
            if ((T_4_4.num > 0 && T_4_1.num < 0 && T_4_3.num < 0) ||
                (T_4_4.num < 0 && T_4_1.num > 0 && T_4_3.num > 0)) {
                err = ERR_overflow;
                goto ex_1;
            }
            wb.vec->data[1] = T_4_4.num;
            }
        }
        end_while_1:
        __CLU_END_LABEL;
        break;
    }
    default: {

  LINE(257);
        { /* signal */
            elist[0] = STR_cannot_040write_040to_040this_040istream;
            signal(ERR_not_possible);
        }
        break;
    }
    }
    } /* end qtagcase */
    goto end_1;
  ex_1: /* resignal */
    __CLU_EX_HANDLER;
    if (err == ERR_not_possible)
        signal(err);
    else
        goto ex_0;
  end_1:;

    goto end_0;
  ex_0:
    __CLU_EX_HANDLER;
    if (err != ERR_failure)
        elist[0] = _pclu_erstr(err);
    signal(ERR_failure);
  end_0:
    signal(ERR_ok);
}

/**** END PROCEDURE putbv ****/

typedef struct {
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[15];
} istream_OPS;

static CLU_proc istream_oe_abort = { .proc = istreamOPabort };
static CLU_proc istream_oe_can_read = { .proc = istreamOPcan_read };
static CLU_proc istream_oe_can_write = { .proc = istreamOPcan_write };
static CLU_proc istream_oe_close = { .proc = istreamOPclose };
static CLU_proc istream_oe_copy = { .proc = istreamOPcopy };
static CLU_proc istream_oe_empty = { .proc = istreamOPempty };
static CLU_proc istream_oe_equal = { .proc = istreamOPequal };
static CLU_proc istream_oe_flush = { .proc = istreamOPflush };
static CLU_proc istream_oe_get_date = { .proc = istreamOPget_date };
static CLU_proc istream_oe_get_name = { .proc = istreamOPget_name };
static CLU_proc istream_oe_is_closed = { .proc = istreamOPis_closed };
static CLU_proc istream_oe_open = { .proc = istreamOPopen };
static CLU_proc istream_oe_reset = { .proc = istreamOPreset };
static CLU_proc istream_oe_set_date = { .proc = istreamOPset_date };
static CLU_proc istream_oe_similar = { .proc = istreamOPsimilar };

static istream_OPS istream_ops_actual = {15, (OWNPTR)&istream_own_init, (OWNPTR)&istream_own_init, {
    {&istream_oe_abort, "abort"},
    {&istream_oe_can_read, "can_read"},
    {&istream_oe_can_write, "can_write"},
    {&istream_oe_close, "close"},
    {&istream_oe_copy, "copy"},
    {&istream_oe_empty, "empty"},
    {&istream_oe_equal, "equal"},
    {&istream_oe_flush, "flush"},
    {&istream_oe_get_date, "get_date"},
    {&istream_oe_get_name, "get_name"},
    {&istream_oe_is_closed, "is_closed"},
    {&istream_oe_open, "open"},
    {&istream_oe_reset, "reset"},
    {&istream_oe_set_date, "set_date"},
    {&istream_oe_similar, "similar"}}};

struct OPS *istream_ops = (struct OPS *)&istream_ops_actual;

/**** END CLUSTER istream ****/
