
/* This file was automatically generated by pclu.*/

#include "pclu_err.h"
#include "pclu_sys.h"


/**** BEGIN CLUSTER istream ****/

extern errcode boolOPnot();
extern errcode stringOPequal();
extern errcode _chanOPopen();
extern errcode _wordvecOPcreate();
extern errcode oneofOPmake_2();
extern errcode oneofOPmake_3();
extern errcode _chanOPget_name();
extern errcode oneofOPis_2();
extern errcode recordOPget_1();
extern errcode oneofOPis_3();
extern errcode intOPgt();
extern errcode recordOPget_2();
extern errcode recordOPget_3();
extern errcode recordOPset_3();
extern errcode intOPdiv();
extern errcode _chanOPgetw();
extern errcode recordOPget_4();
extern errcode recordOPset_2();
extern errcode _chanOPreset();
extern errcode _chanOPputw();
extern errcode intOPmul();
extern errcode _chanOPget_date();
extern errcode _chanOPclose();
extern errcode recordOPset_1();
extern errcode oneofOPmake_1();
extern errcode _chanOPabort();
extern errcode oneofOPis_1();
extern errcode recordOPequal();
extern errcode _wordvecOPfetch();
extern errcode intOPadd();
extern errcode intOPequal();
extern errcode _wordvecOPstore();
extern errcode _cvt();
extern errcode _bytevecOPcreate();
extern errcode intOPsub();
extern errcode intOPlt();
extern errcode _wordvecOPmove_w2b();
extern errcode _bytevecOPsize();
extern errcode _wordvecOPmove_b2w();
CLUREF STR_read;
CLUREF STR_write;
CLUREF STR_append;
CLUREF STR_bad_040access_040mode;
CLUREF STR_cannot_040read_040from_040this_040istream;
CLUREF STR_cannot_040get_040date;
CLUREF STR_cannot_040set_040date;
CLUREF STR_no_040channel_040attached_040to_040istream;
CLUREF STR_bad_040format;
CLUREF STR_cannot_040write_040to_040this_040istream;
CLUREF STR_;
static int istream_own_init = 0;
OWN_req istream_ownreqs = {0,0};
errcode istream_own_init_proc()
{
    errcode err;
    enter_own_init_proc();
        if (istream_own_init == 0) {
        stringOPcons("read", CLU_1, CLU_4, &STR_read);
        stringOPcons("write", CLU_1, CLU_5, &STR_write);
        stringOPcons("append", CLU_1, CLU_6, &STR_append);
        stringOPcons("bad access mode", CLU_1, CLU_15, &STR_bad_040access_040mode);
        stringOPcons("cannot read from this istream", CLU_1, CLU_29, &STR_cannot_040read_040from_040this_040istream);
        stringOPcons("cannot get date", CLU_1, CLU_15, &STR_cannot_040get_040date);
        stringOPcons("cannot set date", CLU_1, CLU_15, &STR_cannot_040set_040date);
        stringOPcons("no channel attached to istream", CLU_1, CLU_30, &STR_no_040channel_040attached_040to_040istream);
        stringOPcons("bad format", CLU_1, CLU_10, &STR_bad_040format);
        stringOPcons("cannot write to this istream", CLU_1, CLU_28, &STR_cannot_040write_040to_040this_040istream);
        stringOPcons("", CLU_1, CLU_0, &STR_);
        istream_own_init = 1;
        {signal(ERR_ok);}
    ex_0: pclu_unhandled(err); {signal(ERR_failure);}
        }
    }

static int istreamOPopen_own_init = 0;

/**** BEGIN PROCEDURE open ****/

errcode istreamOPopen(f, access, ret_1)
CLUREF f;
CLUREF access;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF ch;
    CLUREF wvec;
    CLUREF b;
        if (istreamOPopen_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        istreamOPopen_own_init = 1;
    }
    enter_proc(29);

  LINE(30);
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    CLUREF T_1_3;
    CLUREF T_1_4;
    CLUREF T_1_5;
    CLUREF T_1_6;
    CLUREF T_1_7;
    CLUREF T_1_8;
    T_1_3.num = ((access.str->size != STR_read.str->size)? false :
        !(bcmp(access.str->data, STR_read.str->data, access.str->size)));
    T_1_4.num = T_1_3.num ^ 1;
    T_1_2.num = T_1_4.num;
    if (T_1_4.num) {
        T_1_5.num = ((access.str->size != STR_write.str->size)? false :
            !(bcmp(access.str->data, STR_write.str->data, access.str->size)));
        T_1_6.num = T_1_5.num ^ 1;
        T_1_2.num = T_1_6.num;
    }
    T_1_1.num = T_1_2.num;
    if (T_1_2.num) {
        T_1_7.num = ((access.str->size != STR_append.str->size)? false :
            !(bcmp(access.str->data, STR_append.str->data, access.str->size)));
        T_1_8.num = T_1_7.num ^ 1;
        T_1_1.num = T_1_8.num;
    }
    if (T_1_1.num == true) {

  LINE(31);
        {
        elist[0] = STR_bad_040access_040mode;
        {signal (ERR_not_possible);}}
        }
        }/* end if */

  LINE(32);
    {
        {CLUREF T_2_1;
        err = _chanOPopen(f, access, CLU_0, &T_2_1);
        if (err != ERR_ok) goto ex_1;
        ch.num = T_2_1.num;
        }
        }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(34);
    {
        {CLUREF T_1_1;
        CLUREF T_1_2;
        T_1_1.num = 256;
        err = _wordvecOPcreate(T_1_1, &T_1_2);
        if (err != ERR_ok) goto ex_0;
        wvec.num = T_1_2.num;
        }
        }

  LINE(36);
    {
    CLUREF T_1_1;
    T_1_1.num = ((access.str->size != STR_read.str->size)? false :
        !(bcmp(access.str->data, STR_read.str->data, access.str->size)));
    if (T_1_1.num == true) {

  LINE(37);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(4, T_2_1);
        T_2_1.vec->data[0]  = ch.num;
        T_2_1.vec->data[3]  = wvec.num;
        T_2_1.vec->data[1]  = 1;
        T_2_1.vec->data[2]  = 0;
        CellAlloc(2, T_2_1.num, T_2_2);
        b.num = T_2_2.num;
        }
        }
    else {

  LINE(41);
        {
        CLUREF T_2_1;
        CLUREF T_2_2;
        RecordAlloc(3, T_2_1);
        T_2_1.vec->data[0]  = ch.num;
        T_2_1.vec->data[2]  = wvec.num;
        T_2_1.vec->data[1]  = 0;
        CellAlloc(3, T_2_1.num, T_2_2);
        b.num = T_2_2.num;
        }
        }}/* end if */

  LINE(45);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    RecordAlloc(2, T_1_1);
    T_1_1.vec->data[0]  = b.num;
    err = _chanOPget_name(ch, &T_1_2);
    if (err != ERR_ok) goto ex_0;
    T_1_1.vec->data[1]  = T_1_2.num;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE open ****/


/**** BEGIN PROCEDURE can_read ****/

errcode istreamOPcan_read(ist, ret_1)
CLUREF ist;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(49);

  LINE(50);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ist.vec->data[0];
    if (T_1_1.cell->tag == 2) T_1_2.num = true; else T_1_2.num = false;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE can_read ****/


/**** BEGIN PROCEDURE can_write ****/

errcode istreamOPcan_write(ist, ret_1)
CLUREF ist;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(53);

  LINE(54);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ist.vec->data[0];
    if (T_1_1.cell->tag == 3) T_1_2.num = true; else T_1_2.num = false;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE can_write ****/

static int istreamOPempty_own_init = 0;

/**** BEGIN PROCEDURE empty ****/

errcode istreamOPempty(ist, ret_1)
CLUREF ist;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
        if (istreamOPempty_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        istreamOPempty_own_init = 1;
    }
    enter_proc(57);

  LINE(58);
    {
    CLUREF T_3_1;
    T_3_1.num = ist.vec->data[0];
    switch (T_3_1.cell->tag) {
    case 2: 
         {CLUREF T_3_2;
        T_3_2.num = T_3_1.cell->value;
        rb.num = T_3_2.num;

  LINE(60);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = rb.vec->data[1];
            T_4_2.num = rb.vec->data[2];
            T_4_3.num = (T_4_1.num > T_4_2.num)? true : false;
            if (T_4_3.num == true) {

  LINE(61);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                CLUREF T_5_4;
                T_5_1.num = rb.vec->data[0];
                T_5_2.num = rb.vec->data[3];
                err = _chanOPgetw(T_5_1, T_5_2, &T_5_3);
                if (err != ERR_ok) goto ex_2;
                err = intOPdiv(T_5_3, CLU_8, &T_5_4);
                if (err != ERR_ok) goto ex_2;
                rb.vec->data[2]  = T_5_4.num;
                }

  LINE(62);
                {
                rb.vec->data[1]  = 1;
                }
                }
                }/* end if */

  LINE(64);
            {
            {
            ret_1->tf = false;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(66);
        {
        elist[0] = STR_cannot_040read_040from_040this_040istream;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_2;
    ex_2:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_1;}
    end_2:;
        goto end_1;
        ex_1:
            if ((err == ERR_end_of_file)) {

  LINE(68);
                {
                {
                ret_1->tf = true;
                }
                {signal (ERR_ok);}}
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE empty ****/


/**** BEGIN PROCEDURE reset ****/

errcode istreamOPreset(ist)
CLUREF ist;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF wb;
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(71);

  LINE(72);
    {
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 2: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(74);
            {
            CLUREF T_3_1;
            T_3_1.num = rb.vec->data[0];
            err = _chanOPreset(T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(75);
            {
            rb.vec->data[1]  = 1;
            }

  LINE(76);
            {
            rb.vec->data[2]  = 0;
            }
            break;
            }
    case 3: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(78);
            {
            CLUREF T_3_1;
            T_3_1.num = wb.vec->data[0];
            err = _chanOPreset(T_3_1);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(79);
            {
            wb.vec->data[1]  = 0;
            }
            break;
            }
    default: {
    }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE reset ****/


/**** BEGIN PROCEDURE flush ****/

errcode istreamOPflush(ist)
CLUREF ist;
    {
    errcode err;
    errcode ecode2;
    CLUREF wb;
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(84);

  LINE(85);
    {
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 3: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(87);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_1.num = wb.vec->data[0];
            T_3_2.num = wb.vec->data[2];
            T_3_3.num = wb.vec->data[1];
            err = intOPmul(CLU_8, T_3_3, &T_3_4);
            if (err != ERR_ok) goto ex_1;
            err = _chanOPputw(T_3_1, T_3_2, CLU_1, T_3_4, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(88);
            {
            wb.vec->data[1]  = 0;
            }
            break;
            }
    default: {
    }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE flush ****/

static int istreamOPget_date_own_init = 0;

/**** BEGIN PROCEDURE get_date ****/

errcode istreamOPget_date(ist, ret_1)
CLUREF ist;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF wb;
        if (istreamOPget_date_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        istreamOPget_date_own_init = 1;
    }
    enter_proc(93);

  LINE(94);
    {
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 2: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(96);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = rb.vec->data[0];
            err = _chanOPget_date(T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            ret_1->num = T_3_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 3: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(98);
            {
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = wb.vec->data[0];
            err = _chanOPget_date(T_3_1, &T_3_2);
            if (err != ERR_ok) goto ex_1;
            ret_1->num = T_3_2.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(100);
        {
        elist[0] = STR_cannot_040get_040date;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_date ****/

static int istreamOPset_date_own_init = 0;

/**** BEGIN PROCEDURE set_date ****/

errcode istreamOPset_date(ist, new_date)
CLUREF ist;
CLUREF new_date;
    {
    errcode err;
    errcode ecode2;
        if (istreamOPset_date_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        istreamOPset_date_own_init = 1;
    }
    enter_proc(104);

  LINE(105);
    {
    elist[0] = STR_cannot_040set_040date;
    {signal (ERR_not_possible);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE set_date ****/


/**** BEGIN PROCEDURE get_name ****/

errcode istreamOPget_name(ist, ret_1)
CLUREF ist;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(108);

  LINE(109);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = ist.vec->data[1];
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_name ****/


/**** BEGIN PROCEDURE close ****/

errcode istreamOPclose(ist)
CLUREF ist;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF wb;
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(112);

  LINE(113);
    {
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 2: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(115);
            {
            CLUREF T_3_1;
            T_3_1.num = rb.vec->data[0];
            err = _chanOPclose(T_3_1);
            if (err != ERR_ok) goto ex_1;
            }
            break;
            }
    case 3: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(117);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            CLUREF T_3_4;
            T_3_1.num = wb.vec->data[0];
            T_3_2.num = wb.vec->data[2];
            T_3_3.num = wb.vec->data[1];
            err = intOPmul(CLU_8, T_3_3, &T_3_4);
            if (err != ERR_ok) goto ex_1;
            err = _chanOPputw(T_3_1, T_3_2, CLU_1, T_3_4, CLU_0);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(118);
            {
            wb.vec->data[1]  = 0;
            }

  LINE(119);
            {
            CLUREF T_3_1;
            T_3_1.num = wb.vec->data[0];
            err = _chanOPclose(T_3_1);
            if (err != ERR_ok) goto ex_1;
            }
            break;
            }
    default: {
    }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;

  LINE(122);
    {
    CLUREF T_1_1;
    CellAlloc(1, nil, T_1_1);
    ist.vec->data[0]  = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE close ****/


/**** BEGIN PROCEDURE abort ****/

errcode istreamOPabort(ist)
CLUREF ist;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF wb;
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(125);

  LINE(126);
    {
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 2: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        rb.num = T_2_2.num;

  LINE(128);
            {
            CLUREF T_3_1;
            T_3_1.num = rb.vec->data[0];
            err = _chanOPabort(T_3_1);
            if (err != ERR_ok) goto ex_1;
            }
            break;
            }
    case 3: 
         {CLUREF T_2_3;
        T_2_3.num = T_2_1.cell->value;
        wb.num = T_2_3.num;

  LINE(130);
            {
            CLUREF T_3_1;
            T_3_1.num = wb.vec->data[0];
            err = _chanOPabort(T_3_1);
            if (err != ERR_ok) goto ex_1;
            }
            break;
            }
    default: {
    }
    }
    }
        goto end_1;
        ex_1:
            if ((err == ERR_not_possible)) {
            }
            else {
                goto ex_0;
            }
        end_1:;

  LINE(133);
    {
    CLUREF T_1_1;
    CellAlloc(1, nil, T_1_1);
    ist.vec->data[0]  = T_1_1.num;
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE abort ****/


/**** BEGIN PROCEDURE is_closed ****/

errcode istreamOPis_closed(ist, ret_1)
CLUREF ist;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(136);

  LINE(137);
    {
    {
    CLUREF T_1_1;
    CLUREF T_1_2;
    T_1_1.num = ist.vec->data[0];
    if (T_1_1.cell->tag == 1) T_1_2.num = true; else T_1_2.num = false;
    ret_1->num = T_1_2.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE is_closed ****/


/**** BEGIN PROCEDURE equal ****/

errcode istreamOPequal(ist1, ist2, ret_1)
CLUREF ist1;
CLUREF ist2;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(140);

  LINE(141);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = (ist1.num == ist2.num)? true : false;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE equal ****/


/**** BEGIN PROCEDURE similar ****/

errcode istreamOPsimilar(ist1, ist2, ret_1)
CLUREF ist1;
CLUREF ist2;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(144);

  LINE(145);
    {
    {
    CLUREF T_1_1;
    T_1_1.num = (ist1.num == ist2.num)? true : false;
    ret_1->num = T_1_1.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE similar ****/


/**** BEGIN PROCEDURE copy ****/

errcode istreamOPcopy(ist, ret_1)
CLUREF ist;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
    enter_proc(148);

  LINE(149);
    {
    {
    ret_1->num = ist.num;
    }
    {signal (ERR_ok);}}
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE copy ****/

static int istreamOPget_chan_own_init = 0;

/**** BEGIN PROCEDURE get_chan ****/

errcode istreamOPget_chan(ist, ret_1)
CLUREF ist;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF wb;
        if (istreamOPget_chan_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        istreamOPget_chan_own_init = 1;
    }
    enter_proc(154);

  LINE(155);
    {
    CLUREF T_1_1;
    T_1_1.num = ist.vec->data[0];
    switch (T_1_1.cell->tag) {
    case 2: 
         {CLUREF T_1_2;
        T_1_2.num = T_1_1.cell->value;
        rb.num = T_1_2.num;

  LINE(157);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = rb.vec->data[0];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    case 3: 
         {CLUREF T_1_3;
        T_1_3.num = T_1_1.cell->value;
        wb.num = T_1_3.num;

  LINE(159);
            {
            {
            CLUREF T_2_1;
            T_2_1.num = wb.vec->data[0];
            ret_1->num = T_2_1.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(161);
        {
        elist[0] = STR_no_040channel_040attached_040to_040istream;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE get_chan ****/

static int istreamOPgeti_own_init = 0;

/**** BEGIN PROCEDURE geti ****/

errcode istreamOPgeti(ist, ret_1)
CLUREF ist;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF i;
        if (istreamOPgeti_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        istreamOPgeti_own_init = 1;
    }
    enter_proc(165);

  LINE(166);
    {
    CLUREF T_3_1;
    T_3_1.num = ist.vec->data[0];
    switch (T_3_1.cell->tag) {
    case 2: 
         {CLUREF T_3_2;
        T_3_2.num = T_3_1.cell->value;
        rb.num = T_3_2.num;

  LINE(168);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = rb.vec->data[1];
            T_4_2.num = rb.vec->data[2];
            T_4_3.num = (T_4_1.num > T_4_2.num)? true : false;
            if (T_4_3.num == true) {

  LINE(169);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                CLUREF T_5_4;
                T_5_1.num = rb.vec->data[0];
                T_5_2.num = rb.vec->data[3];
                err = _chanOPgetw(T_5_1, T_5_2, &T_5_3);
                if (err != ERR_ok) goto ex_2;
                err = intOPdiv(T_5_3, CLU_8, &T_5_4);
                if (err != ERR_ok) goto ex_2;
                rb.vec->data[2]  = T_5_4.num;
                }

  LINE(170);
                {
                rb.vec->data[1]  = 1;
                }
                }
                }/* end if */

  LINE(172);
            {
                {CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                T_4_1.num = rb.vec->data[3];
                T_4_2.num = rb.vec->data[1];
                if (T_4_2.num < 1 || (T_4_2.num<<2) > (T_4_1.str->size)) {
                    err = ERR_bounds;
                    goto ex_2;}
                T_4_3.num = T_4_1.vec->data[T_4_2.num - 1];
                i.num = T_4_3.num;
                }
                }

  LINE(173);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = rb.vec->data[1];
            T_4_2.num = T_4_1.num + 1;
             if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) || 
                 (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_2;}
            rb.vec->data[1]  = T_4_2.num;
            }

  LINE(174);
            {
            {
            ret_1->num = i.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(176);
        {
        elist[0] = STR_cannot_040read_040from_040this_040istream;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_2;
    ex_2:
        if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
        else if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_1;}
    end_2:;
        goto end_1;
        ex_1:
            if ((err == ERR_overflow)) {

  LINE(178);
                {
                elist[0] = STR_bad_040format;
                {signal (ERR_not_possible);}}
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE geti ****/

static int istreamOPputi_own_init = 0;

/**** BEGIN PROCEDURE puti ****/

errcode istreamOPputi(ist, i)
CLUREF ist;
CLUREF i;
    {
    errcode err;
    errcode ecode2;
    CLUREF wb;
        if (istreamOPputi_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        istreamOPputi_own_init = 1;
    }
    enter_proc(181);

  LINE(182);
    {
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 3: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(184);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = wb.vec->data[1];
            T_3_2.num = 256;
            T_3_3.num = (T_3_1.num == T_3_2.num)? true : false;
            if (T_3_3.num == true) {

  LINE(185);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                T_4_1.num = wb.vec->data[0];
                T_4_2.num = wb.vec->data[2];
                T_4_3.num = 2048;
                err = _chanOPputw(T_4_1, T_4_2, CLU_1, T_4_3, CLU_0);
                if (err != ERR_ok) goto ex_1;
                }

  LINE(186);
                {
                wb.vec->data[1]  = 0;
                }
                }
                }/* end if */

  LINE(188);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = wb.vec->data[1];
            T_3_2.num = T_3_1.num + 1;
             if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) || 
                 (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            wb.vec->data[1]  = T_3_2.num;
            }

  LINE(189);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = wb.vec->data[2];
            T_3_2.num = wb.vec->data[1];
            err = _wordvecOPstore(T_3_1, T_3_2, i);
            if (err != ERR_ok) goto ex_1;
            }
            break;
            }
    default: {

  LINE(191);
        {
        elist[0] = STR_cannot_040write_040to_040this_040istream;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE puti ****/

static int istreamOPgetbv_own_init = 0;

/**** BEGIN PROCEDURE getbv ****/

errcode istreamOPgetbv(ist, ret_1)
CLUREF ist;
CLUREF *ret_1;
    {
    errcode err;
    errcode ecode2;
    CLUREF rb;
    CLUREF z;
    CLUREF bvec;
    CLUREF i;
    CLUREF bidx;
    CLUREF cnt;
        if (istreamOPgetbv_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        istreamOPgetbv_own_init = 1;
    }
    enter_proc(195);

  LINE(197);
    {
    CLUREF T_3_1;
    T_3_1.num = ist.vec->data[0];
    switch (T_3_1.cell->tag) {
    case 2: 
         {CLUREF T_3_2;
        T_3_2.num = T_3_1.cell->value;
        rb.num = T_3_2.num;

  LINE(199);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            CLUREF T_4_3;
            T_4_1.num = rb.vec->data[1];
            T_4_2.num = rb.vec->data[2];
            T_4_3.num = (T_4_1.num > T_4_2.num)? true : false;
            if (T_4_3.num == true) {

  LINE(200);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                CLUREF T_5_4;
                T_5_1.num = rb.vec->data[0];
                T_5_2.num = rb.vec->data[3];
                err = _chanOPgetw(T_5_1, T_5_2, &T_5_3);
                if (err != ERR_ok) goto ex_2;
                err = intOPdiv(T_5_3, CLU_8, &T_5_4);
                if (err != ERR_ok) goto ex_2;
                rb.vec->data[2]  = T_5_4.num;
                }

  LINE(201);
                {
                rb.vec->data[1]  = 1;
                }
                }
                }/* end if */

  LINE(203);
            {
                {CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                T_4_1.num = rb.vec->data[3];
                T_4_2.num = rb.vec->data[1];
                if (T_4_2.num < 1 || (T_4_2.num<<2) > (T_4_1.str->size)) {
                    err = ERR_bounds;
                    goto ex_2;}
                T_4_3.num = T_4_1.vec->data[T_4_2.num - 1];
                z.num = T_4_3.num;
                }
                }

  LINE(204);
            {
            CLUREF T_4_1;
            CLUREF T_4_2;
            T_4_1.num = rb.vec->data[1];
            T_4_2.num = T_4_1.num + 1;
             if ((T_4_2.num > 0 && T_4_1.num < 0 && 1 < 0) || 
                 (T_4_2.num < 0 && T_4_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_2;}
            rb.vec->data[1]  = T_4_2.num;
            }

  LINE(205);
            {
            CLUREF T_4_1;
            T_4_1.num = (z.num == 0)? true : false;
            if (T_4_1.num == true) {

  LINE(206);
                {
                {
                CLUREF T_5_1;
                T_5_1.num = STR_.num;
                ret_1->num = T_5_1.num;
                }
                {signal (ERR_ok);}}
                }
                }/* end if */

  LINE(207);
            {
                {CLUREF T_4_1;
                err = _bytevecOPcreate(z, &T_4_1);
                if (err != ERR_ok) goto ex_2;
                bvec.num = T_4_1.num;
                }
                }

  LINE(208);
            {
                {i.num = 1;
                }
                }

  LINE(209);
            for (;;) {
                CLUREF T_4_1;
                T_4_1.num = (z.num > 0)? true : false;
                if (T_4_1.num != true) { break; }

  LINE(210);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                T_5_1.num = rb.vec->data[1];
                T_5_2.num = rb.vec->data[2];
                T_5_3.num = (T_5_1.num > T_5_2.num)? true : false;
                if (T_5_3.num == true) {

  LINE(211);
                    {
                    CLUREF T_6_1;
                    CLUREF T_6_2;
                    CLUREF T_6_3;
                    CLUREF T_6_4;
                    T_6_1.num = rb.vec->data[0];
                    T_6_2.num = rb.vec->data[3];
                    err = _chanOPgetw(T_6_1, T_6_2, &T_6_3);
                    if (err != ERR_ok) goto ex_2;
                    err = intOPdiv(T_6_3, CLU_8, &T_6_4);
                    if (err != ERR_ok) goto ex_2;
                    rb.vec->data[2]  = T_6_4.num;
                    }

  LINE(212);
                    {
                    rb.vec->data[1]  = 1;
                    }
                    }
                    }/* end if */

  LINE(214);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    CLUREF T_5_3;
                    T_5_1.num = rb.vec->data[1];
                    T_5_2.num = T_5_1.num - 1;
                     if ((T_5_2.num >= 0 && T_5_1.num < 0 && (-1) < 0) || 
                         (T_5_2.num <= 0 && T_5_1.num > 0 && (-1) > 0)) {
                        err = ERR_overflow;
                        goto ex_2;}
                    err = intOPmul(T_5_2, CLU_8, &T_5_3);
                    if (err != ERR_ok) goto ex_2;
                    bidx.num = T_5_3.num;
                    }
                    }

  LINE(215);
                {
                    {CLUREF T_5_1;
                    CLUREF T_5_2;
                    CLUREF T_5_3;
                    T_5_1.num = rb.vec->data[2];
                    err = intOPmul(T_5_1, CLU_8, &T_5_2);
                    if (err != ERR_ok) goto ex_2;
                    T_5_3.num = T_5_2.num - bidx.num;
                     if ((T_5_3.num >= 0 && T_5_2.num < 0 && (-bidx.num) < 0) || 
                         (T_5_3.num <= 0 && T_5_2.num > 0 && (-bidx.num) > 0)) {
                        err = ERR_overflow;
                        goto ex_2;}
                    cnt.num = T_5_3.num;
                    }
                    }

  LINE(216);
                {
                CLUREF T_5_1;
                T_5_1.num = (z.num < cnt.num)? true : false;
                if (T_5_1.num == true) {

  LINE(217);
                    {
                    cnt.num = z.num;
                    }
                    }
                    }/* end if */

  LINE(218);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                T_5_1.num = rb.vec->data[3];
                T_5_2.num = bidx.num + 1;
                 if ((T_5_2.num > 0 && bidx.num < 0 && 1 < 0) || 
                     (T_5_2.num < 0 && bidx.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_2;}
                err = _wordvecOPmove_w2b(T_5_1, T_5_2, bvec, i, cnt);
                if (err != ERR_ok) goto ex_2;
                }

  LINE(219);
                {
                CLUREF T_5_1;
                T_5_1.num = z.num - cnt.num;
                 if ((T_5_1.num >= 0 && z.num < 0 && (-cnt.num) < 0) || 
                     (T_5_1.num <= 0 && z.num > 0 && (-cnt.num) > 0)) {
                    err = ERR_overflow;
                    goto ex_2;}
                z.num = T_5_1.num;
                }

  LINE(220);
                {
                CLUREF T_5_1;
                T_5_1.num = i.num + cnt.num;
                 if ((T_5_1.num > 0 && i.num < 0 && cnt.num < 0) || 
                     (T_5_1.num < 0 && i.num > 0 && cnt.num > 0)) {
                    err = ERR_overflow;
                    goto ex_2;}
                i.num = T_5_1.num;
                }

  LINE(221);
                {
                CLUREF T_5_1;
                CLUREF T_5_2;
                CLUREF T_5_3;
                CLUREF T_5_4;
                T_5_1.num = rb.vec->data[1];
                T_5_2.num = cnt.num + 7;
                 if ((T_5_2.num > 0 && cnt.num < 0 && 7 < 0) || 
                     (T_5_2.num < 0 && cnt.num > 0 && 7 > 0)) {
                    err = ERR_overflow;
                    goto ex_2;}
                err = intOPdiv(T_5_2, CLU_8, &T_5_3);
                if (err != ERR_ok) goto ex_2;
                T_5_4.num = T_5_1.num + T_5_3.num;
                 if ((T_5_4.num > 0 && T_5_1.num < 0 && T_5_3.num < 0) || 
                     (T_5_4.num < 0 && T_5_1.num > 0 && T_5_3.num > 0)) {
                    err = ERR_overflow;
                    goto ex_2;}
                rb.vec->data[1]  = T_5_4.num;
                }
                }
                end_while_1:;

  LINE(223);
            {
            {
            ret_1->num = bvec.num;
            }
            {signal (ERR_ok);}}
            break;
            }
    default: {

  LINE(225);
        {
        elist[0] = STR_cannot_040read_040from_040this_040istream;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_2;
    ex_2:
        if (err == ERR_end_of_file) {signal(ERR_end_of_file);}
        else if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_1;}
    end_2:;
        goto end_1;
        ex_1:
            if ((err == ERR_overflow)
             || (err == ERR_toobig)) {

  LINE(227);
                {
                elist[0] = STR_bad_040format;
                {signal (ERR_not_possible);}}
            }
            else {
                goto ex_0;
            }
        end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: elist[0].str = no_return_values_STRING;
        {signal(ERR_failure);}
    }

/**** END PROCEDURE getbv ****/

static int istreamOPputbv_own_init = 0;

/**** BEGIN PROCEDURE putbv ****/

errcode istreamOPputbv(ist, bvec)
CLUREF ist;
CLUREF bvec;
    {
    errcode err;
    errcode ecode2;
    CLUREF wb;
    CLUREF z;
    CLUREF i;
    CLUREF bidx;
    CLUREF cnt;
        if (istreamOPputbv_own_init == 0) {
        if (istream_own_init == 0) {
            err = istream_own_init_proc();
            if (err != ERR_ok) goto ex_0;
            }
        istreamOPputbv_own_init = 1;
    }
    enter_proc(231);

  LINE(232);
    {
    CLUREF T_2_1;
    T_2_1.num = ist.vec->data[0];
    switch (T_2_1.cell->tag) {
    case 3: 
         {CLUREF T_2_2;
        T_2_2.num = T_2_1.cell->value;
        wb.num = T_2_2.num;

  LINE(234);
            {
                {CLUREF T_3_1;
                err = _bytevecOPsize(bvec, &T_3_1);
                if (err != ERR_ok) goto ex_1;
                z.num = T_3_1.num;
                }
                }

  LINE(235);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            CLUREF T_3_3;
            T_3_1.num = wb.vec->data[1];
            T_3_2.num = 256;
            T_3_3.num = (T_3_1.num == T_3_2.num)? true : false;
            if (T_3_3.num == true) {

  LINE(236);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                T_4_1.num = wb.vec->data[0];
                T_4_2.num = wb.vec->data[2];
                T_4_3.num = 2048;
                err = _chanOPputw(T_4_1, T_4_2, CLU_1, T_4_3, CLU_0);
                if (err != ERR_ok) goto ex_1;
                }

  LINE(237);
                {
                wb.vec->data[1]  = 0;
                }
                }
                }/* end if */

  LINE(239);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = wb.vec->data[1];
            T_3_2.num = T_3_1.num + 1;
             if ((T_3_2.num > 0 && T_3_1.num < 0 && 1 < 0) || 
                 (T_3_2.num < 0 && T_3_1.num > 0 && 1 > 0)) {
                err = ERR_overflow;
                goto ex_1;}
            wb.vec->data[1]  = T_3_2.num;
            }

  LINE(240);
            {
            CLUREF T_3_1;
            CLUREF T_3_2;
            T_3_1.num = wb.vec->data[2];
            T_3_2.num = wb.vec->data[1];
            err = _wordvecOPstore(T_3_1, T_3_2, z);
            if (err != ERR_ok) goto ex_1;
            }

  LINE(241);
            {
                {i.num = 1;
                }
                }

  LINE(242);
            for (;;) {
                CLUREF T_3_1;
                T_3_1.num = (z.num > 0)? true : false;
                if (T_3_1.num != true) { break; }

  LINE(243);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                T_4_1.num = wb.vec->data[1];
                T_4_2.num = 256;
                T_4_3.num = (T_4_1.num == T_4_2.num)? true : false;
                if (T_4_3.num == true) {

  LINE(244);
                    {
                    CLUREF T_5_1;
                    CLUREF T_5_2;
                    CLUREF T_5_3;
                    T_5_1.num = wb.vec->data[0];
                    T_5_2.num = wb.vec->data[2];
                    T_5_3.num = 2048;
                    err = _chanOPputw(T_5_1, T_5_2, CLU_1, T_5_3, CLU_0);
                    if (err != ERR_ok) goto ex_1;
                    }

  LINE(245);
                    {
                    wb.vec->data[1]  = 0;
                    }
                    }
                    }/* end if */

  LINE(247);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    T_4_1.num = wb.vec->data[1];
                    err = intOPmul(T_4_1, CLU_8, &T_4_2);
                    if (err != ERR_ok) goto ex_1;
                    bidx.num = T_4_2.num;
                    }
                    }

  LINE(248);
                {
                    {CLUREF T_4_1;
                    CLUREF T_4_2;
                    T_4_1.num = 2048;
                    T_4_2.num = T_4_1.num - bidx.num;
                     if ((T_4_2.num >= 0 && T_4_1.num < 0 && (-bidx.num) < 0) || 
                         (T_4_2.num <= 0 && T_4_1.num > 0 && (-bidx.num) > 0)) {
                        err = ERR_overflow;
                        goto ex_1;}
                    cnt.num = T_4_2.num;
                    }
                    }

  LINE(249);
                {
                CLUREF T_4_1;
                T_4_1.num = (z.num < cnt.num)? true : false;
                if (T_4_1.num == true) {

  LINE(250);
                    {
                    cnt.num = z.num;
                    }
                    }
                    }/* end if */

  LINE(251);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                T_4_1.num = wb.vec->data[2];
                T_4_2.num = bidx.num + 1;
                 if ((T_4_2.num > 0 && bidx.num < 0 && 1 < 0) || 
                     (T_4_2.num < 0 && bidx.num > 0 && 1 > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                err = _wordvecOPmove_b2w(bvec, i, T_4_1, T_4_2, cnt);
                if (err != ERR_ok) goto ex_1;
                }

  LINE(252);
                {
                CLUREF T_4_1;
                T_4_1.num = z.num - cnt.num;
                 if ((T_4_1.num >= 0 && z.num < 0 && (-cnt.num) < 0) || 
                     (T_4_1.num <= 0 && z.num > 0 && (-cnt.num) > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                z.num = T_4_1.num;
                }

  LINE(253);
                {
                CLUREF T_4_1;
                T_4_1.num = i.num + cnt.num;
                 if ((T_4_1.num > 0 && i.num < 0 && cnt.num < 0) || 
                     (T_4_1.num < 0 && i.num > 0 && cnt.num > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                i.num = T_4_1.num;
                }

  LINE(254);
                {
                CLUREF T_4_1;
                CLUREF T_4_2;
                CLUREF T_4_3;
                CLUREF T_4_4;
                T_4_1.num = wb.vec->data[1];
                T_4_2.num = cnt.num + 7;
                 if ((T_4_2.num > 0 && cnt.num < 0 && 7 < 0) || 
                     (T_4_2.num < 0 && cnt.num > 0 && 7 > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                err = intOPdiv(T_4_2, CLU_8, &T_4_3);
                if (err != ERR_ok) goto ex_1;
                T_4_4.num = T_4_1.num + T_4_3.num;
                 if ((T_4_4.num > 0 && T_4_1.num < 0 && T_4_3.num < 0) || 
                     (T_4_4.num < 0 && T_4_1.num > 0 && T_4_3.num > 0)) {
                    err = ERR_overflow;
                    goto ex_1;}
                wb.vec->data[1]  = T_4_4.num;
                }
                }
                end_while_1:;
            break;
            }
    default: {

  LINE(257);
        {
        elist[0] = STR_cannot_040write_040to_040this_040istream;
        {signal (ERR_not_possible);}}
    }
    }
    }
    goto end_1;
    ex_1:
        if (err == ERR_not_possible) {signal(ERR_not_possible);}
        else {
            goto ex_0;}
    end_1:;
    goto end_0;
    ex_0:
        {
            if (err == ERR_failure) {signal(ERR_failure);}
            elist[0] = _pclu_erstr(err);
            {signal(ERR_failure);}
        }
    end_0: {signal(ERR_ok);}
    }

/**** END PROCEDURE putbv ****/

typedef struct{
    long count;
    OWNPTR type_owns;
    OWNPTR op_owns;
    struct OP_ENTRY entry[15];
} istream_OPS;

CLU_proc istream_oe_abort = {{0,0,0,0}, istreamOPabort, 0};
CLU_proc istream_oe_can_read = {{0,0,0,0}, istreamOPcan_read, 0};
CLU_proc istream_oe_can_write = {{0,0,0,0}, istreamOPcan_write, 0};
CLU_proc istream_oe_close = {{0,0,0,0}, istreamOPclose, 0};
CLU_proc istream_oe_copy = {{0,0,0,0}, istreamOPcopy, 0};
CLU_proc istream_oe_empty = {{0,0,0,0}, istreamOPempty, 0};
CLU_proc istream_oe_equal = {{0,0,0,0}, istreamOPequal, 0};
CLU_proc istream_oe_flush = {{0,0,0,0}, istreamOPflush, 0};
CLU_proc istream_oe_get_date = {{0,0,0,0}, istreamOPget_date, 0};
CLU_proc istream_oe_get_name = {{0,0,0,0}, istreamOPget_name, 0};
CLU_proc istream_oe_is_closed = {{0,0,0,0}, istreamOPis_closed, 0};
CLU_proc istream_oe_open = {{0,0,0,0}, istreamOPopen, 0};
CLU_proc istream_oe_reset = {{0,0,0,0}, istreamOPreset, 0};
CLU_proc istream_oe_set_date = {{0,0,0,0}, istreamOPset_date, 0};
CLU_proc istream_oe_similar = {{0,0,0,0}, istreamOPsimilar, 0};

istream_OPS istream_ops_actual = {15, (OWNPTR)&istream_own_init, (OWNPTR)&istream_own_init, {
    {&istream_oe_abort, "abort"},
    {&istream_oe_can_read, "can_read"},
    {&istream_oe_can_write, "can_write"},
    {&istream_oe_close, "close"},
    {&istream_oe_copy, "copy"},
    {&istream_oe_empty, "empty"},
    {&istream_oe_equal, "equal"},
    {&istream_oe_flush, "flush"},
    {&istream_oe_get_date, "get_date"},
    {&istream_oe_get_name, "get_name"},
    {&istream_oe_is_closed, "is_closed"},
    {&istream_oe_open, "open"},
    {&istream_oe_reset, "reset"},
    {&istream_oe_set_date, "set_date"},
    {&istream_oe_similar, "similar"}}};

struct OPS *istream_ops = (struct OPS *)&istream_ops_actual;

/**** END CLUSTER istream ****/
