
%  Copyright    Massachusetts Institute of Technology     1990,1991

g_env = cluster is create, reset, end_all, force_signal, reset_err, set_space,
		   get_space, set_time, get_time, get_err, set_lineno, 
		   get_lineno, get_errst, min_inline,
		   puts, putl, newline, ensure_newline, blankline, indent, outdent,
		   newdefn, error, warn, set_file_name, get_file_name,
		   set_convert_type, set_convert, get_convert, get_comp, 
		   add_typedef, add_global, add_extern, add_find_owns, add_str,
		   add_vlist, add_siglist
    spaces =
    "                                                                             "
    mcvt = oneof [none: null, one: typespec]
    intlist = sequence[int]
    MAXVLIST = 50
    MAXSIGLIST = 11

    rep = record [out,
		  err: stream,
		  curline: array[string],
		  curspaces: string,
		  indent: int,
		  error: int,
		  ensure: bool,
		  convert_cvt: mcvt,
		  convert_flag: bool,
		  srcfn: file_name,
		  comp: ce,
		  time: bool,		% true => optimize time
		  space: bool		% true => optimize space (unimpl)
		  ]

    own current_env: rep
    own last_lineno: int := 0
    own lineno: int := 0
    own typedef_list: idnlist := idnlist$new()
    own global_list: namelist := namelist$new()
    own str_list: namelist := namelist$new()
    own extern_list: namelist := namelist$new()
    own vlist: intlist := intlist$new()
    own siglist: intlist := intlist$new()
    own find_owns_list: namelist := namelist$new()

    create = proc (comp: CE, errst: stream, binfn: file_name) returns (cvt)
	lineno := 0
	current_env := rep${out: stream$open(binfn, "write"),
			    err: errst,
			    curline: as$predict(1,20),
			    curspaces: "",
			    indent: 0,
			    error: 0,
			    ensure: false,
			    convert_cvt: mcvt$make_none(nil),
			    convert_flag: false,
			    srcfn: binfn,
			    comp: comp,
			    time: false,
			    space: false
			    }
	return (current_env)
	end create

    reset = proc (e: cvt, comp: CE, errst: stream, binfn: file_name)
	as$trim(e.curline, 1, 0)
	lineno := 0
	e.indent := 0
	e.error := 0
	typedef_list := idnlist$new()
	global_list := namelist$new()
	str_list := namelist$new()
	extern_list := namelist$new()
	vlist := intlist$new()
	siglist := intlist$new()
	find_owns_list := namelist$new()
	stream$close(e.out)
	   except when not_possible(*): end
	begin
	    e.out := stream$open(binfn, "write")
	    stream$putl(e.out, "\n/* This file was automatically generated by pclu.*/\n")
	    stream$putl(e.out, "#include \"pclu_err.h\"")
	    stream$putl(e.out, "#include \"pclu_sys.h\"")
	    % src: file_name := file_name$create(file_name$get_dir(binfn),
				% file_name$get_name(binfn), "clu", "")
	    % stream$putl(e.out, "#line 0 \"" || file_name$unparse(src) || "\"")
	    end
	   except when not_possible (s: string):
		       stream$putl(e.err, "can't write to binary file: " || s)
		       e.error := 2
		  end
	e.err := errst
	end reset

    end_all = proc (e: cvt)
	if as$size(e.curline) > 0
	   then output_line(e)
	   end
	stream$close(e.out)
	   except when not_possible(*): end
	end end_all

    get_file_name = proc(e: cvt) returns (file_name)
	return(e.srcfn)
	end get_file_name

    set_file_name = proc(e: cvt, fn: file_name)
	e.srcfn := fn
	end set_file_name

    force_signal = proc (e: cvt)
	stream$putl(e.err, "codegen: #SIGNAL directive ignored")
	end force_signal

    reset_err = proc (e: cvt)
	end reset_err

    set_space = proc (e: cvt, b: bool)
	e.space := b
	end set_space

    get_space = proc (e: cvt) returns (bool)
	return(e.space)
	end get_space

    set_time = proc (e: cvt, b: bool)
	e.time := b
	end set_time

    get_time = proc (e: cvt) returns (bool)
	return(e.time)
	end get_time

    get_err = proc (e: cvt) returns (int)
	return (e.error)
	end get_err

    set_lineno = proc (e: cvt, num: int)
	lineno := num
	return
	end set_lineno

    get_lineno = proc (e: cvt) returns (int)
	return (lineno)
	end get_lineno

    get_errst = proc () returns (stream)
	return (current_env.err)
	end get_errst

    min_inline = proc () returns (bool)
	return (~current_env.time)
	end min_inline

    putl = proc (e: cvt, s: string)
	if e.ensure
	   then newline(up(e))
	   end
	as$addh(e.curline, s)

	% start a newline, adding space for current indent.

	output_line(e)
	if string$size(e.curspaces) ~= e.indent
	   then e.curspaces := string$substr(spaces, 1, e.indent) end
	e.ensure := false

	end putl

    puts = proc (e: cvt, s: string)
	if e.ensure
	   then newline(up(e))
	   end
	as$addh(e.curline, s)
	end puts

    newline = proc (e: cvt)
	% start a newline, adding space for current indent.
	output_line(e)
	if string$size(e.curspaces) ~= e.indent
	   then e.curspaces := string$substr(spaces, 1, e.indent) end
	e.ensure := false
	end newline

    blankline = proc (e:cvt)
	output_line(e)
	stream$putl(e.out ,"")
	if string$size(e.curspaces) ~= e.indent
	   then e.curspaces := string$substr(spaces, 1, e.indent) end
	e.ensure := false
	end blankline

    ensure_newline = proc (e: cvt)
	% makes sure a newline() operation proceeds the next puts
	e.ensure := true
	end ensure_newline

    indent = proc (e: cvt)
	% increment current indent. if at beginning of line, add space to current
	% line. 
	e.indent := e.indent + 4
	if as$empty(e.curline)
	   then e.curspaces := string$substr(spaces, 1, e.indent)
	   end
	end indent

    outdent = proc (e: cvt)
	% decrement current indent. if at beginning of line, remove space from
	% current line.
	e.indent := e.indent - 4
	if as$empty(e.curline)
	   then e.curspaces := string$substr(spaces, 1, e.indent)
	   end
	end outdent

    newdefn = proc (e: cvt)
	% set current indent to 0 and start a new line.
	output_line(e)
	stream$putl(e.out, "")
	   except when not_possible(*): e.error := 2 end
	e.curspaces := ""
	e.indent := 0
	end newdefn

    error = proc (e: cvt, s: string)
	stream$puts(e.err, int$unparse(lineno))
	stream$putc(e.err, ':')
	stream$putc(e.err, '\t')
	stream$putl(e.err, s)
	e.error := 2
	end error

    warn = proc (e: cvt, s: string)
	stream$putl(e.err, s)
	e.error := 0
	end warn

    %% gross hack for now
    set_convert_type = proc (e:cvt, t: typespec)
	e.convert_cvt := mcvt$make_one(t)
	end set_convert_type

    set_convert = proc (e: cvt, flag: bool)
	e.convert_flag := flag
	end set_convert

    get_convert = proc (e: cvt) returns (typespec) signals (none)
	if e.convert_flag
	   then tagcase e.convert_cvt
		   tag none: signal none
		   tag one (t: typespec): return (t)
		   end
	   else signal none
	   end
	end get_convert

    % internal procs

    % might be able to get file name by modifying top2/reset_stuff
    %	to save fn and put it into the g_env$reset interface
    %	and thus to save it in e
    output_line = proc (e: rep)

	if ~as$empty(e.curline)
	   then
		if lineno ~= last_lineno then
		   stream$putl(e.out, "")
		   if lineno ~= 0 
		      then
			   if ib$bodies() then
			      % stream$putl(e.out, "#line " || int$unparse(lineno))
			      stream$putl(e.out, "  FB_LINE(" ||
						 int$unparse(lineno) || ");")
			      else
			           % stream$putl(e.out, "#line " || int$unparse(lineno))
				   stream$putl(e.out, "  LINE(" ||
						      int$unparse(lineno) || ");")
			      end
		      % else
			   % stream$putl(e.out, "/*-- " || int$unparse(lineno)
			   %			|| " --*/")
		      end
		   last_lineno := lineno
		   end
		stream$puts(e.out, e.curspaces)
		for each_s: string in as$elements(e.curline) do
		    stream$puts(e.out, each_s)
		    end
		stream$putl(e.out, "")
		as$trim(e.curline, 1, 0)
	   end
	   except when not_possible(*): e.error := 2 end
	end output_line

    get_comp = proc (e: cvt) returns (ce)
	return(e.comp)
	end get_comp
    
    add_typedef = proc(id: idn) returns (bool)

	for each_id: idn in idnlist$elements(typedef_list) do
	    if id.str =  each_id.str then return (false) end
	    end
	typedef_list := idnlist$addh(typedef_list, id)
	return (true)
	end add_typedef

    add_global = proc(nm: name) returns (bool)

	for each_nm: name in namelist$elements(global_list) do
	    if nm =  each_nm then return (false) end
	    end
	global_list := namelist$addh(global_list, nm)
	return (true)
	end add_global

    add_str = proc(nm: name) returns (bool)

	for each_nm: name in namelist$elements(str_list) do
	    if nm =  each_nm then return (false) end
	    end
	str_list := namelist$addh(str_list, nm)
	return (true)
	end add_str

    add_extern = proc(nm: name) returns (bool)

	for each_nm: name in namelist$elements(extern_list) do
	    if each_nm = nm then return (false) end
	    end
	extern_list := namelist$addh(extern_list, nm)
	return (true)
	end add_extern

    add_vlist = proc(n: int) returns (bool)
	if n < MAXVLIST then return (false) end
	for each_n: int in intlist$elements(vlist) do
	    if each_n = n then return (false) end
	    end
	vlist := intlist$addh(vlist, n)
	return (true)
	end add_vlist

    add_siglist = proc(n: int) returns (bool)
	if n < MAXSIGLIST then return (false) end
	for each_n: int in intlist$elements(vlist) do
	    if each_n = n then return (false) end
	    end
	siglist := intlist$addh(siglist, n)
	return (true)
	end add_siglist

    add_find_owns = proc(nm: name) returns (bool)

	for each_nm: name in namelist$elements(find_owns_list) do
	    if each_nm = nm then return (false) end
	    end
	find_owns_list := namelist$addh(find_owns_list, nm)
	return (true)
	end add_find_owns

    end g_env
